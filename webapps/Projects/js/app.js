webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var platform_browser_dynamic_1 = __webpack_require__(1);
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var common_1 = __webpack_require__(2);
	var ng2_translate_1 = __webpack_require__(350);
	var notification_1 = __webpack_require__(376);
	var markdown_1 = __webpack_require__(380);
	var app_component_1 = __webpack_require__(393);
	var app_routes_1 = __webpack_require__(691);
	var translate_service_1 = __webpack_require__(457);
	var services_1 = __webpack_require__(453);
	var store_1 = __webpack_require__(840);
	platform_browser_dynamic_1.bootstrap(app_component_1.AppComponent, [
	    http_1.HTTP_PROVIDERS,
	    app_routes_1.APP_ROUTER_PROVIDERS,
	    core_1.provide(common_1.LocationStrategy, { useClass: common_1.HashLocationStrategy }),
	    ng2_translate_1.TranslateService,
	    ng2_translate_1.TRANSLATE_PROVIDERS,
	    core_1.provide(ng2_translate_1.TranslateLoader, {
	        useFactory: function (trs) { return new CustomTranslateLoader(trs); },
	        deps: [translate_service_1.TranslateService]
	    }),
	    notification_1.NotificationService,
	    markdown_1.MarkdownConverter,
	    services_1.APP_SERVICES,
	    store_1.APP_STORE
	]).catch(function (err) { return console.error(err); });
	var CustomTranslateLoader = (function () {
	    function CustomTranslateLoader(translateService) {
	        this.translateService = translateService;
	    }
	    CustomTranslateLoader.prototype.getTranslation = function (lang) {
	        return this.translateService.fetchTranslations();
	    };
	    return CustomTranslateLoader;
	}());


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(377));
	__export(__webpack_require__(379));
	__export(__webpack_require__(378));


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var notification_1 = __webpack_require__(378);
	var NotificationService = (function () {
	    function NotificationService() {
	        this.emitter = new core_1.EventEmitter();
	    }
	    NotificationService.prototype.getEmitter = function () {
	        return this.emitter;
	    };
	    NotificationService.prototype.info = function (message) {
	        return this.add({ type: 'info', message: message });
	    };
	    NotificationService.prototype.success = function (message) {
	        return this.add({ type: 'success', message: message });
	    };
	    NotificationService.prototype.error = function (message) {
	        return this.add({ type: 'error', message: message });
	    };
	    NotificationService.prototype.process = function (message) {
	        return this.add({ type: 'process', message: message });
	    };
	    NotificationService.prototype.add = function (options) {
	        var noty = new notification_1.Notification(options.type, options.message);
	        this.emitter.emit({ command: 'add', notify: noty });
	        return noty;
	    };
	    NotificationService.prototype.removeAll = function () {
	        this.emitter.emit({ command: 'cleanAll' });
	    };
	    NotificationService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], NotificationService);
	    return NotificationService;
	}());
	exports.NotificationService = NotificationService;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(5);
	var Notification = (function () {
	    function Notification(type, message) {
	        this.emitter = new core_1.EventEmitter();
	        this.display = false;
	        this.type = type;
	        this.message = message;
	    }
	    Notification.prototype.getEmitter = function () {
	        return this.emitter;
	    };
	    Notification.prototype.show = function () {
	        this.display = true;
	        return this;
	    };
	    Notification.prototype.hide = function () {
	        this.display = false;
	        return this;
	    };
	    Notification.prototype.set = function (options) {
	        for (var key in options) {
	            if (key === 'message') {
	                this.message = options[key];
	            }
	            else if (key === 'type') {
	                this.type = options[key];
	            }
	        }
	        return this;
	    };
	    Notification.prototype.dismiss = function () {
	        if (this.delay === 'click') {
	            this.emitter.emit({ dismiss: true, notify: this, promise: this.promise });
	        }
	    };
	    Notification.prototype.remove = function (delay) {
	        var _this = this;
	        this.delay = delay;
	        if (delay === 'click') {
	        }
	        else if (delay > 0) {
	            setTimeout(function () {
	                _this.emitter.emit({ dismiss: true, notify: _this, promise: _this.promise });
	            }, delay);
	        }
	        else {
	            this.emitter.emit({ dismiss: true, notify: this, promise: this.promise });
	        }
	        return this.promise;
	    };
	    return Notification;
	}());
	exports.Notification = Notification;


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var notification_service_1 = __webpack_require__(377);
	var NotificationComponent = (function () {
	    function NotificationComponent(notifyService) {
	        this.notifyService = notifyService;
	        this.notifications = [];
	    }
	    Object.defineProperty(NotificationComponent.prototype, "isHidden", {
	        get: function () { return this.notifications.length == 0; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    NotificationComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.listener = this.notifyService.getEmitter().subscribe(function (item) {
	            switch (item.command) {
	                case 'cleanAll':
	                    _this.notifications = [];
	                    break;
	                case 'add':
	                    _this.addNotify(item.notify);
	                    break;
	                default:
	                    break;
	            }
	        });
	    };
	    NotificationComponent.prototype.ngOnDestroy = function () {
	        if (this.listener) {
	            this.notifications.map(function (it) { return it.getEmitter().unsubscribe(); });
	            this.listener.unsubscribe();
	        }
	    };
	    NotificationComponent.prototype.addNotify = function (notify) {
	        var _this = this;
	        this.notifications.push(notify);
	        notify.getEmitter().subscribe(function (item) { return _this.notifyEmitter(item); });
	    };
	    NotificationComponent.prototype.notifyEmitter = function (data) {
	        if (data.dismiss) {
	            var index = this.notifications.indexOf(data.notify);
	            this.notifications.splice(index, 1);
	            data.notify.getEmitter().unsubscribe();
	        }
	    };
	    __decorate([
	        core_1.HostBinding('class.nb-notify'), 
	        __metadata('design:type', Object)
	    ], NotificationComponent.prototype, "true", void 0);
	    __decorate([
	        core_1.HostBinding('class.hidden'), 
	        __metadata('design:type', Object)
	    ], NotificationComponent.prototype, "isHidden", null);
	    NotificationComponent = __decorate([
	        core_1.Component({
	            selector: 'notification',
	            template: "\n        <div class=\"nb-notify-entry-{{notify.type}}\"\n            [class.dismiss-click]=\"notify.delay == 'click'\"\n            [style.display]=\"notify.display ? 'block': 'none'\"\n            (click)=\"notify.dismiss()\"\n            *ngFor=\"let notify of notifications\">\n            {{notify.message}}\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [notification_service_1.NotificationService])
	    ], NotificationComponent);
	    return NotificationComponent;
	}());
	exports.NotificationComponent = NotificationComponent;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var markdown_converter_1 = __webpack_require__(381);
	exports.MarkdownConverter = markdown_converter_1.MarkdownConverter;
	var markdown_editor_1 = __webpack_require__(391);
	exports.MarkdownEditorComponent = markdown_editor_1.MarkdownEditorComponent;
	var marked_pipe_1 = __webpack_require__(392);
	exports.MarkedPipe = marked_pipe_1.MarkedPipe;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var marked = __webpack_require__(382);
	var toMarkdown = __webpack_require__(383);
	var MarkdownConverter = (function () {
	    function MarkdownConverter() {
	    }
	    MarkdownConverter.prototype.toMarkdown = function (html) {
	        return toMarkdown(html, { gfm: true });
	    };
	    MarkdownConverter.prototype.toHtml = function (markdown) {
	        return marked(markdown);
	    };
	    MarkdownConverter = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], MarkdownConverter);
	    return MarkdownConverter;
	}());
	exports.MarkdownConverter = MarkdownConverter;


/***/ },
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var markdown_converter_1 = __webpack_require__(381);
	var MarkdownEditorComponent = (function () {
	    function MarkdownEditorComponent(mdc) {
	        this.mdc = mdc;
	        this.editable = true;
	        this.markdown = '';
	        this.klass = '';
	        this.updateTimeout = 150;
	        this.update = new core_1.EventEmitter();
	        this.focus = new core_1.EventEmitter();
	        this.blur = new core_1.EventEmitter();
	    }
	    MarkdownEditorComponent.prototype.ngOnInit = function () {
	        this.html = this.mdc.toHtml(this.markdown);
	    };
	    MarkdownEditorComponent.prototype.updateValue = function ($el) {
	        var _this = this;
	        clearTimeout(this.to);
	        this.to = setTimeout(function () {
	            _this.update.emit(_this.mdc.toMarkdown($el.innerHTML));
	        }, this.updateTimeout);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], MarkdownEditorComponent.prototype, "editable", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], MarkdownEditorComponent.prototype, "markdown", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], MarkdownEditorComponent.prototype, "klass", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], MarkdownEditorComponent.prototype, "placeHolder", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Number)
	    ], MarkdownEditorComponent.prototype, "updateTimeout", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], MarkdownEditorComponent.prototype, "update", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], MarkdownEditorComponent.prototype, "focus", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], MarkdownEditorComponent.prototype, "blur", void 0);
	    MarkdownEditorComponent = __decorate([
	        core_1.Component({
	            selector: 'markdown-editor',
	            template: "\n        <div class=\"rt-editor\">\n            <div class=\"rt-editor__area {{klass}}\" [class.edit]=\"editable\" contenteditable=\"true\"\n                innerHtml=\"{{html}}\"\n                (keyup)=\"updateValue($event.target)\"\n                (focus)=\"focus.emit(1)\"\n                (blur)=\"blur.emit(1)\">\n            </div>\n            <!-- <span class=\"rt-editor__placeholder\" *ngIf=\"!html.length\">{{placeHolder}}</span> -->\n        </div>\n    ",
	            providers: [markdown_converter_1.MarkdownConverter]
	        }), 
	        __metadata('design:paramtypes', [markdown_converter_1.MarkdownConverter])
	    ], MarkdownEditorComponent);
	    return MarkdownEditorComponent;
	}());
	exports.MarkdownEditorComponent = MarkdownEditorComponent;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var markdown_converter_1 = __webpack_require__(381);
	var MarkedPipe = (function () {
	    function MarkedPipe(mdc) {
	        this.mdc = mdc;
	    }
	    MarkedPipe.prototype.transform = function (text) {
	        return this.mdc.toHtml(text);
	    };
	    MarkedPipe = __decorate([
	        core_1.Pipe({ name: 'marked' }), 
	        __metadata('design:paramtypes', [markdown_converter_1.MarkdownConverter])
	    ], MarkedPipe);
	    return MarkedPipe;
	}());
	exports.MarkedPipe = MarkedPipe;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var services_1 = __webpack_require__(453);
	var notification_1 = __webpack_require__(376);
	var dropdown_1 = __webpack_require__(686);
	var nav_1 = __webpack_require__(689);
	var user_1 = __webpack_require__(461);
	var AppComponent = (function () {
	    function AppComponent(store, appService, referenceService, staffService, translate) {
	        var _this = this;
	        this.store = store;
	        this.appService = appService;
	        this.referenceService = referenceService;
	        this.staffService = staffService;
	        this.translate = translate;
	        this.isReady = false;
	        this.HEADER_TITLE = 'Projects';
	        this.workspaceUrl = '/Workspace/p?id=workspace';
	        this.store.select('authed').subscribe(function (data) {
	            _this.loggedUser = data.userProfile;
	        });
	        this.sub = this.store.select('reference');
	        this.appService.getUserProfile().subscribe(function (action) {
	            _this.store.dispatch(action);
	            _this.isReady = true;
	            _this.appService.isLogged = true;
	        });
	    }
	    AppComponent.prototype.resize = function (window) { this.onResize(window); };
	    ;
	    Object.defineProperty(AppComponent.prototype, "device", {
	        get: function () { return this.isMobileDevice; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(AppComponent.prototype, "toggleNavVisible", {
	        get: function () { return this.isNavCollapsed; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(AppComponent.prototype, "toggleSearch", {
	        get: function () { return this.isSearchOpen; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    AppComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.referenceService.loadReference();
	        this.staffService.fetchOrganizations().subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	        this.staffService.fetchUsers().subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	        this.isSearchOpen = false;
	        this.isNavCollapsed = false;
	        this.loggedUser = new user_1.User();
	        this.isMobileDevice = this.isMobile();
	        var userLang = navigator.language.split('-')[0];
	        userLang = /(ru|en)/gi.test(userLang) ? userLang : 'en';
	        this.translate.setDefaultLang('en');
	        this.translate.use('en');
	        this.translate.get('brand').subscribe(function (value) { return _this.HEADER_TITLE = value; });
	    };
	    AppComponent.prototype.ngOnDestroy = function () {
	        this.sub && this.sub.unsubscribe();
	    };
	    AppComponent.prototype.toggleNav = function () {
	        this.isNavCollapsed = !this.isNavCollapsed;
	    };
	    AppComponent.prototype.hideNav = function (event) {
	        event.preventDefault();
	        this.isNavCollapsed = false;
	        this.isSearchOpen = false;
	    };
	    AppComponent.prototype.searchToggle = function () {
	        this.isSearchOpen = !this.isSearchOpen;
	    };
	    AppComponent.prototype.logout = function (event) {
	        event.preventDefault();
	        window.location.href = 'Logout';
	    };
	    AppComponent.prototype.goBack = function () {
	        window.history.back();
	    };
	    AppComponent.prototype.preventDefault = function (event) {
	        event.preventDefault();
	    };
	    AppComponent.prototype.isMobile = function () {
	        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
	    };
	    AppComponent.prototype.onResize = function (window) {
	        this.isMobileDevice = window.innerWidth <= 1024 || this.isMobile();
	    };
	    __decorate([
	        core_1.HostListener('window:resize', ['$event.target']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [Object]), 
	        __metadata('design:returntype', void 0)
	    ], AppComponent.prototype, "resize", null);
	    __decorate([
	        core_1.HostBinding('class.phone'), 
	        __metadata('design:type', Object)
	    ], AppComponent.prototype, "device", null);
	    __decorate([
	        core_1.HostBinding('class.side-nav-toggle'), 
	        __metadata('design:type', Object)
	    ], AppComponent.prototype, "toggleNavVisible", null);
	    __decorate([
	        core_1.HostBinding('class.search-open'), 
	        __metadata('design:type', Object)
	    ], AppComponent.prototype, "toggleSearch", null);
	    AppComponent = __decorate([
	        core_1.Component({
	            selector: 'app',
	            template: __webpack_require__(690),
	            directives: [router_1.ROUTER_DIRECTIVES, nav_1.NavComponent, notification_1.NotificationComponent, dropdown_1.DROPDOWN_DIRECTIVES],
	            providers: [notification_1.NotificationService],
	            pipes: [ng2_translate_1.TranslatePipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, services_1.AppService, services_1.ReferenceService, services_1.StaffService, ng2_translate_1.TranslateService])
	    ], AppComponent);
	    return AppComponent;
	}());
	exports.AppComponent = AppComponent;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var router_link_1 = __webpack_require__(395);
	var router_link_active_1 = __webpack_require__(433);
	var router_outlet_1 = __webpack_require__(434);
	var router_1 = __webpack_require__(396);
	exports.NavigationCancel = router_1.NavigationCancel;
	exports.NavigationEnd = router_1.NavigationEnd;
	exports.NavigationError = router_1.NavigationError;
	exports.NavigationStart = router_1.NavigationStart;
	exports.Router = router_1.Router;
	exports.RoutesRecognized = router_1.RoutesRecognized;
	var router_outlet_map_1 = __webpack_require__(432);
	exports.RouterOutletMap = router_outlet_map_1.RouterOutletMap;
	var router_providers_1 = __webpack_require__(435);
	exports.provideRouter = router_providers_1.provideRouter;
	var router_state_1 = __webpack_require__(423);
	exports.ActivatedRoute = router_state_1.ActivatedRoute;
	exports.ActivatedRouteSnapshot = router_state_1.ActivatedRouteSnapshot;
	exports.RouterState = router_state_1.RouterState;
	exports.RouterStateSnapshot = router_state_1.RouterStateSnapshot;
	var shared_1 = __webpack_require__(416);
	exports.PRIMARY_OUTLET = shared_1.PRIMARY_OUTLET;
	var url_serializer_1 = __webpack_require__(418);
	exports.DefaultUrlSerializer = url_serializer_1.DefaultUrlSerializer;
	exports.UrlSerializer = url_serializer_1.UrlSerializer;
	var url_tree_1 = __webpack_require__(417);
	exports.UrlPathWithParams = url_tree_1.UrlPathWithParams;
	exports.UrlTree = url_tree_1.UrlTree;
	exports.ROUTER_DIRECTIVES = [router_outlet_1.RouterOutlet, router_link_1.RouterLink, router_link_active_1.RouterLinkActive];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLDRCQUF5QiwwQkFBMEIsQ0FBQyxDQUFBO0FBQ3BELG1DQUErQixpQ0FBaUMsQ0FBQyxDQUFBO0FBQ2pFLDhCQUEyQiw0QkFBNEIsQ0FBQyxDQUFBO0FBS3hELHVCQUFpSCxVQUFVLENBQUM7QUFBN0cscURBQWdCO0FBQUUsK0NBQWE7QUFBRSxtREFBZTtBQUFFLG1EQUFlO0FBQUUsaUNBQU07QUFBRSxxREFBa0M7QUFDNUgsa0NBQThCLHFCQUFxQixDQUFDO0FBQTVDLDhEQUE0QztBQUNwRCxpQ0FBNEIsb0JBQW9CLENBQUM7QUFBekMseURBQXlDO0FBQ2pELDZCQUF1RixnQkFBZ0IsQ0FBQztBQUFoRyx1REFBYztBQUFFLHVFQUFzQjtBQUFFLGlEQUFXO0FBQUUsaUVBQTJDO0FBQ3hHLHVCQUFxQyxVQUFVLENBQUM7QUFBeEMsaURBQXdDO0FBQ2hELCtCQUFrRCxrQkFBa0IsQ0FBQztBQUE3RCxxRUFBb0I7QUFBRSx1REFBdUM7QUFDckUseUJBQXlDLFlBQVksQ0FBQztBQUE5Qyx5REFBaUI7QUFBRSxxQ0FBMkI7QUFFekMseUJBQWlCLEdBQUcsQ0FBQyw0QkFBWSxFQUFFLHdCQUFVLEVBQUUscUNBQWdCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Um91dGVyTGlua30gZnJvbSAnLi9kaXJlY3RpdmVzL3JvdXRlcl9saW5rJztcbmltcG9ydCB7Um91dGVyTGlua0FjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL3JvdXRlcl9saW5rX2FjdGl2ZSc7XG5pbXBvcnQge1JvdXRlck91dGxldH0gZnJvbSAnLi9kaXJlY3RpdmVzL3JvdXRlcl9vdXRsZXQnO1xuXG5leHBvcnQge0V4dHJhT3B0aW9uc30gZnJvbSAnLi9jb21tb25fcm91dGVyX3Byb3ZpZGVycyc7XG5leHBvcnQge1JvdXRlLCBSb3V0ZXJDb25maWd9IGZyb20gJy4vY29uZmlnJztcbmV4cG9ydCB7Q2FuQWN0aXZhdGUsIENhbkRlYWN0aXZhdGV9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5leHBvcnQge0V2ZW50LCBOYXZpZ2F0aW9uQ2FuY2VsLCBOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uRXJyb3IsIE5hdmlnYXRpb25TdGFydCwgUm91dGVyLCBSb3V0ZXNSZWNvZ25pemVkfSBmcm9tICcuL3JvdXRlcic7XG5leHBvcnQge1JvdXRlck91dGxldE1hcH0gZnJvbSAnLi9yb3V0ZXJfb3V0bGV0X21hcCc7XG5leHBvcnQge3Byb3ZpZGVSb3V0ZXJ9IGZyb20gJy4vcm91dGVyX3Byb3ZpZGVycyc7XG5leHBvcnQge0FjdGl2YXRlZFJvdXRlLCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZXJTdGF0ZSwgUm91dGVyU3RhdGVTbmFwc2hvdH0gZnJvbSAnLi9yb3V0ZXJfc3RhdGUnO1xuZXhwb3J0IHtQUklNQVJZX09VVExFVCwgUGFyYW1zfSBmcm9tICcuL3NoYXJlZCc7XG5leHBvcnQge0RlZmF1bHRVcmxTZXJpYWxpemVyLCBVcmxTZXJpYWxpemVyfSBmcm9tICcuL3VybF9zZXJpYWxpemVyJztcbmV4cG9ydCB7VXJsUGF0aFdpdGhQYXJhbXMsIFVybFRyZWV9IGZyb20gJy4vdXJsX3RyZWUnO1xuXG5leHBvcnQgY29uc3QgUk9VVEVSX0RJUkVDVElWRVMgPSBbUm91dGVyT3V0bGV0LCBSb3V0ZXJMaW5rLCBSb3V0ZXJMaW5rQWN0aXZlXTsiXX0=

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var common_1 = __webpack_require__(2);
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(396);
	var router_state_1 = __webpack_require__(423);
	var RouterLink = (function () {
	    function RouterLink(router, route, locationStrategy) {
	        this.router = router;
	        this.route = route;
	        this.locationStrategy = locationStrategy;
	        this.commands = [];
	    }
	    Object.defineProperty(RouterLink.prototype, "routerLink", {
	        set: function (data) {
	            if (Array.isArray(data)) {
	                this.commands = data;
	            }
	            else {
	                this.commands = [data];
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RouterLink.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
	    RouterLink.prototype.onClick = function (button, ctrlKey, metaKey) {
	        if (button !== 0 || ctrlKey || metaKey) {
	            return true;
	        }
	        if (typeof this.target === 'string' && this.target != '_self') {
	            return true;
	        }
	        this.router.navigateByUrl(this.urlTree);
	        return false;
	    };
	    RouterLink.prototype.updateTargetUrlAndHref = function () {
	        this.urlTree = this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment });
	        if (this.urlTree) {
	            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
	        }
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], RouterLink.prototype, "target", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], RouterLink.prototype, "queryParams", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], RouterLink.prototype, "fragment", void 0);
	    __decorate([
	        core_1.HostBinding(), 
	        __metadata('design:type', String)
	    ], RouterLink.prototype, "href", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object), 
	        __metadata('design:paramtypes', [Object])
	    ], RouterLink.prototype, "routerLink", null);
	    __decorate([
	        core_1.HostListener('click', ['$event.button', '$event.ctrlKey', '$event.metaKey']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [Number, Boolean, Boolean]), 
	        __metadata('design:returntype', Boolean)
	    ], RouterLink.prototype, "onClick", null);
	    RouterLink = __decorate([
	        core_1.Directive({ selector: '[routerLink]' }), 
	        __metadata('design:paramtypes', [router_1.Router, router_state_1.ActivatedRoute, common_1.LocationStrategy])
	    ], RouterLink);
	    return RouterLink;
	}());
	exports.RouterLink = RouterLink;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX2xpbmsuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZGlyZWN0aXZlcy9yb3V0ZXJfbGluay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsdUJBQStCLGlCQUFpQixDQUFDLENBQUE7QUFDakQscUJBQXFFLGVBQWUsQ0FBQyxDQUFBO0FBRXJGLHVCQUFxQixXQUFXLENBQUMsQ0FBQTtBQUNqQyw2QkFBNkIsaUJBQWlCLENBQUMsQ0FBQTtBQStCL0M7SUFjRSxvQkFDWSxNQUFjLEVBQVUsS0FBcUIsRUFDN0MsZ0JBQWtDO1FBRGxDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFnQjtRQUM3QyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBZHRDLGFBQVEsR0FBVSxFQUFFLENBQUM7SUFjb0IsQ0FBQztJQUdsRCxzQkFBSSxrQ0FBVTthQUFkLFVBQWUsSUFBa0I7WUFDL0IsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQVEsSUFBSSxDQUFDO1lBQzVCLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekIsQ0FBQztRQUNILENBQUM7OztPQUFBO0lBRUQsZ0NBQVcsR0FBWCxVQUFZLE9BQVcsSUFBUyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFHaEUsNEJBQU8sR0FBUCxVQUFRLE1BQWMsRUFBRSxPQUFnQixFQUFFLE9BQWdCO1FBQ3hELEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztZQUM5RCxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLDJDQUFzQixHQUE5QjtRQUNFLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQ3BDLElBQUksQ0FBQyxRQUFRLEVBQ2IsRUFBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBQyxDQUFDLENBQUM7UUFDdEYsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDakIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDL0YsQ0FBQztJQUNILENBQUM7SUFqREQ7UUFBQyxZQUFLLEVBQUU7OzhDQUFBO0lBRVI7UUFBQyxZQUFLLEVBQUU7O21EQUFBO0lBQ1I7UUFBQyxZQUFLLEVBQUU7O2dEQUFBO0lBR1I7UUFBQyxrQkFBVyxFQUFFOzs0Q0FBQTtJQVdkO1FBQUMsWUFBSyxFQUFFOzs7Z0RBQUE7SUFXUjtRQUFDLG1CQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDLENBQUM7Ozs7NkNBQUE7SUE5Qi9FO1FBQUMsZ0JBQVMsQ0FBQyxFQUFDLFFBQVEsRUFBRSxjQUFjLEVBQUMsQ0FBQzs7a0JBQUE7SUFvRHRDLGlCQUFDO0FBQUQsQ0FBQyxBQW5ERCxJQW1EQztBQW5EWSxrQkFBVSxhQW1EdEIsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TG9jYXRpb25TdHJhdGVneX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RGlyZWN0aXZlLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25DaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtSb3V0ZXJ9IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQge0FjdGl2YXRlZFJvdXRlfSBmcm9tICcuLi9yb3V0ZXJfc3RhdGUnO1xuaW1wb3J0IHtVcmxUcmVlfSBmcm9tICcuLi91cmxfdHJlZSc7XG5cblxuXG4vKipcbiAqIFRoZSBSb3V0ZXJMaW5rIGRpcmVjdGl2ZSBsZXRzIHlvdSBsaW5rIHRvIHNwZWNpZmljIHBhcnRzIG9mIHlvdXIgYXBwLlxuICpcbiAqIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgcm91dGUgY29uZmlndXJhdGlvbjpcblxuICogYGBgXG4gKiBbeyBwYXRoOiAnL3VzZXInLCBjb21wb25lbnQ6IFVzZXJDbXAgfV1cbiAqIGBgYFxuICpcbiAqIFdoZW4gbGlua2luZyB0byB0aGlzIGBVc2VyYCByb3V0ZSwgeW91IGNhbiB3cml0ZTpcbiAqXG4gKiBgYGBcbiAqIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3VzZXInXVwiPmxpbmsgdG8gdXNlciBjb21wb25lbnQ8L2E+XG4gKiBgYGBcbiAqXG4gKiBSb3V0ZXJMaW5rIGV4cGVjdHMgdGhlIHZhbHVlIHRvIGJlIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBwYXJhbXNcbiAqIGZvciB0aGF0IGxldmVsIG9mIHJvdXRpbmcuIEZvciBpbnN0YW5jZSBgWycvdGVhbScsIHt0ZWFtSWQ6IDF9LCAndXNlcicsIHt1c2VySWQ6IDJ9XWBcbiAqIG1lYW5zIHRoYXQgd2Ugd2FudCB0byBnZW5lcmF0ZSBhIGxpbmsgdG8gYC90ZWFtO3RlYW1JZD0xL3VzZXI7dXNlcklkPTJgLlxuICpcbiAqIFRoZSBmaXJzdCBzZWdtZW50IG5hbWUgY2FuIGJlIHByZXBlbmRlZCB3aXRoIGAvYCwgYC4vYCwgb3IgYC4uL2AuXG4gKiBJZiB0aGUgc2VnbWVudCBiZWdpbnMgd2l0aCBgL2AsIHRoZSByb3V0ZXIgd2lsbCBsb29rIHVwIHRoZSByb3V0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBhcHAuXG4gKiBJZiB0aGUgc2VnbWVudCBiZWdpbnMgd2l0aCBgLi9gLCBvciBkb2Vzbid0IGJlZ2luIHdpdGggYSBzbGFzaCwgdGhlIHJvdXRlciB3aWxsXG4gKiBpbnN0ZWFkIGxvb2sgaW4gdGhlIGN1cnJlbnQgY29tcG9uZW50J3MgY2hpbGRyZW4gZm9yIHRoZSByb3V0ZS5cbiAqIEFuZCBpZiB0aGUgc2VnbWVudCBiZWdpbnMgd2l0aCBgLi4vYCwgdGhlIHJvdXRlciB3aWxsIGdvIHVwIG9uZSBsZXZlbC5cbiAqL1xuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbcm91dGVyTGlua10nfSlcbmV4cG9ydCBjbGFzcyBSb3V0ZXJMaW5rIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgdGFyZ2V0OiBzdHJpbmc7XG4gIHByaXZhdGUgY29tbWFuZHM6IGFueVtdID0gW107XG4gIEBJbnB1dCgpIHF1ZXJ5UGFyYW1zOiB7W2s6IHN0cmluZ106IGFueX07XG4gIEBJbnB1dCgpIGZyYWdtZW50OiBzdHJpbmc7XG5cbiAgLy8gdGhlIHVybCBkaXNwbGF5ZWQgb24gdGhlIGFuY2hvciBlbGVtZW50LlxuICBASG9zdEJpbmRpbmcoKSBocmVmOiBzdHJpbmc7XG5cbiAgdXJsVHJlZTogVXJsVHJlZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsIHByaXZhdGUgcm91dGU6IEFjdGl2YXRlZFJvdXRlLFxuICAgICAgcHJpdmF0ZSBsb2NhdGlvblN0cmF0ZWd5OiBMb2NhdGlvblN0cmF0ZWd5KSB7fVxuXG4gIEBJbnB1dCgpXG4gIHNldCByb3V0ZXJMaW5rKGRhdGE6IGFueVtdfHN0cmluZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLmNvbW1hbmRzID0gPGFueT5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbW1hbmRzID0gW2RhdGFdO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHt9KTogYW55IHsgdGhpcy51cGRhdGVUYXJnZXRVcmxBbmRIcmVmKCk7IH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LmJ1dHRvbicsICckZXZlbnQuY3RybEtleScsICckZXZlbnQubWV0YUtleSddKVxuICBvbkNsaWNrKGJ1dHRvbjogbnVtYmVyLCBjdHJsS2V5OiBib29sZWFuLCBtZXRhS2V5OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgaWYgKGJ1dHRvbiAhPT0gMCB8fCBjdHJsS2V5IHx8IG1ldGFLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICdzdHJpbmcnICYmIHRoaXMudGFyZ2V0ICE9ICdfc2VsZicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodGhpcy51cmxUcmVlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVRhcmdldFVybEFuZEhyZWYoKTogdm9pZCB7XG4gICAgdGhpcy51cmxUcmVlID0gdGhpcy5yb3V0ZXIuY3JlYXRlVXJsVHJlZShcbiAgICAgICAgdGhpcy5jb21tYW5kcyxcbiAgICAgICAge3JlbGF0aXZlVG86IHRoaXMucm91dGUsIHF1ZXJ5UGFyYW1zOiB0aGlzLnF1ZXJ5UGFyYW1zLCBmcmFnbWVudDogdGhpcy5mcmFnbWVudH0pO1xuICAgIGlmICh0aGlzLnVybFRyZWUpIHtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMubG9jYXRpb25TdHJhdGVneS5wcmVwYXJlRXh0ZXJuYWxVcmwodGhpcy5yb3V0ZXIuc2VyaWFsaXplVXJsKHRoaXMudXJsVHJlZSkpO1xuICAgIH1cbiAgfVxufVxuIl19

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(363);
	__webpack_require__(397);
	__webpack_require__(399);
	__webpack_require__(401);
	__webpack_require__(403);
	__webpack_require__(405);
	__webpack_require__(407);
	__webpack_require__(408);
	var core_1 = __webpack_require__(5);
	var Observable_1 = __webpack_require__(38);
	var Subject_1 = __webpack_require__(37);
	var of_1 = __webpack_require__(354);
	var apply_redirects_1 = __webpack_require__(415);
	var config_1 = __webpack_require__(420);
	var create_router_state_1 = __webpack_require__(421);
	var create_url_tree_1 = __webpack_require__(425);
	var recognize_1 = __webpack_require__(426);
	var resolve_1 = __webpack_require__(427);
	var router_outlet_map_1 = __webpack_require__(432);
	var router_state_1 = __webpack_require__(423);
	var shared_1 = __webpack_require__(416);
	var url_tree_1 = __webpack_require__(417);
	var collection_1 = __webpack_require__(419);
	var NavigationStart = (function () {
	    function NavigationStart(id, url) {
	        this.id = id;
	        this.url = url;
	    }
	    NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
	    return NavigationStart;
	}());
	exports.NavigationStart = NavigationStart;
	var NavigationEnd = (function () {
	    function NavigationEnd(id, url, urlAfterRedirects) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	    }
	    NavigationEnd.prototype.toString = function () {
	        return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
	    };
	    return NavigationEnd;
	}());
	exports.NavigationEnd = NavigationEnd;
	var NavigationCancel = (function () {
	    function NavigationCancel(id, url) {
	        this.id = id;
	        this.url = url;
	    }
	    NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
	    return NavigationCancel;
	}());
	exports.NavigationCancel = NavigationCancel;
	var NavigationError = (function () {
	    function NavigationError(id, url, error) {
	        this.id = id;
	        this.url = url;
	        this.error = error;
	    }
	    NavigationError.prototype.toString = function () {
	        return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
	    };
	    return NavigationError;
	}());
	exports.NavigationError = NavigationError;
	var RoutesRecognized = (function () {
	    function RoutesRecognized(id, url, urlAfterRedirects, state) {
	        this.id = id;
	        this.url = url;
	        this.urlAfterRedirects = urlAfterRedirects;
	        this.state = state;
	    }
	    RoutesRecognized.prototype.toString = function () {
	        return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
	    };
	    return RoutesRecognized;
	}());
	exports.RoutesRecognized = RoutesRecognized;
	var Router = (function () {
	    function Router(rootComponentType, resolver, urlSerializer, outletMap, location, injector, config) {
	        this.rootComponentType = rootComponentType;
	        this.resolver = resolver;
	        this.urlSerializer = urlSerializer;
	        this.outletMap = outletMap;
	        this.location = location;
	        this.injector = injector;
	        this.navigationId = 0;
	        this.resetConfig(config);
	        this.routerEvents = new Subject_1.Subject();
	        this.currentUrlTree = url_tree_1.createEmptyUrlTree();
	        this.currentRouterState = router_state_1.createEmptyState(this.currentUrlTree, this.rootComponentType);
	    }
	    Router.prototype.initialNavigation = function () {
	        this.setUpLocationChangeListener();
	        this.navigateByUrl(this.location.path());
	    };
	    Object.defineProperty(Router.prototype, "routerState", {
	        get: function () { return this.currentRouterState; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Router.prototype, "url", {
	        get: function () { return this.serializeUrl(this.currentUrlTree); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Router.prototype, "events", {
	        get: function () { return this.routerEvents; },
	        enumerable: true,
	        configurable: true
	    });
	    Router.prototype.resetConfig = function (config) {
	        config_1.validateConfig(config);
	        this.config = config;
	    };
	    Router.prototype.dispose = function () { this.locationSubscription.unsubscribe(); };
	    Router.prototype.createUrlTree = function (commands, _a) {
	        var _b = _a === void 0 ? {} : _a, relativeTo = _b.relativeTo, queryParams = _b.queryParams, fragment = _b.fragment;
	        var a = relativeTo ? relativeTo : this.routerState.root;
	        return create_url_tree_1.createUrlTree(a, this.currentUrlTree, commands, queryParams, fragment);
	    };
	    Router.prototype.navigateByUrl = function (url) {
	        if (url instanceof url_tree_1.UrlTree) {
	            return this.scheduleNavigation(url, false);
	        }
	        else {
	            var urlTree = this.urlSerializer.parse(url);
	            return this.scheduleNavigation(urlTree, false);
	        }
	    };
	    Router.prototype.navigate = function (commands, extras) {
	        if (extras === void 0) { extras = {}; }
	        return this.scheduleNavigation(this.createUrlTree(commands, extras), false);
	    };
	    Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
	    Router.prototype.parseUrl = function (url) { return this.urlSerializer.parse(url); };
	    Router.prototype.scheduleNavigation = function (url, preventPushState) {
	        var _this = this;
	        var id = ++this.navigationId;
	        this.routerEvents.next(new NavigationStart(id, this.serializeUrl(url)));
	        return Promise.resolve().then(function (_) { return _this.runNavigate(url, preventPushState, id); });
	    };
	    Router.prototype.setUpLocationChangeListener = function () {
	        var _this = this;
	        this.locationSubscription = this.location.subscribe(function (change) {
	            return _this.scheduleNavigation(_this.urlSerializer.parse(change['url']), change['pop']);
	        });
	    };
	    Router.prototype.runNavigate = function (url, preventPushState, id) {
	        var _this = this;
	        if (id !== this.navigationId) {
	            this.location.go(this.urlSerializer.serialize(this.currentUrlTree));
	            this.routerEvents.next(new NavigationCancel(id, this.serializeUrl(url)));
	            return Promise.resolve(false);
	        }
	        return new Promise(function (resolvePromise, rejectPromise) {
	            var updatedUrl;
	            var state;
	            apply_redirects_1.applyRedirects(url, _this.config)
	                .mergeMap(function (u) {
	                updatedUrl = u;
	                return recognize_1.recognize(_this.rootComponentType, _this.config, updatedUrl, _this.serializeUrl(updatedUrl));
	            })
	                .mergeMap(function (newRouterStateSnapshot) {
	                _this.routerEvents.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(updatedUrl), newRouterStateSnapshot));
	                return resolve_1.resolve(_this.resolver, newRouterStateSnapshot);
	            })
	                .map(function (routerStateSnapshot) {
	                return create_router_state_1.createRouterState(routerStateSnapshot, _this.currentRouterState);
	            })
	                .map(function (newState) {
	                state = newState;
	            })
	                .mergeMap(function (_) {
	                return new GuardChecks(state.snapshot, _this.currentRouterState.snapshot, _this.injector)
	                    .check(_this.outletMap);
	            })
	                .forEach(function (shouldActivate) {
	                if (!shouldActivate || id !== _this.navigationId) {
	                    _this.routerEvents.next(new NavigationCancel(id, _this.serializeUrl(url)));
	                    return Promise.resolve(false);
	                }
	                new ActivateRoutes(state, _this.currentRouterState).activate(_this.outletMap);
	                _this.currentUrlTree = updatedUrl;
	                _this.currentRouterState = state;
	                if (!preventPushState) {
	                    var path = _this.urlSerializer.serialize(updatedUrl);
	                    if (_this.location.isCurrentPathEqualTo(path)) {
	                        _this.location.replaceState(path);
	                    }
	                    else {
	                        _this.location.go(path);
	                    }
	                }
	                return Promise.resolve(true);
	            })
	                .then(function () {
	                _this.routerEvents.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(updatedUrl)));
	                resolvePromise(true);
	            }, function (e) {
	                _this.routerEvents.next(new NavigationError(id, _this.serializeUrl(url), e));
	                rejectPromise(e);
	            });
	        });
	    };
	    return Router;
	}());
	exports.Router = Router;
	var CanActivate = (function () {
	    function CanActivate(route) {
	        this.route = route;
	    }
	    return CanActivate;
	}());
	var CanDeactivate = (function () {
	    function CanDeactivate(component, route) {
	        this.component = component;
	        this.route = route;
	    }
	    return CanDeactivate;
	}());
	var GuardChecks = (function () {
	    function GuardChecks(future, curr, injector) {
	        this.future = future;
	        this.curr = curr;
	        this.injector = injector;
	        this.checks = [];
	    }
	    GuardChecks.prototype.check = function (parentOutletMap) {
	        var _this = this;
	        var futureRoot = this.future._root;
	        var currRoot = this.curr ? this.curr._root : null;
	        this.traverseChildRoutes(futureRoot, currRoot, parentOutletMap);
	        if (this.checks.length === 0)
	            return of_1.of(true);
	        return Observable_1.Observable.from(this.checks)
	            .map(function (s) {
	            if (s instanceof CanActivate) {
	                return _this.runCanActivate(s.route);
	            }
	            else if (s instanceof CanDeactivate) {
	                return _this.runCanDeactivate(s.component, s.route);
	            }
	            else {
	                throw new Error('Cannot be reached');
	            }
	        })
	            .mergeAll()
	            .every(function (result) { return result === true; });
	    };
	    GuardChecks.prototype.traverseChildRoutes = function (futureNode, currNode, outletMap) {
	        var _this = this;
	        var prevChildren = nodeChildrenAsMap(currNode);
	        futureNode.children.forEach(function (c) {
	            _this.traverseRoutes(c, prevChildren[c.value.outlet], outletMap);
	            delete prevChildren[c.value.outlet];
	        });
	        collection_1.forEach(prevChildren, function (v, k) { return _this.deactivateOutletAndItChildren(v, outletMap._outlets[k]); });
	    };
	    GuardChecks.prototype.traverseRoutes = function (futureNode, currNode, parentOutletMap) {
	        var future = futureNode.value;
	        var curr = currNode ? currNode.value : null;
	        var outlet = parentOutletMap ? parentOutletMap._outlets[futureNode.value.outlet] : null;
	        if (curr && future._routeConfig === curr._routeConfig) {
	            if (!collection_1.shallowEqual(future.params, curr.params)) {
	                this.checks.push(new CanDeactivate(outlet.component, curr), new CanActivate(future));
	            }
	            this.traverseChildRoutes(futureNode, currNode, outlet ? outlet.outletMap : null);
	        }
	        else {
	            this.deactivateOutletAndItChildren(curr, outlet);
	            this.checks.push(new CanActivate(future));
	            this.traverseChildRoutes(futureNode, null, outlet ? outlet.outletMap : null);
	        }
	    };
	    GuardChecks.prototype.deactivateOutletAndItChildren = function (route, outlet) {
	        var _this = this;
	        if (outlet && outlet.isActivated) {
	            collection_1.forEach(outlet.outletMap._outlets, function (v) {
	                if (v.isActivated) {
	                    _this.deactivateOutletAndItChildren(v.activatedRoute.snapshot, v);
	                }
	            });
	            this.checks.push(new CanDeactivate(outlet.component, route));
	        }
	    };
	    GuardChecks.prototype.runCanActivate = function (future) {
	        var _this = this;
	        var canActivate = future._routeConfig ? future._routeConfig.canActivate : null;
	        if (!canActivate || canActivate.length === 0)
	            return of_1.of(true);
	        return Observable_1.Observable.from(canActivate)
	            .map(function (c) {
	            var guard = _this.injector.get(c);
	            if (guard.canActivate) {
	                return wrapIntoObservable(guard.canActivate(future, _this.future));
	            }
	            else {
	                return wrapIntoObservable(guard(future, _this.future));
	            }
	        })
	            .mergeAll()
	            .every(function (result) { return result === true; });
	    };
	    GuardChecks.prototype.runCanDeactivate = function (component, curr) {
	        var _this = this;
	        var canDeactivate = curr._routeConfig ? curr._routeConfig.canDeactivate : null;
	        if (!canDeactivate || canDeactivate.length === 0)
	            return of_1.of(true);
	        return Observable_1.Observable.from(canDeactivate)
	            .map(function (c) {
	            var guard = _this.injector.get(c);
	            if (guard.canDeactivate) {
	                return wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr));
	            }
	            else {
	                return wrapIntoObservable(guard(component, curr, _this.curr));
	            }
	        })
	            .mergeAll()
	            .every(function (result) { return result === true; });
	    };
	    return GuardChecks;
	}());
	function wrapIntoObservable(value) {
	    if (value instanceof Observable_1.Observable) {
	        return value;
	    }
	    else {
	        return of_1.of(value);
	    }
	}
	var ActivateRoutes = (function () {
	    function ActivateRoutes(futureState, currState) {
	        this.futureState = futureState;
	        this.currState = currState;
	    }
	    ActivateRoutes.prototype.activate = function (parentOutletMap) {
	        var futureRoot = this.futureState._root;
	        var currRoot = this.currState ? this.currState._root : null;
	        pushQueryParamsAndFragment(this.futureState);
	        this.activateChildRoutes(futureRoot, currRoot, parentOutletMap);
	    };
	    ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, outletMap) {
	        var _this = this;
	        var prevChildren = nodeChildrenAsMap(currNode);
	        futureNode.children.forEach(function (c) {
	            _this.activateRoutes(c, prevChildren[c.value.outlet], outletMap);
	            delete prevChildren[c.value.outlet];
	        });
	        collection_1.forEach(prevChildren, function (v, k) { return _this.deactivateOutletAndItChildren(outletMap._outlets[k]); });
	    };
	    ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentOutletMap) {
	        var future = futureNode.value;
	        var curr = currNode ? currNode.value : null;
	        var outlet = getOutlet(parentOutletMap, futureNode.value);
	        if (future === curr) {
	            router_state_1.advanceActivatedRoute(future);
	            this.activateChildRoutes(futureNode, currNode, outlet.outletMap);
	        }
	        else {
	            this.deactivateOutletAndItChildren(outlet);
	            var outletMap = new router_outlet_map_1.RouterOutletMap();
	            this.activateNewRoutes(outletMap, future, outlet);
	            this.activateChildRoutes(futureNode, null, outletMap);
	        }
	    };
	    ActivateRoutes.prototype.activateNewRoutes = function (outletMap, future, outlet) {
	        var resolved = core_1.ReflectiveInjector.resolve([
	            { provide: router_state_1.ActivatedRoute, useValue: future },
	            { provide: router_outlet_map_1.RouterOutletMap, useValue: outletMap }
	        ]);
	        router_state_1.advanceActivatedRoute(future);
	        outlet.activate(future._futureSnapshot._resolvedComponentFactory, future, resolved, outletMap);
	    };
	    ActivateRoutes.prototype.deactivateOutletAndItChildren = function (outlet) {
	        var _this = this;
	        if (outlet && outlet.isActivated) {
	            collection_1.forEach(outlet.outletMap._outlets, function (v) { return _this.deactivateOutletAndItChildren(v); });
	            outlet.deactivate();
	        }
	    };
	    return ActivateRoutes;
	}());
	function pushQueryParamsAndFragment(state) {
	    if (!collection_1.shallowEqual(state.snapshot.queryParams, state.queryParams.value)) {
	        state.queryParams.next(state.snapshot.queryParams);
	    }
	    if (state.snapshot.fragment !== state.fragment.value) {
	        state.fragment.next(state.snapshot.fragment);
	    }
	}
	function nodeChildrenAsMap(node) {
	    return node ? node.children.reduce(function (m, c) {
	        m[c.value.outlet] = c;
	        return m;
	    }, {}) : {};
	}
	function getOutlet(outletMap, route) {
	    var outlet = outletMap._outlets[route.outlet];
	    if (!outlet) {
	        var componentName = route.component.name;
	        if (route.outlet === shared_1.PRIMARY_OUTLET) {
	            throw new Error("Cannot find primary outlet to load '" + componentName + "'");
	        }
	        else {
	            throw new Error("Cannot find the outlet " + route.outlet + " to load '" + componentName + "'");
	        }
	    }
	    return outlet;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JvdXRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsUUFBTyx1QkFBdUIsQ0FBQyxDQUFBO0FBQy9CLFFBQU8sd0JBQXdCLENBQUMsQ0FBQTtBQUNoQyxRQUFPLDRCQUE0QixDQUFDLENBQUE7QUFDcEMsUUFBTywwQkFBMEIsQ0FBQyxDQUFBO0FBQ2xDLFFBQU8sNkJBQTZCLENBQUMsQ0FBQTtBQUNyQyxRQUFPLHlCQUF5QixDQUFDLENBQUE7QUFDakMsUUFBTyw0QkFBNEIsQ0FBQyxDQUFBO0FBQ3BDLFFBQU8sMEJBQTBCLENBQUMsQ0FBQTtBQUdsQyxxQkFBb0UsZUFBZSxDQUFDLENBQUE7QUFDcEYsMkJBQXlCLGlCQUFpQixDQUFDLENBQUE7QUFDM0Msd0JBQXNCLGNBQWMsQ0FBQyxDQUFBO0FBRXJDLG1CQUFrQixvQkFBb0IsQ0FBQyxDQUFBO0FBRXZDLGdDQUE2QixtQkFBbUIsQ0FBQyxDQUFBO0FBQ2pELHVCQUEyQyxVQUFVLENBQUMsQ0FBQTtBQUN0RCxvQ0FBZ0MsdUJBQXVCLENBQUMsQ0FBQTtBQUN4RCxnQ0FBNEIsbUJBQW1CLENBQUMsQ0FBQTtBQUVoRCwwQkFBd0IsYUFBYSxDQUFDLENBQUE7QUFDdEMsd0JBQXNCLFdBQVcsQ0FBQyxDQUFBO0FBQ2xDLGtDQUE4QixxQkFBcUIsQ0FBQyxDQUFBO0FBQ3BELDZCQUFnSSxnQkFBZ0IsQ0FBQyxDQUFBO0FBQ2pKLHVCQUFxQyxVQUFVLENBQUMsQ0FBQTtBQUVoRCx5QkFBMEMsWUFBWSxDQUFDLENBQUE7QUFDdkQsMkJBQW9DLG9CQUFvQixDQUFDLENBQUE7QUFZekQ7SUFDRSx5QkFBbUIsRUFBVSxFQUFTLEdBQVc7UUFBOUIsT0FBRSxHQUFGLEVBQUUsQ0FBUTtRQUFTLFFBQUcsR0FBSCxHQUFHLENBQVE7SUFBRyxDQUFDO0lBRXJELGtDQUFRLEdBQVIsY0FBcUIsTUFBTSxDQUFDLHlCQUF1QixJQUFJ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LGFBQWEsR0FBUyxLQUFLLENBQUMsU0FBVSxDQUFDLElBQUksQ0FBQztRQUNsRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLHVCQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXVDLGFBQWEsTUFBRyxDQUFDLENBQUM7UUFDM0UsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBMEIsS0FBSyxDQUFDLE1BQU0sa0JBQWEsYUFBYSxNQUFHLENBQUMsQ0FBQztRQUN2RixDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc2Nhbic7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0JztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0TWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZXZlcnknO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZUFsbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZnJvbSc7XG5cbmltcG9ydCB7TG9jYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0NvbXBvbmVudFJlc29sdmVyLCBJbmplY3RvciwgUmVmbGVjdGl2ZUluamVjdG9yLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7U3ViamVjdH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQge29mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcblxuaW1wb3J0IHthcHBseVJlZGlyZWN0c30gZnJvbSAnLi9hcHBseV9yZWRpcmVjdHMnO1xuaW1wb3J0IHtSb3V0ZXJDb25maWcsIHZhbGlkYXRlQ29uZmlnfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQge2NyZWF0ZVJvdXRlclN0YXRlfSBmcm9tICcuL2NyZWF0ZV9yb3V0ZXJfc3RhdGUnO1xuaW1wb3J0IHtjcmVhdGVVcmxUcmVlfSBmcm9tICcuL2NyZWF0ZV91cmxfdHJlZSc7XG5pbXBvcnQge1JvdXRlck91dGxldH0gZnJvbSAnLi9kaXJlY3RpdmVzL3JvdXRlcl9vdXRsZXQnO1xuaW1wb3J0IHtyZWNvZ25pemV9IGZyb20gJy4vcmVjb2duaXplJztcbmltcG9ydCB7cmVzb2x2ZX0gZnJvbSAnLi9yZXNvbHZlJztcbmltcG9ydCB7Um91dGVyT3V0bGV0TWFwfSBmcm9tICcuL3JvdXRlcl9vdXRsZXRfbWFwJztcbmltcG9ydCB7QWN0aXZhdGVkUm91dGUsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlLCBSb3V0ZXJTdGF0ZVNuYXBzaG90LCBhZHZhbmNlQWN0aXZhdGVkUm91dGUsIGNyZWF0ZUVtcHR5U3RhdGV9IGZyb20gJy4vcm91dGVyX3N0YXRlJztcbmltcG9ydCB7UFJJTUFSWV9PVVRMRVQsIFBhcmFtc30gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHtVcmxTZXJpYWxpemVyfSBmcm9tICcuL3VybF9zZXJpYWxpemVyJztcbmltcG9ydCB7VXJsVHJlZSwgY3JlYXRlRW1wdHlVcmxUcmVlfSBmcm9tICcuL3VybF90cmVlJztcbmltcG9ydCB7Zm9yRWFjaCwgc2hhbGxvd0VxdWFsfSBmcm9tICcuL3V0aWxzL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHtUcmVlTm9kZX0gZnJvbSAnLi91dGlscy90cmVlJztcblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0aW9uRXh0cmFzIHtcbiAgcmVsYXRpdmVUbz86IEFjdGl2YXRlZFJvdXRlO1xuICBxdWVyeVBhcmFtcz86IFBhcmFtcztcbiAgZnJhZ21lbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIHN0YXJ0c1xuICovXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvblN0YXJ0IHtcbiAgY29uc3RydWN0b3IocHVibGljIGlkOiBudW1iZXIsIHB1YmxpYyB1cmw6IHN0cmluZykge31cblxuICB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gYE5hdmlnYXRpb25TdGFydChpZDogJHt0aGlzLmlkfSwgdXJsOiAnJHt0aGlzLnVybH0nKWA7IH1cbn1cblxuLyoqXG4gKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gZW5kcyBzdWNjZXNzZnVsbHlcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25FbmQge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaWQ6IG51bWJlciwgcHVibGljIHVybDogc3RyaW5nLCBwdWJsaWMgdXJsQWZ0ZXJSZWRpcmVjdHM6IHN0cmluZykge31cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgTmF2aWdhdGlvbkVuZChpZDogJHt0aGlzLmlkfSwgdXJsOiAnJHt0aGlzLnVybH0nLCB1cmxBZnRlclJlZGlyZWN0czogJyR7dGhpcy51cmxBZnRlclJlZGlyZWN0c30nKWA7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gaXMgY2FuY2VsZWRcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25DYW5jZWwge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaWQ6IG51bWJlciwgcHVibGljIHVybDogc3RyaW5nKSB7fVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiBgTmF2aWdhdGlvbkNhbmNlbChpZDogJHt0aGlzLmlkfSwgdXJsOiAnJHt0aGlzLnVybH0nKWA7IH1cbn1cblxuLyoqXG4gKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gZmFpbHMgZHVlIHRvIHVuZXhwZWN0ZWQgZXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBpZDogbnVtYmVyLCBwdWJsaWMgdXJsOiBzdHJpbmcsIHB1YmxpYyBlcnJvcjogYW55KSB7fVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBOYXZpZ2F0aW9uRXJyb3IoaWQ6ICR7dGhpcy5pZH0sIHVybDogJyR7dGhpcy51cmx9JywgZXJyb3I6ICR7dGhpcy5lcnJvcn0pYDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHJvdXRlcyBhcmUgcmVjb2duaXplZFxuICovXG5leHBvcnQgY2xhc3MgUm91dGVzUmVjb2duaXplZCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIGlkOiBudW1iZXIsIHB1YmxpYyB1cmw6IHN0cmluZywgcHVibGljIHVybEFmdGVyUmVkaXJlY3RzOiBzdHJpbmcsXG4gICAgICBwdWJsaWMgc3RhdGU6IFJvdXRlclN0YXRlU25hcHNob3QpIHt9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFJvdXRlc1JlY29nbml6ZWQoaWQ6ICR7dGhpcy5pZH0sIHVybDogJyR7dGhpcy51cmx9JywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICcke3RoaXMudXJsQWZ0ZXJSZWRpcmVjdHN9Jywgc3RhdGU6ICR7dGhpcy5zdGF0ZX0pYDtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBFdmVudCA9IE5hdmlnYXRpb25TdGFydCB8IE5hdmlnYXRpb25FbmQgfCBOYXZpZ2F0aW9uQ2FuY2VsIHwgTmF2aWdhdGlvbkVycm9yO1xuXG4vKipcbiAqIFRoZSBgUm91dGVyYCBpcyByZXNwb25zaWJsZSBmb3IgbWFwcGluZyBVUkxzIHRvIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3V0ZXIge1xuICBwcml2YXRlIGN1cnJlbnRVcmxUcmVlOiBVcmxUcmVlO1xuICBwcml2YXRlIGN1cnJlbnRSb3V0ZXJTdGF0ZTogUm91dGVyU3RhdGU7XG4gIHByaXZhdGUgbG9jYXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSByb3V0ZXJFdmVudHM6IFN1YmplY3Q8RXZlbnQ+O1xuICBwcml2YXRlIG5hdmlnYXRpb25JZDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBjb25maWc6IFJvdXRlckNvbmZpZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgcm9vdENvbXBvbmVudFR5cGU6IFR5cGUsIHByaXZhdGUgcmVzb2x2ZXI6IENvbXBvbmVudFJlc29sdmVyLFxuICAgICAgcHJpdmF0ZSB1cmxTZXJpYWxpemVyOiBVcmxTZXJpYWxpemVyLCBwcml2YXRlIG91dGxldE1hcDogUm91dGVyT3V0bGV0TWFwLFxuICAgICAgcHJpdmF0ZSBsb2NhdGlvbjogTG9jYXRpb24sIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLCBjb25maWc6IFJvdXRlckNvbmZpZykge1xuICAgIHRoaXMucmVzZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnJvdXRlckV2ZW50cyA9IG5ldyBTdWJqZWN0PEV2ZW50PigpO1xuICAgIHRoaXMuY3VycmVudFVybFRyZWUgPSBjcmVhdGVFbXB0eVVybFRyZWUoKTtcbiAgICB0aGlzLmN1cnJlbnRSb3V0ZXJTdGF0ZSA9IGNyZWF0ZUVtcHR5U3RhdGUodGhpcy5jdXJyZW50VXJsVHJlZSwgdGhpcy5yb290Q29tcG9uZW50VHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBpbml0aWFsTmF2aWdhdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcigpO1xuICAgIHRoaXMubmF2aWdhdGVCeVVybCh0aGlzLmxvY2F0aW9uLnBhdGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByb3V0ZSBzdGF0ZS5cbiAgICovXG4gIGdldCByb3V0ZXJTdGF0ZSgpOiBSb3V0ZXJTdGF0ZSB7IHJldHVybiB0aGlzLmN1cnJlbnRSb3V0ZXJTdGF0ZTsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVybC5cbiAgICovXG4gIGdldCB1cmwoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplVXJsKHRoaXMuY3VycmVudFVybFRyZWUpOyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiByb3V0ZSBldmVudHNcbiAgICovXG4gIGdldCBldmVudHMoKTogT2JzZXJ2YWJsZTxFdmVudD4geyByZXR1cm4gdGhpcy5yb3V0ZXJFdmVudHM7IH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjb25maWd1cmF0aW9uIHVzZWQgZm9yIG5hdmlnYXRpb24gYW5kIGdlbmVyYXRpbmcgbGlua3MuXG4gICAqXG4gICAqICMjIyBVc2FnZVxuICAgKlxuICAgKiBgYGBcbiAgICogcm91dGVyLnJlc2V0Q29uZmlnKFtcbiAgICogIHsgcGF0aDogJ3RlYW0vOmlkJywgY29tcG9uZW50OiBUZWFtQ21wLCBjaGlsZHJlbjogW1xuICAgKiAgICB7IHBhdGg6ICdzaW1wbGUnLCBjb21wb25lbnQ6IFNpbXBsZUNtcCB9LFxuICAgKiAgICB7IHBhdGg6ICd1c2VyLzpuYW1lJywgY29tcG9uZW50OiBVc2VyQ21wIH1cbiAgICogIF0gfVxuICAgKiBdKTtcbiAgICogYGBgXG4gICAqL1xuICByZXNldENvbmZpZyhjb25maWc6IFJvdXRlckNvbmZpZyk6IHZvaWQge1xuICAgIHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQgeyB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH1cblxuICAvKipcbiAgICogQXBwbGllcyBhbiBhcnJheSBvZiBjb21tYW5kcyB0byB0aGUgY3VycmVudCB1cmwgdHJlZSBhbmQgY3JlYXRlc1xuICAgKiBhIG5ldyB1cmwgdHJlZS5cbiAgICpcbiAgICogV2hlbiBnaXZlbiBhbiBhY3RpdmF0ZSByb3V0ZSwgYXBwbGllcyB0aGUgZ2l2ZW4gY29tbWFuZHMgc3RhcnRpbmcgZnJvbSB0aGUgcm91dGUuXG4gICAqIFdoZW4gbm90IGdpdmVuIGEgcm91dGUsIGFwcGxpZXMgdGhlIGdpdmVuIGNvbW1hbmQgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICpcbiAgICogIyMjIFVzYWdlXG4gICAqXG4gICAqIGBgYFxuICAgKiAvLyBjcmVhdGUgL3RlYW0vMzMvdXNlci8xMVxuICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJy90ZWFtJywgMzMsICd1c2VyJywgMTFdKTtcbiAgICpcbiAgICogLy8gY3JlYXRlIC90ZWFtLzMzO2V4cGFuZD10cnVlL3VzZXIvMTFcbiAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycvdGVhbScsIDMzLCB7ZXhwYW5kOiB0cnVlfSwgJ3VzZXInLCAxMV0pO1xuICAgKlxuICAgKiAvLyB5b3UgY2FuIGNvbGxhcHNlIHN0YXRpYyBmcmFnbWVudHMgbGlrZSB0aGlzXG4gICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0vMzMvdXNlcicsIHVzZXJJZF0pO1xuICAgKlxuICAgKiAvLyBhc3N1bWluZyB0aGUgY3VycmVudCB1cmwgaXMgYC90ZWFtLzMzL3VzZXIvMTFgIGFuZCB0aGUgcm91dGUgcG9pbnRzIHRvIGB1c2VyLzExYFxuICAgKlxuICAgKiAvLyBuYXZpZ2F0ZSB0byAvdGVhbS8zMy91c2VyLzExL2RldGFpbHNcbiAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWydkZXRhaWxzJ10sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgKlxuICAgKiAvLyBuYXZpZ2F0ZSB0byAvdGVhbS8zMy91c2VyLzIyXG4gICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnLi4vMjInXSwge3JlbGF0aXZlVG86IHJvdXRlfSk7XG4gICAqXG4gICAqIC8vIG5hdmlnYXRlIHRvIC90ZWFtLzQ0L3VzZXIvMjJcbiAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycuLi8uLi90ZWFtLzQ0L3VzZXIvMjInXSwge3JlbGF0aXZlVG86IHJvdXRlfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgY3JlYXRlVXJsVHJlZShjb21tYW5kczogYW55W10sIHtyZWxhdGl2ZVRvLCBxdWVyeVBhcmFtcywgZnJhZ21lbnR9OiBOYXZpZ2F0aW9uRXh0cmFzID0ge30pOlxuICAgICAgVXJsVHJlZSB7XG4gICAgY29uc3QgYSA9IHJlbGF0aXZlVG8gPyByZWxhdGl2ZVRvIDogdGhpcy5yb3V0ZXJTdGF0ZS5yb290O1xuICAgIHJldHVybiBjcmVhdGVVcmxUcmVlKGEsIHRoaXMuY3VycmVudFVybFRyZWUsIGNvbW1hbmRzLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB1cmwuIFRoaXMgbmF2aWdhdGlvbiBpcyBhbHdheXMgYWJzb2x1dGUuXG4gICAqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQ6XG4gICAqIC0gaXMgcmVzb2x2ZWQgd2l0aCAndHJ1ZScgd2hlbiBuYXZpZ2F0aW9uIHN1Y2NlZWRzXG4gICAqIC0gaXMgcmVzb2x2ZWQgd2l0aCAnZmFsc2UnIHdoZW4gbmF2aWdhdGlvbiBmYWlsc1xuICAgKiAtIGlzIHJlamVjdGVkIHdoZW4gYW4gZXJyb3IgaGFwcGVuc1xuICAgKlxuICAgKiAjIyMgVXNhZ2VcbiAgICpcbiAgICogYGBgXG4gICAqIHJvdXRlci5uYXZpZ2F0ZUJ5VXJsKFwiL3RlYW0vMzMvdXNlci8xMVwiKTtcbiAgICogYGBgXG4gICAqL1xuICBuYXZpZ2F0ZUJ5VXJsKHVybDogc3RyaW5nfFVybFRyZWUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodXJsIGluc3RhbmNlb2YgVXJsVHJlZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKHVybCwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cmxUcmVlID0gdGhpcy51cmxTZXJpYWxpemVyLnBhcnNlKHVybCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZU5hdmlnYXRpb24odXJsVHJlZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgY29tbWFuZHMgYW5kIGEgc3RhcnRpbmcgcG9pbnQuXG4gICAqIElmIG5vIHN0YXJ0aW5nIHJvdXRlIGlzIHByb3ZpZGVkLCB0aGUgbmF2aWdhdGlvbiBpcyBhYnNvbHV0ZS5cbiAgICpcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdDpcbiAgICogLSBpcyByZXNvbHZlZCB3aXRoICd0cnVlJyB3aGVuIG5hdmlnYXRpb24gc3VjY2VlZHNcbiAgICogLSBpcyByZXNvbHZlZCB3aXRoICdmYWxzZScgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzXG4gICAqIC0gaXMgcmVqZWN0ZWQgd2hlbiBhbiBlcnJvciBoYXBwZW5zXG4gICAqXG4gICAqICMjIyBVc2FnZVxuICAgKlxuICAgKiBgYGBcbiAgICogcm91dGVyLm5hdmlnYXRlKFsndGVhbScsIDMzLCAndGVhbScsICcxMV0sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgKiBgYGBcbiAgICovXG4gIG5hdmlnYXRlKGNvbW1hbmRzOiBhbnlbXSwgZXh0cmFzOiBOYXZpZ2F0aW9uRXh0cmFzID0ge30pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5zY2hlZHVsZU5hdmlnYXRpb24odGhpcy5jcmVhdGVVcmxUcmVlKGNvbW1hbmRzLCBleHRyYXMpLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIHtAbGluayBVcmxUcmVlfSBpbnRvIGEgc3RyaW5nLlxuICAgKi9cbiAgc2VyaWFsaXplVXJsKHVybDogVXJsVHJlZSk6IHN0cmluZyB7IHJldHVybiB0aGlzLnVybFNlcmlhbGl6ZXIuc2VyaWFsaXplKHVybCk7IH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzdHJpbmcgaW50byBhIHtAbGluayBVcmxUcmVlfS5cbiAgICovXG4gIHBhcnNlVXJsKHVybDogc3RyaW5nKTogVXJsVHJlZSB7IHJldHVybiB0aGlzLnVybFNlcmlhbGl6ZXIucGFyc2UodXJsKTsgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGVOYXZpZ2F0aW9uKHVybDogVXJsVHJlZSwgcHJldmVudFB1c2hTdGF0ZTogYm9vbGVhbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGlkID0gKyt0aGlzLm5hdmlnYXRpb25JZDtcbiAgICB0aGlzLnJvdXRlckV2ZW50cy5uZXh0KG5ldyBOYXZpZ2F0aW9uU3RhcnQoaWQsIHRoaXMuc2VyaWFsaXplVXJsKHVybCkpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoXykgPT4gdGhpcy5ydW5OYXZpZ2F0ZSh1cmwsIHByZXZlbnRQdXNoU3RhdGUsIGlkKSk7XG4gIH1cblxuICBwcml2YXRlIHNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uID0gPGFueT50aGlzLmxvY2F0aW9uLnN1YnNjcmliZSgoY2hhbmdlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZU5hdmlnYXRpb24odGhpcy51cmxTZXJpYWxpemVyLnBhcnNlKGNoYW5nZVsndXJsJ10pLCBjaGFuZ2VbJ3BvcCddKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcnVuTmF2aWdhdGUodXJsOiBVcmxUcmVlLCBwcmV2ZW50UHVzaFN0YXRlOiBib29sZWFuLCBpZDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKGlkICE9PSB0aGlzLm5hdmlnYXRpb25JZCkge1xuICAgICAgdGhpcy5sb2NhdGlvbi5nbyh0aGlzLnVybFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMuY3VycmVudFVybFRyZWUpKTtcbiAgICAgIHRoaXMucm91dGVyRXZlbnRzLm5leHQobmV3IE5hdmlnYXRpb25DYW5jZWwoaWQsIHRoaXMuc2VyaWFsaXplVXJsKHVybCkpKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpID0+IHtcbiAgICAgIGxldCB1cGRhdGVkVXJsOiBVcmxUcmVlO1xuICAgICAgbGV0IHN0YXRlOiBSb3V0ZXJTdGF0ZTtcbiAgICAgIGFwcGx5UmVkaXJlY3RzKHVybCwgdGhpcy5jb25maWcpXG4gICAgICAgICAgLm1lcmdlTWFwKHUgPT4ge1xuICAgICAgICAgICAgdXBkYXRlZFVybCA9IHU7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplKFxuICAgICAgICAgICAgICAgIHRoaXMucm9vdENvbXBvbmVudFR5cGUsIHRoaXMuY29uZmlnLCB1cGRhdGVkVXJsLCB0aGlzLnNlcmlhbGl6ZVVybCh1cGRhdGVkVXJsKSk7XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIC5tZXJnZU1hcCgobmV3Um91dGVyU3RhdGVTbmFwc2hvdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXJFdmVudHMubmV4dChuZXcgUm91dGVzUmVjb2duaXplZChcbiAgICAgICAgICAgICAgICBpZCwgdGhpcy5zZXJpYWxpemVVcmwodXJsKSwgdGhpcy5zZXJpYWxpemVVcmwodXBkYXRlZFVybCksIG5ld1JvdXRlclN0YXRlU25hcHNob3QpKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMucmVzb2x2ZXIsIG5ld1JvdXRlclN0YXRlU25hcHNob3QpO1xuXG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKChyb3V0ZXJTdGF0ZVNuYXBzaG90KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUm91dGVyU3RhdGUocm91dGVyU3RhdGVTbmFwc2hvdCwgdGhpcy5jdXJyZW50Um91dGVyU3RhdGUpO1xuXG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKChuZXdTdGF0ZTogUm91dGVyU3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG5cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tZXJnZU1hcChfID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3VhcmRDaGVja3Moc3RhdGUuc25hcHNob3QsIHRoaXMuY3VycmVudFJvdXRlclN0YXRlLnNuYXBzaG90LCB0aGlzLmluamVjdG9yKVxuICAgICAgICAgICAgICAgIC5jaGVjayh0aGlzLm91dGxldE1hcCk7XG5cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKChzaG91bGRBY3RpdmF0ZTogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGRBY3RpdmF0ZSB8fCBpZCAhPT0gdGhpcy5uYXZpZ2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5yb3V0ZXJFdmVudHMubmV4dChuZXcgTmF2aWdhdGlvbkNhbmNlbChpZCwgdGhpcy5zZXJpYWxpemVVcmwodXJsKSkpO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3IEFjdGl2YXRlUm91dGVzKHN0YXRlLCB0aGlzLmN1cnJlbnRSb3V0ZXJTdGF0ZSkuYWN0aXZhdGUodGhpcy5vdXRsZXRNYXApO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRVcmxUcmVlID0gdXBkYXRlZFVybDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdXRlclN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXByZXZlbnRQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgbGV0IHBhdGggPSB0aGlzLnVybFNlcmlhbGl6ZXIuc2VyaWFsaXplKHVwZGF0ZWRVcmwpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5sb2NhdGlvbi5pc0N1cnJlbnRQYXRoRXF1YWxUbyhwYXRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZVN0YXRlKHBhdGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24uZ28ocGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyRXZlbnRzLm5leHQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOYXZpZ2F0aW9uRW5kKGlkLCB0aGlzLnNlcmlhbGl6ZVVybCh1cmwpLCB0aGlzLnNlcmlhbGl6ZVVybCh1cGRhdGVkVXJsKSkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHRydWUpO1xuXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyRXZlbnRzLm5leHQobmV3IE5hdmlnYXRpb25FcnJvcihpZCwgdGhpcy5zZXJpYWxpemVVcmwodXJsKSwgZSkpO1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UoZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIENhbkFjdGl2YXRlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KSB7fVxufVxuY2xhc3MgQ2FuRGVhY3RpdmF0ZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjb21wb25lbnQ6IE9iamVjdCwgcHVibGljIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KSB7fVxufVxuXG5jbGFzcyBHdWFyZENoZWNrcyB7XG4gIHByaXZhdGUgY2hlY2tzOiBBcnJheTxDYW5BY3RpdmF0ZXxDYW5EZWFjdGl2YXRlPiA9IFtdO1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgZnV0dXJlOiBSb3V0ZXJTdGF0ZVNuYXBzaG90LCBwcml2YXRlIGN1cnI6IFJvdXRlclN0YXRlU25hcHNob3QsXG4gICAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3Rvcikge31cblxuICBjaGVjayhwYXJlbnRPdXRsZXRNYXA6IFJvdXRlck91dGxldE1hcCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGZ1dHVyZVJvb3QgPSB0aGlzLmZ1dHVyZS5fcm9vdDtcbiAgICBjb25zdCBjdXJyUm9vdCA9IHRoaXMuY3VyciA/IHRoaXMuY3Vyci5fcm9vdCA6IG51bGw7XG4gICAgdGhpcy50cmF2ZXJzZUNoaWxkUm91dGVzKGZ1dHVyZVJvb3QsIGN1cnJSb290LCBwYXJlbnRPdXRsZXRNYXApO1xuICAgIGlmICh0aGlzLmNoZWNrcy5sZW5ndGggPT09IDApIHJldHVybiBvZiAodHJ1ZSk7XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5mcm9tKHRoaXMuY2hlY2tzKVxuICAgICAgICAubWFwKHMgPT4ge1xuICAgICAgICAgIGlmIChzIGluc3RhbmNlb2YgQ2FuQWN0aXZhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkNhbkFjdGl2YXRlKHMucm91dGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocyBpbnN0YW5jZW9mIENhbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkNhbkRlYWN0aXZhdGUocy5jb21wb25lbnQsIHMucm91dGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiZSByZWFjaGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAubWVyZ2VBbGwoKVxuICAgICAgICAuZXZlcnkocmVzdWx0ID0+IHJlc3VsdCA9PT0gdHJ1ZSk7XG4gIH1cblxuICBwcml2YXRlIHRyYXZlcnNlQ2hpbGRSb3V0ZXMoXG4gICAgICBmdXR1cmVOb2RlOiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90PiwgY3Vyck5vZGU6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+LFxuICAgICAgb3V0bGV0TWFwOiBSb3V0ZXJPdXRsZXRNYXApOiB2b2lkIHtcbiAgICBjb25zdCBwcmV2Q2hpbGRyZW46IHtba2V5OiBzdHJpbmddOiBhbnl9ID0gbm9kZUNoaWxkcmVuQXNNYXAoY3Vyck5vZGUpO1xuICAgIGZ1dHVyZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChjID0+IHtcbiAgICAgIHRoaXMudHJhdmVyc2VSb3V0ZXMoYywgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XSwgb3V0bGV0TWFwKTtcbiAgICAgIGRlbGV0ZSBwcmV2Q2hpbGRyZW5bYy52YWx1ZS5vdXRsZXRdO1xuICAgIH0pO1xuICAgIGZvckVhY2goXG4gICAgICAgIHByZXZDaGlsZHJlbixcbiAgICAgICAgKHY6IGFueSwgazogc3RyaW5nKSA9PiB0aGlzLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKHYsIG91dGxldE1hcC5fb3V0bGV0c1trXSkpO1xuICB9XG5cbiAgdHJhdmVyc2VSb3V0ZXMoXG4gICAgICBmdXR1cmVOb2RlOiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90PiwgY3Vyck5vZGU6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+LFxuICAgICAgcGFyZW50T3V0bGV0TWFwOiBSb3V0ZXJPdXRsZXRNYXApOiB2b2lkIHtcbiAgICBjb25zdCBmdXR1cmUgPSBmdXR1cmVOb2RlLnZhbHVlO1xuICAgIGNvbnN0IGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcbiAgICBjb25zdCBvdXRsZXQgPSBwYXJlbnRPdXRsZXRNYXAgPyBwYXJlbnRPdXRsZXRNYXAuX291dGxldHNbZnV0dXJlTm9kZS52YWx1ZS5vdXRsZXRdIDogbnVsbDtcblxuICAgIGlmIChjdXJyICYmIGZ1dHVyZS5fcm91dGVDb25maWcgPT09IGN1cnIuX3JvdXRlQ29uZmlnKSB7XG4gICAgICBpZiAoIXNoYWxsb3dFcXVhbChmdXR1cmUucGFyYW1zLCBjdXJyLnBhcmFtcykpIHtcbiAgICAgICAgdGhpcy5jaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShvdXRsZXQuY29tcG9uZW50LCBjdXJyKSwgbmV3IENhbkFjdGl2YXRlKGZ1dHVyZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmF2ZXJzZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBvdXRsZXQgPyBvdXRsZXQub3V0bGV0TWFwIDogbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZU91dGxldEFuZEl0Q2hpbGRyZW4oY3Vyciwgb3V0bGV0KTtcbiAgICAgIHRoaXMuY2hlY2tzLnB1c2gobmV3IENhbkFjdGl2YXRlKGZ1dHVyZSkpO1xuICAgICAgdGhpcy50cmF2ZXJzZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIG51bGwsIG91dGxldCA/IG91dGxldC5vdXRsZXRNYXAgOiBudWxsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBvdXRsZXQ6IFJvdXRlck91dGxldCk6IHZvaWQge1xuICAgIGlmIChvdXRsZXQgJiYgb3V0bGV0LmlzQWN0aXZhdGVkKSB7XG4gICAgICBmb3JFYWNoKG91dGxldC5vdXRsZXRNYXAuX291dGxldHMsICh2OiBSb3V0ZXJPdXRsZXQpID0+IHtcbiAgICAgICAgaWYgKHYuaXNBY3RpdmF0ZWQpIHtcbiAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKHYuYWN0aXZhdGVkUm91dGUuc25hcHNob3QsIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2hlY2tzLnB1c2gobmV3IENhbkRlYWN0aXZhdGUob3V0bGV0LmNvbXBvbmVudCwgcm91dGUpKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJ1bkNhbkFjdGl2YXRlKGZ1dHVyZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGNhbkFjdGl2YXRlID0gZnV0dXJlLl9yb3V0ZUNvbmZpZyA/IGZ1dHVyZS5fcm91dGVDb25maWcuY2FuQWN0aXZhdGUgOiBudWxsO1xuICAgIGlmICghY2FuQWN0aXZhdGUgfHwgY2FuQWN0aXZhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gb2YgKHRydWUpO1xuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20oY2FuQWN0aXZhdGUpXG4gICAgICAgIC5tYXAoYyA9PiB7XG4gICAgICAgICAgY29uc3QgZ3VhcmQgPSB0aGlzLmluamVjdG9yLmdldChjKTtcbiAgICAgICAgICBpZiAoZ3VhcmQuY2FuQWN0aXZhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQuY2FuQWN0aXZhdGUoZnV0dXJlLCB0aGlzLmZ1dHVyZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkKGZ1dHVyZSwgdGhpcy5mdXR1cmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5tZXJnZUFsbCgpXG4gICAgICAgIC5ldmVyeShyZXN1bHQgPT4gcmVzdWx0ID09PSB0cnVlKTtcbiAgfVxuXG4gIHByaXZhdGUgcnVuQ2FuRGVhY3RpdmF0ZShjb21wb25lbnQ6IE9iamVjdCwgY3VycjogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGNhbkRlYWN0aXZhdGUgPSBjdXJyLl9yb3V0ZUNvbmZpZyA/IGN1cnIuX3JvdXRlQ29uZmlnLmNhbkRlYWN0aXZhdGUgOiBudWxsO1xuICAgIGlmICghY2FuRGVhY3RpdmF0ZSB8fCBjYW5EZWFjdGl2YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9mICh0cnVlKTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5mcm9tKGNhbkRlYWN0aXZhdGUpXG4gICAgICAgIC5tYXAoYyA9PiB7XG4gICAgICAgICAgY29uc3QgZ3VhcmQgPSB0aGlzLmluamVjdG9yLmdldChjKTtcbiAgICAgICAgICBpZiAoZ3VhcmQuY2FuRGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZC5jYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgY3VyciwgdGhpcy5jdXJyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQoY29tcG9uZW50LCBjdXJyLCB0aGlzLmN1cnIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5tZXJnZUFsbCgpXG4gICAgICAgIC5ldmVyeShyZXN1bHQgPT4gcmVzdWx0ID09PSB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwSW50b09ic2VydmFibGU8VD4odmFsdWU6IFQgfCBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9mICh2YWx1ZSk7XG4gIH1cbn1cblxuY2xhc3MgQWN0aXZhdGVSb3V0ZXMge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZ1dHVyZVN0YXRlOiBSb3V0ZXJTdGF0ZSwgcHJpdmF0ZSBjdXJyU3RhdGU6IFJvdXRlclN0YXRlKSB7fVxuXG4gIGFjdGl2YXRlKHBhcmVudE91dGxldE1hcDogUm91dGVyT3V0bGV0TWFwKTogdm9pZCB7XG4gICAgY29uc3QgZnV0dXJlUm9vdCA9IHRoaXMuZnV0dXJlU3RhdGUuX3Jvb3Q7XG4gICAgY29uc3QgY3VyclJvb3QgPSB0aGlzLmN1cnJTdGF0ZSA/IHRoaXMuY3VyclN0YXRlLl9yb290IDogbnVsbDtcblxuICAgIHB1c2hRdWVyeVBhcmFtc0FuZEZyYWdtZW50KHRoaXMuZnV0dXJlU3RhdGUpO1xuICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVSb290LCBjdXJyUm9vdCwgcGFyZW50T3V0bGV0TWFwKTtcbiAgfVxuXG4gIHByaXZhdGUgYWN0aXZhdGVDaGlsZFJvdXRlcyhcbiAgICAgIGZ1dHVyZU5vZGU6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlPiwgY3Vyck5vZGU6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlPixcbiAgICAgIG91dGxldE1hcDogUm91dGVyT3V0bGV0TWFwKTogdm9pZCB7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuOiB7W2tleTogc3RyaW5nXTogYW55fSA9IG5vZGVDaGlsZHJlbkFzTWFwKGN1cnJOb2RlKTtcbiAgICBmdXR1cmVOb2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRlUm91dGVzKGMsIHByZXZDaGlsZHJlbltjLnZhbHVlLm91dGxldF0sIG91dGxldE1hcCk7XG4gICAgICBkZWxldGUgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKFxuICAgICAgICBwcmV2Q2hpbGRyZW4sXG4gICAgICAgICh2OiBhbnksIGs6IHN0cmluZykgPT4gdGhpcy5kZWFjdGl2YXRlT3V0bGV0QW5kSXRDaGlsZHJlbihvdXRsZXRNYXAuX291dGxldHNba10pKTtcbiAgfVxuXG4gIGFjdGl2YXRlUm91dGVzKFxuICAgICAgZnV0dXJlTm9kZTogVHJlZU5vZGU8QWN0aXZhdGVkUm91dGU+LCBjdXJyTm9kZTogVHJlZU5vZGU8QWN0aXZhdGVkUm91dGU+LFxuICAgICAgcGFyZW50T3V0bGV0TWFwOiBSb3V0ZXJPdXRsZXRNYXApOiB2b2lkIHtcbiAgICBjb25zdCBmdXR1cmUgPSBmdXR1cmVOb2RlLnZhbHVlO1xuICAgIGNvbnN0IGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcblxuICAgIGNvbnN0IG91dGxldCA9IGdldE91dGxldChwYXJlbnRPdXRsZXRNYXAsIGZ1dHVyZU5vZGUudmFsdWUpO1xuXG4gICAgaWYgKGZ1dHVyZSA9PT0gY3Vycikge1xuICAgICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlKGZ1dHVyZSk7XG4gICAgICB0aGlzLmFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIG91dGxldC5vdXRsZXRNYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKG91dGxldCk7XG4gICAgICBjb25zdCBvdXRsZXRNYXAgPSBuZXcgUm91dGVyT3V0bGV0TWFwKCk7XG4gICAgICB0aGlzLmFjdGl2YXRlTmV3Um91dGVzKG91dGxldE1hcCwgZnV0dXJlLCBvdXRsZXQpO1xuICAgICAgdGhpcy5hY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIG51bGwsIG91dGxldE1hcCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhY3RpdmF0ZU5ld1JvdXRlcyhcbiAgICAgIG91dGxldE1hcDogUm91dGVyT3V0bGV0TWFwLCBmdXR1cmU6IEFjdGl2YXRlZFJvdXRlLCBvdXRsZXQ6IFJvdXRlck91dGxldCk6IHZvaWQge1xuICAgIGNvbnN0IHJlc29sdmVkID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW1xuICAgICAge3Byb3ZpZGU6IEFjdGl2YXRlZFJvdXRlLCB1c2VWYWx1ZTogZnV0dXJlfSxcbiAgICAgIHtwcm92aWRlOiBSb3V0ZXJPdXRsZXRNYXAsIHVzZVZhbHVlOiBvdXRsZXRNYXB9XG4gICAgXSk7XG4gICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlKGZ1dHVyZSk7XG4gICAgb3V0bGV0LmFjdGl2YXRlKGZ1dHVyZS5fZnV0dXJlU25hcHNob3QuX3Jlc29sdmVkQ29tcG9uZW50RmFjdG9yeSwgZnV0dXJlLCByZXNvbHZlZCwgb3V0bGV0TWFwKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVhY3RpdmF0ZU91dGxldEFuZEl0Q2hpbGRyZW4ob3V0bGV0OiBSb3V0ZXJPdXRsZXQpOiB2b2lkIHtcbiAgICBpZiAob3V0bGV0ICYmIG91dGxldC5pc0FjdGl2YXRlZCkge1xuICAgICAgZm9yRWFjaChcbiAgICAgICAgICBvdXRsZXQub3V0bGV0TWFwLl9vdXRsZXRzLCAodjogUm91dGVyT3V0bGV0KSA9PiB0aGlzLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKHYpKTtcbiAgICAgIG91dGxldC5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hRdWVyeVBhcmFtc0FuZEZyYWdtZW50KHN0YXRlOiBSb3V0ZXJTdGF0ZSk6IHZvaWQge1xuICBpZiAoIXNoYWxsb3dFcXVhbChzdGF0ZS5zbmFwc2hvdC5xdWVyeVBhcmFtcywgKDxhbnk+c3RhdGUucXVlcnlQYXJhbXMpLnZhbHVlKSkge1xuICAgICg8YW55PnN0YXRlLnF1ZXJ5UGFyYW1zKS5uZXh0KHN0YXRlLnNuYXBzaG90LnF1ZXJ5UGFyYW1zKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5zbmFwc2hvdC5mcmFnbWVudCAhPT0gKDxhbnk+c3RhdGUuZnJhZ21lbnQpLnZhbHVlKSB7XG4gICAgKDxhbnk+c3RhdGUuZnJhZ21lbnQpLm5leHQoc3RhdGUuc25hcHNob3QuZnJhZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVDaGlsZHJlbkFzTWFwKG5vZGU6IFRyZWVOb2RlPGFueT4pIHtcbiAgcmV0dXJuIG5vZGUgPyBub2RlLmNoaWxkcmVuLnJlZHVjZSgobTogYW55LCBjOiBUcmVlTm9kZTxhbnk+KSA9PiB7XG4gICAgbVtjLnZhbHVlLm91dGxldF0gPSBjO1xuICAgIHJldHVybiBtO1xuICB9LCB7fSkgOiB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0bGV0KG91dGxldE1hcDogUm91dGVyT3V0bGV0TWFwLCByb3V0ZTogQWN0aXZhdGVkUm91dGUpOiBSb3V0ZXJPdXRsZXQge1xuICBsZXQgb3V0bGV0ID0gb3V0bGV0TWFwLl9vdXRsZXRzW3JvdXRlLm91dGxldF07XG4gIGlmICghb3V0bGV0KSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9ICg8YW55PnJvdXRlLmNvbXBvbmVudCkubmFtZTtcbiAgICBpZiAocm91dGUub3V0bGV0ID09PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBwcmltYXJ5IG91dGxldCB0byBsb2FkICcke2NvbXBvbmVudE5hbWV9J2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIHRoZSBvdXRsZXQgJHtyb3V0ZS5vdXRsZXR9IHRvIGxvYWQgJyR7Y29tcG9uZW50TmFtZX0nYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRsZXQ7XG59XG4iXX0=

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var scan_1 = __webpack_require__(398);
	Observable_1.Observable.prototype.scan = scan_1.scan;
	//# sourceMappingURL=scan.js.map

/***/ },
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var concat_1 = __webpack_require__(402);
	Observable_1.Observable.prototype.concat = concat_1.concat;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(358);
	var ArrayObservable_1 = __webpack_require__(355);
	var mergeAll_1 = __webpack_require__(367);
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins this Observable with multiple other Observables by subscribing to them
	 * one at a time, starting with the source, and merging their results into the
	 * output Observable. Will wait for each Observable to complete before moving
	 * on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = timer.concat(sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = timer1.concat(timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} other An input Observable to concatenate after the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @method concat
	 * @owner Observable
	 */
	function concat() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return concatStatic.apply(void 0, [this].concat(observables));
	}
	exports.concat = concat;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins multiple Observables together by subscribing to them one at a time and
	 * merging their results into the output Observable. Will wait for each
	 * Observable to complete before moving on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = Rx.Observable.concat(timer, sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = Rx.Observable.concat(timer1, timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} input1 An input Observable to concatenate with others.
	 * @param {Observable} input2 An input Observable to concatenate with others.
	 * More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @static true
	 * @name concat
	 * @owner Observable
	 */
	function concatStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var scheduler = null;
	    var args = observables;
	    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
	        scheduler = args.pop();
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatStatic = concatStatic;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var concatMap_1 = __webpack_require__(404);
	Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMap_1 = __webpack_require__(400);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, in a serialized fashion waiting for each one to complete before
	 * merging the next.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link concatAll}.</span>
	 *
	 * <img src="./img/concatMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each new inner Observable is
	 * concatenated with the previous inner Observable.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMapTo}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} an observable of values merged from the projected
	 * Observables as they were subscribed to, one at a time. Optionally, these
	 * values may have been projected from a passed `projectResult` argument.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking values from each projected inner
	 * Observable sequentially.
	 * @method concatMap
	 * @owner Observable
	 */
	function concatMap(project, resultSelector) {
	    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
	}
	exports.concatMap = concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var every_1 = __webpack_require__(406);
	Observable_1.Observable.prototype.every = every_1.every;
	//# sourceMappingURL=every.js.map

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
	 * @param {function} predicate a function for determining if an item meets a specified condition.
	 * @param {any} [thisArg] optional object to use for `this` in the callback
	 * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.
	 * @method every
	 * @owner Observable
	 */
	function every(predicate, thisArg) {
	    return this.lift(new EveryOperator(predicate, thisArg, this));
	}
	exports.every = every;
	var EveryOperator = (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	    EveryOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
	    };
	    return EveryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var EverySubscriber = (function (_super) {
	    __extends(EverySubscriber, _super);
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	        this.index = 0;
	        this.thisArg = thisArg || this;
	    }
	    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	    EverySubscriber.prototype._next = function (value) {
	        var result = false;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	    EverySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return EverySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=every.js.map

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var mergeAll_1 = __webpack_require__(367);
	Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;
	//# sourceMappingURL=mergeAll.js.map

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var from_1 = __webpack_require__(409);
	Observable_1.Observable.from = from_1.from;
	//# sourceMappingURL=from.js.map

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromObservable_1 = __webpack_require__(410);
	exports.from = FromObservable_1.FromObservable.create;
	//# sourceMappingURL=from.js.map

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(45);
	var isFunction_1 = __webpack_require__(43);
	var isPromise_1 = __webpack_require__(370);
	var isScheduler_1 = __webpack_require__(358);
	var PromiseObservable_1 = __webpack_require__(57);
	var IteratorObservable_1 = __webpack_require__(411);
	var ArrayObservable_1 = __webpack_require__(355);
	var ArrayLikeObservable_1 = __webpack_require__(412);
	var iterator_1 = __webpack_require__(371);
	var Observable_1 = __webpack_require__(38);
	var observeOn_1 = __webpack_require__(413);
	var $$observable = __webpack_require__(52);
	var isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromObservable = (function (_super) {
	    __extends(FromObservable, _super);
	    function FromObservable(ish, scheduler) {
	        _super.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable from an Array, an array-like object, a Promise, an
	     * iterable object, or an Observable-like object.
	     *
	     * <span class="informal">Converts almost anything to an Observable.</span>
	     *
	     * <img src="./img/from.png" width="100%">
	     *
	     * Convert various other objects and data types into Observables. `from`
	     * converts a Promise or an array-like or an
	     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	     * object into an Observable that emits the items in that promise or array or
	     * iterable. A String, in this context, is treated as an array of characters.
	     * Observable-like objects (contains a function named with the ES2015 Symbol
	     * for Observable) can also be converted through this operator.
	     *
	     * @example <caption>Converts an array to an Observable</caption>
	     * var array = [10, 20, 30];
	     * var result = Rx.Observable.from(array);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
	     * function* generateDoubles(seed) {
	     *   var i = seed;
	     *   while (true) {
	     *     yield i;
	     *     i = 2 * i; // double it
	     *   }
	     * }
	     *
	     * var iterator = generateDoubles(3);
	     * var result = Rx.Observable.from(iterator).take(10);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link fromEvent}
	     * @see {@link fromEventPattern}
	     * @see {@link fromPromise}
	     *
	     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
	     * Observable-like, an Array, an iterable or an array-like object to be
	     * converted.
	     * @param {function(x: any, i: number): T} [mapFn] A "map" function to call
	     * when converting array-like objects, where `x` is a value from the
	     * array-like and `i` is the index of that value in the sequence.
	     * @param {any} [thisArg] The context object to use when calling the `mapFn`,
	     * if provided.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * emissions of values.
	     * @return {Observable<T>} The Observable whose values are originally from the
	     * input object that was converted.
	     * @static true
	     * @name from
	     * @owner Observable
	     */
	    FromObservable.create = function (ish, mapFnOrScheduler, thisArg, lastScheduler) {
	        var scheduler = null;
	        var mapFn = null;
	        if (isFunction_1.isFunction(mapFnOrScheduler)) {
	            scheduler = lastScheduler || null;
	            mapFn = mapFnOrScheduler;
	        }
	        else if (isScheduler_1.isScheduler(scheduler)) {
	            scheduler = mapFnOrScheduler;
	        }
	        if (ish != null) {
	            if (typeof ish[$$observable] === 'function') {
	                if (ish instanceof Observable_1.Observable && !scheduler) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            }
	            else if (isArray_1.isArray(ish)) {
	                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
	            }
	            else if (isPromise_1.isPromise(ish)) {
	                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
	            }
	            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
	                return new IteratorObservable_1.IteratorObservable(ish, null, null, scheduler);
	            }
	            else if (isArrayLike(ish)) {
	                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, mapFn, thisArg, scheduler);
	            }
	        }
	        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
	    };
	    FromObservable.prototype._subscribe = function (subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            return ish[$$observable]().subscribe(subscriber);
	        }
	        else {
	            return ish[$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	    return FromObservable;
	}(Observable_1.Observable));
	exports.FromObservable = FromObservable;
	//# sourceMappingURL=FromObservable.js.map

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(39);
	var isObject_1 = __webpack_require__(46);
	var tryCatch_1 = __webpack_require__(47);
	var Observable_1 = __webpack_require__(38);
	var isFunction_1 = __webpack_require__(43);
	var iterator_1 = __webpack_require__(371);
	var errorObject_1 = __webpack_require__(48);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IteratorObservable = (function (_super) {
	    __extends(IteratorObservable, _super);
	    function IteratorObservable(iterator, project, thisArg, scheduler) {
	        _super.call(this);
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        if (isObject_1.isObject(project)) {
	            this.thisArg = project;
	            this.scheduler = thisArg;
	        }
	        else if (isFunction_1.isFunction(project)) {
	            this.project = project;
	            this.thisArg = thisArg;
	            this.scheduler = scheduler;
	        }
	        else if (project != null) {
	            throw new Error('When provided, `project` must be a function.');
	        }
	        this.iterator = getIterator(iterator);
	    }
	    IteratorObservable.create = function (iterator, project, thisArg, scheduler) {
	        return new IteratorObservable(iterator, project, thisArg, scheduler);
	    };
	    IteratorObservable.dispatch = function (state) {
	        var index = state.index, hasError = state.hasError, thisArg = state.thisArg, project = state.project, iterator = state.iterator, subscriber = state.subscriber;
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        if (project) {
	            result = tryCatch_1.tryCatch(project).call(thisArg, result.value, index);
	            if (result === errorObject_1.errorObject) {
	                state.error = errorObject_1.errorObject.e;
	                state.hasError = true;
	            }
	            else {
	                subscriber.next(result);
	                state.index = index + 1;
	            }
	        }
	        else {
	            subscriber.next(result.value);
	            state.index = index + 1;
	        }
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        this.schedule(state);
	    };
	    IteratorObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, iterator = _a.iterator, project = _a.project, thisArg = _a.thisArg, scheduler = _a.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, thisArg: thisArg, project: project, iterator: iterator, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                }
	                else if (project) {
	                    result = tryCatch_1.tryCatch(project).call(thisArg, result.value, index++);
	                    if (result === errorObject_1.errorObject) {
	                        subscriber.error(errorObject_1.errorObject.e);
	                        break;
	                    }
	                    subscriber.next(result);
	                }
	                else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return IteratorObservable;
	}(Observable_1.Observable));
	exports.IteratorObservable = IteratorObservable;
	var StringIterator = (function () {
	    function StringIterator(str, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = str.length; }
	        this.str = str;
	        this.idx = idx;
	        this.len = len;
	    }
	    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };
	    StringIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return StringIterator;
	}());
	var ArrayIterator = (function () {
	    function ArrayIterator(arr, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = toLength(arr); }
	        this.arr = arr;
	        this.idx = idx;
	        this.len = len;
	    }
	    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };
	    ArrayIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return ArrayIterator;
	}());
	function getIterator(obj) {
	    var i = obj[iterator_1.$$iterator];
	    if (!i && typeof obj === 'string') {
	        return new StringIterator(obj);
	    }
	    if (!i && obj.length !== undefined) {
	        return new ArrayIterator(obj);
	    }
	    if (!i) {
	        throw new TypeError('Object is not iterable');
	    }
	    return obj[iterator_1.$$iterator]();
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && root_1.root.isFinite(value);
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	//# sourceMappingURL=IteratorObservable.js.map

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var ScalarObservable_1 = __webpack_require__(356);
	var EmptyObservable_1 = __webpack_require__(357);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayLikeObservable = (function (_super) {
	    __extends(ArrayLikeObservable, _super);
	    function ArrayLikeObservable(arrayLike, mapFn, thisArg, scheduler) {
	        _super.call(this);
	        this.arrayLike = arrayLike;
	        this.scheduler = scheduler;
	        if (!mapFn && !scheduler && arrayLike.length === 1) {
	            this._isScalar = true;
	            this.value = arrayLike[0];
	        }
	        if (mapFn) {
	            this.mapFn = mapFn.bind(thisArg);
	        }
	    }
	    ArrayLikeObservable.create = function (arrayLike, mapFn, thisArg, scheduler) {
	        var length = arrayLike.length;
	        if (length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        else if (length === 1 && !mapFn) {
	            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
	        }
	        else {
	            return new ArrayLikeObservable(arrayLike, mapFn, thisArg, scheduler);
	        }
	    };
	    ArrayLikeObservable.dispatch = function (state) {
	        var arrayLike = state.arrayLike, index = state.index, length = state.length, mapFn = state.mapFn, subscriber = state.subscriber;
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        if (index >= length) {
	            subscriber.complete();
	            return;
	        }
	        var result = mapFn ? mapFn(arrayLike[index], index) : arrayLike[index];
	        subscriber.next(result);
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, arrayLike = _a.arrayLike, mapFn = _a.mapFn, scheduler = _a.scheduler;
	        var length = arrayLike.length;
	        if (scheduler) {
	            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
	                arrayLike: arrayLike, index: index, length: length, mapFn: mapFn, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < length && !subscriber.isUnsubscribed; i++) {
	                var result = mapFn ? mapFn(arrayLike[i], i) : arrayLike[i];
	                subscriber.next(result);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayLikeObservable;
	}(Observable_1.Observable));
	exports.ArrayLikeObservable = ArrayLikeObservable;
	//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ },
/* 413 */,
/* 414 */,
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var of_1 = __webpack_require__(354);
	var shared_1 = __webpack_require__(416);
	var url_tree_1 = __webpack_require__(417);
	var NoMatch = (function () {
	    function NoMatch(segment) {
	        if (segment === void 0) { segment = null; }
	        this.segment = segment;
	    }
	    return NoMatch;
	}());
	var GlobalRedirect = (function () {
	    function GlobalRedirect(paths) {
	        this.paths = paths;
	    }
	    return GlobalRedirect;
	}());
	function applyRedirects(urlTree, config) {
	    try {
	        return createUrlTree(urlTree, expandSegment(config, urlTree.root, shared_1.PRIMARY_OUTLET));
	    }
	    catch (e) {
	        if (e instanceof GlobalRedirect) {
	            return createUrlTree(urlTree, new url_tree_1.UrlSegment([], (_a = {}, _a[shared_1.PRIMARY_OUTLET] = new url_tree_1.UrlSegment(e.paths, {}), _a)));
	        }
	        else if (e instanceof NoMatch) {
	            return new Observable_1.Observable(function (obs) {
	                return obs.error(new Error("Cannot match any routes: '" + e.segment + "'"));
	            });
	        }
	        else {
	            return new Observable_1.Observable(function (obs) { return obs.error(e); });
	        }
	    }
	    var _a;
	}
	exports.applyRedirects = applyRedirects;
	function createUrlTree(urlTree, root) {
	    return of_1.of(new url_tree_1.UrlTree(root, urlTree.queryParams, urlTree.fragment));
	}
	function expandSegment(routes, segment, outlet) {
	    if (segment.pathsWithParams.length === 0 && Object.keys(segment.children).length > 0) {
	        return new url_tree_1.UrlSegment([], expandSegmentChildren(routes, segment));
	    }
	    else {
	        return expandPathsWithParams(segment, routes, segment.pathsWithParams, outlet, true);
	    }
	}
	function expandSegmentChildren(routes, segment) {
	    return url_tree_1.mapChildren(segment, function (child, childOutlet) { return expandSegment(routes, child, childOutlet); });
	}
	function expandPathsWithParams(segment, routes, paths, outlet, allowRedirects) {
	    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
	        var r = routes_1[_i];
	        try {
	            return expandPathsWithParamsAgainstRoute(segment, routes, r, paths, outlet, allowRedirects);
	        }
	        catch (e) {
	            if (!(e instanceof NoMatch))
	                throw e;
	        }
	    }
	    throw new NoMatch(segment);
	}
	function expandPathsWithParamsAgainstRoute(segment, routes, route, paths, outlet, allowRedirects) {
	    if ((route.outlet ? route.outlet : shared_1.PRIMARY_OUTLET) !== outlet)
	        throw new NoMatch();
	    if (route.redirectTo && !allowRedirects)
	        throw new NoMatch();
	    if (route.redirectTo) {
	        return expandPathsWithParamsAgainstRouteUsingRedirect(segment, routes, route, paths, outlet);
	    }
	    else {
	        return matchPathsWithParamsAgainstRoute(segment, route, paths);
	    }
	}
	function expandPathsWithParamsAgainstRouteUsingRedirect(segment, routes, route, paths, outlet) {
	    if (route.path === '**') {
	        return expandWildCardWithParamsAgainstRouteUsingRedirect(route);
	    }
	    else {
	        return expandRegularPathWithParamsAgainstRouteUsingRedirect(segment, routes, route, paths, outlet);
	    }
	}
	function expandWildCardWithParamsAgainstRouteUsingRedirect(route) {
	    var newPaths = applyRedirectCommands([], route.redirectTo, {});
	    if (route.redirectTo.startsWith('/')) {
	        throw new GlobalRedirect(newPaths);
	    }
	    else {
	        return new url_tree_1.UrlSegment(newPaths, {});
	    }
	}
	function expandRegularPathWithParamsAgainstRouteUsingRedirect(segment, routes, route, paths, outlet) {
	    var _a = match(segment, route, paths), consumedPaths = _a.consumedPaths, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
	    var newPaths = applyRedirectCommands(consumedPaths, route.redirectTo, positionalParamSegments);
	    if (route.redirectTo.startsWith('/')) {
	        throw new GlobalRedirect(newPaths);
	    }
	    else {
	        return expandPathsWithParams(segment, routes, newPaths.concat(paths.slice(lastChild)), outlet, false);
	    }
	}
	function matchPathsWithParamsAgainstRoute(segment, route, paths) {
	    if (route.path === '**') {
	        return new url_tree_1.UrlSegment(paths, {});
	    }
	    else {
	        var _a = match(segment, route, paths), consumedPaths = _a.consumedPaths, lastChild = _a.lastChild;
	        var childConfig = route.children ? route.children : [];
	        var slicedPath = paths.slice(lastChild);
	        if (childConfig.length === 0 && slicedPath.length === 0) {
	            return new url_tree_1.UrlSegment(consumedPaths, {});
	        }
	        else if (slicedPath.length === 0 && Object.keys(segment.children).length > 0) {
	            var children = expandSegmentChildren(childConfig, segment);
	            return new url_tree_1.UrlSegment(consumedPaths, children);
	        }
	        else {
	            var cs = expandPathsWithParams(segment, childConfig, slicedPath, shared_1.PRIMARY_OUTLET, true);
	            return new url_tree_1.UrlSegment(consumedPaths.concat(cs.pathsWithParams), cs.children);
	        }
	    }
	}
	function match(segment, route, paths) {
	    if (route.path === '') {
	        if (route.terminal && (Object.keys(segment.children).length > 0 || paths.length > 0)) {
	            throw new NoMatch();
	        }
	        else {
	            return { consumedPaths: [], lastChild: 0, positionalParamSegments: {} };
	        }
	    }
	    var path = route.path;
	    var parts = path.split('/');
	    var positionalParamSegments = {};
	    var consumedPaths = [];
	    var currentIndex = 0;
	    for (var i = 0; i < parts.length; ++i) {
	        if (currentIndex >= paths.length)
	            throw new NoMatch();
	        var current = paths[currentIndex];
	        var p = parts[i];
	        var isPosParam = p.startsWith(':');
	        if (!isPosParam && p !== current.path)
	            throw new NoMatch();
	        if (isPosParam) {
	            positionalParamSegments[p.substring(1)] = current;
	        }
	        consumedPaths.push(current);
	        currentIndex++;
	    }
	    if (route.terminal && (Object.keys(segment.children).length > 0 || currentIndex < paths.length)) {
	        throw new NoMatch();
	    }
	    return { consumedPaths: consumedPaths, lastChild: currentIndex, positionalParamSegments: positionalParamSegments };
	}
	function applyRedirectCommands(paths, redirectTo, posParams) {
	    if (redirectTo.startsWith('/')) {
	        var parts = redirectTo.substring(1).split('/');
	        return createPaths(redirectTo, parts, paths, posParams);
	    }
	    else {
	        var parts = redirectTo.split('/');
	        return createPaths(redirectTo, parts, paths, posParams);
	    }
	}
	function createPaths(redirectTo, parts, segments, posParams) {
	    return parts.map(function (p) { return p.startsWith(':') ? findPosParam(p, posParams, redirectTo) :
	        findOrCreatePath(p, segments); });
	}
	function findPosParam(part, posParams, redirectTo) {
	    var paramName = part.substring(1);
	    var pos = posParams[paramName];
	    if (!pos)
	        throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + part + "'.");
	    return pos;
	}
	function findOrCreatePath(part, paths) {
	    var matchingIndex = paths.findIndex(function (s) { return s.path === part; });
	    if (matchingIndex > -1) {
	        var r = paths[matchingIndex];
	        paths.splice(matchingIndex);
	        return r;
	    }
	    else {
	        return new url_tree_1.UrlPathWithParams(part, {});
	    }
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHlfcmVkaXJlY3RzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FwcGx5X3JlZGlyZWN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsMkJBQXlCLGlCQUFpQixDQUFDLENBQUE7QUFFM0MsbUJBQWtCLG9CQUFvQixDQUFDLENBQUE7QUFHdkMsdUJBQTZCLFVBQVUsQ0FBQyxDQUFBO0FBQ3hDLHlCQUFrRSxZQUFZLENBQUMsQ0FBQTtBQUUvRTtJQUNFLGlCQUFtQixPQUEwQjtRQUFqQyx1QkFBaUMsR0FBakMsY0FBaUM7UUFBMUIsWUFBTyxHQUFQLE9BQU8sQ0FBbUI7SUFBRyxDQUFDO0lBQ25ELGNBQUM7QUFBRCxDQUFDLEFBRkQsSUFFQztBQUNEO0lBQ0Usd0JBQW1CLEtBQTBCO1FBQTFCLFVBQUssR0FBTCxLQUFLLENBQXFCO0lBQUcsQ0FBQztJQUNuRCxxQkFBQztBQUFELENBQUMsQUFGRCxJQUVDO0FBRUQsd0JBQStCLE9BQWdCLEVBQUUsTUFBb0I7SUFDbkUsSUFBSSxDQUFDO1FBQ0gsTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLHVCQUFjLENBQUMsQ0FBQyxDQUFDO0lBQ3JGLENBQUU7SUFBQSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1gsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsTUFBTSxDQUFDLGFBQWEsQ0FDaEIsT0FBTyxFQUFFLElBQUkscUJBQVUsQ0FBQyxFQUFFLEVBQUUsVUFBQyxHQUFDLHVCQUFjLENBQUMsR0FBRSxJQUFJLHFCQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRixDQUFDO1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxPQUFPLENB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Q0FBQztRQUN0QyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLEVBRGpELENBQ2lELENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBRUQsc0JBQ0ksSUFBWSxFQUFFLFNBQTJDLEVBQ3pELFVBQWtCO0lBQ3BCLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsSUFBTSxHQUFHLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2pDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBdUIsVUFBVSx3QkFBbUIsSUFBSSxPQUFJLENBQUMsQ0FBQztJQUN4RixNQUFNLENBQUMsR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELDBCQUEwQixJQUFZLEVBQUUsS0FBMEI7SUFDaEUsSUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxFQUFmLENBQWUsQ0FBQyxDQUFDO0lBQzVELEVBQUUsQ0FBQyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsSUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQy9CLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDNUIsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLE1BQU0sQ0FBQyxJQUFJLDRCQUFpQixDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN6QyxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7T2JzZXJ2ZXJ9IGZyb20gJ3J4anMvT2JzZXJ2ZXInO1xuaW1wb3J0IHtvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5cbmltcG9ydCB7Um91dGUsIFJvdXRlckNvbmZpZ30gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHtQUklNQVJZX09VVExFVH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHtVcmxQYXRoV2l0aFBhcmFtcywgVXJsU2VnbWVudCwgVXJsVHJlZSwgbWFwQ2hpbGRyZW59IGZyb20gJy4vdXJsX3RyZWUnO1xuXG5jbGFzcyBOb01hdGNoIHtcbiAgY29uc3RydWN0b3IocHVibGljIHNlZ21lbnQ6IFVybFNlZ21lbnQgPSBudWxsKSB7fVxufVxuY2xhc3MgR2xvYmFsUmVkaXJlY3Qge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGF0aHM6IFVybFBhdGhXaXRoUGFyYW1zW10pIHt9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZGlyZWN0cyh1cmxUcmVlOiBVcmxUcmVlLCBjb25maWc6IFJvdXRlckNvbmZpZyk6IE9ic2VydmFibGU8VXJsVHJlZT4ge1xuICB0cnkge1xuICAgIHJldHVybiBjcmVhdGVVcmxUcmVlKHVybFRyZWUsIGV4cGFuZFNlZ21lbnQoY29uZmlnLCB1cmxUcmVlLnJvb3QsIFBSSU1BUllfT1VUTEVUKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEdsb2JhbFJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gY3JlYXRlVXJsVHJlZShcbiAgICAgICAgICB1cmxUcmVlLCBuZXcgVXJsU2VnbWVudChbXSwge1tQUklNQVJZX09VVExFVF06IG5ldyBVcmxTZWdtZW50KGUucGF0aHMsIHt9KX0pKTtcbiAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBOb01hdGNoKSB7XG4gICAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8VXJsVHJlZT4oXG4gICAgICAgICAgKG9iczogT2JzZXJ2ZXI8VXJsVHJlZT4pID0+XG4gICAgICAgICAgICAgIG9icy5lcnJvcihuZXcgRXJyb3IoYENhbm5vdCBtYXRjaCBhbnkgcm91dGVzOiAnJHtlLnNlZ21lbnR9J2ApKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxVcmxUcmVlPigob2JzOiBPYnNlcnZlcjxVcmxUcmVlPikgPT4gb2JzLmVycm9yKGUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVXJsVHJlZSh1cmxUcmVlOiBVcmxUcmVlLCByb290OiBVcmxTZWdtZW50KTogT2JzZXJ2YWJsZTxVcmxUcmVlPiB7XG4gIHJldHVybiBvZiAobmV3IFVybFRyZWUocm9vdCwgdXJsVHJlZS5xdWVyeVBhcmFtcywgdXJsVHJlZS5mcmFnbWVudCkpO1xufVxuXG5mdW5jdGlvbiBleHBhbmRTZWdtZW50KHJvdXRlczogUm91dGVbXSwgc2VnbWVudDogVXJsU2VnbWVudCwgb3V0bGV0OiBzdHJpbmcpOiBVcmxTZWdtZW50IHtcbiAgaWYgKHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KFtdLCBleHBhbmRTZWdtZW50Q2hpbGRyZW4ocm91dGVzLCBzZWdtZW50KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGFuZFBhdGhzV2l0aFBhcmFtcyhzZWdtZW50LCByb3V0ZXMsIHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLCBvdXRsZXQsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFNlZ21lbnRDaGlsZHJlbihyb3V0ZXM6IFJvdXRlW10sIHNlZ21lbnQ6IFVybFNlZ21lbnQpOiB7W25hbWU6IHN0cmluZ106IFVybFNlZ21lbnR9IHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKHNlZ21lbnQsIChjaGlsZCwgY2hpbGRPdXRsZXQpID0+IGV4cGFuZFNlZ21lbnQocm91dGVzLCBjaGlsZCwgY2hpbGRPdXRsZXQpKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kUGF0aHNXaXRoUGFyYW1zKFxuICAgIHNlZ21lbnQ6IFVybFNlZ21lbnQsIHJvdXRlczogUm91dGVbXSwgcGF0aHM6IFVybFBhdGhXaXRoUGFyYW1zW10sIG91dGxldDogc3RyaW5nLFxuICAgIGFsbG93UmVkaXJlY3RzOiBib29sZWFuKTogVXJsU2VnbWVudCB7XG4gIGZvciAobGV0IHIgb2Ygcm91dGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBleHBhbmRQYXRoc1dpdGhQYXJhbXNBZ2FpbnN0Um91dGUoc2VnbWVudCwgcm91dGVzLCByLCBwYXRocywgb3V0bGV0LCBhbGxvd1JlZGlyZWN0cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE5vTWF0Y2gpKSB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgTm9NYXRjaChzZWdtZW50KTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kUGF0aHNXaXRoUGFyYW1zQWdhaW5zdFJvdXRlKFxuICAgIHNlZ21lbnQ6IFVybFNlZ21lbnQsIHJvdXRlczogUm91dGVbXSwgcm91dGU6IFJvdXRlLCBwYXRoczogVXJsUGF0aFdpdGhQYXJhbXNbXSwgb3V0bGV0OiBzdHJpbmcsXG4gICAgYWxsb3dSZWRpcmVjdHM6IGJvb2xlYW4pOiBVcmxTZWdtZW50IHtcbiAgaWYgKChyb3V0ZS5vdXRsZXQgPyByb3V0ZS5vdXRsZXQgOiBQUklNQVJZX09VVExFVCkgIT09IG91dGxldCkgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gJiYgIWFsbG93UmVkaXJlY3RzKSB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuXG4gIGlmIChyb3V0ZS5yZWRpcmVjdFRvKSB7XG4gICAgcmV0dXJuIGV4cGFuZFBhdGhzV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3Qoc2VnbWVudCwgcm91dGVzLCByb3V0ZSwgcGF0aHMsIG91dGxldCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoUGF0aHNXaXRoUGFyYW1zQWdhaW5zdFJvdXRlKHNlZ21lbnQsIHJvdXRlLCBwYXRocyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwYW5kUGF0aHNXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChcbiAgICBzZWdtZW50OiBVcmxTZWdtZW50LCByb3V0ZXM6IFJvdXRlW10sIHJvdXRlOiBSb3V0ZSwgcGF0aHM6IFVybFBhdGhXaXRoUGFyYW1zW10sXG4gICAgb3V0bGV0OiBzdHJpbmcpOiBVcmxTZWdtZW50IHtcbiAgaWYgKHJvdXRlLnBhdGggPT09ICcqKicpIHtcbiAgICByZXR1cm4gZXhwYW5kV2lsZENhcmRXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChyb3V0ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGFuZFJlZ3VsYXJQYXRoV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QoXG4gICAgICAgIHNlZ21lbnQsIHJvdXRlcywgcm91dGUsIHBhdGhzLCBvdXRsZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFdpbGRDYXJkV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3Qocm91dGU6IFJvdXRlKTogVXJsU2VnbWVudCB7XG4gIGNvbnN0IG5ld1BhdGhzID0gYXBwbHlSZWRpcmVjdENvbW1hbmRzKFtdLCByb3V0ZS5yZWRpcmVjdFRvLCB7fSk7XG4gIGlmIChyb3V0ZS5yZWRpcmVjdFRvLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHRocm93IG5ldyBHbG9iYWxSZWRpcmVjdChuZXdQYXRocyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KG5ld1BhdGhzLCB7fSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwYW5kUmVndWxhclBhdGhXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChcbiAgICBzZWdtZW50OiBVcmxTZWdtZW50LCByb3V0ZXM6IFJvdXRlW10sIHJvdXRlOiBSb3V0ZSwgcGF0aHM6IFVybFBhdGhXaXRoUGFyYW1zW10sXG4gICAgb3V0bGV0OiBzdHJpbmcpOiBVcmxTZWdtZW50IHtcbiAgY29uc3Qge2NvbnN1bWVkUGF0aHMsIGxhc3RDaGlsZCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHN9ID0gbWF0Y2goc2VnbWVudCwgcm91dGUsIHBhdGhzKTtcbiAgY29uc3QgbmV3UGF0aHMgPVxuICAgICAgYXBwbHlSZWRpcmVjdENvbW1hbmRzKGNvbnN1bWVkUGF0aHMsIHJvdXRlLnJlZGlyZWN0VG8sIDxhbnk+cG9zaXRpb25hbFBhcmFtU2VnbWVudHMpO1xuICBpZiAocm91dGUucmVkaXJlY3RUby5zdGFydHNXaXRoKCcvJykpIHtcbiAgICB0aHJvdyBuZXcgR2xvYmFsUmVkaXJlY3QobmV3UGF0aHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBhbmRQYXRoc1dpdGhQYXJhbXMoXG4gICAgICAgIHNlZ21lbnQsIHJvdXRlcywgbmV3UGF0aHMuY29uY2F0KHBhdGhzLnNsaWNlKGxhc3RDaGlsZCkpLCBvdXRsZXQsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFBhdGhzV2l0aFBhcmFtc0FnYWluc3RSb3V0ZShcbiAgICBzZWdtZW50OiBVcmxTZWdtZW50LCByb3V0ZTogUm91dGUsIHBhdGhzOiBVcmxQYXRoV2l0aFBhcmFtc1tdKTogVXJsU2VnbWVudCB7XG4gIGlmIChyb3V0ZS5wYXRoID09PSAnKionKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KHBhdGhzLCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge2NvbnN1bWVkUGF0aHMsIGxhc3RDaGlsZH0gPSBtYXRjaChzZWdtZW50LCByb3V0ZSwgcGF0aHMpO1xuICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcm91dGUuY2hpbGRyZW4gPyByb3V0ZS5jaGlsZHJlbiA6IFtdO1xuICAgIGNvbnN0IHNsaWNlZFBhdGggPSBwYXRocy5zbGljZShsYXN0Q2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkQ29uZmlnLmxlbmd0aCA9PT0gMCAmJiBzbGljZWRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KGNvbnN1bWVkUGF0aHMsIHt9KTtcblxuICAgICAgLy8gVE9ETzogY2hlY2sgdGhhdCB0aGUgcmlnaHQgc2VnbWVudCBpcyBwcmVzZW50XG4gICAgfSBlbHNlIGlmIChzbGljZWRQYXRoLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGV4cGFuZFNlZ21lbnRDaGlsZHJlbihjaGlsZENvbmZpZywgc2VnbWVudCk7XG4gICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnQoY29uc3VtZWRQYXRocywgY2hpbGRyZW4pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzID0gZXhwYW5kUGF0aHNXaXRoUGFyYW1zKHNlZ21lbnQsIGNoaWxkQ29uZmlnLCBzbGljZWRQYXRoLCBQUklNQVJZX09VVExFVCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnQoY29uc3VtZWRQYXRocy5jb25jYXQoY3MucGF0aHNXaXRoUGFyYW1zKSwgY3MuY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaChzZWdtZW50OiBVcmxTZWdtZW50LCByb3V0ZTogUm91dGUsIHBhdGhzOiBVcmxQYXRoV2l0aFBhcmFtc1tdKToge1xuICBjb25zdW1lZFBhdGhzOiBVcmxQYXRoV2l0aFBhcmFtc1tdLFxuICBsYXN0Q2hpbGQ6IG51bWJlcixcbiAgcG9zaXRpb25hbFBhcmFtU2VnbWVudHM6IHtbazogc3RyaW5nXTogVXJsUGF0aFdpdGhQYXJhbXN9XG59IHtcbiAgaWYgKHJvdXRlLnBhdGggPT09ICcnKSB7XG4gICAgaWYgKHJvdXRlLnRlcm1pbmFsICYmIChPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwIHx8IHBhdGhzLmxlbmd0aCA+IDApKSB7XG4gICAgICB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge2NvbnN1bWVkUGF0aHM6IFtdLCBsYXN0Q2hpbGQ6IDAsIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzOiB7fX07XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICBjb25zdCBwb3NpdGlvbmFsUGFyYW1TZWdtZW50czoge1trOiBzdHJpbmddOiBVcmxQYXRoV2l0aFBhcmFtc30gPSB7fTtcbiAgY29uc3QgY29uc3VtZWRQYXRoczogVXJsUGF0aFdpdGhQYXJhbXNbXSA9IFtdO1xuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoY3VycmVudEluZGV4ID49IHBhdGhzLmxlbmd0aCkgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICBjb25zdCBjdXJyZW50ID0gcGF0aHNbY3VycmVudEluZGV4XTtcblxuICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICBjb25zdCBpc1Bvc1BhcmFtID0gcC5zdGFydHNXaXRoKCc6Jyk7XG5cbiAgICBpZiAoIWlzUG9zUGFyYW0gJiYgcCAhPT0gY3VycmVudC5wYXRoKSB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuICAgIGlmIChpc1Bvc1BhcmFtKSB7XG4gICAgICBwb3NpdGlvbmFsUGFyYW1TZWdtZW50c1twLnN1YnN0cmluZygxKV0gPSBjdXJyZW50O1xuICAgIH1cbiAgICBjb25zdW1lZFBhdGhzLnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudEluZGV4Kys7XG4gIH1cblxuICBpZiAocm91dGUudGVybWluYWwgJiYgKE9iamVjdC5rZXlzKHNlZ21lbnQuY2hpbGRyZW4pLmxlbmd0aCA+IDAgfHwgY3VycmVudEluZGV4IDwgcGF0aHMubGVuZ3RoKSkge1xuICAgIHRocm93IG5ldyBOb01hdGNoKCk7XG4gIH1cblxuICByZXR1cm4ge2NvbnN1bWVkUGF0aHMsIGxhc3RDaGlsZDogY3VycmVudEluZGV4LCBwb3NpdGlvbmFsUGFyYW1TZWdtZW50c307XG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVkaXJlY3RDb21tYW5kcyhcbiAgICBwYXRoczogVXJsUGF0aFdpdGhQYXJhbXNbXSwgcmVkaXJlY3RUbzogc3RyaW5nLFxuICAgIHBvc1BhcmFtczoge1trOiBzdHJpbmddOiBVcmxQYXRoV2l0aFBhcmFtc30pOiBVcmxQYXRoV2l0aFBhcmFtc1tdIHtcbiAgaWYgKHJlZGlyZWN0VG8uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgY29uc3QgcGFydHMgPSByZWRpcmVjdFRvLnN1YnN0cmluZygxKS5zcGxpdCgnLycpO1xuICAgIHJldHVybiBjcmVhdGVQYXRocyhyZWRpcmVjdFRvLCBwYXJ0cywgcGF0aHMsIHBvc1BhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGFydHMgPSByZWRpcmVjdFRvLnNwbGl0KCcvJyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhdGhzKHJlZGlyZWN0VG8sIHBhcnRzLCBwYXRocywgcG9zUGFyYW1zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRocyhcbiAgICByZWRpcmVjdFRvOiBzdHJpbmcsIHBhcnRzOiBzdHJpbmdbXSwgc2VnbWVudHM6IFVybFBhdGhXaXRoUGFyYW1zW10sXG4gICAgcG9zUGFyYW1zOiB7W2s6IHN0cmluZ106IFVybFBhdGhXaXRoUGFyYW1zfSk6IFVybFBhdGhXaXRoUGFyYW1zW10ge1xuICByZXR1cm4gcGFydHMubWFwKFxuICAgICAgcCA9PiBwLnN0YXJ0c1dpdGgoJzonKSA/IGZpbmRQb3NQYXJhbShwLCBwb3NQYXJhbXMsIHJlZGlyZWN0VG8pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kT3JDcmVhdGVQYXRoKHAsIHNlZ21lbnRzKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRQb3NQYXJhbShcbiAgICBwYXJ0OiBzdHJpbmcsIHBvc1BhcmFtczoge1trOiBzdHJpbmddOiBVcmxQYXRoV2l0aFBhcmFtc30sXG4gICAgcmVkaXJlY3RUbzogc3RyaW5nKTogVXJsUGF0aFdpdGhQYXJhbXMge1xuICBjb25zdCBwYXJhbU5hbWUgPSBwYXJ0LnN1YnN0cmluZygxKTtcbiAgY29uc3QgcG9zID0gcG9zUGFyYW1zW3BhcmFtTmFtZV07XG4gIGlmICghcG9zKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWRpcmVjdCB0byAnJHtyZWRpcmVjdFRvfScuIENhbm5vdCBmaW5kICcke3BhcnR9Jy5gKTtcbiAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlUGF0aChwYXJ0OiBzdHJpbmcsIHBhdGhzOiBVcmxQYXRoV2l0aFBhcmFtc1tdKTogVXJsUGF0aFdpdGhQYXJhbXMge1xuICBjb25zdCBtYXRjaGluZ0luZGV4ID0gcGF0aHMuZmluZEluZGV4KHMgPT4gcy5wYXRoID09PSBwYXJ0KTtcbiAgaWYgKG1hdGNoaW5nSW5kZXggPiAtMSkge1xuICAgIGNvbnN0IHIgPSBwYXRoc1ttYXRjaGluZ0luZGV4XTtcbiAgICBwYXRocy5zcGxpY2UobWF0Y2hpbmdJbmRleCk7XG4gICAgcmV0dXJuIHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVcmxQYXRoV2l0aFBhcmFtcyhwYXJ0LCB7fSk7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 416 */
/***/ function(module, exports) {

	"use strict";
	exports.PRIMARY_OUTLET = 'PRIMARY_OUTLET';
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3NoYXJlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBSWEsc0JBQWMsR0FBRyxnQkFBZ0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTmFtZSBvZiB0aGUgcHJpbWFyeSBvdXRsZXQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgUFJJTUFSWV9PVVRMRVQgPSAnUFJJTUFSWV9PVVRMRVQnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwYXJhbWV0ZXJzLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXMgPSB7XG4gIFtrZXk6IHN0cmluZ106IGFueVxufTtcbiJdfQ==

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var shared_1 = __webpack_require__(416);
	var url_serializer_1 = __webpack_require__(418);
	var collection_1 = __webpack_require__(419);
	function createEmptyUrlTree() {
	    return new UrlTree(new UrlSegment([], {}), {}, null);
	}
	exports.createEmptyUrlTree = createEmptyUrlTree;
	function containsTree(container, containee, exact) {
	    if (exact) {
	        return equalSegments(container.root, containee.root);
	    }
	    else {
	        return containsSegment(container.root, containee.root);
	    }
	}
	exports.containsTree = containsTree;
	function equalSegments(container, containee) {
	    if (!equalPath(container.pathsWithParams, containee.pathsWithParams))
	        return false;
	    if (Object.keys(container.children).length !== Object.keys(containee.children).length)
	        return false;
	    for (var c in containee.children) {
	        if (!container.children[c])
	            return false;
	        if (!equalSegments(container.children[c], containee.children[c]))
	            return false;
	    }
	    return true;
	}
	function containsSegment(container, containee) {
	    return containsSegmentHelper(container, containee, containee.pathsWithParams);
	}
	function containsSegmentHelper(container, containee, containeePaths) {
	    if (container.pathsWithParams.length > containeePaths.length) {
	        var current = container.pathsWithParams.slice(0, containeePaths.length);
	        if (!equalPath(current, containeePaths))
	            return false;
	        if (Object.keys(containee.children).length > 0)
	            return false;
	        return true;
	    }
	    else if (container.pathsWithParams.length === containeePaths.length) {
	        if (!equalPath(container.pathsWithParams, containeePaths))
	            return false;
	        for (var c in containee.children) {
	            if (!container.children[c])
	                return false;
	            if (!containsSegment(container.children[c], containee.children[c]))
	                return false;
	        }
	        return true;
	    }
	    else {
	        var current = containeePaths.slice(0, container.pathsWithParams.length);
	        var next = containeePaths.slice(container.pathsWithParams.length);
	        if (!equalPath(container.pathsWithParams, current))
	            return false;
	        return containsSegmentHelper(container.children[shared_1.PRIMARY_OUTLET], containee, next);
	    }
	}
	var UrlTree = (function () {
	    function UrlTree(root, queryParams, fragment) {
	        this.root = root;
	        this.queryParams = queryParams;
	        this.fragment = fragment;
	    }
	    UrlTree.prototype.toString = function () { return new url_serializer_1.DefaultUrlSerializer().serialize(this); };
	    return UrlTree;
	}());
	exports.UrlTree = UrlTree;
	var UrlSegment = (function () {
	    function UrlSegment(pathsWithParams, children) {
	        var _this = this;
	        this.pathsWithParams = pathsWithParams;
	        this.children = children;
	        this.parent = null;
	        collection_1.forEach(children, function (v, k) { return v.parent = _this; });
	    }
	    UrlSegment.prototype.toString = function () { return url_serializer_1.serializePaths(this); };
	    return UrlSegment;
	}());
	exports.UrlSegment = UrlSegment;
	var UrlPathWithParams = (function () {
	    function UrlPathWithParams(path, parameters) {
	        this.path = path;
	        this.parameters = parameters;
	    }
	    UrlPathWithParams.prototype.toString = function () { return url_serializer_1.serializePath(this); };
	    return UrlPathWithParams;
	}());
	exports.UrlPathWithParams = UrlPathWithParams;
	function equalPathsWithParams(a, b) {
	    if (a.length !== b.length)
	        return false;
	    for (var i = 0; i < a.length; ++i) {
	        if (a[i].path !== b[i].path)
	            return false;
	        if (!collection_1.shallowEqual(a[i].parameters, b[i].parameters))
	            return false;
	    }
	    return true;
	}
	exports.equalPathsWithParams = equalPathsWithParams;
	function equalPath(a, b) {
	    if (a.length !== b.length)
	        return false;
	    for (var i = 0; i < a.length; ++i) {
	        if (a[i].path !== b[i].path)
	            return false;
	    }
	    return true;
	}
	exports.equalPath = equalPath;
	function mapChildren(segment, fn) {
	    var newChildren = {};
	    collection_1.forEach(segment.children, function (child, childOutlet) {
	        if (childOutlet === shared_1.PRIMARY_OUTLET) {
	            newChildren[childOutlet] = fn(child, childOutlet);
	        }
	    });
	    collection_1.forEach(segment.children, function (child, childOutlet) {
	        if (childOutlet !== shared_1.PRIMARY_OUTLET) {
	            newChildren[childOutlet] = fn(child, childOutlet);
	        }
	    });
	    return newChildren;
	}
	exports.mapChildren = mapChildren;
	function mapChildrenIntoArray(segment, fn) {
	    var res = [];
	    collection_1.forEach(segment.children, function (child, childOutlet) {
	        if (childOutlet === shared_1.PRIMARY_OUTLET) {
	            res = res.concat(fn(child, childOutlet));
	        }
	    });
	    collection_1.forEach(segment.children, function (child, childOutlet) {
	        if (childOutlet !== shared_1.PRIMARY_OUTLET) {
	            res = res.concat(fn(child, childOutlet));
	        }
	    });
	    return res;
	}
	exports.mapChildrenIntoArray = mapChildrenIntoArray;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsX3RyZWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXJsX3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHVCQUE2QixVQUFVLENBQUMsQ0FBQTtBQUN4QywrQkFBa0Usa0JBQWtCLENBQUMsQ0FBQTtBQUNyRiwyQkFBb0Msb0JBQW9CLENBQUMsQ0FBQTtBQUV6RDtJQUNFLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFGZSwwQkFBa0IscUJBRWpDLENBQUE7QUFFRCxzQkFBNkIsU0FBa0IsRUFBRSxTQUFrQixFQUFFLEtBQWM7SUFDakYsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNWLE1BQU0sQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sTUFBTSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6RCxDQUFDO0FBQ0gsQ0FBQztBQU5lLG9CQUFZLGVBTTNCLENBQUE7QUFFRCx1QkFBdUIsU0FBcUIsRUFBRSxTQUFxQjtJQUNqRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsZUFBZSxFQUFFLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDbkYsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUNwRixNQUFN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Q0FBQyxDQUFDLENBQUM7WUFDbkMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQzNDLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUNILE1BQU0sQ0FBQyxHQUFHLENBQUM7QUFDYixDQUFDO0FBZGUsNEJBQW9CLHVCQWNuQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtQUklNQVJZX09VVExFVH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHtEZWZhdWx0VXJsU2VyaWFsaXplciwgc2VyaWFsaXplUGF0aCwgc2VyaWFsaXplUGF0aHN9IGZyb20gJy4vdXJsX3NlcmlhbGl6ZXInO1xuaW1wb3J0IHtmb3JFYWNoLCBzaGFsbG93RXF1YWx9IGZyb20gJy4vdXRpbHMvY29sbGVjdGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eVVybFRyZWUoKSB7XG4gIHJldHVybiBuZXcgVXJsVHJlZShuZXcgVXJsU2VnbWVudChbXSwge30pLCB7fSwgbnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1RyZWUoY29udGFpbmVyOiBVcmxUcmVlLCBjb250YWluZWU6IFVybFRyZWUsIGV4YWN0OiBib29sZWFuKTogYm9vbGVhbiB7XG4gIGlmIChleGFjdCkge1xuICAgIHJldHVybiBlcXVhbFNlZ21lbnRzKGNvbnRhaW5lci5yb290LCBjb250YWluZWUucm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zU2VnbWVudChjb250YWluZXIucm9vdCwgY29udGFpbmVlLnJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVxdWFsU2VnbWVudHMoY29udGFpbmVyOiBVcmxTZWdtZW50LCBjb250YWluZWU6IFVybFNlZ21lbnQpOiBib29sZWFuIHtcbiAgaWYgKCFlcXVhbFBhdGgoY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcywgY29udGFpbmVlLnBhdGhzV2l0aFBhcmFtcykpIHJldHVybiBmYWxzZTtcbiAgaWYgKE9iamVjdC5rZXlzKGNvbnRhaW5lci5jaGlsZHJlbikubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjb250YWluZWUuY2hpbGRyZW4pLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGMgaW4gY29udGFpbmVlLmNoaWxkcmVuKSB7XG4gICAgaWYgKCFjb250YWluZXIuY2hpbGRyZW5bY10pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWVxdWFsU2VnbWVudHMoY29udGFpbmVyLmNoaWxkcmVuW2NdLCBjb250YWluZWUuY2hpbGRyZW5bY10pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zU2VnbWVudChjb250YWluZXI6IFVybFNlZ21lbnQsIGNvbnRhaW5lZTogVXJsU2VnbWVudCk6IGJvb2xlYW4ge1xuICByZXR1cm4gY29udGFpbnNTZWdtZW50SGVscGVyKGNvbnRhaW5lciwgY29udGFpbmVlLCBjb250YWluZWUucGF0aHNXaXRoUGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTZWdtZW50SGVscGVyKFxuICAgIGNvbnRhaW5lcjogVXJsU2VnbWVudCwgY29udGFpbmVlOiBVcmxTZWdtZW50LCBjb250YWluZWVQYXRoczogVXJsUGF0aFdpdGhQYXJhbXNbXSk6IGJvb2xlYW4ge1xuICBpZiAoY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcy5sZW5ndGggPiBjb250YWluZWVQYXRocy5sZW5ndGgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcy5zbGljZSgwLCBjb250YWluZWVQYXRocy5sZW5ndGgpO1xuICAgIGlmICghZXF1YWxQYXRoKGN1cnJlbnQsIGNvbnRhaW5lZVBhdGhzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChPYmplY3Qua2V5cyhjb250YWluZWUuY2hpbGRyZW4pLmxlbmd0aCA+IDApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGNvbnRhaW5lci5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoID09PSBjb250YWluZWVQYXRocy5sZW5ndGgpIHtcbiAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIucGF0aHNXaXRoUGFyYW1zLCBjb250YWluZWVQYXRocykpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjIGluIGNvbnRhaW5lZS5jaGlsZHJlbikge1xuICAgICAgaWYgKCFjb250YWluZXIuY2hpbGRyZW5bY10pIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghY29udGFpbnNTZWdtZW50KGNvbnRhaW5lci5jaGlsZHJlbltjXSwgY29udGFpbmVlLmNoaWxkcmVuW2NdKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBjb250YWluZWVQYXRocy5zbGljZSgwLCBjb250YWluZXIucGF0aHNXaXRoUGFyYW1zLmxlbmd0aCk7XG4gICAgY29uc3QgbmV4dCA9IGNvbnRhaW5lZVBhdGhzLnNsaWNlKGNvbnRhaW5lci5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoKTtcbiAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIucGF0aHNXaXRoUGFyYW1zLCBjdXJyZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb250YWluc1NlZ21lbnRIZWxwZXIoY29udGFpbmVyLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSwgY29udGFpbmVlLCBuZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgVVJMIGluIHRoZSB0cmVlIGZvcm0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVcmxUcmVlIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcm9vdDogVXJsU2VnbWVudCwgcHVibGljIHF1ZXJ5UGFyYW1zOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSxcbiAgICAgIHB1YmxpYyBmcmFnbWVudDogc3RyaW5nKSB7fVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiBuZXcgRGVmYXVsdFVybFNlcmlhbGl6ZXIoKS5zZXJpYWxpemUodGhpcyk7IH1cbn1cblxuZXhwb3J0IGNsYXNzIFVybFNlZ21lbnQge1xuICBwdWJsaWMgcGFyZW50OiBVcmxTZWdtZW50ID0gbnVsbDtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcGF0aHNXaXRoUGFyYW1zOiBVcmxQYXRoV2l0aFBhcmFtc1tdLCBwdWJsaWMgY2hpbGRyZW46IHtba2V5OiBzdHJpbmddOiBVcmxTZWdtZW50fSkge1xuICAgIGZvckVhY2goY2hpbGRyZW4sICh2OiBhbnksIGs6IGFueSkgPT4gdi5wYXJlbnQgPSB0aGlzKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiBzZXJpYWxpemVQYXRocyh0aGlzKTsgfVxufVxuXG5leHBvcnQgY2xhc3MgVXJsUGF0aFdpdGhQYXJhbXMge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGF0aDogc3RyaW5nLCBwdWJsaWMgcGFyYW1ldGVyczoge1trZXk6IHN0cmluZ106IHN0cmluZ30pIHt9XG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiBzZXJpYWxpemVQYXRoKHRoaXMpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbFBhdGhzV2l0aFBhcmFtcyhhOiBVcmxQYXRoV2l0aFBhcmFtc1tdLCBiOiBVcmxQYXRoV2l0aFBhcmFtc1tdKTogYm9vbGVhbiB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFbaV0ucGF0aCAhPT0gYltpXS5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFzaGFsbG93RXF1YWwoYVtpXS5wYXJhbWV0ZXJzLCBiW2ldLnBhcmFtZXRlcnMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbFBhdGgoYTogVXJsUGF0aFdpdGhQYXJhbXNbXSwgYjogVXJsUGF0aFdpdGhQYXJhbXNbXSk6IGJvb2xlYW4ge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhW2ldLnBhdGggIT09IGJbaV0ucGF0aCkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oc2VnbWVudDogVXJsU2VnbWVudCwgZm46ICh2OiBVcmxTZWdtZW50LCBrOiBzdHJpbmcpID0+IFVybFNlZ21lbnQpOlxuICAgIHtbbmFtZTogc3RyaW5nXTogVXJsU2VnbWVudH0ge1xuICBjb25zdCBuZXdDaGlsZHJlbjoge1tuYW1lOiBzdHJpbmddOiBVcmxTZWdtZW50fSA9IHt9O1xuICBmb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIChjaGlsZDogVXJsU2VnbWVudCwgY2hpbGRPdXRsZXQ6IHN0cmluZykgPT4ge1xuICAgIGlmIChjaGlsZE91dGxldCA9PT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgIG5ld0NoaWxkcmVuW2NoaWxkT3V0bGV0XSA9IGZuKGNoaWxkLCBjaGlsZE91dGxldCk7XG4gICAgfVxuICB9KTtcbiAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCAoY2hpbGQ6IFVybFNlZ21lbnQsIGNoaWxkT3V0bGV0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoY2hpbGRPdXRsZXQgIT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICBuZXdDaGlsZHJlbltjaGlsZE91dGxldF0gPSBmbihjaGlsZCwgY2hpbGRPdXRsZXQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdDaGlsZHJlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcENoaWxkcmVuSW50b0FycmF5PFQ+KFxuICAgIHNlZ21lbnQ6IFVybFNlZ21lbnQsIGZuOiAodjogVXJsU2VnbWVudCwgazogc3RyaW5nKSA9PiBUW10pOiBUW10ge1xuICBsZXQgcmVzOiBUW10gPSBbXTtcbiAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCAoY2hpbGQ6IFVybFNlZ21lbnQsIGNoaWxkT3V0bGV0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoY2hpbGRPdXRsZXQgPT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICByZXMgPSByZXMuY29uY2F0KGZuKGNoaWxkLCBjaGlsZE91dGxldCkpO1xuICAgIH1cbiAgfSk7XG4gIGZvckVhY2goc2VnbWVudC5jaGlsZHJlbiwgKGNoaWxkOiBVcmxTZWdtZW50LCBjaGlsZE91dGxldDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGNoaWxkT3V0bGV0ICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgcmVzID0gcmVzLmNvbmNhdChmbihjaGlsZCwgY2hpbGRPdXRsZXQpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuIl19

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var shared_1 = __webpack_require__(416);
	var url_tree_1 = __webpack_require__(417);
	var collection_1 = __webpack_require__(419);
	var UrlSerializer = (function () {
	    function UrlSerializer() {
	    }
	    return UrlSerializer;
	}());
	exports.UrlSerializer = UrlSerializer;
	var DefaultUrlSerializer = (function () {
	    function DefaultUrlSerializer() {
	    }
	    DefaultUrlSerializer.prototype.parse = function (url) {
	        var p = new UrlParser(url);
	        return new url_tree_1.UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
	    };
	    DefaultUrlSerializer.prototype.serialize = function (tree) {
	        var segment = "/" + serializeSegment(tree.root, true);
	        var query = serializeQueryParams(tree.queryParams);
	        var fragment = tree.fragment !== null ? "#" + tree.fragment : '';
	        return "" + segment + query + fragment;
	    };
	    return DefaultUrlSerializer;
	}());
	exports.DefaultUrlSerializer = DefaultUrlSerializer;
	function serializePaths(segment) {
	    return segment.pathsWithParams.map(function (p) { return serializePath(p); }).join('/');
	}
	exports.serializePaths = serializePaths;
	function serializeSegment(segment, root) {
	    if (segment.children[shared_1.PRIMARY_OUTLET] && root) {
	        var primary = serializeSegment(segment.children[shared_1.PRIMARY_OUTLET], false);
	        var children_1 = [];
	        collection_1.forEach(segment.children, function (v, k) {
	            if (k !== shared_1.PRIMARY_OUTLET) {
	                children_1.push(k + ":" + serializeSegment(v, false));
	            }
	        });
	        if (children_1.length > 0) {
	            return primary + "(" + children_1.join('//') + ")";
	        }
	        else {
	            return "" + primary;
	        }
	    }
	    else if (segment.children[shared_1.PRIMARY_OUTLET] && !root) {
	        var children_2 = [serializeSegment(segment.children[shared_1.PRIMARY_OUTLET], false)];
	        collection_1.forEach(segment.children, function (v, k) {
	            if (k !== shared_1.PRIMARY_OUTLET) {
	                children_2.push(k + ":" + serializeSegment(v, false));
	            }
	        });
	        return serializePaths(segment) + "/(" + children_2.join('//') + ")";
	    }
	    else {
	        return serializePaths(segment);
	    }
	}
	function serializeChildren(segment) {
	    if (segment.children[shared_1.PRIMARY_OUTLET]) {
	        var primary = serializePaths(segment.children[shared_1.PRIMARY_OUTLET]);
	        var secondary_1 = [];
	        collection_1.forEach(segment.children, function (v, k) {
	            if (k !== shared_1.PRIMARY_OUTLET) {
	                secondary_1.push(k + ":" + serializePaths(v) + serializeChildren(v));
	            }
	        });
	        var secondaryStr = secondary_1.length > 0 ? "(" + secondary_1.join('//') + ")" : '';
	        var primaryChildren = serializeChildren(segment.children[shared_1.PRIMARY_OUTLET]);
	        var primaryChildrenStr = primaryChildren ? "/" + primaryChildren : '';
	        return "" + primary + secondaryStr + primaryChildrenStr;
	    }
	    else {
	        return '';
	    }
	}
	function serializePath(path) {
	    return "" + path.path + serializeParams(path.parameters);
	}
	exports.serializePath = serializePath;
	function serializeParams(params) {
	    return pairs(params).map(function (p) { return (";" + p.first + "=" + p.second); }).join('');
	}
	function serializeQueryParams(params) {
	    var strs = pairs(params).map(function (p) { return (p.first + "=" + p.second); });
	    return strs.length > 0 ? "?" + strs.join("&") : '';
	}
	var Pair = (function () {
	    function Pair(first, second) {
	        this.first = first;
	        this.second = second;
	    }
	    return Pair;
	}());
	function pairs(obj) {
	    var res = [];
	    for (var prop in obj) {
	        if (obj.hasOwnProperty(prop)) {
	            res.push(new Pair(prop, obj[prop]));
	        }
	    }
	    return res;
	}
	var SEGMENT_RE = /^[^\/\(\)\?;=&#]+/;
	function matchPathWithParams(str) {
	    SEGMENT_RE.lastIndex = 0;
	    var match = SEGMENT_RE.exec(str);
	    return match ? match[0] : '';
	}
	var QUERY_PARAM_RE = /^[^=\?&#]+/;
	function matchQueryParams(str) {
	    QUERY_PARAM_RE.lastIndex = 0;
	    var match = SEGMENT_RE.exec(str);
	    return match ? match[0] : '';
	}
	var QUERY_PARAM_VALUE_RE = /^[^\?&#]+/;
	function matchUrlQueryParamValue(str) {
	    QUERY_PARAM_VALUE_RE.lastIndex = 0;
	    var match = QUERY_PARAM_VALUE_RE.exec(str);
	    return match ? match[0] : '';
	}
	var UrlParser = (function () {
	    function UrlParser(remaining) {
	        this.remaining = remaining;
	    }
	    UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
	    UrlParser.prototype.capture = function (str) {
	        if (!this.remaining.startsWith(str)) {
	            throw new Error("Expected \"" + str + "\".");
	        }
	        this.remaining = this.remaining.substring(str.length);
	    };
	    UrlParser.prototype.parseRootSegment = function () {
	        if (this.remaining === '' || this.remaining === '/') {
	            return new url_tree_1.UrlSegment([], {});
	        }
	        else {
	            return new url_tree_1.UrlSegment([], this.parseSegmentChildren());
	        }
	    };
	    UrlParser.prototype.parseSegmentChildren = function () {
	        if (this.remaining.length == 0) {
	            return {};
	        }
	        if (this.peekStartsWith('/')) {
	            this.capture('/');
	        }
	        var paths = [this.parsePathWithParams()];
	        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
	            this.capture('/');
	            paths.push(this.parsePathWithParams());
	        }
	        var children = {};
	        if (this.peekStartsWith('/(')) {
	            this.capture('/');
	            children = this.parseParens(true);
	        }
	        var res = {};
	        if (this.peekStartsWith('(')) {
	            res = this.parseParens(false);
	        }
	        res[shared_1.PRIMARY_OUTLET] = new url_tree_1.UrlSegment(paths, children);
	        return res;
	    };
	    UrlParser.prototype.parsePathWithParams = function () {
	        var path = matchPathWithParams(this.remaining);
	        this.capture(path);
	        var matrixParams = {};
	        if (this.peekStartsWith(';')) {
	            matrixParams = this.parseMatrixParams();
	        }
	        return new url_tree_1.UrlPathWithParams(path, matrixParams);
	    };
	    UrlParser.prototype.parseQueryParams = function () {
	        var params = {};
	        if (this.peekStartsWith('?')) {
	            this.capture('?');
	            this.parseQueryParam(params);
	            while (this.remaining.length > 0 && this.peekStartsWith('&')) {
	                this.capture('&');
	                this.parseQueryParam(params);
	            }
	        }
	        return params;
	    };
	    UrlParser.prototype.parseFragment = function () {
	        if (this.peekStartsWith('#')) {
	            return this.remaining.substring(1);
	        }
	        else {
	            return null;
	        }
	    };
	    UrlParser.prototype.parseMatrixParams = function () {
	        var params = {};
	        while (this.remaining.length > 0 && this.peekStartsWith(';')) {
	            this.capture(';');
	            this.parseParam(params);
	        }
	        return params;
	    };
	    UrlParser.prototype.parseParam = function (params) {
	        var key = matchPathWithParams(this.remaining);
	        if (!key) {
	            return;
	        }
	        this.capture(key);
	        var value = 'true';
	        if (this.peekStartsWith('=')) {
	            this.capture('=');
	            var valueMatch = matchPathWithParams(this.remaining);
	            if (valueMatch) {
	                value = valueMatch;
	                this.capture(value);
	            }
	        }
	        params[key] = value;
	    };
	    UrlParser.prototype.parseQueryParam = function (params) {
	        var key = matchQueryParams(this.remaining);
	        if (!key) {
	            return;
	        }
	        this.capture(key);
	        var value = 'true';
	        if (this.peekStartsWith('=')) {
	            this.capture('=');
	            var valueMatch = matchUrlQueryParamValue(this.remaining);
	            if (valueMatch) {
	                value = valueMatch;
	                this.capture(value);
	            }
	        }
	        params[key] = value;
	    };
	    UrlParser.prototype.parseParens = function (allowPrimary) {
	        var segments = {};
	        this.capture('(');
	        while (!this.peekStartsWith(')') && this.remaining.length > 0) {
	            var path = matchPathWithParams(this.remaining);
	            var outletName = void 0;
	            if (path.indexOf(':') > -1) {
	                outletName = path.substr(0, path.indexOf(':'));
	                this.capture(outletName);
	                this.capture(':');
	            }
	            else if (allowPrimary) {
	                outletName = shared_1.PRIMARY_OUTLET;
	            }
	            var children = this.parseSegmentChildren();
	            segments[outletName] = Object.keys(children).length === 1 ? children[shared_1.PRIMARY_OUTLET] :
	                new url_tree_1.UrlSegment([], children);
	            if (this.peekStartsWith('//')) {
	                this.capture('//');
	            }
	        }
	        this.capture(')');
	        return segments;
	    };
	    return UrlParser;
	}());
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsX3NlcmlhbGl6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXJsX3NlcmlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHVCQUE2QixVQUFVLENBQUMsQ0FBQTtBQUN4Qyx5QkFBcUQsWUFBWSxDQUFDLENBQUE7QUFDbEUsMkJBQXNCLG9CQUFvQixDQUFDLENBQUE7QUFPM0M7SUFBQTtJQVVBLENBQUM7SUFBRCxvQkFBQztBQUFELENBQUMsQUFWRCxJQVVDO0FBVnFCLHFCQUFhLGdCQVVsQyxDQUFBO0FBS0Q7SUFBQTtJQVlBLENBQUM7SUFYQyxvQ0FBSyxHQUFMLFVBQU0sR0FBVztRQUNmLElBQU0sQ0FBQyxHQUFHLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLE1BQU0sQ0FBQyxJQUFJLGtCQUFPLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUVELHdDQUFTLEdBQVQsVUFBVSxJQUFhO1FBQ3JCLElBQU0sT0FBTyxHQUFHLE1BQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUcsQ0FBQztRQUN4RCxJQUFNLEtBQUssR0FBRyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLEdBQUcsTUFBSSxJQUFJLENBQUMsUUFBVSxHQUFHLEVBQUUsQ0FBQztRQUNuRSxNQUFNLENBQUMsS0FBRyxPQUFPLEdBQUcsS0FBSyxHQUFHLFFBQVUsQ0FBQztJQUN6QyxDQUFDO0lBQ0gsMkJBQUM7QUFBRCxDQUFDLEFBWkQsSUFZQztBQVpZLDRCQUFvQix1QkFZaEMsQ0FBQTtBQUVELHdCQUErQixPQUFtQjtJQUNoRCxNQUFNLENBQUMsT0FB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QyxBQTNKRCxJQTJKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UFJJTUFSWV9PVVRMRVR9IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7VXJsUGF0aFdpdGhQYXJhbXMsIFVybFNlZ21lbnQsIFVybFRyZWV9IGZyb20gJy4vdXJsX3RyZWUnO1xuaW1wb3J0IHtmb3JFYWNofSBmcm9tICcuL3V0aWxzL2NvbGxlY3Rpb24nO1xuXG5cblxuLyoqXG4gKiBEZWZpbmVzIGEgd2F5IHRvIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBhIHVybCB0cmVlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVXJsU2VyaWFsaXplciB7XG4gIC8qKlxuICAgKiBQYXJzZSBhIHVybCBpbnRvIGEge0BMaW5rIFVybFRyZWV9XG4gICAqL1xuICBhYnN0cmFjdCBwYXJzZSh1cmw6IHN0cmluZyk6IFVybFRyZWU7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEge0BMaW5rIFVybFRyZWV9IGludG8gYSB1cmxcbiAgICovXG4gIGFic3RyYWN0IHNlcmlhbGl6ZSh0cmVlOiBVcmxUcmVlKTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXphdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRVcmxTZXJpYWxpemVyIGltcGxlbWVudHMgVXJsU2VyaWFsaXplciB7XG4gIHBhcnNlKHVybDogc3RyaW5nKTogVXJsVHJlZSB7XG4gICAgY29uc3QgcCA9IG5ldyBVcmxQYXJzZXIodXJsKTtcbiAgICByZXR1cm4gbmV3IFVybFRyZWUocC5wYXJzZVJvb3RTZWdtZW50KCksIHAucGFyc2VRdWVyeVBhcmFtcygpLCBwLnBhcnNlRnJhZ21lbnQoKSk7XG4gIH1cblxuICBzZXJpYWxpemUodHJlZTogVXJsVHJlZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGAvJHtzZXJpYWxpemVTZWdtZW50KHRyZWUucm9vdCwgdHJ1ZSl9YDtcbiAgICBjb25zdCBxdWVyeSA9IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHRyZWUucXVlcnlQYXJhbXMpO1xuICAgIGNvbnN0IGZyYWdtZW50ID0gdHJlZS5mcmFnbWVudCAhPT0gbnVsbCA/IGAjJHt0cmVlLmZyYWdtZW50fWAgOiAnJztcbiAgICByZXR1cm4gYCR7c2VnbWVudH0ke3F1ZXJ5fSR7ZnJhZ21lbnR9YDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUGF0aHMoc2VnbWVudDogVXJsU2VnbWVudCk6IHN0cmluZyB7XG4gIHJldHVybiBzZWdtZW50LnBhdGhzV2l0aFBhcmFtcy5tYXAocCA9PiBzZXJpYWxpemVQYXRoKHApKS5qb2luKCcvJyk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudDogVXJsU2VnbWVudCwgcm9vdDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChzZWdtZW50LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSAmJiByb290KSB7XG4gICAgY29uc3QgcHJpbWFyeSA9IHNlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0sIGZhbHNlKTtcbiAgICBjb25zdCBjaGlsZHJlbjogc3RyaW5nW10gPSBbXTtcbiAgICBmb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sICh2OiBVcmxTZWdtZW50LCBrOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChrICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGAke2t9OiR7c2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSl9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBgJHtwcmltYXJ5fSgke2NoaWxkcmVuLmpvaW4oJy8vJyl9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtwcmltYXJ5fWA7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlZ21lbnQuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdICYmICFyb290KSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbc2VyaWFsaXplU2VnbWVudChzZWdtZW50LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSwgZmFsc2UpXTtcbiAgICBmb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sICh2OiBVcmxTZWdtZW50LCBrOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChrICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGAke2t9OiR7c2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSl9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGAke3NlcmlhbGl6ZVBhdGhzKHNlZ21lbnQpfS8oJHtjaGlsZHJlbi5qb2luKCcvLycpfSlgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZXJpYWxpemVQYXRocyhzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVDaGlsZHJlbihzZWdtZW50OiBVcmxTZWdtZW50KSB7XG4gIGlmIChzZWdtZW50LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSkge1xuICAgIGNvbnN0IHByaW1hcnkgPSBzZXJpYWxpemVQYXRocyhzZWdtZW50LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSk7XG5cbiAgICBjb25zdCBzZWNvbmRhcnk6IHN0cmluZ1tdID0gW107XG4gICAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCAodjogVXJsU2VnbWVudCwgazogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoayAhPT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgc2Vjb25kYXJ5LnB1c2goYCR7a306JHtzZXJpYWxpemVQYXRocyh2KX0ke3NlcmlhbGl6ZUNoaWxkcmVuKHYpfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlY29uZGFyeVN0ciA9IHNlY29uZGFyeS5sZW5ndGggPiAwID8gYCgke3NlY29uZGFyeS5qb2luKCcvLycpfSlgIDogJyc7XG4gICAgY29uc3QgcHJpbWFyeUNoaWxkcmVuID0gc2VyaWFsaXplQ2hpbGRyZW4oc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0pO1xuICAgIGNvbnN0IHByaW1hcnlDaGlsZHJlblN0cjogc3RyaW5nID0gcHJpbWFyeUNoaWxkcmVuID8gYC8ke3ByaW1hcnlDaGlsZHJlbn1gIDogJyc7XG4gICAgcmV0dXJuIGAke3ByaW1hcnl9JHtzZWNvbmRhcnlTdHJ9JHtwcmltYXJ5Q2hpbGRyZW5TdHJ9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGgocGF0aDogVXJsUGF0aFdpdGhQYXJhbXMpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7cGF0aC5wYXRofSR7c2VyaWFsaXplUGFyYW1zKHBhdGgucGFyYW1ldGVycyl9YDtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplUGFyYW1zKHBhcmFtczoge1trZXk6IHN0cmluZ106IHN0cmluZ30pOiBzdHJpbmcge1xuICByZXR1cm4gcGFpcnMocGFyYW1zKS5tYXAocCA9PiBgOyR7cC5maXJzdH09JHtwLnNlY29uZH1gKS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplUXVlcnlQYXJhbXMocGFyYW1zOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0cnMgPSBwYWlycyhwYXJhbXMpLm1hcChwID0+IGAke3AuZmlyc3R9PSR7cC5zZWNvbmR9YCk7XG4gIHJldHVybiBzdHJzLmxlbmd0aCA+IDAgPyBgPyR7c3Rycy5qb2luKFwiJlwiKX1gIDogJyc7XG59XG5cbmNsYXNzIFBhaXI8QSwgQj4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZmlyc3Q6IEEsIHB1YmxpYyBzZWNvbmQ6IEIpIHt9XG59XG5mdW5jdGlvbiBwYWlyczxUPihvYmo6IHtba2V5OiBzdHJpbmddOiBUfSk6IFBhaXI8c3RyaW5nLCBUPltdIHtcbiAgY29uc3QgcmVzOiBQYWlyPHN0cmluZywgVD5bXSA9IFtdO1xuICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHJlcy5wdXNoKG5ldyBQYWlyPHN0cmluZywgVD4ocHJvcCwgb2JqW3Byb3BdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmNvbnN0IFNFR01FTlRfUkUgPSAvXlteXFwvXFwoXFwpXFw/Oz0mI10rLztcbmZ1bmN0aW9uIG1hdGNoUGF0aFdpdGhQYXJhbXMoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBTRUdNRU5UX1JFLmxhc3RJbmRleCA9IDA7XG4gIGNvbnN0IG1hdGNoID0gU0VHTUVOVF9SRS5leGVjKHN0cik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG59XG5cbmNvbnN0IFFVRVJZX1BBUkFNX1JFID0gL15bXj1cXD8mI10rLztcbmZ1bmN0aW9uIG1hdGNoUXVlcnlQYXJhbXMoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBRVUVSWV9QQVJBTV9SRS5sYXN0SW5kZXggPSAwO1xuICBjb25zdCBtYXRjaCA9IFNFR01FTlRfUkUuZXhlYyhzdHIpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xufVxuXG5jb25zdCBRVUVSWV9QQVJBTV9WQUxVRV9SRSA9IC9eW15cXD8mI10rLztcbmZ1bmN0aW9uIG1hdGNoVXJsUXVlcnlQYXJhbVZhbHVlKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgUVVFUllfUEFSQU1fVkFMVUVfUkUubGFzdEluZGV4ID0gMDtcbiAgY29uc3QgbWF0Y2ggPSBRVUVSWV9QQVJBTV9WQUxVRV9SRS5leGVjKHN0cik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG59XG5cbmNsYXNzIFVybFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVtYWluaW5nOiBzdHJpbmcpIHt9XG5cbiAgcGVla1N0YXJ0c1dpdGgoc3RyOiBzdHJpbmcpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMucmVtYWluaW5nLnN0YXJ0c1dpdGgoc3RyKTsgfVxuXG4gIGNhcHR1cmUoc3RyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucmVtYWluaW5nLnN0YXJ0c1dpdGgoc3RyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBcIiR7c3RyfVwiLmApO1xuICAgIH1cbiAgICB0aGlzLnJlbWFpbmluZyA9IHRoaXMucmVtYWluaW5nLnN1YnN0cmluZyhzdHIubGVuZ3RoKTtcbiAgfVxuXG4gIHBhcnNlUm9vdFNlZ21lbnQoKTogVXJsU2VnbWVudCB7XG4gICAgaWYgKHRoaXMucmVtYWluaW5nID09PSAnJyB8fCB0aGlzLnJlbWFpbmluZyA9PT0gJy8nKSB7XG4gICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnQoW10sIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KFtdLCB0aGlzLnBhcnNlU2VnbWVudENoaWxkcmVuKCkpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlU2VnbWVudENoaWxkcmVuKCk6IHtba2V5OiBzdHJpbmddOiBVcmxTZWdtZW50fSB7XG4gICAgaWYgKHRoaXMucmVtYWluaW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aHMgPSBbdGhpcy5wYXJzZVBhdGhXaXRoUGFyYW1zKCldO1xuXG4gICAgd2hpbGUgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8nKSAmJiAhdGhpcy5wZWVrU3RhcnRzV2l0aCgnLy8nKSAmJiAhdGhpcy5wZWVrU3RhcnRzV2l0aCgnLygnKSkge1xuICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XG4gICAgICBwYXRocy5wdXNoKHRoaXMucGFyc2VQYXRoV2l0aFBhcmFtcygpKTtcbiAgICB9XG5cbiAgICBsZXQgY2hpbGRyZW46IHtba2V5OiBzdHJpbmddOiBVcmxTZWdtZW50fSA9IHt9O1xuICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvKCcpKSB7XG4gICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcbiAgICAgIGNoaWxkcmVuID0gdGhpcy5wYXJzZVBhcmVucyh0cnVlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzOiB7W2tleTogc3RyaW5nXTogVXJsU2VnbWVudH0gPSB7fTtcbiAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlUGFyZW5zKGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXNbUFJJTUFSWV9PVVRMRVRdID0gbmV3IFVybFNlZ21lbnQocGF0aHMsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcGFyc2VQYXRoV2l0aFBhcmFtcygpOiBVcmxQYXRoV2l0aFBhcmFtcyB7XG4gICAgbGV0IHBhdGggPSBtYXRjaFBhdGhXaXRoUGFyYW1zKHRoaXMucmVtYWluaW5nKTtcbiAgICB0aGlzLmNhcHR1cmUocGF0aCk7XG4gICAgbGV0IG1hdHJpeFBhcmFtczoge1trZXk6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnOycpKSB7XG4gICAgICBtYXRyaXhQYXJhbXMgPSB0aGlzLnBhcnNlTWF0cml4UGFyYW1zKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVXJsUGF0aFdpdGhQYXJhbXMocGF0aCwgbWF0cml4UGFyYW1zKTtcbiAgfVxuXG4gIHBhcnNlUXVlcnlQYXJhbXMoKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIGNvbnN0IHBhcmFtczoge1trZXk6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnPycpKSB7XG4gICAgICB0aGlzLmNhcHR1cmUoJz8nKTtcbiAgICAgIHRoaXMucGFyc2VRdWVyeVBhcmFtKHBhcmFtcyk7XG4gICAgICB3aGlsZSAodGhpcy5yZW1haW5pbmcubGVuZ3RoID4gMCAmJiB0aGlzLnBlZWtTdGFydHNXaXRoKCcmJykpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlKCcmJyk7XG4gICAgICAgIHRoaXMucGFyc2VRdWVyeVBhcmFtKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBwYXJzZUZyYWdtZW50KCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VNYXRyaXhQYXJhbXMoKToge1trZXk6IHN0cmluZ106IGFueX0ge1xuICAgIGNvbnN0IHBhcmFtczoge1trZXk6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgICB3aGlsZSAodGhpcy5yZW1haW5pbmcubGVuZ3RoID4gMCAmJiB0aGlzLnBlZWtTdGFydHNXaXRoKCc7JykpIHtcbiAgICAgIHRoaXMuY2FwdHVyZSgnOycpO1xuICAgICAgdGhpcy5wYXJzZVBhcmFtKHBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBwYXJzZVBhcmFtKHBhcmFtczoge1trZXk6IHN0cmluZ106IGFueX0pOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBtYXRjaFBhdGhXaXRoUGFyYW1zKHRoaXMucmVtYWluaW5nKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNhcHR1cmUoa2V5KTtcbiAgICBsZXQgdmFsdWU6IGFueSA9ICd0cnVlJztcbiAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnPScpKSB7XG4gICAgICB0aGlzLmNhcHR1cmUoJz0nKTtcbiAgICAgIGNvbnN0IHZhbHVlTWF0Y2ggPSBtYXRjaFBhdGhXaXRoUGFyYW1zKHRoaXMucmVtYWluaW5nKTtcbiAgICAgIGlmICh2YWx1ZU1hdGNoKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVNYXRjaDtcbiAgICAgICAgdGhpcy5jYXB0dXJlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcGFyc2VRdWVyeVBhcmFtKHBhcmFtczoge1trZXk6IHN0cmluZ106IGFueX0pOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBtYXRjaFF1ZXJ5UGFyYW1zKHRoaXMucmVtYWluaW5nKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNhcHR1cmUoa2V5KTtcbiAgICBsZXQgdmFsdWU6IGFueSA9ICd0cnVlJztcbiAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnPScpKSB7XG4gICAgICB0aGlzLmNhcHR1cmUoJz0nKTtcbiAgICAgIHZhciB2YWx1ZU1hdGNoID0gbWF0Y2hVcmxRdWVyeVBhcmFtVmFsdWUodGhpcy5yZW1haW5pbmcpO1xuICAgICAgaWYgKHZhbHVlTWF0Y2gpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZU1hdGNoO1xuICAgICAgICB0aGlzLmNhcHR1cmUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcGFyc2VQYXJlbnMoYWxsb3dQcmltYXJ5OiBib29sZWFuKToge1trZXk6IHN0cmluZ106IFVybFNlZ21lbnR9IHtcbiAgICBjb25zdCBzZWdtZW50czoge1trZXk6IHN0cmluZ106IFVybFNlZ21lbnR9ID0ge307XG4gICAgdGhpcy5jYXB0dXJlKCcoJyk7XG5cbiAgICB3aGlsZSAoIXRoaXMucGVla1N0YXJ0c1dpdGgoJyknKSAmJiB0aGlzLnJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgcGF0aCA9IG1hdGNoUGF0aFdpdGhQYXJhbXModGhpcy5yZW1haW5pbmcpO1xuICAgICAgbGV0IG91dGxldE5hbWU6IHN0cmluZztcbiAgICAgIGlmIChwYXRoLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgICAgIG91dGxldE5hbWUgPSBwYXRoLnN1YnN0cigwLCBwYXRoLmluZGV4T2YoJzonKSk7XG4gICAgICAgIHRoaXMuY2FwdHVyZShvdXRsZXROYW1lKTtcbiAgICAgICAgdGhpcy5jYXB0dXJlKCc6Jyk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93UHJpbWFyeSkge1xuICAgICAgICBvdXRsZXROYW1lID0gUFJJTUFSWV9PVVRMRVQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wYXJzZVNlZ21lbnRDaGlsZHJlbigpO1xuICAgICAgc2VnbWVudHNbb3V0bGV0TmFtZV0gPSBPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVcmxTZWdtZW50KFtdLCBjaGlsZHJlbik7XG5cbiAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZSgnLy8nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jYXB0dXJlKCcpJyk7XG5cbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 419 */
/***/ function(module, exports) {

	"use strict";
	function shallowEqual(a, b) {
	    var k1 = Object.keys(a);
	    var k2 = Object.keys(b);
	    if (k1.length != k2.length) {
	        return false;
	    }
	    var key;
	    for (var i = 0; i < k1.length; i++) {
	        key = k1[i];
	        if (a[key] !== b[key]) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.shallowEqual = shallowEqual;
	function flatten(a) {
	    var target = [];
	    for (var i = 0; i < a.length; ++i) {
	        for (var j = 0; j < a[i].length; ++j) {
	            target.push(a[i][j]);
	        }
	    }
	    return target;
	}
	exports.flatten = flatten;
	function first(a) {
	    return a.length > 0 ? a[0] : null;
	}
	exports.first = first;
	function last(a) {
	    return a.length > 0 ? a[a.length - 1] : null;
	}
	exports.last = last;
	function and(bools) {
	    return bools.reduce(function (a, b) { return a && b; }, true);
	}
	exports.and = and;
	function merge(m1, m2) {
	    var m = {};
	    for (var attr in m1) {
	        if (m1.hasOwnProperty(attr)) {
	            m[attr] = m1[attr];
	        }
	    }
	    for (var attr in m2) {
	        if (m2.hasOwnProperty(attr)) {
	            m[attr] = m2[attr];
	        }
	    }
	    return m;
	}
	exports.merge = merge;
	function forEach(map, callback) {
	    for (var prop in map) {
	        if (map.hasOwnProperty(prop)) {
	            callback(map[prop], prop);
	        }
	    }
	}
	exports.forEach = forEach;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jb2xsZWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxzQkFBNkIsQ0FBcUIsRUFBRSxDQUFxQjtJQUN2RSxJQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLElBQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMzQixNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELElBQUksR0FBVyxDQUFDO0lBQ2hCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ25DLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDWixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QixNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQWRlLG9CQUFZLGVBYzNCLENBQUE7QUFFRCxpQkFBMkIsQ0FBUTtJQUNqQyxJQUFNLE1BQU0sR0FBUSxFQUFFLENBQUM7SUFDdkIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDbEMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDckMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQVJlLGVBQU8sVUFRdEIsQ0FBQTtBQUVELGVBQXlCLENBQU07SUFDN0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDcEMsQ0FBQztBQUZlLGFBQUssUUFFcEIsQ0FBQTtBQUVELGNBQXdCLENBQU07SUFDNUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUMvQyxDQUFDO0FBRmUsWUFBSSxPQUVuQixDQUFBO0FBRUQsYUFBb0IsS0FBZ0I7SUFDbEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxJQUFJLENBQUMsRUFBTixDQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDOUMsQ0FBQztBQUZlLFdBQUcsTUFFbEIsQ0FBQTtBQUVELGVBQXlCLEVBQXNCLEVBQUUsRUFBc0I7SUFDckUsSUFBSSxDQUFDLEdBQXVCLEVBQUUsQ0FBQztJQUUvQixHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsQ0FBQztJQUNILENBQUM7SUFFRCxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQWhCZSxhQUFLLFFBZ0JwQixDQUFBO0FBRUQsaUJBQ0ksR0FBdUIsRUFBRSxRQUFxQztJQUNoRSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdCLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDNUIsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBUGUsZUFBTyxVQU90QixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhOiB7W3g6IHN0cmluZ106IGFueX0sIGI6IHtbeDogc3RyaW5nXTogYW55fSk6IGJvb2xlYW4ge1xuICBjb25zdCBrMSA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBrMiA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQga2V5OiBzdHJpbmc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrMVtpXTtcbiAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuPFQ+KGE6IFRbXVtdKTogVFtdIHtcbiAgY29uc3QgdGFyZ2V0OiBUW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICB0YXJnZXQucHVzaChhW2ldW2pdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQ+KGE6IFRbXSk6IFQge1xuICByZXR1cm4gYS5sZW5ndGggPiAwID8gYVswXSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+KGE6IFRbXSk6IFQge1xuICByZXR1cm4gYS5sZW5ndGggPiAwID8gYVthLmxlbmd0aCAtIDFdIDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZChib29sczogYm9vbGVhbltdKTogYm9vbGVhbiB7XG4gIHJldHVybiBib29scy5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxWPihtMToge1trZXk6IHN0cmluZ106IFZ9LCBtMjoge1trZXk6IHN0cmluZ106IFZ9KToge1trZXk6IHN0cmluZ106IFZ9IHtcbiAgdmFyIG06IHtba2V5OiBzdHJpbmddOiBWfSA9IHt9O1xuXG4gIGZvciAodmFyIGF0dHIgaW4gbTEpIHtcbiAgICBpZiAobTEuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgIG1bYXR0cl0gPSBtMVthdHRyXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBhdHRyIGluIG0yKSB7XG4gICAgaWYgKG0yLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBtW2F0dHJdID0gbTJbYXR0cl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoPEssIFY+KFxuICAgIG1hcDoge1trZXk6IHN0cmluZ106IFZ9LCBjYWxsYmFjazogLyooViwgSykgPT4gdm9pZCovIEZ1bmN0aW9uKTogdm9pZCB7XG4gIGZvciAodmFyIHByb3AgaW4gbWFwKSB7XG4gICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgY2FsbGJhY2sobWFwW3Byb3BdLCBwcm9wKTtcbiAgICB9XG4gIH1cbn0iXX0=

/***/ },
/* 420 */
/***/ function(module, exports) {

	"use strict";
	function validateConfig(config) {
	    config.forEach(validateNode);
	}
	exports.validateConfig = validateConfig;
	function validateNode(route) {
	    if (!!route.redirectTo && !!route.children) {
	        throw new Error("Invalid configuration of route '" + route.path + "': redirectTo and children cannot be used together");
	    }
	    if (!!route.redirectTo && !!route.component) {
	        throw new Error("Invalid configuration of route '" + route.path + "': redirectTo and component cannot be used together");
	    }
	    if (route.path === undefined) {
	        throw new Error("Invalid route configuration: routes must have path specified");
	    }
	    if (route.path.startsWith('/')) {
	        throw new Error("Invalid route configuration of route '" + route.path + "': path cannot start with a slash");
	    }
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBZUEsd0JBQStCLE1BQW9CO0lBQ2pELE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDL0IsQ0FBQztBQUZlLHNCQUFjLGlCQUU3QixDQUFBO0FBRUQsc0JBQXNCLEtBQVk7SUFDaEMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sSUFBSSxLQUFLLENBQ1gscUNBQW1DLEtBQUssQ0FBQyxJQUFJLHVEQUFvRCxDQUFDLENBQUM7SUFDekcsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUM1QyxNQUFNLElBQUksS0FBSyxDQUNYLHFDQUFtQyxLQUFLLENBQUMsSUFBSSx3REFBcUQsQ0FBQyxDQUFDO0lBQzFHLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBeUMsS0FBSyxDQUFDLElBQUksc0NBQW1DLENBQUMsQ0FBQztJQUMxRyxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCB0eXBlIFJvdXRlckNvbmZpZyA9IFJvdXRlW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGUge1xuICBwYXRoPzogc3RyaW5nO1xuICB0ZXJtaW5hbD86IGJvb2xlYW47XG4gIGNvbXBvbmVudD86IFR5cGV8c3RyaW5nO1xuICBvdXRsZXQ/OiBzdHJpbmc7XG4gIGNhbkFjdGl2YXRlPzogYW55W107XG4gIGNhbkRlYWN0aXZhdGU/OiBhbnlbXTtcbiAgcmVkaXJlY3RUbz86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSb3V0ZVtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb25maWcoY29uZmlnOiBSb3V0ZXJDb25maWcpOiB2b2lkIHtcbiAgY29uZmlnLmZvckVhY2godmFsaWRhdGVOb2RlKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOb2RlKHJvdXRlOiBSb3V0ZSk6IHZvaWQge1xuICBpZiAoISFyb3V0ZS5yZWRpcmVjdFRvICYmICEhcm91dGUuY2hpbGRyZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJyR7cm91dGUucGF0aH0nOiByZWRpcmVjdFRvIGFuZCBjaGlsZHJlbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlcmApO1xuICB9XG4gIGlmICghIXJvdXRlLnJlZGlyZWN0VG8gJiYgISFyb3V0ZS5jb21wb25lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJyR7cm91dGUucGF0aH0nOiByZWRpcmVjdFRvIGFuZCBjb21wb25lbnQgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJgKTtcbiAgfVxuICBpZiAocm91dGUucGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvdXRlIGNvbmZpZ3VyYXRpb246IHJvdXRlcyBtdXN0IGhhdmUgcGF0aCBzcGVjaWZpZWRgKTtcbiAgfVxuICBpZiAocm91dGUucGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm91dGUgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnJHtyb3V0ZS5wYXRofSc6IHBhdGggY2Fubm90IHN0YXJ0IHdpdGggYSBzbGFzaGApO1xuICB9XG59Il19

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BehaviorSubject_1 = __webpack_require__(422);
	var router_state_1 = __webpack_require__(423);
	var tree_1 = __webpack_require__(424);
	function createRouterState(curr, prevState) {
	    var root = createNode(curr._root, prevState ? prevState._root : undefined);
	    var queryParams = prevState ? prevState.queryParams : new BehaviorSubject_1.BehaviorSubject(curr.queryParams);
	    var fragment = prevState ? prevState.fragment : new BehaviorSubject_1.BehaviorSubject(curr.fragment);
	    return new router_state_1.RouterState(root, queryParams, fragment, curr);
	}
	exports.createRouterState = createRouterState;
	function createNode(curr, prevState) {
	    if (prevState && equalRouteSnapshots(prevState.value.snapshot, curr.value)) {
	        var value = prevState.value;
	        value._futureSnapshot = curr.value;
	        var children = createOrReuseChildren(curr, prevState);
	        return new tree_1.TreeNode(value, children);
	    }
	    else {
	        var value = createActivatedRoute(curr.value);
	        var children = curr.children.map(function (c) { return createNode(c); });
	        return new tree_1.TreeNode(value, children);
	    }
	}
	function createOrReuseChildren(curr, prevState) {
	    return curr.children.map(function (child) {
	        var index = prevState.children.findIndex(function (p) { return equalRouteSnapshots(p.value.snapshot, child.value); });
	        if (index >= 0) {
	            return createNode(child, prevState.children[index]);
	        }
	        else {
	            return createNode(child);
	        }
	    });
	}
	function createActivatedRoute(c) {
	    return new router_state_1.ActivatedRoute(new BehaviorSubject_1.BehaviorSubject(c.url), new BehaviorSubject_1.BehaviorSubject(c.params), c.outlet, c.component, c);
	}
	function equalRouteSnapshots(a, b) {
	    return a._routeConfig === b._routeConfig;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlX3JvdXRlcl9zdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jcmVhdGVfcm91dGVyX3N0YXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxnQ0FBOEIsc0JBQXNCLENBQUMsQ0FBQTtBQUVyRCw2QkFBdUYsZ0JBQWdCLENBQUMsQ0FBQTtBQUN4RyxxQkFBdUIsY0FBYyxDQUFDLENBQUE7QUFFdEMsMkJBQWtDLElBQXlCLEVBQUUsU0FBc0I7SUFDakYsSUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUM7SUFDN0UsSUFBTSxXQUFXLEdBQUcsU0FBUyxHQUFHLFNBQVMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5RixJQUFNLFFBQVEsR0FBRyxTQUFTLEdBQUcsU0FBUyxDQUFDLFFBQVEsR0FBRyxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JGLE1BQU0sQ0FBQyxJQUFJLDBCQUFXLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDNUQsQ0FBQztBQUxlLHlCQUFpQixvQkFLaEMsQ0FBQTtBQUVELG9CQUFvQixJQUFzQyxFQUFFLFNBQW9DO0lBRTlGLEVBQUUsQ0FBQyxDQUFDLFNBQVMsSUFBSSxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNFLElBQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUM7UUFDOUIsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRW5DLElBQU0sUUFBUSxHQUFHLHFCQUFxQixDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztRQUN4RCxNQUFNLENBQUMsSUFBSSxlQUFRLENBQWlCLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztJQUV2RCxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixJQUFNLEtBQUssR0FBRyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0MsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQWIsQ0FBYSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLElBQUksZUFBUSxDQUFpQixLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkQsQ0FBQztBQUNILENBQUM7QUFFRCwrQkFDSSxJQUFzQyxFQUFFLFNBQW1DO0lBQzdFLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFBLEtBQUs7UUFDNUIsSUFBTSxLQUFLLEdBQ1AsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQWxELENBQWtELENBQUMsQ0FBQztRQUMxRixFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNmLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN0RCxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCw4QkFBOEIsQ0FBeUI7SUFDckQsTUFBTSxDQUFDLElBQUksNkJBQWMsQ0FDckIsSUFBSSxpQ0FBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLGlDQUFlLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMzRixDQUFDO0FBRUQsNkJBQTZCLENBQXlCLEVBQUUsQ0FBeUI7SUFDL0UsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLEtBQUssQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUMzQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtCZWhhdmlvclN1YmplY3R9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuaW1wb3J0IHtBY3RpdmF0ZWRSb3V0ZSwgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgUm91dGVyU3RhdGUsIFJvdXRlclN0YXRlU25hcHNob3R9IGZyb20gJy4vcm91dGVyX3N0YXRlJztcbmltcG9ydCB7VHJlZU5vZGV9IGZyb20gJy4vdXRpbHMvdHJlZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJTdGF0ZShjdXJyOiBSb3V0ZXJTdGF0ZVNuYXBzaG90LCBwcmV2U3RhdGU6IFJvdXRlclN0YXRlKTogUm91dGVyU3RhdGUge1xuICBjb25zdCByb290ID0gY3JlYXRlTm9kZShjdXJyLl9yb290LCBwcmV2U3RhdGUgPyBwcmV2U3RhdGUuX3Jvb3QgOiB1bmRlZmluZWQpO1xuICBjb25zdCBxdWVyeVBhcmFtcyA9IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5xdWVyeVBhcmFtcyA6IG5ldyBCZWhhdmlvclN1YmplY3QoY3Vyci5xdWVyeVBhcmFtcyk7XG4gIGNvbnN0IGZyYWdtZW50ID0gcHJldlN0YXRlID8gcHJldlN0YXRlLmZyYWdtZW50IDogbmV3IEJlaGF2aW9yU3ViamVjdChjdXJyLmZyYWdtZW50KTtcbiAgcmV0dXJuIG5ldyBSb3V0ZXJTdGF0ZShyb290LCBxdWVyeVBhcmFtcywgZnJhZ21lbnQsIGN1cnIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGN1cnI6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+LCBwcmV2U3RhdGU/OiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZT4pOlxuICAgIFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlPiB7XG4gIGlmIChwcmV2U3RhdGUgJiYgZXF1YWxSb3V0ZVNuYXBzaG90cyhwcmV2U3RhdGUudmFsdWUuc25hcHNob3QsIGN1cnIudmFsdWUpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcmV2U3RhdGUudmFsdWU7XG4gICAgdmFsdWUuX2Z1dHVyZVNuYXBzaG90ID0gY3Vyci52YWx1ZTtcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlT3JSZXVzZUNoaWxkcmVuKGN1cnIsIHByZXZTdGF0ZSk7XG4gICAgcmV0dXJuIG5ldyBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZT4odmFsdWUsIGNoaWxkcmVuKTtcblxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZhbHVlID0gY3JlYXRlQWN0aXZhdGVkUm91dGUoY3Vyci52YWx1ZSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyLmNoaWxkcmVuLm1hcChjID0+IGNyZWF0ZU5vZGUoYykpO1xuICAgIHJldHVybiBuZXcgVHJlZU5vZGU8QWN0aXZhdGVkUm91dGU+KHZhbHVlLCBjaGlsZHJlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JSZXVzZUNoaWxkcmVuKFxuICAgIGN1cnI6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+LCBwcmV2U3RhdGU6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlPikge1xuICByZXR1cm4gY3Vyci5jaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgIGNvbnN0IGluZGV4ID1cbiAgICAgICAgcHJldlN0YXRlLmNoaWxkcmVuLmZpbmRJbmRleChwID0+IGVxdWFsUm91dGVTbmFwc2hvdHMocC52YWx1ZS5zbmFwc2hvdCwgY2hpbGQudmFsdWUpKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoY2hpbGQsIHByZXZTdGF0ZS5jaGlsZHJlbltpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZShjaGlsZCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aXZhdGVkUm91dGUoYzogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCkge1xuICByZXR1cm4gbmV3IEFjdGl2YXRlZFJvdXRlKFxuICAgICAgbmV3IEJlaGF2aW9yU3ViamVjdChjLnVybCksIG5ldyBCZWhhdmlvclN1YmplY3QoYy5wYXJhbXMpLCBjLm91dGxldCwgYy5jb21wb25lbnQsIGMpO1xufVxuXG5mdW5jdGlvbiBlcXVhbFJvdXRlU25hcHNob3RzKGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGI6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIGEuX3JvdXRlQ29uZmlnID09PSBiLl9yb3V0ZUNvbmZpZztcbn0iXX0=

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(37);
	var throwError_1 = __webpack_require__(55);
	var ObjectUnsubscribedError_1 = __webpack_require__(56);
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasErrored) {
	            throwError_1.throwError(this.errorValue);
	        }
	        else if (this.isUnsubscribed) {
	            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
	        }
	        else {
	            return this._value;
	        }
	    };
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.isUnsubscribed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype._next = function (value) {
	        _super.prototype._next.call(this, this._value = value);
	    };
	    BehaviorSubject.prototype._error = function (err) {
	        this.hasErrored = true;
	        _super.prototype._error.call(this, this.errorValue = err);
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	exports.BehaviorSubject = BehaviorSubject;
	//# sourceMappingURL=BehaviorSubject.js.map

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BehaviorSubject_1 = __webpack_require__(422);
	var shared_1 = __webpack_require__(416);
	var url_tree_1 = __webpack_require__(417);
	var collection_1 = __webpack_require__(419);
	var tree_1 = __webpack_require__(424);
	var RouterState = (function (_super) {
	    __extends(RouterState, _super);
	    function RouterState(root, queryParams, fragment, snapshot) {
	        _super.call(this, root);
	        this.queryParams = queryParams;
	        this.fragment = fragment;
	        this.snapshot = snapshot;
	    }
	    RouterState.prototype.toString = function () { return this.snapshot.toString(); };
	    return RouterState;
	}(tree_1.Tree));
	exports.RouterState = RouterState;
	function createEmptyState(urlTree, rootComponent) {
	    var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
	    var emptyUrl = new BehaviorSubject_1.BehaviorSubject([new url_tree_1.UrlPathWithParams('', {})]);
	    var emptyParams = new BehaviorSubject_1.BehaviorSubject({});
	    var emptyQueryParams = new BehaviorSubject_1.BehaviorSubject({});
	    var fragment = new BehaviorSubject_1.BehaviorSubject('');
	    var activated = new ActivatedRoute(emptyUrl, emptyParams, shared_1.PRIMARY_OUTLET, rootComponent, snapshot.root);
	    activated.snapshot = snapshot.root;
	    return new RouterState(new tree_1.TreeNode(activated, []), emptyQueryParams, fragment, snapshot);
	}
	exports.createEmptyState = createEmptyState;
	function createEmptyStateSnapshot(urlTree, rootComponent) {
	    var emptyParams = {};
	    var emptyQueryParams = {};
	    var fragment = '';
	    var activated = new ActivatedRouteSnapshot([], emptyParams, shared_1.PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1);
	    return new RouterStateSnapshot('', new tree_1.TreeNode(activated, []), emptyQueryParams, fragment);
	}
	var ActivatedRoute = (function () {
	    function ActivatedRoute(url, params, outlet, component, futureSnapshot) {
	        this.url = url;
	        this.params = params;
	        this.outlet = outlet;
	        this.component = component;
	        this._futureSnapshot = futureSnapshot;
	    }
	    ActivatedRoute.prototype.toString = function () {
	        return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
	    };
	    return ActivatedRoute;
	}());
	exports.ActivatedRoute = ActivatedRoute;
	var ActivatedRouteSnapshot = (function () {
	    function ActivatedRouteSnapshot(url, params, outlet, component, routeConfig, urlSegment, lastPathIndex) {
	        this.url = url;
	        this.params = params;
	        this.outlet = outlet;
	        this.component = component;
	        this._routeConfig = routeConfig;
	        this._urlSegment = urlSegment;
	        this._lastPathIndex = lastPathIndex;
	    }
	    ActivatedRouteSnapshot.prototype.toString = function () {
	        var url = this.url.map(function (s) { return s.toString(); }).join('/');
	        var matched = this._routeConfig ? this._routeConfig.path : '';
	        return "Route(url:'" + url + "', path:'" + matched + "')";
	    };
	    return ActivatedRouteSnapshot;
	}());
	exports.ActivatedRouteSnapshot = ActivatedRouteSnapshot;
	var RouterStateSnapshot = (function (_super) {
	    __extends(RouterStateSnapshot, _super);
	    function RouterStateSnapshot(url, root, queryParams, fragment) {
	        _super.call(this, root);
	        this.url = url;
	        this.queryParams = queryParams;
	        this.fragment = fragment;
	    }
	    RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
	    return RouterStateSnapshot;
	}(tree_1.Tree));
	exports.RouterStateSnapshot = RouterStateSnapshot;
	function serializeNode(node) {
	    var c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(", ") + " } " : '';
	    return "" + node.value + c;
	}
	function advanceActivatedRoute(route) {
	    if (route.snapshot && !collection_1.shallowEqual(route.snapshot.params, route._futureSnapshot.params)) {
	        route.snapshot = route._futureSnapshot;
	        route.url.next(route.snapshot.url);
	        route.params.next(route.snapshot.params);
	    }
	    else {
	        route.snapshot = route._futureSnapshot;
	    }
	}
	exports.advanceActivatedRoute = advanceActivatedRoute;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX3N0YXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JvdXRlcl9zdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxnQ0FBOEIsc0JBQXNCLENBQUMsQ0FBQTtBQUlyRCx1QkFBcUMsVUFBVSxDQUFDLENBQUE7QUFDaEQseUJBQXFELFlBQVksQ0FBQyxDQUFBO0FBQ2xFLDJCQUEyQixvQkFBb0IsQ0FBQyxDQUFBO0FBQ2hELHFCQUE2QixjQUFjLENBQUMsQ0FBQTtBQWtCNUM7SUFBaUMsK0JBQW9CO0lBSW5ELHFCQUNJLElBQThCLEVBQVMsV0FBK0IsRUFDL0QsUUFBNEIsRUFBUyxRQUE2QjtRQUMzRSxrQkFBTSxJQUFJLENBQUMsQ0FBQztRQUY2QixnQkFBVyxHQUFYLFdBQVcsQ0FBb0I7UUFDL0QsYUFBUSxHQUFSLFFBQVEsQ0FBb0I7UUFBUyxhQUFRLEdBQVIsUUFBUSxDQUFxQjtJQUU3RSxDQUFDO0lBRUQsOEJBQVEsR0FBUixjQUFxQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDekQsa0JBQUM7QUFBRCxDQUFDLEFBWEQsQ0FBaUMsV0FBSSxHQVdwQztBQVhZLG1CQUFXLGNBV3ZCLENBQUE7QUFFRCwwQkFBaUMsT0FBZ0IsRUFBRSxhQUFtQjtJQUNwRSxJQUFNLFFBQVEsR0FBRyx3QkFBd0IsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDbEUsSUFBTSxRQUFRLEdBQUcsSUFBSSxpQ0FBZSxDQUFDLENBQUMsSUFBSSw0QkFBaUIsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLElBQU0sV0FBVyxHQUFHLElBQUksaUNBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM1QyxJQUFNLGdCQUFnQixHQUFHLElBQUksaUNBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNqRCxJQUFNLFFBQVEs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UUFDTixLQUFLLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUM7SUFDekMsQ0FBQztBQUNILENBQUM7QUFSZSw2QkFBcUIsd0JBUXBDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudEZhY3RvcnksIFR5cGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3R9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcblxuaW1wb3J0IHtSb3V0ZX0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHtQUklNQVJZX09VVExFVCwgUGFyYW1zfSBmcm9tICcuL3NoYXJlZCc7XG5pbXBvcnQge1VybFBhdGhXaXRoUGFyYW1zLCBVcmxTZWdtZW50LCBVcmxUcmVlfSBmcm9tICcuL3VybF90cmVlJztcbmltcG9ydCB7c2hhbGxvd0VxdWFsfSBmcm9tICcuL3V0aWxzL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHtUcmVlLCBUcmVlTm9kZX0gZnJvbSAnLi91dGlscy90cmVlJztcblxuXG4vKipcbiAqIFRoZSBzdGF0ZSBvZiB0aGUgcm91dGVyLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIGBgYFxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICogICAgIGNvbnN0IHN0YXRlID0gcm91dGVyLnJvdXRlclN0YXRlO1xuICogICAgIGNvbnN0IGlkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSBzdGF0ZS5maXJzdENoaWxkKHN0YXRlLnJvb3QpLnBhcmFtcy5tYXAocCA9PiBwLmlkKTtcbiAqICAgICBjb25zdCBpc0RlYnVnOiBPYnNlcnZhYmxlPHN0cmluZz4gPSBzdGF0ZS5xdWVyeVBhcmFtcy5tYXAocSA9PiBxLmRlYnVnKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3V0ZXJTdGF0ZSBleHRlbmRzIFRyZWU8QWN0aXZhdGVkUm91dGU+IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICByb290OiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZT4sIHB1YmxpYyBxdWVyeVBhcmFtczogT2JzZXJ2YWJsZTxQYXJhbXM+LFxuICAgICAgcHVibGljIGZyYWdtZW50OiBPYnNlcnZhYmxlPHN0cmluZz4sIHB1YmxpYyBzbmFwc2hvdDogUm91dGVyU3RhdGVTbmFwc2hvdCkge1xuICAgIHN1cGVyKHJvb3QpO1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuc25hcHNob3QudG9TdHJpbmcoKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlTdGF0ZSh1cmxUcmVlOiBVcmxUcmVlLCByb290Q29tcG9uZW50OiBUeXBlKTogUm91dGVyU3RhdGUge1xuICBjb25zdCBzbmFwc2hvdCA9IGNyZWF0ZUVtcHR5U3RhdGVTbmFwc2hvdCh1cmxUcmVlLCByb290Q29tcG9uZW50KTtcbiAgY29uc3QgZW1wdHlVcmwgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtuZXcgVXJsUGF0aFdpdGhQYXJhbXMoJycsIHt9KV0pO1xuICBjb25zdCBlbXB0eVBhcmFtcyA9IG5ldyBCZWhhdmlvclN1YmplY3Qoe30pO1xuICBjb25zdCBlbXB0eVF1ZXJ5UGFyYW1zID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7fSk7XG4gIGNvbnN0IGZyYWdtZW50ID0gbmV3IEJlaGF2aW9yU3ViamVjdCgnJyk7XG4gIGNvbnN0IGFjdGl2YXRlZCA9XG4gICAgICBuZXcgQWN0aXZhdGVkUm91dGUoZW1wdHlVcmwsIGVtcHR5UGFyYW1zLCBQUklNQVJZX09VVExFVCwgcm9vdENvbXBvbmVudCwgc25hcHNob3Qucm9vdCk7XG4gIGFjdGl2YXRlZC5zbmFwc2hvdCA9IHNuYXBzaG90LnJvb3Q7XG4gIHJldHVybiBuZXcgUm91dGVyU3RhdGUoXG4gICAgICBuZXcgVHJlZU5vZGU8QWN0aXZhdGVkUm91dGU+KGFjdGl2YXRlZCwgW10pLCBlbXB0eVF1ZXJ5UGFyYW1zLCBmcmFnbWVudCwgc25hcHNob3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbXB0eVN0YXRlU25hcHNob3QodXJsVHJlZTogVXJsVHJlZSwgcm9vdENvbXBvbmVudDogVHlwZSk6IFJvdXRlclN0YXRlU25hcHNob3Qge1xuICBjb25zdCBlbXB0eVBhcmFtcyA9IHt9O1xuICBjb25zdCBlbXB0eVF1ZXJ5UGFyYW1zID0ge307XG4gIGNvbnN0IGZyYWdtZW50ID0gJyc7XG4gIGNvbnN0IGFjdGl2YXRlZCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KFxuICAgICAgW10sIGVtcHR5UGFyYW1zLCBQUklNQVJZX09VVExFVCwgcm9vdENvbXBvbmVudCwgbnVsbCwgdXJsVHJlZS5yb290LCAtMSk7XG4gIHJldHVybiBuZXcgUm91dGVyU3RhdGVTbmFwc2hvdChcbiAgICAgICcnLCBuZXcgVHJlZU5vZGU8QWN0aXZhdGVkUm91dGVTbmFwc2hvdD4oYWN0aXZhdGVkLCBbXSksIGVtcHR5UXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbn1cblxuLyoqXG4gKiBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYSBjb21wb25lbnQgbG9hZGVkIGluIGFuIG91dGxldC4gVGhlIGluZm9ybWF0aW9uIGlzIHByb3ZpZGVkXG4gKiB0aHJvdWdoXG4gKiB0aGUgcGFyYW1zIGFuZCB1cmxTZWdtZW50cyBvYnNlcnZhYmxlcy5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBgYGBcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgY29uc3RydWN0b3Iocm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7XG4gKiAgICAgY29uc3QgaWQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHJvdXRlLnBhcmFtcy5tYXAocCA9PiBwLmlkKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3RpdmF0ZWRSb3V0ZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Z1dHVyZVNuYXBzaG90OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90O1xuICBzbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB1cmw6IE9ic2VydmFibGU8VXJsUGF0aFdpdGhQYXJhbXNbXT4sIHB1YmxpYyBwYXJhbXM6IE9ic2VydmFibGU8UGFyYW1zPixcbiAgICAgIHB1YmxpYyBvdXRsZXQ6IHN0cmluZywgcHVibGljIGNvbXBvbmVudDogVHlwZXxzdHJpbmcsXG4gICAgICBmdXR1cmVTbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCkge1xuICAgIHRoaXMuX2Z1dHVyZVNuYXBzaG90ID0gZnV0dXJlU25hcHNob3Q7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNuYXBzaG90ID8gdGhpcy5zbmFwc2hvdC50b1N0cmluZygpIDogYEZ1dHVyZSgke3RoaXMuX2Z1dHVyZVNuYXBzaG90fSlgO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IGxvYWRlZCBpbiBhbiBvdXRsZXQgYXQgYSBwYXJ0aWN1bGFyIG1vbWVudCBpbiB0aW1lLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIGBgYFxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZTogQWN0aXZhdGVkUm91dGUpIHtcbiAqICAgICBjb25zdCBpZDogc3RyaW5nID0gcm91dGUuc25hcHNob3QucGFyYW1zLmlkO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGl2YXRlZFJvdXRlU25hcHNob3Qge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVzb2x2ZWRDb21wb25lbnRGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PGFueT47XG5cbiAgLyoqIEBpbnRlcm5hbCAqKi9cbiAgX3JvdXRlQ29uZmlnOiBSb3V0ZTtcblxuICAvKiogQGludGVybmFsICoqL1xuICBfdXJsU2VnbWVudDogVXJsU2VnbWVudDtcblxuICBfbGFzdFBhdGhJbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHVybDogVXJsUGF0aFdpdGhQYXJhbXNbXSwgcHVibGljIHBhcmFtczogUGFyYW1zLCBwdWJsaWMgb3V0bGV0OiBzdHJpbmcsXG4gICAgICBwdWJsaWMgY29tcG9uZW50OiBUeXBlfHN0cmluZywgcm91dGVDb25maWc6IFJvdXRlLCB1cmxTZWdtZW50OiBVcmxTZWdtZW50LFxuICAgICAgbGFzdFBhdGhJbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fcm91dGVDb25maWcgPSByb3V0ZUNvbmZpZztcbiAgICB0aGlzLl91cmxTZWdtZW50ID0gdXJsU2VnbWVudDtcbiAgICB0aGlzLl9sYXN0UGF0aEluZGV4ID0gbGFzdFBhdGhJbmRleDtcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwubWFwKHMgPT4gcy50b1N0cmluZygpKS5qb2luKCcvJyk7XG4gICAgY29uc3QgbWF0Y2hlZCA9IHRoaXMuX3JvdXRlQ29uZmlnID8gdGhpcy5fcm91dGVDb25maWcucGF0aCA6ICcnO1xuICAgIHJldHVybiBgUm91dGUodXJsOicke3VybH0nLCBwYXRoOicke21hdGNoZWR9JylgO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIG9mIHRoZSByb3V0ZXIgYXQgYSBwYXJ0aWN1bGFyIG1vbWVudCBpbiB0aW1lLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIGBgYFxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICogICAgIGNvbnN0IHNuYXBzaG90ID0gcm91dGVyLnJvdXRlclN0YXRlLnNuYXBzaG90O1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJvdXRlclN0YXRlU25hcHNob3QgZXh0ZW5kcyBUcmVlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgdXJsOiBzdHJpbmcsIHJvb3Q6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+LCBwdWJsaWMgcXVlcnlQYXJhbXM6IFBhcmFtcyxcbiAgICAgIHB1YmxpYyBmcmFnbWVudDogc3RyaW5nKSB7XG4gICAgc3VwZXIocm9vdCk7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gc2VyaWFsaXplTm9kZSh0aGlzLl9yb290KTsgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG5vZGU6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+KTogc3RyaW5nIHtcbiAgY29uc3QgYyA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCA/IGAgeyAke25vZGUuY2hpbGRyZW4ubWFwKHNlcmlhbGl6ZU5vZGUpLmpvaW4oXCIsIFwiKX0gfSBgIDogJyc7XG4gIHJldHVybiBgJHtub2RlLnZhbHVlfSR7Y31gO1xufVxuXG5cbi8qKlxuICogVGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgdGhlIGFjdGl2YXRlIHJvdXRlIGlzIGNyZWF0ZWQgd2l0aCB0aGUgcmlnaHQgc2V0IG9mIHBhcmFtZXRlcnMuXG4gKiBTbyB3ZSBwdXNoIG5ldyB2YWx1ZXMgaW50byB0aGUgb2JzZXJ2YWJsZXMgb25seSB3aGVuIHRoZXkgYXJlIG5vdCB0aGUgaW5pdGlhbCB2YWx1ZXMuXG4gKiBBbmQgd2UgZGV0ZWN0IHRoYXQgYnkgY2hlY2tpbmcgaWYgdGhlIHNuYXBzaG90IGZpZWxkIGlzIHNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZShyb3V0ZTogQWN0aXZhdGVkUm91dGUpOiB2b2lkIHtcbiAgaWYgKHJvdXRlLnNuYXBzaG90ICYmICFzaGFsbG93RXF1YWwocm91dGUuc25hcHNob3QucGFyYW1zLCByb3V0ZS5fZnV0dXJlU25hcHNob3QucGFyYW1zKSkge1xuICAgIHJvdXRlLnNuYXBzaG90ID0gcm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICAgICg8YW55PnJvdXRlLnVybCkubmV4dChyb3V0ZS5zbmFwc2hvdC51cmwpO1xuICAgICg8YW55PnJvdXRlLnBhcmFtcykubmV4dChyb3V0ZS5zbmFwc2hvdC5wYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLnNuYXBzaG90ID0gcm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICB9XG59Il19

/***/ },
/* 424 */
/***/ function(module, exports) {

	"use strict";
	var Tree = (function () {
	    function Tree(root) {
	        this._root = root;
	    }
	    Object.defineProperty(Tree.prototype, "root", {
	        get: function () { return this._root.value; },
	        enumerable: true,
	        configurable: true
	    });
	    Tree.prototype.parent = function (t) {
	        var p = this.pathFromRoot(t);
	        return p.length > 1 ? p[p.length - 2] : null;
	    };
	    Tree.prototype.children = function (t) {
	        var n = findNode(t, this._root);
	        return n ? n.children.map(function (t) { return t.value; }) : [];
	    };
	    Tree.prototype.firstChild = function (t) {
	        var n = findNode(t, this._root);
	        return n && n.children.length > 0 ? n.children[0].value : null;
	    };
	    Tree.prototype.siblings = function (t) {
	        var p = findPath(t, this._root, []);
	        if (p.length < 2)
	            return [];
	        var c = p[p.length - 2].children.map(function (c) { return c.value; });
	        return c.filter(function (cc) { return cc !== t; });
	    };
	    Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root, []).map(function (s) { return s.value; }); };
	    Tree.prototype.contains = function (tree) { return contains(this._root, tree._root); };
	    return Tree;
	}());
	exports.Tree = Tree;
	function findNode(expected, c) {
	    if (expected === c.value)
	        return c;
	    for (var _i = 0, _a = c.children; _i < _a.length; _i++) {
	        var cc = _a[_i];
	        var r = findNode(expected, cc);
	        if (r)
	            return r;
	    }
	    return null;
	}
	function findPath(expected, c, collected) {
	    collected.push(c);
	    if (expected === c.value)
	        return collected;
	    for (var _i = 0, _a = c.children; _i < _a.length; _i++) {
	        var cc = _a[_i];
	        var cloned = collected.slice(0);
	        var r = findPath(expected, cc, cloned);
	        if (r)
	            return r;
	    }
	    return [];
	}
	function contains(tree, subtree) {
	    if (tree.value !== subtree.value)
	        return false;
	    var _loop_1 = function(subtreeNode) {
	        var s = tree.children.filter(function (child) { return child.value === subtreeNode.value; });
	        if (s.length === 0)
	            return { value: false };
	        if (!contains(s[0], subtreeNode))
	            return { value: false };
	    };
	    for (var _i = 0, _a = subtree.children; _i < _a.length; _i++) {
	        var subtreeNode = _a[_i];
	        var state_1 = _loop_1(subtreeNode);
	        if (typeof state_1 === "object") return state_1.value;
	    }
	    return true;
	}
	var TreeNode = (function () {
	    function TreeNode(value, children) {
	        this.value = value;
	        this.children = children;
	    }
	    TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
	    return TreeNode;
	}());
	exports.TreeNode = TreeNode;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy90cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtJQUlFLGNBQVksSUFBaUI7UUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUFDLENBQUM7SUFFckQsc0JBQUksc0JBQUk7YUFBUixjQUFnQixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUUxQyxxQkFBTSxHQUFOLFVBQU8sQ0FBSTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztJQUMvQyxDQUFDO0lBRUQsdUJBQVEsR0FBUixVQUFTLENBQUk7UUFDWCxJQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLEtBQUssRUFBUCxDQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQUVELHlCQUFVLEdBQVYsVUFBVyxDQUFJO1FBQ2IsSUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2pFLENBQUM7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SyxFQUFqQyxDQUFpQyxDQUFDLENBQUM7UUFDM0UsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7WUFBQyxnQkFBTyxLQUFLLEdBQUM7UUFDakMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQUMsZ0JBQU8sS0FBSyxHQUFDOztJQUhqRCxHQUFHLENBQUMsQ0FBb0IsVUFBZ0IsRUFBaEIsS0FBQSxPQUFPLENBQUMsUUFBUSxFQUFoQixjQUFnQixFQUFoQixJQUFnQixDQUFDO1FBQXBDLElBQUksV0FBVyxTQUFBOzs7S0FJbkI7SUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEO0lBQ0Usa0JBQW1CLEtBQVEsRUFBUyxRQUF1QjtRQUF4QyxVQUFLLEdBQUwsS0FBSyxDQUFHO1FBQVMsYUFBUSxHQUFSLFFBQVEsQ0FBZTtJQUFHLENBQUM7SUFFL0QsMkJBQVEsR0FBUixjQUFxQixNQUFNLENBQUMsY0FBWSxJQUFJLENBQUMsS0FBSyxNQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzFELGVBQUM7QUFBRCxDQUFDLEFBSkQsSUFJQztBQUpZLGdCQUFRLFdBSXBCLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgVHJlZTxUPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3Jvb3Q6IFRyZWVOb2RlPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKHJvb3Q6IFRyZWVOb2RlPFQ+KSB7IHRoaXMuX3Jvb3QgPSByb290OyB9XG5cbiAgZ2V0IHJvb3QoKTogVCB7IHJldHVybiB0aGlzLl9yb290LnZhbHVlOyB9XG5cbiAgcGFyZW50KHQ6IFQpOiBUIHtcbiAgICBjb25zdCBwID0gdGhpcy5wYXRoRnJvbVJvb3QodCk7XG4gICAgcmV0dXJuIHAubGVuZ3RoID4gMSA/IHBbcC5sZW5ndGggLSAyXSA6IG51bGw7XG4gIH1cblxuICBjaGlsZHJlbih0OiBUKTogVFtdIHtcbiAgICBjb25zdCBuID0gZmluZE5vZGUodCwgdGhpcy5fcm9vdCk7XG4gICAgcmV0dXJuIG4gPyBuLmNoaWxkcmVuLm1hcCh0ID0+IHQudmFsdWUpIDogW107XG4gIH1cblxuICBmaXJzdENoaWxkKHQ6IFQpOiBUIHtcbiAgICBjb25zdCBuID0gZmluZE5vZGUodCwgdGhpcy5fcm9vdCk7XG4gICAgcmV0dXJuIG4gJiYgbi5jaGlsZHJlbi5sZW5ndGggPiAwID8gbi5jaGlsZHJlblswXS52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBzaWJsaW5ncyh0OiBUKTogVFtdIHtcbiAgICBjb25zdCBwID0gZmluZFBhdGgodCwgdGhpcy5fcm9vdCwgW10pO1xuICAgIGlmIChwLmxlbmd0aCA8IDIpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGMgPSBwW3AubGVuZ3RoIC0gMl0uY2hpbGRyZW4ubWFwKGMgPT4gYy52YWx1ZSk7XG4gICAgcmV0dXJuIGMuZmlsdGVyKGNjID0+IGNjICE9PSB0KTtcbiAgfVxuXG4gIHBhdGhGcm9tUm9vdCh0OiBUKTogVFtdIHsgcmV0dXJuIGZpbmRQYXRoKHQsIHRoaXMuX3Jvb3QsIFtdKS5tYXAocyA9PiBzLnZhbHVlKTsgfVxuXG4gIGNvbnRhaW5zKHRyZWU6IFRyZWU8VD4pOiBib29sZWFuIHsgcmV0dXJuIGNvbnRhaW5zKHRoaXMuX3Jvb3QsIHRyZWUuX3Jvb3QpOyB9XG59XG5cbmZ1bmN0aW9uIGZpbmROb2RlPFQ+KGV4cGVjdGVkOiBULCBjOiBUcmVlTm9kZTxUPik6IFRyZWVOb2RlPFQ+IHtcbiAgaWYgKGV4cGVjdGVkID09PSBjLnZhbHVlKSByZXR1cm4gYztcbiAgZm9yIChsZXQgY2Mgb2YgYy5jaGlsZHJlbikge1xuICAgIGNvbnN0IHIgPSBmaW5kTm9kZShleHBlY3RlZCwgY2MpO1xuICAgIGlmIChyKSByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZFBhdGg8VD4oZXhwZWN0ZWQ6IFQsIGM6IFRyZWVOb2RlPFQ+LCBjb2xsZWN0ZWQ6IFRyZWVOb2RlPFQ+W10pOiBUcmVlTm9kZTxUPltdIHtcbiAgY29sbGVjdGVkLnB1c2goYyk7XG4gIGlmIChleHBlY3RlZCA9PT0gYy52YWx1ZSkgcmV0dXJuIGNvbGxlY3RlZDtcblxuICBmb3IgKGxldCBjYyBvZiBjLmNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY29sbGVjdGVkLnNsaWNlKDApO1xuICAgIGNvbnN0IHIgPSBmaW5kUGF0aChleHBlY3RlZCwgY2MsIGNsb25lZCk7XG4gICAgaWYgKHIpIHJldHVybiByO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBjb250YWluczxUPih0cmVlOiBUcmVlTm9kZTxUPiwgc3VidHJlZTogVHJlZU5vZGU8VD4pOiBib29sZWFuIHtcbiAgaWYgKHRyZWUudmFsdWUgIT09IHN1YnRyZWUudmFsdWUpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBzdWJ0cmVlTm9kZSBvZiBzdWJ0cmVlLmNoaWxkcmVuKSB7XG4gICAgY29uc3QgcyA9IHRyZWUuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLnZhbHVlID09PSBzdWJ0cmVlTm9kZS52YWx1ZSk7XG4gICAgaWYgKHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjb250YWlucyhzWzBdLCBzdWJ0cmVlTm9kZSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgY2xhc3MgVHJlZU5vZGU8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFQsIHB1YmxpYyBjaGlsZHJlbjogVHJlZU5vZGU8VD5bXSkge31cblxuICB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gYFRyZWVOb2RlKCR7dGhpcy52YWx1ZX0pYDsgfVxufSJdfQ==

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var shared_1 = __webpack_require__(416);
	var url_tree_1 = __webpack_require__(417);
	var collection_1 = __webpack_require__(419);
	function createUrlTree(route, urlTree, commands, queryParams, fragment) {
	    if (commands.length === 0) {
	        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
	    }
	    var normalizedCommands = normalizeCommands(commands);
	    if (navigateToRoot(normalizedCommands)) {
	        return tree(urlTree.root, new url_tree_1.UrlSegment([], {}), urlTree, queryParams, fragment);
	    }
	    var startingPosition = findStartingPosition(normalizedCommands, urlTree, route);
	    var segment = startingPosition.processChildren ?
	        updateSegmentChildren(startingPosition.segment, startingPosition.index, normalizedCommands.commands) :
	        updateSegment(startingPosition.segment, startingPosition.index, normalizedCommands.commands);
	    return tree(startingPosition.segment, segment, urlTree, queryParams, fragment);
	}
	exports.createUrlTree = createUrlTree;
	function tree(oldSegment, newSegment, urlTree, queryParams, fragment) {
	    var q = queryParams ? stringify(queryParams) : urlTree.queryParams;
	    var f = fragment ? fragment : urlTree.fragment;
	    if (urlTree.root === oldSegment) {
	        return new url_tree_1.UrlTree(newSegment, q, f);
	    }
	    else {
	        return new url_tree_1.UrlTree(replaceSegment(urlTree.root, oldSegment, newSegment), q, f);
	    }
	}
	function replaceSegment(current, oldSegment, newSegment) {
	    var children = {};
	    collection_1.forEach(current.children, function (c, outletName) {
	        if (c === oldSegment) {
	            children[outletName] = newSegment;
	        }
	        else {
	            children[outletName] = replaceSegment(c, oldSegment, newSegment);
	        }
	    });
	    return new url_tree_1.UrlSegment(current.pathsWithParams, children);
	}
	function navigateToRoot(normalizedChange) {
	    return normalizedChange.isAbsolute && normalizedChange.commands.length === 1 &&
	        normalizedChange.commands[0] == '/';
	}
	var NormalizedNavigationCommands = (function () {
	    function NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, commands) {
	        this.isAbsolute = isAbsolute;
	        this.numberOfDoubleDots = numberOfDoubleDots;
	        this.commands = commands;
	    }
	    return NormalizedNavigationCommands;
	}());
	function normalizeCommands(commands) {
	    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] == '/') {
	        return new NormalizedNavigationCommands(true, 0, commands);
	    }
	    var numberOfDoubleDots = 0;
	    var isAbsolute = false;
	    var res = [];
	    for (var i = 0; i < commands.length; ++i) {
	        var c = commands[i];
	        if (!(typeof c === 'string')) {
	            res.push(c);
	            continue;
	        }
	        var parts = c.split('/');
	        for (var j = 0; j < parts.length; ++j) {
	            var cc = parts[j];
	            if (i == 0) {
	                if (j == 0 && cc == '.') {
	                }
	                else if (j == 0 && cc == '') {
	                    isAbsolute = true;
	                }
	                else if (cc == '..') {
	                    numberOfDoubleDots++;
	                }
	                else if (cc != '') {
	                    res.push(cc);
	                }
	            }
	            else {
	                if (cc != '') {
	                    res.push(cc);
	                }
	            }
	        }
	    }
	    return new NormalizedNavigationCommands(isAbsolute, numberOfDoubleDots, res);
	}
	var Position = (function () {
	    function Position(segment, processChildren, index) {
	        this.segment = segment;
	        this.processChildren = processChildren;
	        this.index = index;
	    }
	    return Position;
	}());
	function findStartingPosition(normalizedChange, urlTree, route) {
	    if (normalizedChange.isAbsolute) {
	        return new Position(urlTree.root, true, 0);
	    }
	    else if (route.snapshot._lastPathIndex === -1) {
	        return new Position(route.snapshot._urlSegment, true, 0);
	    }
	    else if (route.snapshot._lastPathIndex + 1 - normalizedChange.numberOfDoubleDots >= 0) {
	        return new Position(route.snapshot._urlSegment, false, route.snapshot._lastPathIndex + 1 - normalizedChange.numberOfDoubleDots);
	    }
	    else {
	        throw new Error('Invalid number of \'../\'');
	    }
	}
	function getPath(command) {
	    if (!(typeof command === 'string'))
	        return command.toString();
	    var parts = command.toString().split(':');
	    return parts.length > 1 ? parts[1] : command;
	}
	function getOutlet(commands) {
	    if (!(typeof commands[0] === 'string'))
	        return shared_1.PRIMARY_OUTLET;
	    var parts = commands[0].toString().split(':');
	    return parts.length > 1 ? parts[0] : shared_1.PRIMARY_OUTLET;
	}
	function updateSegment(segment, startIndex, commands) {
	    if (!segment) {
	        segment = new url_tree_1.UrlSegment([], {});
	    }
	    if (segment.pathsWithParams.length === 0 && Object.keys(segment.children).length > 0) {
	        return updateSegmentChildren(segment, startIndex, commands);
	    }
	    var m = prefixedWith(segment, startIndex, commands);
	    var slicedCommands = commands.slice(m.lastIndex);
	    if (m.match && slicedCommands.length === 0) {
	        return new url_tree_1.UrlSegment(segment.pathsWithParams, {});
	    }
	    else if (m.match && Object.keys(segment.children).length === 0) {
	        return createNewSegment(segment, startIndex, commands);
	    }
	    else if (m.match) {
	        return updateSegmentChildren(segment, 0, slicedCommands);
	    }
	    else {
	        return createNewSegment(segment, startIndex, commands);
	    }
	}
	function updateSegmentChildren(segment, startIndex, commands) {
	    if (commands.length === 0) {
	        return new url_tree_1.UrlSegment(segment.pathsWithParams, {});
	    }
	    else {
	        var outlet_1 = getOutlet(commands);
	        var children_1 = {};
	        children_1[outlet_1] = updateSegment(segment.children[outlet_1], startIndex, commands);
	        collection_1.forEach(segment.children, function (child, childOutlet) {
	            if (childOutlet !== outlet_1) {
	                children_1[childOutlet] = child;
	            }
	        });
	        return new url_tree_1.UrlSegment(segment.pathsWithParams, children_1);
	    }
	}
	function prefixedWith(segment, startIndex, commands) {
	    var currentCommandIndex = 0;
	    var currentPathIndex = startIndex;
	    var noMatch = { match: false, lastIndex: 0 };
	    while (currentPathIndex < segment.pathsWithParams.length) {
	        if (currentCommandIndex >= commands.length)
	            return noMatch;
	        var path = segment.pathsWithParams[currentPathIndex];
	        var curr = getPath(commands[currentCommandIndex]);
	        var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
	        if (curr && next && (typeof next === 'object')) {
	            if (!compare(curr, next, path))
	                return noMatch;
	            currentCommandIndex += 2;
	        }
	        else {
	            if (!compare(curr, {}, path))
	                return noMatch;
	            currentCommandIndex++;
	        }
	        currentPathIndex++;
	    }
	    return { match: true, lastIndex: currentCommandIndex };
	}
	function createNewSegment(segment, startIndex, commands) {
	    var paths = segment.pathsWithParams.slice(0, startIndex);
	    var i = 0;
	    while (i < commands.length) {
	        if (i === 0 && (typeof commands[0] === 'object')) {
	            var p = segment.pathsWithParams[startIndex];
	            paths.push(new url_tree_1.UrlPathWithParams(p.path, commands[0]));
	            i++;
	            continue;
	        }
	        var curr = getPath(commands[i]);
	        var next = (i < commands.length - 1) ? commands[i + 1] : null;
	        if (curr && next && (typeof next === 'object')) {
	            paths.push(new url_tree_1.UrlPathWithParams(curr, stringify(next)));
	            i += 2;
	        }
	        else {
	            paths.push(new url_tree_1.UrlPathWithParams(curr, {}));
	            i++;
	        }
	    }
	    return new url_tree_1.UrlSegment(paths, {});
	}
	function stringify(params) {
	    var res = {};
	    collection_1.forEach(params, function (v, k) { return res[k] = "" + v; });
	    return res;
	}
	function compare(path, params, pathWithParams) {
	    return path == pathWithParams.path && collection_1.shallowEqual(params, pathWithParams.parameters);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlX3VybF90cmVlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NyZWF0ZV91cmxfdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsdUJBQXFDLFVBQVUsQ0FBQyxDQUFBO0FBQ2hELHlCQUFxRCxZQUFZLENBQUMsQ0FBQTtBQUNsRSwyQkFBb0Msb0JBQW9CLENBQUMsQ0FBQTtBQUV6RCx1QkFDSSxLQUFxQixFQUFFLE9BQWdCLEVBQUUsUUFBZSxFQUFFLFdBQW1CLEVBQzdFLFFBQWdCO0lBQ2xCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRCxJQUFNLGtCQUFrQixHQUFHLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZELEVBQUUsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxxQkFBVSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3BGLENBQUM7SUFFRCxJQUFNLGdCQUFnQixHQUFHLG9CQUFvQixDQUFDLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNsRixJQUFNLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxlQUFlO1FBQzVDLHFCQUFxQixDQUNqQixnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLGtCQUFrQixDQUFDLFFBQVEsQ0FBQztRQUNsRixhQUFhLENBQUMsZ0JBQWdCLENB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QkFBaUIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM1QyxDQUFDLEVBQUUsQ0FBQztRQUNOLENBQUM7SUFDSCxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUkscUJBQVUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUVELG1CQUFtQixNQUE0QjtJQUM3QyxJQUFNLEdBQUcsR0FBNEIsRUFBRSxDQUFDO0lBQ3hDLG9CQUFPLENBQUMsTUFBTSxFQUFFLFVBQUMsQ0FBTSxFQUFFLENBQVMsSUFBSyxPQUFBLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFHLENBQUcsRUFBZixDQUFlLENBQUMsQ0FBQztJQUN4RCxNQUFNLENBQUMsR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELGlCQUNJLElBQVksRUFBRSxNQUE0QixFQUFFLGNBQWlDO0lBQy9FLE1BQU0sQ0FBQyxJQUFJLElBQUksY0FBYyxDQUFDLElBQUksSUFBSSx5QkFBWSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDeEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QWN0aXZhdGVkUm91dGV9IGZyb20gJy4vcm91dGVyX3N0YXRlJztcbmltcG9ydCB7UFJJTUFSWV9PVVRMRVQsIFBhcmFtc30gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHtVcmxQYXRoV2l0aFBhcmFtcywgVXJsU2VnbWVudCwgVXJsVHJlZX0gZnJvbSAnLi91cmxfdHJlZSc7XG5pbXBvcnQge2ZvckVhY2gsIHNoYWxsb3dFcXVhbH0gZnJvbSAnLi91dGlscy9jb2xsZWN0aW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVybFRyZWUoXG4gICAgcm91dGU6IEFjdGl2YXRlZFJvdXRlLCB1cmxUcmVlOiBVcmxUcmVlLCBjb21tYW5kczogYW55W10sIHF1ZXJ5UGFyYW1zOiBQYXJhbXMsXG4gICAgZnJhZ21lbnQ6IHN0cmluZyk6IFVybFRyZWUge1xuICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRyZWUodXJsVHJlZS5yb290LCB1cmxUcmVlLnJvb3QsIHVybFRyZWUsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCk7XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkQ29tbWFuZHMgPSBub3JtYWxpemVDb21tYW5kcyhjb21tYW5kcyk7XG4gIGlmIChuYXZpZ2F0ZVRvUm9vdChub3JtYWxpemVkQ29tbWFuZHMpKSB7XG4gICAgcmV0dXJuIHRyZWUodXJsVHJlZS5yb290LCBuZXcgVXJsU2VnbWVudChbXSwge30pLCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRpbmdQb3NpdGlvbiA9IGZpbmRTdGFydGluZ1Bvc2l0aW9uKG5vcm1hbGl6ZWRDb21tYW5kcywgdXJsVHJlZSwgcm91dGUpO1xuICBjb25zdCBzZWdtZW50ID0gc3RhcnRpbmdQb3NpdGlvbi5wcm9jZXNzQ2hpbGRyZW4gP1xuICAgICAgdXBkYXRlU2VnbWVudENoaWxkcmVuKFxuICAgICAgICAgIHN0YXJ0aW5nUG9zaXRpb24uc2VnbWVudCwgc3RhcnRpbmdQb3NpdGlvbi5pbmRleCwgbm9ybWFsaXplZENvbW1hbmRzLmNvbW1hbmRzKSA6XG4gICAgICB1cGRhdGVTZWdtZW50KHN0YXJ0aW5nUG9zaXRpb24uc2VnbWVudCwgc3RhcnRpbmdQb3NpdGlvbi5pbmRleCwgbm9ybWFsaXplZENvbW1hbmRzLmNvbW1hbmRzKTtcbiAgcmV0dXJuIHRyZWUoc3RhcnRpbmdQb3NpdGlvbi5zZWdtZW50LCBzZWdtZW50LCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xufVxuXG5mdW5jdGlvbiB0cmVlKFxuICAgIG9sZFNlZ21lbnQ6IFVybFNlZ21lbnQsIG5ld1NlZ21lbnQ6IFVybFNlZ21lbnQsIHVybFRyZWU6IFVybFRyZWUsIHF1ZXJ5UGFyYW1zOiBQYXJhbXMsXG4gICAgZnJhZ21lbnQ6IHN0cmluZyk6IFVybFRyZWUge1xuICBjb25zdCBxID0gcXVlcnlQYXJhbXMgPyBzdHJpbmdpZnkocXVlcnlQYXJhbXMpIDogdXJsVHJlZS5xdWVyeVBhcmFtcztcbiAgY29uc3QgZiA9IGZyYWdtZW50ID8gZnJhZ21lbnQgOiB1cmxUcmVlLmZyYWdtZW50O1xuXG4gIGlmICh1cmxUcmVlLnJvb3QgPT09IG9sZFNlZ21lbnQpIHtcbiAgICByZXR1cm4gbmV3IFVybFRyZWUobmV3U2VnbWVudCwgcSwgZik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVcmxUcmVlKHJlcGxhY2VTZWdtZW50KHVybFRyZWUucm9vdCwgb2xkU2VnbWVudCwgbmV3U2VnbWVudCksIHEsIGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTZWdtZW50KFxuICAgIGN1cnJlbnQ6IFVybFNlZ21lbnQsIG9sZFNlZ21lbnQ6IFVybFNlZ21lbnQsIG5ld1NlZ21lbnQ6IFVybFNlZ21lbnQpOiBVcmxTZWdtZW50IHtcbiAgY29uc3QgY2hpbGRyZW46IHtba2V5OiBzdHJpbmddOiBVcmxTZWdtZW50fSA9IHt9O1xuICBmb3JFYWNoKGN1cnJlbnQuY2hpbGRyZW4sIChjOiBVcmxTZWdtZW50LCBvdXRsZXROYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoYyA9PT0gb2xkU2VnbWVudCkge1xuICAgICAgY2hpbGRyZW5bb3V0bGV0TmFtZV0gPSBuZXdTZWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbltvdXRsZXROYW1lXSA9IHJlcGxhY2VTZWdtZW50KGMsIG9sZFNlZ21lbnQsIG5ld1NlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgVXJsU2VnbWVudChjdXJyZW50LnBhdGhzV2l0aFBhcmFtcywgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBuYXZpZ2F0ZVRvUm9vdChub3JtYWxpemVkQ2hhbmdlOiBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzKTogYm9vbGVhbiB7XG4gIHJldHVybiBub3JtYWxpemVkQ2hhbmdlLmlzQWJzb2x1dGUgJiYgbm9ybWFsaXplZENoYW5nZS5jb21tYW5kcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vcm1hbGl6ZWRDaGFuZ2UuY29tbWFuZHNbMF0gPT0gJy8nO1xufVxuXG5jbGFzcyBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgaXNBYnNvbHV0ZTogYm9vbGVhbiwgcHVibGljIG51bWJlck9mRG91YmxlRG90czogbnVtYmVyLCBwdWJsaWMgY29tbWFuZHM6IGFueVtdKSB7fVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21tYW5kcyhjb21tYW5kczogYW55W10pOiBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzIHtcbiAgaWYgKCh0eXBlb2YgY29tbWFuZHNbMF0gPT09ICdzdHJpbmcnKSAmJiBjb21tYW5kcy5sZW5ndGggPT09IDEgJiYgY29tbWFuZHNbMF0gPT0gJy8nKSB7XG4gICAgcmV0dXJuIG5ldyBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzKHRydWUsIDAsIGNvbW1hbmRzKTtcbiAgfVxuXG4gIGxldCBudW1iZXJPZkRvdWJsZURvdHMgPSAwO1xuICBsZXQgaXNBYnNvbHV0ZSA9IGZhbHNlO1xuICBjb25zdCByZXM6IGFueVtdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGMgPSBjb21tYW5kc1tpXTtcblxuICAgIGlmICghKHR5cGVvZiBjID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBjLnNwbGl0KCcvJyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgbGV0IGNjID0gcGFydHNbal07XG5cbiAgICAgIC8vIGZpcnN0IGV4cCBpcyB0cmVhdGVkIGluIGEgc3BlY2lhbCB3YXlcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgaWYgKGogPT0gMCAmJiBjYyA9PSAnLicpIHsgIC8vICAnLi9hJ1xuICAgICAgICAgIC8vIHNraXAgaXRcbiAgICAgICAgfSBlbHNlIGlmIChqID09IDAgJiYgY2MgPT0gJycpIHsgIC8vICAnL2EnXG4gICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2MgPT0gJy4uJykgeyAgLy8gICcuLi9hJ1xuICAgICAgICAgIG51bWJlck9mRG91YmxlRG90cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNjICE9ICcnKSB7XG4gICAgICAgICAgcmVzLnB1c2goY2MpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYyAhPSAnJykge1xuICAgICAgICAgIHJlcy5wdXNoKGNjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgTm9ybWFsaXplZE5hdmlnYXRpb25Db21tYW5kcyhpc0Fic29sdXRlLCBudW1iZXJPZkRvdWJsZURvdHMsIHJlcyk7XG59XG5cbmNsYXNzIFBvc2l0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIHNlZ21lbnQ6IFVybFNlZ21lbnQsIHB1YmxpYyBwcm9jZXNzQ2hpbGRyZW46IGJvb2xlYW4sIHB1YmxpYyBpbmRleDogbnVtYmVyKSB7fVxufVxuXG5mdW5jdGlvbiBmaW5kU3RhcnRpbmdQb3NpdGlvbihcbiAgICBub3JtYWxpemVkQ2hhbmdlOiBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzLCB1cmxUcmVlOiBVcmxUcmVlLFxuICAgIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSk6IFBvc2l0aW9uIHtcbiAgaWYgKG5vcm1hbGl6ZWRDaGFuZ2UuaXNBYnNvbHV0ZSkge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odXJsVHJlZS5yb290LCB0cnVlLCAwKTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5zbmFwc2hvdC5fbGFzdFBhdGhJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJvdXRlLnNuYXBzaG90Ll91cmxTZWdtZW50LCB0cnVlLCAwKTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5zbmFwc2hvdC5fbGFzdFBhdGhJbmRleCArIDEgLSBub3JtYWxpemVkQ2hhbmdlLm51bWJlck9mRG91YmxlRG90cyA+PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbihcbiAgICAgICAgcm91dGUuc25hcHNob3QuX3VybFNlZ21lbnQsIGZhbHNlLFxuICAgICAgICByb3V0ZS5zbmFwc2hvdC5fbGFzdFBhdGhJbmRleCArIDEgLSBub3JtYWxpemVkQ2hhbmdlLm51bWJlck9mRG91YmxlRG90cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBcXCcuLi9cXCcnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoKGNvbW1hbmQ6IGFueSk6IGFueSB7XG4gIGlmICghKHR5cGVvZiBjb21tYW5kID09PSAnc3RyaW5nJykpIHJldHVybiBjb21tYW5kLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHBhcnRzID0gY29tbWFuZC50b1N0cmluZygpLnNwbGl0KCc6Jyk7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0gOiBjb21tYW5kO1xufVxuXG5mdW5jdGlvbiBnZXRPdXRsZXQoY29tbWFuZHM6IGFueVtdKTogc3RyaW5nIHtcbiAgaWYgKCEodHlwZW9mIGNvbW1hbmRzWzBdID09PSAnc3RyaW5nJykpIHJldHVybiBQUklNQVJZX09VVExFVDtcbiAgY29uc3QgcGFydHMgPSBjb21tYW5kc1swXS50b1N0cmluZygpLnNwbGl0KCc6Jyk7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMF0gOiBQUklNQVJZX09VVExFVDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2VnbWVudChzZWdtZW50OiBVcmxTZWdtZW50LCBzdGFydEluZGV4OiBudW1iZXIsIGNvbW1hbmRzOiBhbnlbXSk6IFVybFNlZ21lbnQge1xuICBpZiAoIXNlZ21lbnQpIHtcbiAgICBzZWdtZW50ID0gbmV3IFVybFNlZ21lbnQoW10sIHt9KTtcbiAgfVxuICBpZiAoc2VnbWVudC5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKHNlZ21lbnQuY2hpbGRyZW4pLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdXBkYXRlU2VnbWVudENoaWxkcmVuKHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKTtcbiAgfVxuICBjb25zdCBtID0gcHJlZml4ZWRXaXRoKHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKTtcbiAgY29uc3Qgc2xpY2VkQ29tbWFuZHMgPSBjb21tYW5kcy5zbGljZShtLmxhc3RJbmRleCk7XG5cbiAgaWYgKG0ubWF0Y2ggJiYgc2xpY2VkQ29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLCB7fSk7XG4gIH0gZWxzZSBpZiAobS5tYXRjaCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY3JlYXRlTmV3U2VnbWVudChzZWdtZW50LCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gIH0gZWxzZSBpZiAobS5tYXRjaCkge1xuICAgIHJldHVybiB1cGRhdGVTZWdtZW50Q2hpbGRyZW4oc2VnbWVudCwgMCwgc2xpY2VkQ29tbWFuZHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVOZXdTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTZWdtZW50Q2hpbGRyZW4oXG4gICAgc2VnbWVudDogVXJsU2VnbWVudCwgc3RhcnRJbmRleDogbnVtYmVyLCBjb21tYW5kczogYW55W10pOiBVcmxTZWdtZW50IHtcbiAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgVXJsU2VnbWVudChzZWdtZW50LnBhdGhzV2l0aFBhcmFtcywge30pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG91dGxldCA9IGdldE91dGxldChjb21tYW5kcyk7XG4gICAgY29uc3QgY2hpbGRyZW46IHtba2V5OiBzdHJpbmddOiBVcmxTZWdtZW50fSA9IHt9O1xuICAgIGNoaWxkcmVuW291dGxldF0gPSB1cGRhdGVTZWdtZW50KHNlZ21lbnQuY2hpbGRyZW5bb3V0bGV0XSwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgIGZvckVhY2goc2VnbWVudC5jaGlsZHJlbiwgKGNoaWxkOiBVcmxTZWdtZW50LCBjaGlsZE91dGxldDogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoY2hpbGRPdXRsZXQgIT09IG91dGxldCkge1xuICAgICAgICBjaGlsZHJlbltjaGlsZE91dGxldF0gPSBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFVybFNlZ21lbnQoc2VnbWVudC5wYXRoc1dpdGhQYXJhbXMsIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVmaXhlZFdpdGgoc2VnbWVudDogVXJsU2VnbWVudCwgc3RhcnRJbmRleDogbnVtYmVyLCBjb21tYW5kczogYW55W10pIHtcbiAgbGV0IGN1cnJlbnRDb21tYW5kSW5kZXggPSAwO1xuICBsZXQgY3VycmVudFBhdGhJbmRleCA9IHN0YXJ0SW5kZXg7XG5cbiAgY29uc3Qgbm9NYXRjaCA9IHttYXRjaDogZmFsc2UsIGxhc3RJbmRleDogMH07XG4gIHdoaWxlIChjdXJyZW50UGF0aEluZGV4IDwgc2VnbWVudC5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoKSB7XG4gICAgaWYgKGN1cnJlbnRDb21tYW5kSW5kZXggPj0gY29tbWFuZHMubGVuZ3RoKSByZXR1cm4gbm9NYXRjaDtcbiAgICBjb25zdCBwYXRoID0gc2VnbWVudC5wYXRoc1dpdGhQYXJhbXNbY3VycmVudFBhdGhJbmRleF07XG4gICAgY29uc3QgY3VyciA9IGdldFBhdGgoY29tbWFuZHNbY3VycmVudENvbW1hbmRJbmRleF0pO1xuICAgIGNvbnN0IG5leHQgPVxuICAgICAgICBjdXJyZW50Q29tbWFuZEluZGV4IDwgY29tbWFuZHMubGVuZ3RoIC0gMSA/IGNvbW1hbmRzW2N1cnJlbnRDb21tYW5kSW5kZXggKyAxXSA6IG51bGw7XG5cbiAgICBpZiAoY3VyciAmJiBuZXh0ICYmICh0eXBlb2YgbmV4dCA9PT0gJ29iamVjdCcpKSB7XG4gICAgICBpZiAoIWNvbXBhcmUoY3VyciwgbmV4dCwgcGF0aCkpIHJldHVybiBub01hdGNoO1xuICAgICAgY3VycmVudENvbW1hbmRJbmRleCArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNvbXBhcmUoY3Vyciwge30sIHBhdGgpKSByZXR1cm4gbm9NYXRjaDtcbiAgICAgIGN1cnJlbnRDb21tYW5kSW5kZXgrKztcbiAgICB9XG4gICAgY3VycmVudFBhdGhJbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHttYXRjaDogdHJ1ZSwgbGFzdEluZGV4OiBjdXJyZW50Q29tbWFuZEluZGV4fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTmV3U2VnbWVudChzZWdtZW50OiBVcmxTZWdtZW50LCBzdGFydEluZGV4OiBudW1iZXIsIGNvbW1hbmRzOiBhbnlbXSk6IFVybFNlZ21lbnQge1xuICBjb25zdCBwYXRocyA9IHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLnNsaWNlKDAsIHN0YXJ0SW5kZXgpO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgd2Ugc3RhcnQgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCwgd2UgbmVlZCB0byByZXVzZSB0aGUgcGF0aCBwYXJ0IGZyb20gdGhlIHNlZ21lbnRcbiAgICBpZiAoaSA9PT0gMCAmJiAodHlwZW9mIGNvbW1hbmRzWzBdID09PSAnb2JqZWN0JykpIHtcbiAgICAgIGNvbnN0IHAgPSBzZWdtZW50LnBhdGhzV2l0aFBhcmFtc1tzdGFydEluZGV4XTtcbiAgICAgIHBhdGhzLnB1c2gobmV3IFVybFBhdGhXaXRoUGFyYW1zKHAucGF0aCwgY29tbWFuZHNbMF0pKTtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnIgPSBnZXRQYXRoKGNvbW1hbmRzW2ldKTtcbiAgICBjb25zdCBuZXh0ID0gKGkgPCBjb21tYW5kcy5sZW5ndGggLSAxKSA/IGNvbW1hbmRzW2kgKyAxXSA6IG51bGw7XG4gICAgaWYgKGN1cnIgJiYgbmV4dCAmJiAodHlwZW9mIG5leHQgPT09ICdvYmplY3QnKSkge1xuICAgICAgcGF0aHMucHVzaChuZXcgVXJsUGF0aFdpdGhQYXJhbXMoY3Vyciwgc3RyaW5naWZ5KG5leHQpKSk7XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzLnB1c2gobmV3IFVybFBhdGhXaXRoUGFyYW1zKGN1cnIsIHt9KSk7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVXJsU2VnbWVudChwYXRocywge30pO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkocGFyYW1zOiB7W2tleTogc3RyaW5nXTogYW55fSk6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgY29uc3QgcmVzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICBmb3JFYWNoKHBhcmFtcywgKHY6IGFueSwgazogc3RyaW5nKSA9PiByZXNba10gPSBgJHt2fWApO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlKFxuICAgIHBhdGg6IHN0cmluZywgcGFyYW1zOiB7W2tleTogc3RyaW5nXTogYW55fSwgcGF0aFdpdGhQYXJhbXM6IFVybFBhdGhXaXRoUGFyYW1zKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXRoID09IHBhdGhXaXRoUGFyYW1zLnBhdGggJiYgc2hhbGxvd0VxdWFsKHBhcmFtcywgcGF0aFdpdGhQYXJhbXMucGFyYW1ldGVycyk7XG59Il19

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var of_1 = __webpack_require__(354);
	var router_state_1 = __webpack_require__(423);
	var shared_1 = __webpack_require__(416);
	var url_tree_1 = __webpack_require__(417);
	var collection_1 = __webpack_require__(419);
	var tree_1 = __webpack_require__(424);
	var NoMatch = (function () {
	    function NoMatch(segment) {
	        if (segment === void 0) { segment = null; }
	        this.segment = segment;
	    }
	    return NoMatch;
	}());
	function recognize(rootComponentType, config, urlTree, url) {
	    try {
	        var children = processSegment(config, urlTree.root, shared_1.PRIMARY_OUTLET);
	        var root = new router_state_1.ActivatedRouteSnapshot([], {}, shared_1.PRIMARY_OUTLET, rootComponentType, null, urlTree.root, -1);
	        var rootNode = new tree_1.TreeNode(root, children);
	        return of_1.of(new router_state_1.RouterStateSnapshot(url, rootNode, urlTree.queryParams, urlTree.fragment));
	    }
	    catch (e) {
	        if (e instanceof NoMatch) {
	            return new Observable_1.Observable(function (obs) {
	                return obs.error(new Error("Cannot match any routes: '" + e.segment + "'"));
	            });
	        }
	        else {
	            return new Observable_1.Observable(function (obs) { return obs.error(e); });
	        }
	    }
	}
	exports.recognize = recognize;
	function processSegment(config, segment, outlet) {
	    if (segment.pathsWithParams.length === 0 && Object.keys(segment.children).length > 0) {
	        return processSegmentChildren(config, segment);
	    }
	    else {
	        return [processPathsWithParams(config, segment, 0, segment.pathsWithParams, outlet)];
	    }
	}
	function processSegmentChildren(config, segment) {
	    var children = url_tree_1.mapChildrenIntoArray(segment, function (child, childOutlet) { return processSegment(config, child, childOutlet); });
	    checkOutletNameUniqueness(children);
	    sortActivatedRouteSnapshots(children);
	    return children;
	}
	function sortActivatedRouteSnapshots(nodes) {
	    nodes.sort(function (a, b) {
	        if (a.value.outlet === shared_1.PRIMARY_OUTLET)
	            return -1;
	        if (b.value.outlet === shared_1.PRIMARY_OUTLET)
	            return 1;
	        return a.value.outlet.localeCompare(b.value.outlet);
	    });
	}
	function processPathsWithParams(config, segment, pathIndex, paths, outlet) {
	    for (var _i = 0, config_1 = config; _i < config_1.length; _i++) {
	        var r = config_1[_i];
	        try {
	            return processPathsWithParamsAgainstRoute(r, segment, pathIndex, paths, outlet);
	        }
	        catch (e) {
	            if (!(e instanceof NoMatch))
	                throw e;
	        }
	    }
	    throw new NoMatch(segment);
	}
	function processPathsWithParamsAgainstRoute(route, segment, pathIndex, paths, outlet) {
	    if (route.redirectTo)
	        throw new NoMatch();
	    if ((route.outlet ? route.outlet : shared_1.PRIMARY_OUTLET) !== outlet)
	        throw new NoMatch();
	    if (route.path === '**') {
	        var params = paths.length > 0 ? collection_1.last(paths).parameters : {};
	        var snapshot_1 = new router_state_1.ActivatedRouteSnapshot(paths, params, outlet, route.component, route, segment, -1);
	        return new tree_1.TreeNode(snapshot_1, []);
	    }
	    var _a = match(segment, route, paths), consumedPaths = _a.consumedPaths, parameters = _a.parameters, lastChild = _a.lastChild;
	    var snapshot = new router_state_1.ActivatedRouteSnapshot(consumedPaths, parameters, outlet, route.component, route, segment, pathIndex + lastChild - 1);
	    var slicedPath = paths.slice(lastChild);
	    var childConfig = route.children ? route.children : [];
	    if (childConfig.length === 0 && slicedPath.length === 0) {
	        return new tree_1.TreeNode(snapshot, []);
	    }
	    else if (slicedPath.length === 0 && Object.keys(segment.children).length > 0) {
	        var children = processSegmentChildren(childConfig, segment);
	        return new tree_1.TreeNode(snapshot, children);
	    }
	    else {
	        var child = processPathsWithParams(childConfig, segment, pathIndex + lastChild, slicedPath, shared_1.PRIMARY_OUTLET);
	        return new tree_1.TreeNode(snapshot, [child]);
	    }
	}
	function match(segment, route, paths) {
	    if (route.path === '') {
	        if (route.terminal && (Object.keys(segment.children).length > 0 || paths.length > 0)) {
	            throw new NoMatch();
	        }
	        else {
	            return { consumedPaths: [], lastChild: 0, parameters: {} };
	        }
	    }
	    var path = route.path;
	    var parts = path.split('/');
	    var posParameters = {};
	    var consumedPaths = [];
	    var currentIndex = 0;
	    for (var i = 0; i < parts.length; ++i) {
	        if (currentIndex >= paths.length)
	            throw new NoMatch();
	        var current = paths[currentIndex];
	        var p = parts[i];
	        var isPosParam = p.startsWith(':');
	        if (!isPosParam && p !== current.path)
	            throw new NoMatch();
	        if (isPosParam) {
	            posParameters[p.substring(1)] = current.path;
	        }
	        consumedPaths.push(current);
	        currentIndex++;
	    }
	    if (route.terminal && (Object.keys(segment.children).length > 0 || currentIndex < paths.length)) {
	        throw new NoMatch();
	    }
	    var parameters = collection_1.merge(posParameters, consumedPaths[consumedPaths.length - 1].parameters);
	    return { consumedPaths: consumedPaths, lastChild: currentIndex, parameters: parameters };
	}
	function checkOutletNameUniqueness(nodes) {
	    var names = {};
	    nodes.forEach(function (n) {
	        var routeWithSameOutletName = names[n.value.outlet];
	        if (routeWithSameOutletName) {
	            var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
	            var c = n.value.url.map(function (s) { return s.toString(); }).join('/');
	            throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
	        }
	        names[n.value.outlet] = n.value;
	    });
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjb2duaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JlY29nbml6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsMkJBQXlCLGlCQUFpQixDQUFDLENBQUE7QUFFM0MsbUJBQWtCLG9CQUFvQixDQUFDLENBQUE7QUFHdkMsNkJBQTBELGdCQUFnQixDQUFDLENBQUE7QUFDM0UsdUJBQTZCLFVBQVUsQ0FBQyxDQUFBO0FBQ3hDLHlCQUEyRSxZQUFZLENBQUMsQ0FBQTtBQUN4RiwyQkFBMEIsb0JBQW9CLENBQUMsQ0FBQTtBQUMvQyxxQkFBdUIsY0FBYyxDQUFDLENBQUE7QUFFdEM7SUFDRSxpQkFBbUIsT0FBMEI7UUFBakMsdUJBQWlDLEdBQWpDLGNBQWlDO1FBQTFCLFlBQU8sR0FBUCxPQUFPLENBQW1CO0lBQUcsQ0FBQztJQUNuRCxjQUFDO0FBQUQsQ0FBQyxBQUZELElBRUM7QUFFRCxtQkFDSSxpQkFBdUIsRUFBRSxNQUFvQixFQUFFLE9BQWdCLEVBQy9ELEdBQVc7SUFDYixJQUFJLENBQUM7UUFDSCxJQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1FBQ3RFLElBQU0sSUFBSSxHQUFHLElBQUkscUNBQXNCLENBQ25DLEVBQUUsRUFBRSxFQUFFLEVBQUUsdUJBQWMsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLElBQU0sUUFBUSxHQUFHLElBQUksZUFBUSxDQUF5QixJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEUsTUFBTSxDQUFDLE9BQUUsQ0FBRSxJQUFJLGtDQUFtQixDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFFO0lBQUEsS0FBSyxD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QUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQVosQ0FBWSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sSUFBSSxLQUFLLENBQUMscURBQW1ELENBQUMsZUFBVSxDQUFDLE9BQUksQ0FBQyxDQUFDO1FBQ3ZGLENBQUM7UUFDRCxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ2xDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQge09ic2VydmVyfSBmcm9tICdyeGpzL09ic2VydmVyJztcbmltcG9ydCB7b2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuXG5pbXBvcnQge1JvdXRlLCBSb3V0ZXJDb25maWd9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7QWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgUm91dGVyU3RhdGVTbmFwc2hvdH0gZnJvbSAnLi9yb3V0ZXJfc3RhdGUnO1xuaW1wb3J0IHtQUklNQVJZX09VVExFVH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHtVcmxQYXRoV2l0aFBhcmFtcywgVXJsU2VnbWVudCwgVXJsVHJlZSwgbWFwQ2hpbGRyZW5JbnRvQXJyYXl9IGZyb20gJy4vdXJsX3RyZWUnO1xuaW1wb3J0IHtsYXN0LCBtZXJnZX0gZnJvbSAnLi91dGlscy9jb2xsZWN0aW9uJztcbmltcG9ydCB7VHJlZU5vZGV9IGZyb20gJy4vdXRpbHMvdHJlZSc7XG5cbmNsYXNzIE5vTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc2VnbWVudDogVXJsU2VnbWVudCA9IG51bGwpIHt9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvZ25pemUoXG4gICAgcm9vdENvbXBvbmVudFR5cGU6IFR5cGUsIGNvbmZpZzogUm91dGVyQ29uZmlnLCB1cmxUcmVlOiBVcmxUcmVlLFxuICAgIHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwcm9jZXNzU2VnbWVudChjb25maWcsIHVybFRyZWUucm9vdCwgUFJJTUFSWV9PVVRMRVQpO1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgQWN0aXZhdGVkUm91dGVTbmFwc2hvdChcbiAgICAgICAgW10sIHt9LCBQUklNQVJZX09VVExFVCwgcm9vdENvbXBvbmVudFR5cGUsIG51bGwsIHVybFRyZWUucm9vdCwgLTEpO1xuICAgIGNvbnN0IHJvb3ROb2RlID0gbmV3IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+KHJvb3QsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gb2YgKG5ldyBSb3V0ZXJTdGF0ZVNuYXBzaG90KHVybCwgcm9vdE5vZGUsIHVybFRyZWUucXVlcnlQYXJhbXMsIHVybFRyZWUuZnJhZ21lbnQpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTm9NYXRjaCkge1xuICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlPFJvdXRlclN0YXRlU25hcHNob3Q+KFxuICAgICAgICAgIChvYnM6IE9ic2VydmVyPFJvdXRlclN0YXRlU25hcHNob3Q+KSA9PlxuICAgICAgICAgICAgICBvYnMuZXJyb3IobmV3IEVycm9yKGBDYW5ub3QgbWF0Y2ggYW55IHJvdXRlczogJyR7ZS5zZWdtZW50fSdgKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8Um91dGVyU3RhdGVTbmFwc2hvdD4oXG4gICAgICAgICAgKG9iczogT2JzZXJ2ZXI8Um91dGVyU3RhdGVTbmFwc2hvdD4pID0+IG9icy5lcnJvcihlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KFxuICAgIGNvbmZpZzogUm91dGVbXSwgc2VnbWVudDogVXJsU2VnbWVudCwgb3V0bGV0OiBzdHJpbmcpOiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90PltdIHtcbiAgaWYgKHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NTZWdtZW50Q2hpbGRyZW4oY29uZmlnLCBzZWdtZW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3Byb2Nlc3NQYXRoc1dpdGhQYXJhbXMoY29uZmlnLCBzZWdtZW50LCAwLCBzZWdtZW50LnBhdGhzV2l0aFBhcmFtcywgb3V0bGV0KV07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnRDaGlsZHJlbihcbiAgICBjb25maWc6IFJvdXRlW10sIHNlZ21lbnQ6IFVybFNlZ21lbnQpOiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90PltdIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBtYXBDaGlsZHJlbkludG9BcnJheShcbiAgICAgIHNlZ21lbnQsIChjaGlsZCwgY2hpbGRPdXRsZXQpID0+IHByb2Nlc3NTZWdtZW50KGNvbmZpZywgY2hpbGQsIGNoaWxkT3V0bGV0KSk7XG4gIGNoZWNrT3V0bGV0TmFtZVVuaXF1ZW5lc3MoY2hpbGRyZW4pO1xuICBzb3J0QWN0aXZhdGVkUm91dGVTbmFwc2hvdHMoY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHNvcnRBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90cyhub2RlczogVHJlZU5vZGU8QWN0aXZhdGVkUm91dGVTbmFwc2hvdD5bXSk6IHZvaWQge1xuICBub2Rlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEudmFsdWUub3V0bGV0ID09PSBQUklNQVJZX09VVExFVCkgcmV0dXJuIC0xO1xuICAgIGlmIChiLnZhbHVlLm91dGxldCA9PT0gUFJJTUFSWV9PVVRMRVQpIHJldHVybiAxO1xuICAgIHJldHVybiBhLnZhbHVlLm91dGxldC5sb2NhbGVDb21wYXJlKGIudmFsdWUub3V0bGV0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQYXRoc1dpdGhQYXJhbXMoXG4gICAgY29uZmlnOiBSb3V0ZVtdLCBzZWdtZW50OiBVcmxTZWdtZW50LCBwYXRoSW5kZXg6IG51bWJlciwgcGF0aHM6IFVybFBhdGhXaXRoUGFyYW1zW10sXG4gICAgb3V0bGV0OiBzdHJpbmcpOiBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90PiB7XG4gIGZvciAobGV0IHIgb2YgY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwcm9jZXNzUGF0aHNXaXRoUGFyYW1zQWdhaW5zdFJvdXRlKHIsIHNlZ21lbnQsIHBhdGhJbmRleCwgcGF0aHMsIG91dGxldCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE5vTWF0Y2gpKSB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgTm9NYXRjaChzZWdtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1BhdGhzV2l0aFBhcmFtc0FnYWluc3RSb3V0ZShcbiAgICByb3V0ZTogUm91dGUsIHNlZ21lbnQ6IFVybFNlZ21lbnQsIHBhdGhJbmRleDogbnVtYmVyLCBwYXRoczogVXJsUGF0aFdpdGhQYXJhbXNbXSxcbiAgICBvdXRsZXQ6IHN0cmluZyk6IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+IHtcbiAgaWYgKHJvdXRlLnJlZGlyZWN0VG8pIHRocm93IG5ldyBOb01hdGNoKCk7XG4gIGlmICgocm91dGUub3V0bGV0ID8gcm91dGUub3V0bGV0IDogUFJJTUFSWV9PVVRMRVQpICE9PSBvdXRsZXQpIHRocm93IG5ldyBOb01hdGNoKCk7XG5cbiAgaWYgKHJvdXRlLnBhdGggPT09ICcqKicpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBwYXRocy5sZW5ndGggPiAwID8gbGFzdChwYXRocykucGFyYW1ldGVycyA6IHt9O1xuICAgIGNvbnN0IHNuYXBzaG90ID1cbiAgICAgICAgbmV3IEFjdGl2YXRlZFJvdXRlU25hcHNob3QocGF0aHMsIHBhcmFtcywgb3V0bGV0LCByb3V0ZS5jb21wb25lbnQsIHJvdXRlLCBzZWdtZW50LCAtMSk7XG4gICAgcmV0dXJuIG5ldyBUcmVlTm9kZTxBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90PihzbmFwc2hvdCwgW10pO1xuICB9XG5cbiAgY29uc3Qge2NvbnN1bWVkUGF0aHMsIHBhcmFtZXRlcnMsIGxhc3RDaGlsZH0gPSBtYXRjaChzZWdtZW50LCByb3V0ZSwgcGF0aHMpO1xuXG4gIGNvbnN0IHNuYXBzaG90ID0gbmV3IEFjdGl2YXRlZFJvdXRlU25hcHNob3QoXG4gICAgICBjb25zdW1lZFBhdGhzLCBwYXJhbWV0ZXJzLCBvdXRsZXQsIHJvdXRlLmNvbXBvbmVudCwgcm91dGUsIHNlZ21lbnQsXG4gICAgICBwYXRoSW5kZXggKyBsYXN0Q2hpbGQgLSAxKTtcbiAgY29uc3Qgc2xpY2VkUGF0aCA9IHBhdGhzLnNsaWNlKGxhc3RDaGlsZCk7XG4gIGNvbnN0IGNoaWxkQ29uZmlnID0gcm91dGUuY2hpbGRyZW4gPyByb3V0ZS5jaGlsZHJlbiA6IFtdO1xuXG4gIGlmIChjaGlsZENvbmZpZy5sZW5ndGggPT09IDAgJiYgc2xpY2VkUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+KHNuYXBzaG90LCBbXSk7XG5cbiAgICAvLyBUT0RPOiBjaGVjayB0aGF0IHRoZSByaWdodCBzZWdtZW50IGlzIHByZXNlbnRcbiAgfSBlbHNlIGlmIChzbGljZWRQYXRoLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwcm9jZXNzU2VnbWVudENoaWxkcmVuKGNoaWxkQ29uZmlnLCBzZWdtZW50KTtcbiAgICByZXR1cm4gbmV3IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+KHNuYXBzaG90LCBjaGlsZHJlbik7XG5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaGlsZCA9IHByb2Nlc3NQYXRoc1dpdGhQYXJhbXMoXG4gICAgICAgIGNoaWxkQ29uZmlnLCBzZWdtZW50LCBwYXRoSW5kZXggKyBsYXN0Q2hpbGQsIHNsaWNlZFBhdGgsIFBSSU1BUllfT1VUTEVUKTtcbiAgICByZXR1cm4gbmV3IFRyZWVOb2RlPEFjdGl2YXRlZFJvdXRlU25hcHNob3Q+KHNuYXBzaG90LCBbY2hpbGRdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaChzZWdtZW50OiBVcmxTZWdtZW50LCByb3V0ZTogUm91dGUsIHBhdGhzOiBVcmxQYXRoV2l0aFBhcmFtc1tdKSB7XG4gIGlmIChyb3V0ZS5wYXRoID09PSAnJykge1xuICAgIGlmIChyb3V0ZS50ZXJtaW5hbCAmJiAoT2JqZWN0LmtleXMoc2VnbWVudC5jaGlsZHJlbikubGVuZ3RoID4gMCB8fCBwYXRocy5sZW5ndGggPiAwKSkge1xuICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtjb25zdW1lZFBhdGhzOiBbXSwgbGFzdENoaWxkOiAwLCBwYXJhbWV0ZXJzOiB7fX07XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICBjb25zdCBwb3NQYXJhbWV0ZXJzOiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9O1xuICBjb25zdCBjb25zdW1lZFBhdGhzOiBVcmxQYXRoV2l0aFBhcmFtc1tdID0gW107XG5cbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChjdXJyZW50SW5kZXggPj0gcGF0aHMubGVuZ3RoKSB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoc1tjdXJyZW50SW5kZXhdO1xuXG4gICAgY29uc3QgcCA9IHBhcnRzW2ldO1xuICAgIGNvbnN0IGlzUG9zUGFyYW0gPSBwLnN0YXJ0c1dpdGgoJzonKTtcblxuICAgIGlmICghaXNQb3NQYXJhbSAmJiBwICE9PSBjdXJyZW50LnBhdGgpIHRocm93IG5ldyBOb01hdGNoKCk7XG4gICAgaWYgKGlzUG9zUGFyYW0pIHtcbiAgICAgIHBvc1BhcmFtZXRlcnNbcC5zdWJzdHJpbmcoMSldID0gY3VycmVudC5wYXRoO1xuICAgIH1cbiAgICBjb25zdW1lZFBhdGhzLnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudEluZGV4Kys7XG4gIH1cblxuICBpZiAocm91dGUudGVybWluYWwgJiYgKE9iamVjdC5rZXlzKHNlZ21lbnQuY2hpbGRyZW4pLmxlbmd0aCA+IDAgfHwgY3VycmVudEluZGV4IDwgcGF0aHMubGVuZ3RoKSkge1xuICAgIHRocm93IG5ldyBOb01hdGNoKCk7XG4gIH1cblxuICBjb25zdCBwYXJhbWV0ZXJzID0gbWVyZ2UocG9zUGFyYW1ldGVycywgY29uc3VtZWRQYXRoc1tjb25zdW1lZFBhdGhzLmxlbmd0aCAtIDFdLnBhcmFtZXRlcnMpO1xuICByZXR1cm4ge2NvbnN1bWVkUGF0aHMsIGxhc3RDaGlsZDogY3VycmVudEluZGV4LCBwYXJhbWV0ZXJzfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tPdXRsZXROYW1lVW5pcXVlbmVzcyhub2RlczogVHJlZU5vZGU8QWN0aXZhdGVkUm91dGVTbmFwc2hvdD5bXSk6IHZvaWQge1xuICBjb25zdCBuYW1lczoge1trOiBzdHJpbmddOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90fSA9IHt9O1xuICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgIGxldCByb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZSA9IG5hbWVzW24udmFsdWUub3V0bGV0XTtcbiAgICBpZiAocm91dGVXaXRoU2FtZU91dGxldE5hbWUpIHtcbiAgICAgIGNvbnN0IHAgPSByb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZS51cmwubWFwKHMgPT4gcy50b1N0cmluZygpKS5qb2luKCcvJyk7XG4gICAgICBjb25zdCBjID0gbi52YWx1ZS51cmwubWFwKHMgPT4gcy50b1N0cmluZygpKS5qb2luKCcvJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFR3byBzZWdtZW50cyBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBvdXRsZXQgbmFtZTogJyR7cH0nIGFuZCAnJHtjfScuYCk7XG4gICAgfVxuICAgIG5hbWVzW24udmFsdWUub3V0bGV0XSA9IG4udmFsdWU7XG4gIH0pO1xufSJdfQ==

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(363);
	__webpack_require__(428);
	var forkJoin_1 = __webpack_require__(429);
	var fromPromise_1 = __webpack_require__(431);
	function resolve(resolver, state) {
	    return resolveNode(resolver, state._root).map(function (_) { return state; });
	}
	exports.resolve = resolve;
	function resolveNode(resolver, node) {
	    if (node.children.length === 0) {
	        return fromPromise_1.fromPromise(resolver.resolveComponent(node.value.component).then(function (factory) {
	            node.value._resolvedComponentFactory = factory;
	            return node.value;
	        }));
	    }
	    else {
	        var c = node.children.map(function (c) { return resolveNode(resolver, c).toPromise(); });
	        return forkJoin_1.forkJoin(c).map(function (_) { return resolver.resolveComponent(node.value.component).then(function (factory) {
	            node.value._resolvedComponentFactory = factory;
	            return node.value;
	        }); });
	    }
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb2x2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNvbHZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxRQUFPLHVCQUF1QixDQUFDLENBQUE7QUFDL0IsUUFBTyw2QkFBNkIsQ0FBQyxDQUFBO0FBSXJDLHlCQUF1QiwwQkFBMEIsQ0FBQyxDQUFBO0FBQ2xELDRCQUEwQiw2QkFBNkIsQ0FBQyxDQUFBO0FBS3hELGlCQUNJLFFBQTJCLEVBQUUsS0FBMEI7SUFDekQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLEtBQUssRUFBTCxDQUFLLENBQUMsQ0FBQztBQUM1RCxDQUFDO0FBSGUsZUFBTyxVQUd0QixDQUFBO0FBRUQscUJBQ0ksUUFBMkIsRUFBRSxJQUFzQztJQUNyRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9CLE1BQU0sQ0FBQyx5QkFBVyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBTSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFBLE9BQU87WUFDbEYsSUFBSSxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsR0FBRyxPQUFPLENBQUM7WUFDL0MsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDcEIsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVOLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBcEMsQ0FBb0MsQ0FBQyxDQUFDO1FBQ3ZFLE1BQU0sQ0FBQyxtQkFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FDbEIsVUFBQSxDQUFDLElBQUksT0FBQSxRQUFRLENBQUMsZ0JBQWdCLENBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQSxPQUFPO1lBQ3BFLElBQUksQ0FBQyxLQUFLLENBQUMseUJBQXlCLEdBQUcsT0FBTyxDQUFDO1lBQy9DLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUMsQ0FBQyxFQUhHLENBR0gsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3RvUHJvbWlzZSc7XG5cbmltcG9ydCB7Q29tcG9uZW50UmVzb2x2ZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHtmb3JrSm9pbn0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2ZvcmtKb2luJztcbmltcG9ydCB7ZnJvbVByb21pc2V9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZSc7XG5cbmltcG9ydCB7QWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgUm91dGVyU3RhdGVTbmFwc2hvdH0gZnJvbSAnLi9yb3V0ZXJfc3RhdGUnO1xuaW1wb3J0IHtUcmVlTm9kZX0gZnJvbSAnLi91dGlscy90cmVlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoXG4gICAgcmVzb2x2ZXI6IENvbXBvbmVudFJlc29sdmVyLCBzdGF0ZTogUm91dGVyU3RhdGVTbmFwc2hvdCk6IE9ic2VydmFibGU8Um91dGVyU3RhdGVTbmFwc2hvdD4ge1xuICByZXR1cm4gcmVzb2x2ZU5vZGUocmVzb2x2ZXIsIHN0YXRlLl9yb290KS5tYXAoXyA9PiBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKFxuICAgIHJlc29sdmVyOiBDb21wb25lbnRSZXNvbHZlciwgbm9kZTogVHJlZU5vZGU8QWN0aXZhdGVkUm91dGVTbmFwc2hvdD4pOiBPYnNlcnZhYmxlPGFueT4ge1xuICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbVByb21pc2UocmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudCg8YW55Pm5vZGUudmFsdWUuY29tcG9uZW50KS50aGVuKGZhY3RvcnkgPT4ge1xuICAgICAgbm9kZS52YWx1ZS5fcmVzb2x2ZWRDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH0pKTtcblxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGMgPSBub2RlLmNoaWxkcmVuLm1hcChjID0+IHJlc29sdmVOb2RlKHJlc29sdmVyLCBjKS50b1Byb21pc2UoKSk7XG4gICAgcmV0dXJuIGZvcmtKb2luKGMpLm1hcChcbiAgICAgICAgXyA9PiByZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50KDxhbnk+bm9kZS52YWx1ZS5jb21wb25lbnQpLnRoZW4oZmFjdG9yeSA9PiB7XG4gICAgICAgICAgbm9kZS52YWx1ZS5fcmVzb2x2ZWRDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfSkpO1xuICB9XG59Il19

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var toPromise_1 = __webpack_require__(58);
	Observable_1.Observable.prototype.toPromise = toPromise_1.toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ },
/* 429 */,
/* 430 */,
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PromiseObservable_1 = __webpack_require__(57);
	exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
	//# sourceMappingURL=fromPromise.js.map

/***/ },
/* 432 */
/***/ function(module, exports) {

	"use strict";
	var RouterOutletMap = (function () {
	    function RouterOutletMap() {
	        this._outlets = {};
	    }
	    RouterOutletMap.prototype.registerOutlet = function (name, outlet) { this._outlets[name] = outlet; };
	    return RouterOutletMap;
	}());
	exports.RouterOutletMap = RouterOutletMap;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX291dGxldF9tYXAuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcm91dGVyX291dGxldF9tYXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUtBO0lBQUE7UUFFRSxhQUFRLEdBQW1DLEVBQUUsQ0FBQztJQUVoRCxDQUFDO0lBREMsd0NBQWMsR0FBZCxVQUFlLElBQVksRUFBRSxNQUFvQixJQUFVLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM1RixzQkFBQztBQUFELENBQUMsQUFKRCxJQUlDO0FBSlksdUJBQWUsa0JBSTNCLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1JvdXRlck91dGxldH0gZnJvbSAnLi9kaXJlY3RpdmVzL3JvdXRlcl9vdXRsZXQnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgUm91dGVyT3V0bGV0TWFwIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3V0bGV0czoge1tuYW1lOiBzdHJpbmddOiBSb3V0ZXJPdXRsZXR9ID0ge307XG4gIHJlZ2lzdGVyT3V0bGV0KG5hbWU6IHN0cmluZywgb3V0bGV0OiBSb3V0ZXJPdXRsZXQpOiB2b2lkIHsgdGhpcy5fb3V0bGV0c1tuYW1lXSA9IG91dGxldDsgfVxufVxuIl19

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(396);
	var url_tree_1 = __webpack_require__(417);
	var router_link_1 = __webpack_require__(395);
	var RouterLinkActive = (function () {
	    function RouterLinkActive(router, element, renderer) {
	        var _this = this;
	        this.router = router;
	        this.element = element;
	        this.renderer = renderer;
	        this.classes = [];
	        this.routerLinkActiveOptions = { exact: true };
	        this.subscription = router.events.subscribe(function (s) {
	            if (s instanceof router_1.NavigationEnd) {
	                _this.update();
	            }
	        });
	    }
	    RouterLinkActive.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this.links.changes.subscribe(function (s) { return _this.update(); });
	        this.update();
	    };
	    Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
	        set: function (data) {
	            if (Array.isArray(data)) {
	                this.classes = data;
	            }
	            else {
	                this.classes = data.split(' ');
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
	    RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
	    RouterLinkActive.prototype.update = function () {
	        var _this = this;
	        if (!this.links || this.links.length === 0)
	            return;
	        var currentUrlTree = this.router.parseUrl(this.router.url);
	        var isActive = this.links.reduce(function (res, link) {
	            return res || url_tree_1.containsTree(currentUrlTree, link.urlTree, _this.routerLinkActiveOptions.exact);
	        }, false);
	        this.classes.forEach(function (c) { return _this.renderer.setElementClass(_this.element.nativeElement, c, isActive); });
	    };
	    __decorate([
	        core_1.ContentChildren(router_link_1.RouterLink), 
	        __metadata('design:type', core_1.QueryList)
	    ], RouterLinkActive.prototype, "links", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], RouterLinkActive.prototype, "routerLinkActiveOptions", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object), 
	        __metadata('design:paramtypes', [Object])
	    ], RouterLinkActive.prototype, "routerLinkActive", null);
	    RouterLinkActive = __decorate([
	        core_1.Directive({ selector: '[routerLinkActive]' }), 
	        __metadata('design:paramtypes', [router_1.Router, core_1.ElementRef, core_1.Renderer])
	    ], RouterLinkActive);
	    return RouterLinkActive;
	}());
	exports.RouterLinkActive = RouterLinkActive;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX2xpbmtfYWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RpcmVjdGl2ZXMvcm91dGVyX2xpbmtfYWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxQkFBeUgsZUFBZSxDQUFDLENBQUE7QUFHekksdUJBQW9DLFdBQVcsQ0FBQyxDQUFBO0FBQ2hELHlCQUEyQixhQUFhLENBQUMsQ0FBQTtBQUV6Qyw0QkFBeUIsZUFBZSxDQUFDLENBQUE7QUFPekM7SUFVRSwwQkFBb0IsTUFBYyxFQUFVLE9BQW1CLEVBQVUsUUFBa0I7UUFWN0YsaUJBK0NDO1FBckNxQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVU7UUFSbkYsWUFBTyxHQUFhLEVBQUUsQ0FBQztRQUdkLDRCQUF1QixHQUE0QixFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUMsQ0FBQztRQU1oRixJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQUEsQ0FBQztZQUMzQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksc0JBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLEtBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNoQixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsNkNBQWtCLEdBQWxCO1FBQUEsaUJBR0M7UUFGQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsTUFBTSxFQUFFLEVBQWIsQ0FBYSxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUFHRCxzQkFBSSw4Q0FBZ0I7YUFBcEIsVUFBcUIsSUFBcUI7WUFDeEMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQVEsSUFBSSxDQUFDO1lBQzNCLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsQ0FBQztRQUNILENBQUM7OztPQUFBO0lBRUQsc0NBQVcsR0FBWCxVQUFZLE9BQVcsSUFBUyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hELHNDQUFXLEdBQVgsY0FBcUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFL0MsaUNBQU0sR0FBZDtRQUFBLGlCQVdDO1FBVkMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztZQUFDLE1BQU0sQ0FBQztRQUVuRCxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUM5QixVQUFDLEdBQUcsRUFBRSxJQUFJO1lBQ04sT0FBQSxHQUFHLElBQUksdUJBQVksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFJLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFDO1FBQXJGLENBQXFGLEVBQ3pGLEtBQUssQ0FBQyxDQUFDO1FBRVgsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQ2hCLFVBQUEsQ0FBQyxJQUFJLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxFQUF0RSxDQUFzRSxDQUFDLENBQUM7SUFDbkYsQ0FBQztJQTdDRDtRQUFDLHNCQUFlLENBQUMsd0JBQVUsQ0FBQzs7bURBQUE7SUFJNUI7UUFBQyxZQUFLLEVBQUU7O3FFQUFBO0lBa0JSO1FBQUMsWUFBSyxFQUFFOzs7NERBQUE7SUF4QlY7UUFBQyxnQkFBUyxDQUFDLEVBQUMsUUFBUSxFQUFFLG9CQUFvQixFQUFDLENBQUM7O3dCQUFBO0lBZ0Q1Qyx1QkFBQztBQUFELENBQUMsQUEvQ0QsSUErQ0M7QUEvQ1ksd0JBQWdCLG1CQStDNUIsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBSZW5kZXJlcn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5pbXBvcnQge05hdmlnYXRpb25FbmQsIFJvdXRlcn0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7Y29udGFpbnNUcmVlfSBmcm9tICcuLi91cmxfdHJlZSc7XG5cbmltcG9ydCB7Um91dGVyTGlua30gZnJvbSAnLi9yb3V0ZXJfbGluayc7XG5cbmludGVyZmFjZSBSb3V0ZXJMaW5rQWN0aXZlT3B0aW9ucyB7XG4gIGV4YWN0OiBib29sZWFuO1xufVxuXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tyb3V0ZXJMaW5rQWN0aXZlXSd9KVxuZXhwb3J0IGNsYXNzIFJvdXRlckxpbmtBY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIEBDb250ZW50Q2hpbGRyZW4oUm91dGVyTGluaykgcHJpdmF0ZSBsaW5rczogUXVlcnlMaXN0PFJvdXRlckxpbms+O1xuICBwcml2YXRlIGNsYXNzZXM6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgQElucHV0KCkgcHJpdmF0ZSByb3V0ZXJMaW5rQWN0aXZlT3B0aW9uczogUm91dGVyTGlua0FjdGl2ZU9wdGlvbnMgPSB7ZXhhY3Q6IHRydWV9O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHJvdXRlci5ldmVudHMuc3Vic2NyaWJlKHMgPT4ge1xuICAgICAgaWYgKHMgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5saW5rcy5jaGFuZ2VzLnN1YnNjcmliZShzID0+IHRoaXMudXBkYXRlKCkpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgcm91dGVyTGlua0FjdGl2ZShkYXRhOiBzdHJpbmdbXXxzdHJpbmcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5jbGFzc2VzID0gPGFueT5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsYXNzZXMgPSBkYXRhLnNwbGl0KCcgJyk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczoge30pOiBhbnkgeyB0aGlzLnVwZGF0ZSgpOyB9XG4gIG5nT25EZXN0cm95KCk6IGFueSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH1cblxuICBwcml2YXRlIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubGlua3MgfHwgdGhpcy5saW5rcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRVcmxUcmVlID0gdGhpcy5yb3V0ZXIucGFyc2VVcmwodGhpcy5yb3V0ZXIudXJsKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMubGlua3MucmVkdWNlKFxuICAgICAgICAocmVzLCBsaW5rKSA9PlxuICAgICAgICAgICAgcmVzIHx8IGNvbnRhaW5zVHJlZShjdXJyZW50VXJsVHJlZSwgbGluay51cmxUcmVlLCB0aGlzLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zLmV4YWN0KSxcbiAgICAgICAgZmFsc2UpO1xuXG4gICAgdGhpcy5jbGFzc2VzLmZvckVhY2goXG4gICAgICAgIGMgPT4gdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGMsIGlzQWN0aXZlKSk7XG4gIH1cbn1cbiJdfQ==

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var core_1 = __webpack_require__(5);
	var router_outlet_map_1 = __webpack_require__(432);
	var shared_1 = __webpack_require__(416);
	var RouterOutlet = (function () {
	    function RouterOutlet(parentOutletMap, location, name) {
	        this.location = location;
	        parentOutletMap.registerOutlet(name ? name : shared_1.PRIMARY_OUTLET, this);
	    }
	    Object.defineProperty(RouterOutlet.prototype, "isActivated", {
	        get: function () { return !!this.activated; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "component", {
	        get: function () {
	            if (!this.activated)
	                throw new Error('Outlet is not activated');
	            return this.activated.instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
	        get: function () {
	            if (!this.activated)
	                throw new Error('Outlet is not activated');
	            return this._activatedRoute;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RouterOutlet.prototype.deactivate = function () {
	        if (this.activated) {
	            this.activated.destroy();
	            this.activated = null;
	        }
	    };
	    RouterOutlet.prototype.activate = function (factory, activatedRoute, providers, outletMap) {
	        this.outletMap = outletMap;
	        this._activatedRoute = activatedRoute;
	        var inj = core_1.ReflectiveInjector.fromResolvedProviders(providers, this.location.parentInjector);
	        this.activated = this.location.createComponent(factory, this.location.length, inj, []);
	    };
	    RouterOutlet = __decorate([
	        core_1.Directive({ selector: 'router-outlet' }),
	        __param(2, core_1.Attribute('name')), 
	        __metadata('design:paramtypes', [router_outlet_map_1.RouterOutletMap, core_1.ViewContainerRef, String])
	    ], RouterOutlet);
	    return RouterOutlet;
	}());
	exports.RouterOutlet = RouterOutlet;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX291dGxldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaXJlY3RpdmVzL3JvdXRlcl9vdXRsZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLHFCQUFxSSxlQUFlLENBQUMsQ0FBQTtBQUNySixrQ0FBOEIsc0JBQXNCLENBQUMsQ0FBQTtBQUVyRCx1QkFBNkIsV0FBVyxDQUFDLENBQUE7QUFHekM7SUFRRSxzQkFDSSxlQUFnQyxFQUFVLFFBQTBCLEVBQ2pELElBQVk7UUFEVyxhQUFRLEdBQVIsUUFBUSxDQUFrQjtRQUV0RSxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUcsdUJBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsc0JBQUkscUNBQVc7YUFBZixjQUE2QixNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUN2RCxzQkFBSSxtQ0FBUzthQUFiO1lBQ0UsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztZQUNoRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7UUFDakMsQ0FBQzs7O09BQUE7SUFDRCxzQkFBSSx3Q0FBYzthQUFsQjtZQUNFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFBQyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7WUFDaEUsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDOUIsQ0FBQzs7O09BQUE7SUFFRCxpQ0FBVSxHQUFWO1FBQ0UsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztRQUN4QixDQUFDO0lBQ0gsQ0FBQztJQUVELCtCQUFRLEdBQVIsVUFDSSxPQUE4QixFQUFFLGNBQThCLEVBQzlELFNBQXVDLEVBQUUsU0FBMEI7UUFDckUsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxjQUFjLENBQUM7UUFDdEMsSUFBTSxHQUFHLEdBQUcseUJBQWtCLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDOUYsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUF2Q0g7UUFBQyxnQkFBUyxDQUFDLEVBQUMsUUFBUSxFQUFFLGVBQWUsRUFBQyxDQUFDO21CQVdoQyxnQkFBUyxDQUFDLE1BQU0sQ0FBQzs7b0JBWGU7SUF3Q3ZDLG1CQUFDO0FBQUQsQ0FBQyxBQXZDRCxJQXVDQztBQXZDWSxvQkFBWSxlQXVDeEIsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QXR0cmlidXRlLCBDb21wb25lbnRGYWN0b3J5LCBDb21wb25lbnRSZWYsIERpcmVjdGl2ZSwgUmVmbGVjdGl2ZUluamVjdG9yLCBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlciwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1JvdXRlck91dGxldE1hcH0gZnJvbSAnLi4vcm91dGVyX291dGxldF9tYXAnO1xuaW1wb3J0IHtBY3RpdmF0ZWRSb3V0ZX0gZnJvbSAnLi4vcm91dGVyX3N0YXRlJztcbmltcG9ydCB7UFJJTUFSWV9PVVRMRVR9IGZyb20gJy4uL3NoYXJlZCc7XG5cbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAncm91dGVyLW91dGxldCd9KVxuZXhwb3J0IGNsYXNzIFJvdXRlck91dGxldCB7XG4gIHByaXZhdGUgYWN0aXZhdGVkOiBDb21wb25lbnRSZWY8YW55PjtcbiAgcHJpdmF0ZSBfYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlO1xuICBwdWJsaWMgb3V0bGV0TWFwOiBSb3V0ZXJPdXRsZXRNYXA7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwYXJlbnRPdXRsZXRNYXA6IFJvdXRlck91dGxldE1hcCwgcHJpdmF0ZSBsb2NhdGlvbjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgIEBBdHRyaWJ1dGUoJ25hbWUnKSBuYW1lOiBzdHJpbmcpIHtcbiAgICBwYXJlbnRPdXRsZXRNYXAucmVnaXN0ZXJPdXRsZXQobmFtZSA/IG5hbWUgOiBQUklNQVJZX09VVExFVCwgdGhpcyk7XG4gIH1cblxuICBnZXQgaXNBY3RpdmF0ZWQoKTogYm9vbGVhbiB7IHJldHVybiAhIXRoaXMuYWN0aXZhdGVkOyB9XG4gIGdldCBjb21wb25lbnQoKTogT2JqZWN0IHtcbiAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKSB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVkLmluc3RhbmNlO1xuICB9XG4gIGdldCBhY3RpdmF0ZWRSb3V0ZSgpOiBBY3RpdmF0ZWRSb3V0ZSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2YXRlZCkgdGhyb3cgbmV3IEVycm9yKCdPdXRsZXQgaXMgbm90IGFjdGl2YXRlZCcpO1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmF0ZWRSb3V0ZTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWN0aXZhdGVkKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlZC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmFjdGl2YXRlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgYWN0aXZhdGUoXG4gICAgICBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PGFueT4sIGFjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSxcbiAgICAgIHByb3ZpZGVyczogUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJbXSwgb3V0bGV0TWFwOiBSb3V0ZXJPdXRsZXRNYXApOiB2b2lkIHtcbiAgICB0aGlzLm91dGxldE1hcCA9IG91dGxldE1hcDtcbiAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuICAgIGNvbnN0IGluaiA9IFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzLCB0aGlzLmxvY2F0aW9uLnBhcmVudEluamVjdG9yKTtcbiAgICB0aGlzLmFjdGl2YXRlZCA9IHRoaXMubG9jYXRpb24uY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHRoaXMubG9jYXRpb24ubGVuZ3RoLCBpbmosIFtdKTtcbiAgfVxufVxuIl19

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var common_1 = __webpack_require__(2);
	var platform_browser_1 = __webpack_require__(260);
	var common = __webpack_require__(436);
	function provideRouter(config, opts) {
	    if (opts === void 0) { opts = {}; }
	    return [
	        { provide: common_1.PlatformLocation, useClass: platform_browser_1.BrowserPlatformLocation }
	    ].concat(common.provideRouter(config, opts));
	}
	exports.provideRouter = provideRouter;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX3Byb3ZpZGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yb3V0ZXJfcHJvdmlkZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSx1QkFBK0IsaUJBQWlCLENBQUMsQ0FBQTtBQUNqRCxpQ0FBc0MsMkJBQTJCLENBQUMsQ0FBQTtBQUVsRSxJQUFZLE1BQU0sV0FBTSwyQkFBMkIsQ0FBQyxDQUFBO0FBc0JwRCx1QkFBOEIsTUFBb0IsRUFBRSxJQUE4QjtJQUE5QixvQkFBOEIsR0FBOUIsU0FBOEI7SUFDaEYsTUFBTSxDQUFDO1FBQ0wsRUFBQyxPQUFPLEVBQUUseUJBQWdCLEVBQUUsUUFBUSxFQUFFLDBDQUF1QixFQUFDO2FBQzNELE1BQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUN0QyxDQUFDO0FBQ0osQ0FBQztBQUxlLHFCQUFhLGdCQUs1QixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtQbGF0Zm9ybUxvY2F0aW9ufSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5cbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbl9yb3V0ZXJfcHJvdmlkZXJzJztcbmltcG9ydCB7Um91dGVyQ29uZmlnfSBmcm9tICcuL2NvbmZpZyc7XG5cblxuLyoqXG4gKiBBIGxpc3Qgb2Yge0BsaW5rIFByb3ZpZGVyfXMuIFRvIHVzZSB0aGUgcm91dGVyLCB5b3UgbXVzdCBhZGQgdGhpcyB0byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcbiAqIGNsYXNzIEFwcENtcCB7XG4gKiAgIC8vIC4uLlxuICogfVxuICpcbiAqIGNvbnN0IHJvdXRlciA9IFtcbiAqICAge3BhdGg6ICcvaG9tZScsIGNvbXBvbmVudDogSG9tZX1cbiAqIF07XG4gKlxuICogYm9vdHN0cmFwKEFwcENtcCwgW3Byb3ZpZGVSb3V0ZXIocm91dGVyKV0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm92aWRlUm91dGVyKGNvbmZpZzogUm91dGVyQ29uZmlnLCBvcHRzOiBjb21tb24uRXh0cmFPcHRpb25zID0ge30pOiBhbnlbXSB7XG4gIHJldHVybiBbXG4gICAge3Byb3ZpZGU6IFBsYXRmb3JtTG9jYXRpb24sIHVzZUNsYXNzOiBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbn0sXG4gICAgLi4uY29tbW9uLnByb3ZpZGVSb3V0ZXIoY29uZmlnLCBvcHRzKVxuICBdO1xufVxuIl19

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var common_1 = __webpack_require__(2);
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(396);
	var router_outlet_map_1 = __webpack_require__(432);
	var router_state_1 = __webpack_require__(423);
	var url_serializer_1 = __webpack_require__(418);
	exports.ROUTER_CONFIG = new core_1.OpaqueToken('ROUTER_CONFIG');
	exports.ROUTER_OPTIONS = new core_1.OpaqueToken('ROUTER_OPTIONS');
	function setupRouter(ref, resolver, urlSerializer, outletMap, location, injector, config, opts) {
	    if (ref.componentTypes.length == 0) {
	        throw new Error('Bootstrap at least one component before injecting Router.');
	    }
	    var componentType = ref.componentTypes[0];
	    var r = new router_1.Router(componentType, resolver, urlSerializer, outletMap, location, injector, config);
	    ref.registerDisposeListener(function () { return r.dispose(); });
	    if (opts.enableTracing) {
	        r.events.subscribe(function (e) {
	            console.group("Router Event: " + e.constructor.name);
	            console.log(e.toString());
	            console.log(e);
	            console.groupEnd();
	        });
	    }
	    return r;
	}
	exports.setupRouter = setupRouter;
	function setupRouterInitializer(injector) {
	    setTimeout(function () {
	        var appRef = injector.get(core_1.ApplicationRef);
	        if (appRef.componentTypes.length == 0) {
	            appRef.registerBootstrapListener(function () { injector.get(router_1.Router).initialNavigation(); });
	        }
	        else {
	            injector.get(router_1.Router).initialNavigation();
	        }
	    }, 0);
	    return function () { return null; };
	}
	exports.setupRouterInitializer = setupRouterInitializer;
	function provideRouter(_config, _opts) {
	    return [
	        { provide: exports.ROUTER_CONFIG, useValue: _config }, { provide: exports.ROUTER_OPTIONS, useValue: _opts },
	        common_1.Location, { provide: common_1.LocationStrategy, useClass: common_1.PathLocationStrategy },
	        { provide: url_serializer_1.UrlSerializer, useClass: url_serializer_1.DefaultUrlSerializer },
	        {
	            provide: router_1.Router,
	            useFactory: setupRouter,
	            deps: [
	                core_1.ApplicationRef, core_1.ComponentResolver, url_serializer_1.UrlSerializer, router_outlet_map_1.RouterOutletMap, common_1.Location, core_1.Injector,
	                exports.ROUTER_CONFIG, exports.ROUTER_OPTIONS
	            ]
	        },
	        router_outlet_map_1.RouterOutletMap,
	        { provide: router_state_1.ActivatedRoute, useFactory: function (r) { return r.routerState.root; }, deps: [router_1.Router] },
	        { provide: core_1.APP_INITIALIZER, multi: true, useFactory: setupRouterInitializer, deps: [core_1.Injector] }
	    ];
	}
	exports.provideRouter = provideRouter;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uX3JvdXRlcl9wcm92aWRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29tbW9uX3JvdXRlcl9wcm92aWRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHVCQUErRCxpQkFBaUIsQ0FBQyxDQUFBO0FBQ2pGLHFCQUF3RixlQUFlLENBQUMsQ0FBQTtBQUd4Ryx1QkFBcUIsVUFBVSxDQUFDLENBQUE7QUFDaEMsa0NBQThCLHFCQUFxQixDQUFDLENBQUE7QUFDcEQsNkJBQTZCLGdCQUFnQixDQUFDLENBQUE7QUFDOUMsK0JBQWtELGtCQUFrQixDQUFDLENBQUE7QUFFeEQscUJBQWEsR0FBRyxJQUFJLGtCQUFXLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDakQsc0JBQWMsR0FBRyxJQUFJLGtCQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUloRSxxQkFDSSxHQUFtQixFQUFFLFFBQTJCLEVBQUUsYUFBNEIsRUFDOUUsU0FBMEIsRUFBRSxRQUFrQixFQUFFLFFBQWtCLEVBQUUsTUFBb0IsRUFDeEYsSUFBa0I7SUFDcEIsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUNELElBQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUMsSUFBTSxDQUFDLEdBQ0gsSUFBSSxlQUFNLENBQUMsYUFBYSxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDOUYsR0FBRyxDQUFDLHVCQUF1QixDQUFDLGNBQU0sT0FBQSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQVgsQ0FBVyxDQUFDLENBQUM7SUFFL0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7UUFDdkIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBQSxDQUFDO1lBQ2xCLE9BQU8sQ0FBQyxLQUFLLENBQUMsbUJBQXVCLENBQUMsQ0FBQyxXQUFZLENBQUMsSUFBTSxDQUFDLENBQUM7WUFDNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUMxQixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2YsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBdEJlLG1CQUFXLGNBc0IxQixDQUFBO0FBRUQsZ0NBQXVDLFFBQWtCO0lBSXZELFVBQVUsQ0FBQztRQUNULElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMscUJBQWMsQ0FBQyxDQUFDO1FBQzVDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsTUFBTSxDQUFDLHlCQUF5QixDQUFDLGNBQVEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxlQUFNLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEYsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sUUFBUSxDQUFDLEdBQUcsQ0FBQyxlQUFNLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzNDLENBQUM7SUFDSCxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDTixNQUFNLENBQUMsY0FBVyxPQUFBLElBQUksRUFBSixDQUFJLENBQUM7QUFDekIsQ0FBQztBQWJlLDhCQUFzQix5QkFhckMsQ0FBQTtBQW9CRCx1QkFBOEIsT0FBcUIsRUFBRSxLQUFtQjtJQUN0RSxNQUFNLENBQUM7UUFDTCxFQUFDLE9BQU8sRUFBRSxxQkFBYSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUMsRUFBRSxFQUFDLE9BQU8sRUFBRSxzQkFBYyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUM7UUFDdkYsaUJBQVEsRUFBRSxFQUFDLE9BQU8sRUFBRSx5QkFBZ0IsRUFBRSxRQUFRLEVBQUUsNkJBQW9CLEVBQUM7UUFDckUsRUFBQyxPQUFPLEVBQUUsOEJBQWEsRUFBRSxRQUFRLEVBQUUscUNBQW9CLEVBQUM7UUFFeEQ7WUFDRSxPQUFPLEVBQUUsZUFBTTtZQUNmLFVBQVUsRUFBRSxXQUFXO1lBQ3ZCLElBQUksRUFBRTtnQkFDSixxQkFBYyxFQUFFLHdCQUFpQixFQUFFLDhCQUFhLEVBQUUsbUNBQWUsRUFBRSxpQkFBUSxFQUFFLGVBQVE7Z0JBQ3JGLHFCQUFhLEVBQUUsc0JBQWM7YUFDOUI7U0FDRjtRQUVELG1DQUFlO1FBQ2YsRUFBQyxPQUFPLEVBQUUsNkJBQWMsRUFBRSxVQUFVLEVBQUUsVUFBQyxDQUFTLElBQUssT0FBQSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksRUFBbEIsQ0FBa0IsRUFBRSxJQUFJLEVBQUUsQ0FBQyxlQUFNLENBQUMsRUFBQztRQUd4RixFQUFDLE9BQU8sRUFBRSxzQkFBZSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLHNCQUFzQixFQUFFLElBQUksRUFBRSxDQUFDLGVBQVEsQ0FBQyxFQUFDO0tBQzlGLENBQUM7QUFDSixDQUFDO0FBckJlLHFCQUFhLGdCQXFCNUIsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TG9jYXRpb24sIExvY2F0aW9uU3RyYXRlZ3ksIFBhdGhMb2NhdGlvblN0cmF0ZWd5fSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBUFBfSU5JVElBTElaRVIsIEFwcGxpY2F0aW9uUmVmLCBDb21wb25lbnRSZXNvbHZlciwgSW5qZWN0b3IsIE9wYXF1ZVRva2VufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtSb3V0ZXJDb25maWd9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7Um91dGVyfSBmcm9tICcuL3JvdXRlcic7XG5pbXBvcnQge1JvdXRlck91dGxldE1hcH0gZnJvbSAnLi9yb3V0ZXJfb3V0bGV0X21hcCc7XG5pbXBvcnQge0FjdGl2YXRlZFJvdXRlfSBmcm9tICcuL3JvdXRlcl9zdGF0ZSc7XG5pbXBvcnQge0RlZmF1bHRVcmxTZXJpYWxpemVyLCBVcmxTZXJpYWxpemVyfSBmcm9tICcuL3VybF9zZXJpYWxpemVyJztcblxuZXhwb3J0IGNvbnN0IFJPVVRFUl9DT05GSUcgPSBuZXcgT3BhcXVlVG9rZW4oJ1JPVVRFUl9DT05GSUcnKTtcbmV4cG9ydCBjb25zdCBST1VURVJfT1BUSU9OUyA9IG5ldyBPcGFxdWVUb2tlbignUk9VVEVSX09QVElPTlMnKTtcblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYU9wdGlvbnMgeyBlbmFibGVUcmFjaW5nPzogYm9vbGVhbjsgfVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBSb3V0ZXIoXG4gICAgcmVmOiBBcHBsaWNhdGlvblJlZiwgcmVzb2x2ZXI6IENvbXBvbmVudFJlc29sdmVyLCB1cmxTZXJpYWxpemVyOiBVcmxTZXJpYWxpemVyLFxuICAgIG91dGxldE1hcDogUm91dGVyT3V0bGV0TWFwLCBsb2NhdGlvbjogTG9jYXRpb24sIGluamVjdG9yOiBJbmplY3RvciwgY29uZmlnOiBSb3V0ZXJDb25maWcsXG4gICAgb3B0czogRXh0cmFPcHRpb25zKSB7XG4gIGlmIChyZWYuY29tcG9uZW50VHlwZXMubGVuZ3RoID09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcCBhdCBsZWFzdCBvbmUgY29tcG9uZW50IGJlZm9yZSBpbmplY3RpbmcgUm91dGVyLicpO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudFR5cGUgPSByZWYuY29tcG9uZW50VHlwZXNbMF07XG4gIGNvbnN0IHIgPVxuICAgICAgbmV3IFJvdXRlcihjb21wb25lbnRUeXBlLCByZXNvbHZlciwgdXJsU2VyaWFsaXplciwgb3V0bGV0TWFwLCBsb2NhdGlvbiwgaW5qZWN0b3IsIGNvbmZpZyk7XG4gIHJlZi5yZWdpc3RlckRpc3Bvc2VMaXN0ZW5lcigoKSA9PiByLmRpc3Bvc2UoKSk7XG5cbiAgaWYgKG9wdHMuZW5hYmxlVHJhY2luZykge1xuICAgIHIuZXZlbnRzLnN1YnNjcmliZShlID0+IHtcbiAgICAgIGNvbnNvbGUuZ3JvdXAoYFJvdXRlciBFdmVudDogJHsoPGFueT5lLmNvbnN0cnVjdG9yKS5uYW1lfWApO1xuICAgICAgY29uc29sZS5sb2coZS50b1N0cmluZygpKTtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFJvdXRlckluaXRpYWxpemVyKGluamVjdG9yOiBJbmplY3Rvcikge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy85MTAxXG4gIC8vIERlbGF5IHRoZSByb3V0ZXIgaW5zdGFudGlhdGlvbiB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IChBcHBsaWNhdGlvblJlZiAtPlxuICAvLyBBUFBfSU5JVElBTElaRVIgLT4gUm91dGVyKVxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjb25zdCBhcHBSZWYgPSBpbmplY3Rvci5nZXQoQXBwbGljYXRpb25SZWYpO1xuICAgIGlmIChhcHBSZWYuY29tcG9uZW50VHlwZXMubGVuZ3RoID09IDApIHtcbiAgICAgIGFwcFJlZi5yZWdpc3RlckJvb3RzdHJhcExpc3RlbmVyKCgpID0+IHsgaW5qZWN0b3IuZ2V0KFJvdXRlcikuaW5pdGlhbE5hdmlnYXRpb24oKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluamVjdG9yLmdldChSb3V0ZXIpLmluaXRpYWxOYXZpZ2F0aW9uKCk7XG4gICAgfVxuICB9LCAwKTtcbiAgcmV0dXJuICgpOiBhbnkgPT4gbnVsbDtcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2Yge0BsaW5rIFByb3ZpZGVyfXMuIFRvIHVzZSB0aGUgcm91dGVyLCB5b3UgbXVzdCBhZGQgdGhpcyB0byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcbiAqIGNsYXNzIEFwcENtcCB7XG4gKiAgIC8vIC4uLlxuICogfVxuICpcbiAqIGNvbnN0IHJvdXRlciA9IFtcbiAqICAge3BhdGg6ICcvaG9tZScsIGNvbXBvbmVudDogSG9tZX1cbiAqIF07XG4gKlxuICogYm9vdHN0cmFwKEFwcENtcCwgW3Byb3ZpZGVSb3V0ZXIocm91dGVyKV0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm92aWRlUm91dGVyKF9jb25maWc6IFJvdXRlckNvbmZpZywgX29wdHM6IEV4dHJhT3B0aW9ucyk6IGFueVtdIHtcbiAgcmV0dXJuIFtcbiAgICB7cHJvdmlkZTogUk9VVEVSX0NPTkZJRywgdXNlVmFsdWU6IF9jb25maWd9LCB7cHJvdmlkZTogUk9VVEVSX09QVElPTlMsIHVzZVZhbHVlOiBfb3B0c30sXG4gICAgTG9jYXRpb24sIHtwcm92aWRlOiBMb2NhdGlvblN0cmF0ZWd5LCB1c2VDbGFzczogUGF0aExvY2F0aW9uU3RyYXRlZ3l9LFxuICAgIHtwcm92aWRlOiBVcmxTZXJpYWxpemVyLCB1c2VDbGFzczogRGVmYXVsdFVybFNlcmlhbGl6ZXJ9LFxuXG4gICAge1xuICAgICAgcHJvdmlkZTogUm91dGVyLFxuICAgICAgdXNlRmFjdG9yeTogc2V0dXBSb3V0ZXIsXG4gICAgICBkZXBzOiBbXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmLCBDb21wb25lbnRSZXNvbHZlciwgVXJsU2VyaWFsaXplciwgUm91dGVyT3V0bGV0TWFwLCBMb2NhdGlvbiwgSW5qZWN0b3IsXG4gICAgICAgIFJPVVRFUl9DT05GSUcsIFJPVVRFUl9PUFRJT05TXG4gICAgICBdXG4gICAgfSxcblxuICAgIFJvdXRlck91dGxldE1hcCxcbiAgICB7cHJvdmlkZTogQWN0aXZhdGVkUm91dGUsIHVzZUZhY3Rvcnk6IChyOiBSb3V0ZXIpID0+IHIucm91dGVyU3RhdGUucm9vdCwgZGVwczogW1JvdXRlcl19LFxuXG4gICAgLy8gVHJpZ2dlciBpbml0aWFsIG5hdmlnYXRpb25cbiAgICB7cHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLCBtdWx0aTogdHJ1ZSwgdXNlRmFjdG9yeTogc2V0dXBSb3V0ZXJJbml0aWFsaXplciwgZGVwczogW0luamVjdG9yXX1cbiAgXTtcbn1cbiJdfQ==

/***/ },
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var app_service_1 = __webpack_require__(454);
	exports.AppService = app_service_1.AppService;
	var translate_service_1 = __webpack_require__(457);
	exports.TranslateService = translate_service_1.TranslateService;
	var project_service_1 = __webpack_require__(458);
	exports.ProjectService = project_service_1.ProjectService;
	var task_service_1 = __webpack_require__(471);
	exports.TaskService = task_service_1.TaskService;
	var reference_service_1 = __webpack_require__(474);
	exports.ReferenceService = reference_service_1.ReferenceService;
	var staff_service_1 = __webpack_require__(476);
	exports.StaffService = staff_service_1.StaffService;
	var upload_service_1 = __webpack_require__(478);
	exports.UploadService = upload_service_1.UploadService;
	exports.APP_SERVICES = [
	    app_service_1.AppService,
	    translate_service_1.TranslateService,
	    project_service_1.ProjectService,
	    task_service_1.TaskService,
	    reference_service_1.ReferenceService,
	    staff_service_1.StaffService,
	    upload_service_1.UploadService
	];


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var authed_reducer_1 = __webpack_require__(455);
	var utils_1 = __webpack_require__(456);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var AppService = (function () {
	    function AppService(http) {
	        this.http = http;
	        this.isLogged = false;
	    }
	    AppService.prototype.getUserProfile = function () {
	        return this.http.get('p?id=userprofile', { headers: HEADERS }).map(function (response) {
	            var res = utils_1.parseResponseObjects(response.json().objects);
	            var pageSize = 20;
	            if (res[0].pagesize) {
	                pageSize = res[0].pagesize;
	            }
	            return {
	                type: authed_reducer_1.FETCH_USER_PROFILE,
	                payload: {
	                    userProfile: res.employee,
	                    languages: res.language.list[0].localizedName,
	                    pageSize: pageSize
	                }
	            };
	        });
	    };
	    AppService.prototype.updateUserProfile = function (user) {
	    };
	    AppService.prototype.logout = function () {
	        return this.http.delete('/');
	    };
	    AppService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [http_1.Http])
	    ], AppService);
	    return AppService;
	}());
	exports.AppService = AppService;


/***/ },
/* 455 */
/***/ function(module, exports) {

	"use strict";
	exports.FETCH_USER_PROFILE = 'FETCH_USER_PROFILE';
	;
	var initialState = {
	    userProfile: null,
	    languages: {},
	    pageSize: 20
	};
	exports.authedReducer = function (state, _a) {
	    if (state === void 0) { state = initialState; }
	    var type = _a.type, payload = _a.payload;
	    switch (type) {
	        case exports.FETCH_USER_PROFILE:
	            return Object.assign({}, state, {
	                userProfile: payload.userProfile,
	                languages: payload.languages,
	                pageSize: payload.pageSize
	            });
	        default:
	            return state;
	    }
	};


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var http_1 = __webpack_require__(329);
	function createURLSearchParams(_params) {
	    var params = new http_1.URLSearchParams();
	    for (var p in _params) {
	        params.set(encodeURIComponent(p), encodeURIComponent(_params[p]));
	    }
	    return params;
	}
	exports.createURLSearchParams = createURLSearchParams;
	function serializeObj(obj) {
	    var result = [];
	    for (var property in obj) {
	        result.push(encodeURIComponent(property) + '=' + encodeURIComponent(obj[property]));
	    }
	    return result.join('&');
	}
	exports.serializeObj = serializeObj;
	function parseResponseObjects(objects) {
	    var result = [];
	    for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
	        var obj = objects_1[_i];
	        if (obj.kind) {
	            result[obj.kind] = obj;
	        }
	        else if (obj.list && obj.meta && obj.type) {
	            result[obj.type] = obj;
	        }
	        else if (obj.name && obj.value) {
	            result[obj.name] = obj.value;
	        }
	        else {
	            result.push(obj);
	        }
	    }
	    return result;
	}
	exports.parseResponseObjects = parseResponseObjects;
	function parseListObjectsToKeyValue(list) {
	    var result = [];
	    if (list) {
	        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
	            var it = list_1[_i];
	            result[it.id] = it;
	        }
	    }
	    return result;
	}
	exports.parseListObjectsToKeyValue = parseListObjectsToKeyValue;
	function transformPostResponse(response) {
	    var json = response.json();
	    return Object.assign(json, {
	        ok: json.type === 'DOCUMENT_SAVED',
	        message: json.captions ? json.captions.type : json.message
	    });
	}
	exports.transformPostResponse = transformPostResponse;
	function createCookie(name, value, days) {
	    var expires;
	    if (days) {
	        var date = new Date();
	        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
	        expires = '; expires=' + date.toUTCString();
	    }
	    else {
	        expires = '';
	    }
	    document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) + expires + '; path=/';
	}
	exports.createCookie = createCookie;


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var TranslateService = (function () {
	    function TranslateService(http) {
	        this.http = http;
	        this.translations = null;
	    }
	    TranslateService.prototype.fetchTranslations = function () {
	        var _this = this;
	        var headers = new http_1.Headers({
	            'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	            'Accept': 'application/json'
	        });
	        return this.http.get('p?id=common-captions', { headers: headers }).map(function (response) {
	            _this.translations = response.json().captions;
	            return _this.translations;
	        });
	    };
	    TranslateService.prototype.getTranslations = function () {
	        return this.translations;
	    };
	    TranslateService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [http_1.Http])
	    ], TranslateService);
	    return TranslateService;
	}());
	exports.TranslateService = TranslateService;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var Observable_1 = __webpack_require__(38);
	var ng2_translate_1 = __webpack_require__(350);
	var projects_reducer_1 = __webpack_require__(459);
	var models_1 = __webpack_require__(460);
	var utils_1 = __webpack_require__(456);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var ProjectService = (function () {
	    function ProjectService(http, translate) {
	        this.http = http;
	        this.translate = translate;
	    }
	    ProjectService.prototype.getProjectStatusTypes = function () {
	        return this.translate.get(['draft', 'processed', 'finished']).map(function (t) { return [
	            { value: 'DRAFT', text: t.draft, default: true },
	            { value: 'PROCESSED', text: t.processed },
	            { value: 'FINISHED', text: t.finished }
	        ]; });
	    };
	    ProjectService.prototype.fetchProjects = function (queryParams) {
	        if (queryParams === void 0) { queryParams = {}; }
	        return this.http.get('p?id=project-view', {
	            headers: HEADERS,
	            search: utils_1.createURLSearchParams(queryParams)
	        })
	            .map(function (response) { return response.json().objects[0]; })
	            .map(function (data) {
	            return {
	                type: projects_reducer_1.FETCH_PROJECTS,
	                payload: {
	                    projects: data.list,
	                    meta: data.meta,
	                    loading: true
	                }
	            };
	        });
	    };
	    ProjectService.prototype.fetchProjectById = function (projectId) {
	        if (projectId === 'new') {
	            return Observable_1.Observable.of({
	                type: projects_reducer_1.FETCH_PROJECT,
	                payload: {
	                    project: new models_1.Project()
	                }
	            });
	        }
	        return this.http.get('p?id=project-form&projectId=' + projectId, { headers: HEADERS })
	            .map(function (response) {
	            var data = utils_1.parseResponseObjects(response.json().objects);
	            var project = data.project;
	            if (data.fsid) {
	                project.fsid = data.fsid;
	            }
	            if (data.attachment) {
	                project.attachments = data.attachment.list;
	            }
	            return {
	                type: projects_reducer_1.FETCH_PROJECT,
	                payload: {
	                    project: project
	                }
	            };
	        });
	    };
	    ProjectService.prototype.saveProject = function (project) {
	        var url = 'p?id=project-form&projectId=' + project.id;
	        return this.http.post(url, utils_1.serializeObj(project), { headers: HEADERS })
	            .map(function (response) { return utils_1.transformPostResponse(response); })
	            .catch(function (error) { return Observable_1.Observable.throw(utils_1.transformPostResponse(error)); });
	    };
	    ProjectService.prototype.deleteProject = function (projects) {
	        return this.http.delete('p?id=project-view&projectIds=' + projects.map(function (it) { return it.id; }).join(','));
	    };
	    ProjectService.prototype.deleteProjectAttachment = function (project, attachment) {
	        return this.http.delete('p?id=project-form&projectId=' + project.id + '&attachmentId=' + attachment.id);
	    };
	    ProjectService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [http_1.Http, ng2_translate_1.TranslateService])
	    ], ProjectService);
	    return ProjectService;
	}());
	exports.ProjectService = ProjectService;


/***/ },
/* 459 */
/***/ function(module, exports) {

	"use strict";
	exports.FETCH_PROJECTS = 'FETCH_PROJECTS';
	exports.FETCH_PROJECT = 'FETCH_PROJECT';
	exports.ADD_PROJECT = 'ADD_PROJECT';
	exports.UPDATE_PROJECT = 'UPDATE_PROJECT';
	exports.DELETE_PROJECT = 'DELETE_PROJECT';
	;
	var initialState = {
	    meta: {},
	    projects: [],
	    project: undefined,
	    loading: false
	};
	exports.projectsReducer = function (state, _a) {
	    if (state === void 0) { state = initialState; }
	    var type = _a.type, payload = _a.payload;
	    switch (type) {
	        case exports.FETCH_PROJECTS:
	            return Object.assign({}, state, {
	                projects: payload.projects,
	                meta: payload.meta
	            });
	        case exports.FETCH_PROJECT:
	            return Object.assign({}, state, {
	                project: payload.project
	            });
	        case exports.ADD_PROJECT:
	            return state;
	        case exports.UPDATE_PROJECT:
	            return state;
	        case exports.DELETE_PROJECT:
	            return state;
	        default:
	            return state;
	    }
	};


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var user_1 = __webpack_require__(461);
	exports.User = user_1.User;
	var organization_1 = __webpack_require__(462);
	exports.Organization = organization_1.Organization;
	var attachment_1 = __webpack_require__(463);
	exports.Attachment = attachment_1.Attachment;
	var project_1 = __webpack_require__(464);
	exports.Project = project_1.Project;
	var task_1 = __webpack_require__(465);
	exports.Task = task_1.Task;
	var tag_1 = __webpack_require__(466);
	exports.Tag = tag_1.Tag;
	var task_type_1 = __webpack_require__(467);
	exports.TaskType = task_type_1.TaskType;
	var comment_1 = __webpack_require__(468);
	exports.Comment = comment_1.Comment;
	var request_1 = __webpack_require__(469);
	exports.Request = request_1.Request;
	var request_type_1 = __webpack_require__(470);
	exports.RequestType = request_type_1.RequestType;


/***/ },
/* 461 */
/***/ function(module, exports) {

	"use strict";
	var User = (function () {
	    function User() {
	        this.id = '';
	        this.userName = '@anonymous';
	    }
	    return User;
	}());
	exports.User = User;


/***/ },
/* 462 */
/***/ function(module, exports) {

	"use strict";
	var Organization = (function () {
	    function Organization() {
	        this.id = '';
	    }
	    return Organization;
	}());
	exports.Organization = Organization;


/***/ },
/* 463 */
/***/ function(module, exports) {

	"use strict";
	var Attachment = (function () {
	    function Attachment() {
	        this.id = '';
	    }
	    return Attachment;
	}());
	exports.Attachment = Attachment;


/***/ },
/* 464 */
/***/ function(module, exports) {

	"use strict";
	var Project = (function () {
	    function Project() {
	        this.id = '';
	        this.fsid = '' + Date.now();
	        this.status = 'DRAFT';
	    }
	    return Project;
	}());
	exports.Project = Project;


/***/ },
/* 465 */
/***/ function(module, exports) {

	"use strict";
	var Task = (function () {
	    function Task() {
	        this.id = '';
	        this.fsid = '' + Date.now();
	        this.status = 'DRAFT';
	        this.priority = 'NORMAL';
	    }
	    return Task;
	}());
	exports.Task = Task;


/***/ },
/* 466 */
/***/ function(module, exports) {

	"use strict";
	var Tag = (function () {
	    function Tag() {
	        this.id = '';
	    }
	    return Tag;
	}());
	exports.Tag = Tag;


/***/ },
/* 467 */
/***/ function(module, exports) {

	"use strict";
	var TaskType = (function () {
	    function TaskType() {
	        this.id = '';
	    }
	    return TaskType;
	}());
	exports.TaskType = TaskType;


/***/ },
/* 468 */
/***/ function(module, exports) {

	"use strict";
	var Comment = (function () {
	    function Comment() {
	        this.id = '';
	        this.fsid = '' + Date.now();
	    }
	    return Comment;
	}());
	exports.Comment = Comment;


/***/ },
/* 469 */
/***/ function(module, exports) {

	"use strict";
	var Request = (function () {
	    function Request() {
	        this.id = '';
	        this.fsid = '' + Date.now();
	    }
	    return Request;
	}());
	exports.Request = Request;


/***/ },
/* 470 */
/***/ function(module, exports) {

	"use strict";
	var RequestType = (function () {
	    function RequestType() {
	        this.id = '';
	    }
	    return RequestType;
	}());
	exports.RequestType = RequestType;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var Observable_1 = __webpack_require__(38);
	var ng2_translate_1 = __webpack_require__(350);
	var tasks_reducer_1 = __webpack_require__(472);
	var task_reducer_1 = __webpack_require__(473);
	var models_1 = __webpack_require__(460);
	var utils_1 = __webpack_require__(456);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var TaskService = (function () {
	    function TaskService(http, translate) {
	        this.http = http;
	        this.translate = translate;
	    }
	    TaskService.prototype.getTaskPriorityTypes = function () {
	        return this.translate.get(['urgent', 'high', 'medium', 'normal']).map(function (t) { return [
	            { value: 'NORMAL', text: t.normal, default: true },
	            { value: 'MEDIUM', text: t.medium },
	            { value: 'HIGH', text: t.high },
	            { value: 'URGENT', text: t.urgent }
	        ]; });
	    };
	    TaskService.prototype.getTaskStatusTypes = function () {
	        return this.translate.get(['draft', 'waiting', 'processed', 'finished']).map(function (t) { return [
	            { value: 'DRAFT', text: t.draft, default: true },
	            { value: 'WAITING', text: t.waiting },
	            { value: 'PROCESSED', text: t.processed },
	            { value: 'FINISHED', text: t.finished }
	        ]; });
	    };
	    TaskService.prototype.fetchTasks = function (queryParams) {
	        if (queryParams === void 0) { queryParams = {}; }
	        return this.http.get('p?id=task-view', {
	            headers: HEADERS,
	            search: utils_1.createURLSearchParams(queryParams)
	        })
	            .map(function (response) { return response.json().objects[0]; })
	            .map(function (data) {
	            return {
	                type: tasks_reducer_1.FETCH_TASKS,
	                payload: {
	                    tasks: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    TaskService.prototype.fetchTaskById = function (taskId) {
	        if (taskId === 'new') {
	            return Observable_1.Observable.of({
	                type: tasks_reducer_1.FETCH_TASK,
	                payload: {
	                    task: new models_1.Task()
	                }
	            });
	        }
	        return this.http.get('p?id=task-form&taskId=' + taskId, { headers: HEADERS })
	            .map(function (response) {
	            var data = utils_1.parseResponseObjects(response.json().objects);
	            var task = data.task;
	            if (data.fsid) {
	                task.fsid = data.fsid;
	            }
	            if (data.attachment) {
	                task.attachments = data.attachment.list;
	            }
	            return {
	                type: tasks_reducer_1.FETCH_TASK,
	                payload: {
	                    task: task
	                }
	            };
	        });
	    };
	    TaskService.prototype.saveTask = function (task) {
	        var url = 'p?id=task-form' + (task.id ? '&taskId=' + task.id : '');
	        return this.http.post(url, utils_1.serializeObj(task), { headers: HEADERS })
	            .map(function (response) { return utils_1.transformPostResponse(response); })
	            .catch(function (error) { return Observable_1.Observable.throw(utils_1.transformPostResponse(error)); });
	    };
	    TaskService.prototype.deleteTask = function (tasks) {
	        return this.http.delete('p?id=task-view&taskIds=' + tasks.map(function (it) { return it.id; }).join(','));
	    };
	    TaskService.prototype.deleteTaskAttachment = function (task, attachment) {
	        return this.http.delete('p?id=task-form&taskId=' + task.id + '&attachmentId=' + attachment.id);
	    };
	    TaskService.prototype.fetchTaskRequests = function (task, page) {
	        if (page === void 0) { page = 0; }
	        return this.http.get('p?id=task-requests&taskId=' + task.id, { headers: HEADERS })
	            .map(function (response) { return utils_1.parseResponseObjects(response.json().objects).request || {}; })
	            .map(function (data) {
	            return {
	                type: task_reducer_1.FETCH_REQUESTS,
	                payload: {
	                    requests: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    TaskService.prototype.sendTaskRequest = function (request) {
	        var url = 'p?id=task-requests&taskId=' + request.taskId;
	        return this.http.post(url, utils_1.serializeObj(request), { headers: HEADERS })
	            .map(function (response) { return utils_1.transformPostResponse(response); })
	            .catch(function (error) { return Observable_1.Observable.throw(utils_1.transformPostResponse(error)); });
	    };
	    TaskService.prototype.doRequestResolution = function (request, resolution) {
	        var url = 'p?id=task-requests&requestId=' + request.id + '&resolution=' + resolution;
	        return this.http.put(url, '', { headers: HEADERS })
	            .map(function (response) { return utils_1.transformPostResponse(response); })
	            .catch(function (error) { return Observable_1.Observable.throw(utils_1.transformPostResponse(error)); });
	    };
	    TaskService.prototype.deleteRequest = function (request) {
	        return this.http.delete('p?id=task-requests&requestId=' + request.id);
	    };
	    TaskService.prototype.deleteRequestAttachment = function (request, attachment) {
	        return this.http.delete('p?id=task-requests&requestId=' + request.id + '&attachmentId=' + attachment.id);
	    };
	    TaskService.prototype.fetchComments = function (task, page) {
	        if (page === void 0) { page = 0; }
	        return this.http.get('p?id=comments&taskId=' + task.id, { headers: HEADERS })
	            .map(function (response) { return utils_1.parseResponseObjects(response.json().objects).comment || {}; })
	            .map(function (data) {
	            return {
	                type: task_reducer_1.FETCH_COMMENTS,
	                payload: {
	                    comments: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    TaskService.prototype.saveComment = function (task, comment) {
	        var url = 'p?id=comments&taskId=' + task.id + (comment.id ? '&commentId=' + comment.id : '');
	        return this.http.post(url, utils_1.serializeObj(comment), { headers: HEADERS })
	            .map(function (response) { return utils_1.transformPostResponse(response); })
	            .catch(function (error) { return Observable_1.Observable.throw(utils_1.transformPostResponse(error)); });
	    };
	    TaskService.prototype.deleteComment = function (comment) {
	        return this.http.delete('p?id=comments&commentId=' + comment.id);
	    };
	    TaskService.prototype.deleteCommentAttachment = function (comment, attachment) {
	        return this.http.delete('p?id=comments&commentId=' + comment.id + '&attachmentId=' + attachment.id);
	    };
	    TaskService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [http_1.Http, ng2_translate_1.TranslateService])
	    ], TaskService);
	    return TaskService;
	}());
	exports.TaskService = TaskService;


/***/ },
/* 472 */
/***/ function(module, exports) {

	"use strict";
	exports.FETCH_TASKS = 'FETCH_TASKS';
	exports.FETCH_TASK = 'FETCH_TASK';
	exports.ADD_TASK = 'ADD_TASK';
	exports.UPDATE_TASK = 'UPDATE_TASK';
	exports.DELETE_TASK = 'DELETE_TASK';
	;
	var initialState = {
	    meta: {},
	    tasks: [],
	    loading: false
	};
	exports.tasksReducer = function (state, _a) {
	    if (state === void 0) { state = initialState; }
	    var type = _a.type, payload = _a.payload;
	    switch (type) {
	        case exports.FETCH_TASKS:
	            return Object.assign({}, state, {
	                tasks: payload.tasks,
	                meta: payload.meta
	            });
	        case exports.FETCH_TASK:
	            return Object.assign({}, state, {
	                task: payload.task
	            });
	        case exports.ADD_TASK:
	            return state;
	        case exports.UPDATE_TASK:
	            return state;
	        case exports.DELETE_TASK:
	            return state;
	        default:
	            return state;
	    }
	};


/***/ },
/* 473 */
/***/ function(module, exports) {

	"use strict";
	exports.TASK_REQUEST_NEW = 'TASK_REQUEST_NEW';
	exports.TASK_REQUEST_CANCEL = 'TASK_REQUEST_CANCEL';
	exports.FETCH_COMMENTS = 'FETCH_COMMENTS';
	exports.FETCH_REQUESTS = 'FETCH_REQUESTS';
	exports.TASK_CLOSE = 'TASK_CLOSE';
	;
	var initialState = {
	    task: null,
	    request: null,
	    requests: [],
	    showRequest: false,
	    comments: []
	};
	exports.taskReducer = function (state, _a) {
	    if (state === void 0) { state = initialState; }
	    var type = _a.type, payload = _a.payload;
	    switch (type) {
	        case exports.FETCH_REQUESTS:
	            return Object.assign({}, state, {
	                requests: payload.requests
	            });
	        case exports.TASK_REQUEST_NEW:
	            return Object.assign({}, state, {
	                task: payload,
	                showRequest: true
	            });
	        case exports.TASK_REQUEST_CANCEL:
	            return Object.assign({}, state, {
	                showRequest: false
	            });
	        case exports.FETCH_COMMENTS:
	            return Object.assign({}, state, {
	                comments: payload.comments
	            });
	        case exports.TASK_CLOSE:
	            return {
	                task: null,
	                request: null,
	                requests: [],
	                showRequest: false,
	                comments: []
	            };
	        default:
	            return state;
	    }
	};


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var store_1 = __webpack_require__(437);
	var reference_reducer_1 = __webpack_require__(475);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var ReferenceService = (function () {
	    function ReferenceService(http, store) {
	        this.http = http;
	        this.store = store;
	    }
	    ReferenceService.prototype.loadReference = function () {
	        var _this = this;
	        this.fetchTags().subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	        this.fetchTaskTypes().subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	        this.fetchRequestTypes().subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	    };
	    ReferenceService.prototype.fetchTags = function () {
	        return this.http.get('/Reference/p?id=tags', { headers: HEADERS })
	            .map(function (response) { return response.json().objects[0]; })
	            .map(function (data) {
	            return {
	                type: reference_reducer_1.FETCH_TAGS,
	                payload: {
	                    tags: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    ReferenceService.prototype.fetchTaskTypes = function () {
	        return this.http.get('/Reference/p?id=tasktypes', { headers: HEADERS })
	            .map(function (response) { return response.json().objects[0]; })
	            .map(function (data) {
	            return {
	                type: reference_reducer_1.FETCH_TASK_TYPES,
	                payload: {
	                    taskTypes: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    ReferenceService.prototype.fetchRequestTypes = function () {
	        return this.http.get('/Reference/p?id=request-types', { headers: HEADERS })
	            .map(function (response) { return response.json().objects[0]; })
	            .map(function (data) {
	            return {
	                type: reference_reducer_1.FETCH_REQUEST_TYPES,
	                payload: {
	                    requestTypes: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    ReferenceService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [http_1.Http, store_1.Store])
	    ], ReferenceService);
	    return ReferenceService;
	}());
	exports.ReferenceService = ReferenceService;


/***/ },
/* 475 */
/***/ function(module, exports) {

	"use strict";
	exports.FETCH_TAGS = 'FETCH_TAGS';
	exports.FETCH_TASK_TYPES = 'FETCH_TASK_TYPES';
	exports.FETCH_REQUEST_TYPES = 'FETCH_REQUEST_TYPES';
	;
	var initialState = {
	    tags: [],
	    taskTypes: [],
	    requestTypes: []
	};
	exports.referenceReducer = function (state, _a) {
	    if (state === void 0) { state = initialState; }
	    var type = _a.type, payload = _a.payload;
	    switch (type) {
	        case exports.FETCH_TAGS:
	            return Object.assign({}, state, {
	                tags: payload.tags
	            });
	        case exports.FETCH_TASK_TYPES:
	            return Object.assign({}, state, {
	                taskTypes: payload.taskTypes
	            });
	        case exports.FETCH_REQUEST_TYPES:
	            return Object.assign({}, state, {
	                requestTypes: payload.requestTypes
	            });
	        default:
	            return state;
	    }
	};


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var staff_reducer_1 = __webpack_require__(477);
	var utils_1 = __webpack_require__(456);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var StaffService = (function () {
	    function StaffService(http) {
	        this.http = http;
	    }
	    StaffService.prototype.fetchOrganizations = function (queryParams) {
	        if (queryParams === void 0) { queryParams = {}; }
	        return this.http.get('/Staff/p?id=get-organizations', {
	            headers: HEADERS,
	            search: utils_1.createURLSearchParams(queryParams)
	        })
	            .map(function (response) { return response.json().objects[0]; })
	            .map(function (data) {
	            return {
	                type: staff_reducer_1.FETCH_ORGANIZATIONS,
	                payload: {
	                    organizations: data.list,
	                    meta: data.meta
	                }
	            };
	        });
	    };
	    StaffService.prototype.fetchUsers = function () {
	        return this.http.get('p?id=users', { headers: HEADERS })
	            .map(function (response) {
	            return {
	                type: staff_reducer_1.FETCH_USERS,
	                payload: {
	                    users: response.json().objects[0].list
	                }
	            };
	        });
	    };
	    StaffService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [http_1.Http])
	    ], StaffService);
	    return StaffService;
	}());
	exports.StaffService = StaffService;


/***/ },
/* 477 */
/***/ function(module, exports) {

	"use strict";
	exports.FETCH_ORGANIZATIONS = 'FETCH_ORGANIZATIONS';
	exports.FETCH_USERS = 'FETCH_USERS';
	;
	var initialState = {
	    organizations: [],
	    users: []
	};
	exports.staffReducer = function (state, _a) {
	    if (state === void 0) { state = initialState; }
	    var type = _a.type, payload = _a.payload;
	    switch (type) {
	        case exports.FETCH_ORGANIZATIONS:
	            return Object.assign({}, state, {
	                organizations: payload.organizations
	            });
	        case exports.FETCH_USERS:
	            return Object.assign({}, state, {
	                users: payload.users
	            });
	        default:
	            return state;
	    }
	};


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var Rx_1 = __webpack_require__(479);
	var UploadService = (function () {
	    function UploadService() {
	        var _this = this;
	        this.progress$ = Rx_1.Observable.create(function (observer) {
	            _this.progressObserver = observer;
	        }).share();
	    }
	    UploadService.prototype.makeFileRequest = function (url, params, files) {
	        var _this = this;
	        return Rx_1.Observable.create(function (observer) {
	            var formData = new FormData(), xhr = new XMLHttpRequest();
	            for (var i = 0; i < files.length; i++) {
	                formData.append('uploads[]', files[i], files[i].name);
	            }
	            if (params) {
	                for (var k in params) {
	                    formData.append(k, params[k]);
	                }
	            }
	            xhr.onreadystatechange = function () {
	                if (xhr.readyState === 4) {
	                    if (xhr.status === 200) {
	                        observer.next(JSON.parse(xhr.response));
	                        observer.complete();
	                    }
	                    else {
	                        observer.error(xhr.response);
	                    }
	                }
	            };
	            xhr.upload.onprogress = function (event) {
	                var progress = Math.round(event.loaded / event.total * 100);
	                _this.progressObserver.next(progress);
	            };
	            xhr.open('POST', url, true);
	            xhr.send(formData);
	        });
	    };
	    UploadService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], UploadService);
	    return UploadService;
	}());
	exports.UploadService = UploadService;


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable:no-unused-variable */
	// Subject imported before Observable to bypass circular dependency issue since
	// Subject extends Observable and Observable references Subject in it's
	// definition
	var Subject_1 = __webpack_require__(37);
	exports.Subject = Subject_1.Subject;
	/* tslint:enable:no-unused-variable */
	var Observable_1 = __webpack_require__(38);
	exports.Observable = Observable_1.Observable;
	// statics
	/* tslint:disable:no-use-before-declare */
	__webpack_require__(480);
	__webpack_require__(484);
	__webpack_require__(487);
	__webpack_require__(489);
	__webpack_require__(491);
	__webpack_require__(494);
	__webpack_require__(496);
	__webpack_require__(408);
	__webpack_require__(497);
	__webpack_require__(500);
	__webpack_require__(503);
	__webpack_require__(504);
	__webpack_require__(506);
	__webpack_require__(512);
	__webpack_require__(514);
	__webpack_require__(516);
	__webpack_require__(353);
	__webpack_require__(520);
	__webpack_require__(523);
	__webpack_require__(526);
	__webpack_require__(530);
	//operators
	__webpack_require__(533);
	__webpack_require__(535);
	__webpack_require__(537);
	__webpack_require__(539);
	__webpack_require__(541);
	__webpack_require__(543);
	__webpack_require__(547);
	__webpack_require__(549);
	__webpack_require__(551);
	__webpack_require__(401);
	__webpack_require__(552);
	__webpack_require__(403);
	__webpack_require__(554);
	__webpack_require__(557);
	__webpack_require__(559);
	__webpack_require__(561);
	__webpack_require__(563);
	__webpack_require__(565);
	__webpack_require__(567);
	__webpack_require__(569);
	__webpack_require__(571);
	__webpack_require__(572);
	__webpack_require__(574);
	__webpack_require__(576);
	__webpack_require__(578);
	__webpack_require__(580);
	__webpack_require__(583);
	__webpack_require__(588);
	__webpack_require__(590);
	__webpack_require__(592);
	__webpack_require__(594);
	__webpack_require__(596);
	__webpack_require__(405);
	__webpack_require__(363);
	__webpack_require__(598);
	__webpack_require__(600);
	__webpack_require__(365);
	__webpack_require__(407);
	__webpack_require__(399);
	__webpack_require__(602);
	__webpack_require__(603);
	__webpack_require__(604);
	__webpack_require__(605);
	__webpack_require__(608);
	__webpack_require__(609);
	__webpack_require__(611);
	__webpack_require__(613);
	__webpack_require__(614);
	__webpack_require__(616);
	__webpack_require__(617);
	__webpack_require__(619);
	__webpack_require__(621);
	__webpack_require__(623);
	__webpack_require__(625);
	__webpack_require__(627);
	__webpack_require__(397);
	__webpack_require__(359);
	__webpack_require__(629);
	__webpack_require__(631);
	__webpack_require__(633);
	__webpack_require__(635);
	__webpack_require__(637);
	__webpack_require__(639);
	__webpack_require__(648);
	__webpack_require__(650);
	__webpack_require__(652);
	__webpack_require__(654);
	__webpack_require__(657);
	__webpack_require__(659);
	__webpack_require__(661);
	__webpack_require__(663);
	__webpack_require__(665);
	__webpack_require__(667);
	__webpack_require__(669);
	__webpack_require__(373);
	__webpack_require__(428);
	__webpack_require__(671);
	__webpack_require__(673);
	__webpack_require__(675);
	__webpack_require__(677);
	__webpack_require__(679);
	__webpack_require__(681);
	__webpack_require__(682);
	__webpack_require__(683);
	/* tslint:disable:no-unused-variable */
	var Operator_1 = __webpack_require__(685);
	exports.Operator = Operator_1.Operator;
	var Subscription_1 = __webpack_require__(44);
	exports.Subscription = Subscription_1.Subscription;
	var Subscriber_1 = __webpack_require__(42);
	exports.Subscriber = Subscriber_1.Subscriber;
	var AsyncSubject_1 = __webpack_require__(483);
	exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
	var ReplaySubject_1 = __webpack_require__(546);
	exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
	var BehaviorSubject_1 = __webpack_require__(422);
	exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
	var ConnectableObservable_1 = __webpack_require__(362);
	exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
	var Notification_1 = __webpack_require__(414);
	exports.Notification = Notification_1.Notification;
	var EmptyError_1 = __webpack_require__(582);
	exports.EmptyError = EmptyError_1.EmptyError;
	var ArgumentOutOfRangeError_1 = __webpack_require__(656);
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	var ObjectUnsubscribedError_1 = __webpack_require__(56);
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
	var UnsubscriptionError_1 = __webpack_require__(49);
	exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
	var asap_1 = __webpack_require__(642);
	var async_1 = __webpack_require__(510);
	var queue_1 = __webpack_require__(448);
	var rxSubscriber_1 = __webpack_require__(50);
	var iterator_1 = __webpack_require__(371);
	var observable = __webpack_require__(52);
	/* tslint:enable:no-unused-variable */
	/**
	 * @typedef {Object} Rx.Scheduler
	 * @property {Scheduler} queue Schedules on a queue in the current event frame
	 * (trampoline scheduler). Use this for iteration operations.
	 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
	 * fastest transport mechanism available, either Node.js' `process.nextTick()`
	 * or Web Worker MessageChannel or setTimeout or others. Use this for
	 * asynchronous conversions.
	 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
	 * time-based operations.
	 */
	var Scheduler = {
	    asap: asap_1.asap,
	    async: async_1.async,
	    queue: queue_1.queue
	};
	exports.Scheduler = Scheduler;
	/**
	 * @typedef {Object} Rx.Symbol
	 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
	 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
	 * an object that has all of the traits of an Rx Subscriber, including the
	 * ability to add and remove subscriptions to the subscription chain and
	 * guarantees involving event triggering (can't "next" after unsubscription,
	 * etc).
	 * @property {Symbol|string} observable A symbol to use as a property name to
	 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
	 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
	 * to retrieve an iterator from an object.
	 */
	var Symbol = {
	    rxSubscriber: rxSubscriber_1.$$rxSubscriber,
	    observable: observable,
	    iterator: iterator_1.$$iterator
	};
	exports.Symbol = Symbol;
	//# sourceMappingURL=Rx.js.map

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var bindCallback_1 = __webpack_require__(481);
	Observable_1.Observable.bindCallback = bindCallback_1.bindCallback;
	//# sourceMappingURL=bindCallback.js.map

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BoundCallbackObservable_1 = __webpack_require__(482);
	exports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;
	//# sourceMappingURL=bindCallback.js.map

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var AsyncSubject_1 = __webpack_require__(483);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundCallbackObservable = (function (_super) {
	    __extends(BoundCallbackObservable, _super);
	    function BoundCallbackObservable(callbackFunc, selector, args, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a callback API to a function that returns an Observable.
	     *
	     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
	     * it will return a function `g` that when called as `g(x)` will output an
	     * Observable.</span>
	     *
	     * `bindCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done. The output of `bindCallback` is a function that takes the same
	     * parameters as `func`, except the last one (the callback). When the output
	     * function is called with arguments, it will return an Observable where the
	     * results will be delivered to.
	     *
	     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
	     * // Suppose we have jQuery.getJSON('/my/url', callback)
	     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
	     * var result = getJSONAsObservable('/my/url');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindNodeCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a callback as the last parameter.
	     * @param {function} selector A function which takes the arguments from the
	     * callback and maps those a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the callback would deliver.
	     * @static true
	     * @name bindCallback
	     * @owner Observable
	     */
	    BoundCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundCallbackObservable(func, selector, args, scheduler);
	        };
	    };
	    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    if (selector) {
	                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1.errorObject) {
	                            subject.error(errorObject_1.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	                if (result === errorObject_1.errorObject) {
	                    subject.error(errorObject_1.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber });
	        }
	    };
	    return BoundCallbackObservable;
	}(Observable_1.Observable));
	exports.BoundCallbackObservable = BoundCallbackObservable;
	function dispatch(state) {
	    var self = this;
	    var source = state.source, subscriber = state.subscriber;
	    var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
	    var subject = source.subject;
	    if (!subject) {
	        subject = source.subject = new AsyncSubject_1.AsyncSubject();
	        var handler = function handlerFn() {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i - 0] = arguments[_i];
	            }
	            var source = handlerFn.source;
	            var selector = source.selector, subject = source.subject;
	            if (selector) {
	                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                if (result_2 === errorObject_1.errorObject) {
	                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	                }
	                else {
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                }
	            }
	            else {
	                var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
	                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	            }
	        };
	        // use named function to pass values in without closure
	        handler.source = source;
	        var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	        if (result === errorObject_1.errorObject) {
	            subject.error(errorObject_1.errorObject.e);
	        }
	    }
	    self.add(subject.subscribe(subscriber));
	}
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}
	//# sourceMappingURL=BoundCallbackObservable.js.map

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(37);
	/**
	 * @class AsyncSubject<T>
	 */
	var AsyncSubject = (function (_super) {
	    __extends(AsyncSubject, _super);
	    function AsyncSubject() {
	        _super.apply(this, arguments);
	        this.value = null;
	        this.hasNext = false;
	    }
	    AsyncSubject.prototype._subscribe = function (subscriber) {
	        if (this.hasCompleted && this.hasNext) {
	            subscriber.next(this.value);
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    AsyncSubject.prototype._next = function (value) {
	        this.value = value;
	        this.hasNext = true;
	    };
	    AsyncSubject.prototype._complete = function () {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.isUnsubscribed = true;
	        if (this.hasNext) {
	            while (++index < len) {
	                var o = observers[index];
	                o.next(this.value);
	                o.complete();
	            }
	        }
	        else {
	            while (++index < len) {
	                observers[index].complete();
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    return AsyncSubject;
	}(Subject_1.Subject));
	exports.AsyncSubject = AsyncSubject;
	//# sourceMappingURL=AsyncSubject.js.map

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var bindNodeCallback_1 = __webpack_require__(485);
	Observable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
	//# sourceMappingURL=bindNodeCallback.js.map

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BoundNodeCallbackObservable_1 = __webpack_require__(486);
	exports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;
	//# sourceMappingURL=bindNodeCallback.js.map

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var AsyncSubject_1 = __webpack_require__(483);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundNodeCallbackObservable = (function (_super) {
	    __extends(BoundNodeCallbackObservable, _super);
	    function BoundNodeCallbackObservable(callbackFunc, selector, args, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a Node.js-style callback API to a function that returns an
	     * Observable.
	     *
	     * <span class="informal">It's just like {@link bindCallback}, but the
	     * callback is expected to be of type `callback(error, result)`.</span>
	     *
	     * `bindNodeCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done. The callback function is expected to follow Node.js conventions,
	     * where the first argument to the callback is an error, while remaining
	     * arguments are the callback result. The output of `bindNodeCallback` is a
	     * function that takes the same parameters as `func`, except the last one (the
	     * callback). When the output function is called with arguments, it will
	     * return an Observable where the results will be delivered to.
	     *
	     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
	     * import * as fs from 'fs';
	     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
	     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a callback as the last parameter.
	     * @param {function} selector A function which takes the arguments from the
	     * callback and maps those a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the Node.js callback would
	     * deliver.
	     * @static true
	     * @name bindNodeCallback
	     * @owner Observable
	     */
	    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundNodeCallbackObservable(func, selector, args, scheduler);
	        };
	    };
	    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    var err = innerArgs.shift();
	                    if (err) {
	                        subject.error(err);
	                    }
	                    else if (selector) {
	                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1.errorObject) {
	                            subject.error(errorObject_1.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	                if (result === errorObject_1.errorObject) {
	                    subject.error(errorObject_1.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber });
	        }
	    };
	    return BoundNodeCallbackObservable;
	}(Observable_1.Observable));
	exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;
	function dispatch(state) {
	    var self = this;
	    var source = state.source, subscriber = state.subscriber;
	    var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
	    var subject = source.subject;
	    if (!subject) {
	        subject = source.subject = new AsyncSubject_1.AsyncSubject();
	        var handler = function handlerFn() {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i - 0] = arguments[_i];
	            }
	            var source = handlerFn.source;
	            var selector = source.selector, subject = source.subject;
	            var err = innerArgs.shift();
	            if (err) {
	                subject.error(err);
	            }
	            else if (selector) {
	                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                if (result_2 === errorObject_1.errorObject) {
	                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	                }
	                else {
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                }
	            }
	            else {
	                var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
	                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	            }
	        };
	        // use named function to pass values in without closure
	        handler.source = source;
	        var result = tryCatch_1.tryCatch(callbackFunc).apply(this, args.concat(handler));
	        if (result === errorObject_1.errorObject) {
	            subject.error(errorObject_1.errorObject.e);
	        }
	    }
	    self.add(subject.subscribe(subscriber));
	}
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}
	//# sourceMappingURL=BoundNodeCallbackObservable.js.map

/***/ },
/* 487 */,
/* 488 */,
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var concat_1 = __webpack_require__(490);
	Observable_1.Observable.concat = concat_1.concat;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var concat_1 = __webpack_require__(402);
	exports.concat = concat_1.concatStatic;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var defer_1 = __webpack_require__(492);
	Observable_1.Observable.defer = defer_1.defer;
	//# sourceMappingURL=defer.js.map

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var DeferObservable_1 = __webpack_require__(493);
	exports.defer = DeferObservable_1.DeferObservable.create;
	//# sourceMappingURL=defer.js.map

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var subscribeToResult_1 = __webpack_require__(369);
	var OuterSubscriber_1 = __webpack_require__(368);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var DeferObservable = (function (_super) {
	    __extends(DeferObservable, _super);
	    function DeferObservable(observableFactory) {
	        _super.call(this);
	        this.observableFactory = observableFactory;
	    }
	    /**
	     * Creates an Observable that, on subscribe, calls an Observable factory to
	     * make an Observable for each new Observer.
	     *
	     * <span class="informal">Creates the Observable lazily, that is, only when it
	     * is subscribed.
	     * </span>
	     *
	     * <img src="./img/defer.png" width="100%">
	     *
	     * `defer` allows you to create the Observable only when the Observer
	     * subscribes, and create a fresh Observable for each Observer. It waits until
	     * an Observer subscribes to it, and then it generates an Observable,
	     * typically with an Observable factory function. It does this afresh for each
	     * subscriber, so although each subscriber may think it is subscribing to the
	     * same Observable, in fact each subscriber gets its own individual
	     * Observable.
	     *
	     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
	     * var clicksOrInterval = Rx.Observable.defer(function () {
	     *   if (Math.random() > 0.5) {
	     *     return Rx.Observable.fromEvent(document, 'click');
	     *   } else {
	     *     return Rx.Observable.interval(1000);
	     *   }
	     * });
	     * clicksOrInterval.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     *
	     * @param {function(): Observable|Promise} observableFactory The Observable
	     * factory function to invoke for each Observer that subscribes to the output
	     * Observable. May also return a Promise, which will be converted on the fly
	     * to an Observable.
	     * @return {Observable} An Observable whose Observers' subscriptions trigger
	     * an invocation of the given Observable factory function.
	     * @static true
	     * @name defer
	     * @owner Observable
	     */
	    DeferObservable.create = function (observableFactory) {
	        return new DeferObservable(observableFactory);
	    };
	    DeferObservable.prototype._subscribe = function (subscriber) {
	        return new DeferSubscriber(subscriber, this.observableFactory);
	    };
	    return DeferObservable;
	}(Observable_1.Observable));
	exports.DeferObservable = DeferObservable;
	var DeferSubscriber = (function (_super) {
	    __extends(DeferSubscriber, _super);
	    function DeferSubscriber(destination, factory) {
	        _super.call(this, destination);
	        this.factory = factory;
	        this.tryDefer();
	    }
	    DeferSubscriber.prototype.tryDefer = function () {
	        try {
	            this._callFactory();
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    DeferSubscriber.prototype._callFactory = function () {
	        var result = this.factory();
	        if (result) {
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return DeferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=DeferObservable.js.map

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var empty_1 = __webpack_require__(495);
	Observable_1.Observable.empty = empty_1.empty;
	//# sourceMappingURL=empty.js.map

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EmptyObservable_1 = __webpack_require__(357);
	exports.empty = EmptyObservable_1.EmptyObservable.create;
	//# sourceMappingURL=empty.js.map

/***/ },
/* 496 */,
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var fromEvent_1 = __webpack_require__(498);
	Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
	//# sourceMappingURL=fromEvent.js.map

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventObservable_1 = __webpack_require__(499);
	exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
	//# sourceMappingURL=fromEvent.js.map

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var Subscription_1 = __webpack_require__(44);
	function isNodeStyleEventEmmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isNodeList(sourceObj) {
	    return !!sourceObj && sourceObj.toString() === '[object NodeList]';
	}
	function isHTMLCollection(sourceObj) {
	    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';
	}
	function isEventTarget(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventObservable = (function (_super) {
	    __extends(FromEventObservable, _super);
	    function FromEventObservable(sourceObj, eventName, selector) {
	        _super.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	    }
	    /**
	     * Creates an Observable that emits events of a specific type coming from the
	     * given event target.
	     *
	     * <span class="informal">Creates an Observable from DOM events, or Node
	     * EventEmitter events or others.</span>
	     *
	     * <img src="./img/fromEvent.png" width="100%">
	     *
	     * Creates an Observable by attaching an event listener to an "event target",
	     * which may be an object with `addEventListener` and `removeEventListener`,
	     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
	     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
	     * the output Observable is subscribed, and removed when the Subscription is
	     * unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * var clicks = Rx.Observable.fromEvent(document, 'click');
	     * clicks.subscribe(x => console.log(x));
	     *
	     * @see {@link from}
	     * @see {@link fromEventPattern}
	     *
	     * @param {EventTargetLike} target The DOMElement, event target, Node.js
	     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
	     * @param {string} eventName The event name of interest, being emitted by the
	     * `target`.
	     * @param {function(...args: any): T} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEvent
	     * @owner Observable
	     */
	    FromEventObservable.create = function (target, eventName, selector) {
	        return new FromEventObservable(target, eventName, selector);
	    };
	    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {
	        var unsubscribe;
	        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
	            }
	        }
	        else if (isEventTarget(sourceObj)) {
	            sourceObj.addEventListener(eventName, handler);
	            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };
	        }
	        else if (isJQueryStyleEventEmitter(sourceObj)) {
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () { return sourceObj.off(eventName, handler); };
	        }
	        else if (isNodeStyleEventEmmitter(sourceObj)) {
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };
	        }
	        subscriber.add(new Subscription_1.Subscription(unsubscribe));
	    };
	    FromEventObservable.prototype._subscribe = function (subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var selector = this.selector;
	        var handler = selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
	            if (result === errorObject_1.errorObject) {
	                subscriber.error(errorObject_1.errorObject.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { return subscriber.next(e); };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
	    };
	    return FromEventObservable;
	}(Observable_1.Observable));
	exports.FromEventObservable = FromEventObservable;
	//# sourceMappingURL=FromEventObservable.js.map

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var fromEventPattern_1 = __webpack_require__(501);
	Observable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;
	//# sourceMappingURL=fromEventPattern.js.map

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventPatternObservable_1 = __webpack_require__(502);
	exports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;
	//# sourceMappingURL=fromEventPattern.js.map

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var Subscription_1 = __webpack_require__(44);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventPatternObservable = (function (_super) {
	    __extends(FromEventPatternObservable, _super);
	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _super.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }
	    /**
	     * Creates an Observable from an API based on addHandler/removeHandler
	     * functions.
	     *
	     * <span class="informal">Converts any addHandler/removeHandler API to an
	     * Observable.</span>
	     *
	     * <img src="./img/fromEventPattern.png" width="100%">
	     *
	     * Creates an Observable by using the `addHandler` and `removeHandler`
	     * functions to add and remove the handlers, with an optional selector
	     * function to project the event arguments to a result. The `addHandler` is
	     * called when the output Observable is subscribed, and `removeHandler` is
	     * called when the Subscription is unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * function addClickHandler(handler) {
	     *   document.addEventListener('click', handler);
	     * }
	     *
	     * function removeClickHandler(handler) {
	     *   document.removeEventListener('click', handler);
	     * }
	     *
	     * var clicks = Rx.Observable.fromEventPattern(
	     *   addClickHandler,
	     *   removeClickHandler
	     * );
	     * clicks.subscribe(x => console.log(x));
	     *
	     * @see {@link from}
	     * @see {@link fromEvent}
	     *
	     * @param {function(handler: Function): any} addHandler A function that takes
	     * a `handler` function as argument and attaches it somehow to the actual
	     * source of events.
	     * @param {function(handler: Function): void} removeHandler A function that
	     * takes a `handler` function as argument and removes it in case it was
	     * previously attached using `addHandler`.
	     * @param {function(...args: any): T} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEventPattern
	     * @owner Observable
	     */
	    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	    };
	    FromEventPatternObservable.prototype._subscribe = function (subscriber) {
	        var addHandler = this.addHandler;
	        var removeHandler = this.removeHandler;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = tryCatch_1.tryCatch(selector).apply(null, arguments);
	            if (result === errorObject_1.errorObject) {
	                subscriber.error(result.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { subscriber.next(e); };
	        var result = tryCatch_1.tryCatch(addHandler)(handler);
	        if (result === errorObject_1.errorObject) {
	            subscriber.error(result.e);
	        }
	        subscriber.add(new Subscription_1.Subscription(function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler);
	        }));
	    };
	    return FromEventPatternObservable;
	}(Observable_1.Observable));
	exports.FromEventPatternObservable = FromEventPatternObservable;
	//# sourceMappingURL=FromEventPatternObservable.js.map

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var fromPromise_1 = __webpack_require__(431);
	Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
	//# sourceMappingURL=fromPromise.js.map

/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var GenerateObservable_1 = __webpack_require__(505);
	Observable_1.Observable.generate = GenerateObservable_1.GenerateObservable.create;
	//# sourceMappingURL=generate.js.map

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var isScheduler_1 = __webpack_require__(358);
	var selfSelector = function (value) { return value; };
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var GenerateObservable = (function (_super) {
	    __extends(GenerateObservable, _super);
	    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
	        _super.call(this);
	        this.initialState = initialState;
	        this.condition = condition;
	        this.iterate = iterate;
	        this.resultSelector = resultSelector;
	        this.scheduler = scheduler;
	    }
	    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
	        if (arguments.length == 1) {
	            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
	        }
	        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
	            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
	        }
	        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
	    };
	    GenerateObservable.prototype._subscribe = function (subscriber) {
	        var state = this.initialState;
	        if (this.scheduler) {
	            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
	                subscriber: subscriber,
	                iterate: this.iterate,
	                condition: this.condition,
	                resultSelector: this.resultSelector,
	                state: state });
	        }
	        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;
	        do {
	            if (condition) {
	                var conditionResult = void 0;
	                try {
	                    conditionResult = condition(state);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (!conditionResult) {
	                    subscriber.complete();
	                    break;
	                }
	            }
	            var value = void 0;
	            try {
	                value = resultSelector(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            subscriber.next(value);
	            if (subscriber.isUnsubscribed) {
	                break;
	            }
	            try {
	                state = iterate(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        } while (true);
	    };
	    GenerateObservable.dispatch = function (state) {
	        var subscriber = state.subscriber, condition = state.condition;
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        if (state.needIterate) {
	            try {
	                state.state = state.iterate(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        }
	        else {
	            state.needIterate = true;
	        }
	        if (condition) {
	            var conditionResult = void 0;
	            try {
	                conditionResult = condition(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            if (!conditionResult) {
	                subscriber.complete();
	                return;
	            }
	            if (subscriber.isUnsubscribed) {
	                return;
	            }
	        }
	        var value;
	        try {
	            value = state.resultSelector(state.state);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return;
	        }
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        return this.schedule(state);
	    };
	    return GenerateObservable;
	}(Observable_1.Observable));
	exports.GenerateObservable = GenerateObservable;
	//# sourceMappingURL=GenerateObservable.js.map

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var interval_1 = __webpack_require__(507);
	Observable_1.Observable.interval = interval_1.interval;
	//# sourceMappingURL=interval.js.map

/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var IntervalObservable_1 = __webpack_require__(508);
	exports.interval = IntervalObservable_1.IntervalObservable.create;
	//# sourceMappingURL=interval.js.map

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = __webpack_require__(509);
	var Observable_1 = __webpack_require__(38);
	var async_1 = __webpack_require__(510);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IntervalObservable = (function (_super) {
	    __extends(IntervalObservable, _super);
	    function IntervalObservable(period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1.async; }
	        _super.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = async_1.async;
	        }
	    }
	    /**
	     * Creates an Observable that emits sequential numbers every specified
	     * interval of time, on a specified Scheduler.
	     *
	     * <span class="informal">Emits incremental numbers periodically in time.
	     * </span>
	     *
	     * <img src="./img/interval.png" width="100%">
	     *
	     * `interval` returns an Observable that emits an infinite sequence of
	     * ascending integers, with a constant interval of time of your choosing
	     * between those emissions. The first emission is not sent immediately, but
	     * only after the first period has passed. By default, this operator uses the
	     * `async` Scheduler to provide a notion of time, but you may pass any
	     * Scheduler to it.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
	     * var numbers = Rx.Observable.interval(1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link delay}
	     *
	     * @param {number} [period=0] The interval size in milliseconds (by default)
	     * or the time unit determined by the scheduler's clock.
	     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a sequential number each time
	     * interval.
	     * @static true
	     * @name interval
	     * @owner Observable
	     */
	    IntervalObservable.create = function (period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1.async; }
	        return new IntervalObservable(period, scheduler);
	    };
	    IntervalObservable.dispatch = function (state) {
	        var index = state.index, subscriber = state.subscriber, period = state.period;
	        subscriber.next(index);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };
	    IntervalObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };
	    return IntervalObservable;
	}(Observable_1.Observable));
	exports.IntervalObservable = IntervalObservable;
	//# sourceMappingURL=IntervalObservable.js.map

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(45);
	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}
	exports.isNumeric = isNumeric;
	;
	//# sourceMappingURL=isNumeric.js.map

/***/ },
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var race_1 = __webpack_require__(515);
	Observable_1.Observable.race = race_1.raceStatic;
	//# sourceMappingURL=race.js.map

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(45);
	var ArrayObservable_1 = __webpack_require__(355);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Returns an Observable that mirrors the first source Observable to emit an item
	 * from the combination of this Observable and supplied Observables
	 * @param {...Observables} ...observables sources used to race for which Observable emits first.
	 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
	 * @method race
	 * @owner Observable
	 */
	function race() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    observables.unshift(this);
	    return raceStatic.apply(this, observables);
	}
	exports.race = race;
	function raceStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1) {
	        if (isArray_1.isArray(observables[0])) {
	            observables = observables[0];
	        }
	        else {
	            return observables[0];
	        }
	    }
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
	}
	exports.raceStatic = raceStatic;
	var RaceOperator = (function () {
	    function RaceOperator() {
	    }
	    RaceOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new RaceSubscriber(subscriber));
	    };
	    return RaceOperator;
	}());
	exports.RaceOperator = RaceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RaceSubscriber = (function (_super) {
	    __extends(RaceSubscriber, _super);
	    function RaceSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasFirst = false;
	        this.observables = [];
	        this.subscriptions = [];
	    }
	    RaceSubscriber.prototype._next = function (observable) {
	        this.observables.push(observable);
	    };
	    RaceSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
	                if (this.subscriptions) {
	                    this.subscriptions.push(subscription);
	                    this.add(subscription);
	                }
	            }
	            this.observables = null;
	        }
	    };
	    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (!this.hasFirst) {
	            this.hasFirst = true;
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                if (i !== outerIndex) {
	                    var subscription = this.subscriptions[i];
	                    subscription.unsubscribe();
	                    this.remove(subscription);
	                }
	            }
	            this.subscriptions = null;
	        }
	        this.destination.next(innerValue);
	    };
	    return RaceSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.RaceSubscriber = RaceSubscriber;
	//# sourceMappingURL=race.js.map

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var never_1 = __webpack_require__(517);
	Observable_1.Observable.never = never_1.never;
	//# sourceMappingURL=never.js.map

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NeverObservable_1 = __webpack_require__(518);
	exports.never = NeverObservable_1.NeverObservable.create;
	//# sourceMappingURL=never.js.map

/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var noop_1 = __webpack_require__(519);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var NeverObservable = (function (_super) {
	    __extends(NeverObservable, _super);
	    function NeverObservable() {
	        _super.call(this);
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer.
	     *
	     * <span class="informal">An Observable that never emits anything.</span>
	     *
	     * <img src="./img/never.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that emits
	     * neither values nor errors nor the completion notification. It can be used
	     * for testing purposes or for composing with other Observables. Please not
	     * that by never emitting a complete notification, this Observable keeps the
	     * subscription from being disposed automatically. Subscriptions need to be
	     * manually disposed.
	     *
	     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
	     * function info() {
	     *   console.log('Will not be called');
	     * }
	     * var result = Rx.Observable.never().startWith(7);
	     * result.subscribe(x => console.log(x), info, info);
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @return {Observable} A "never" Observable: never emits anything.
	     * @static true
	     * @name never
	     * @owner Observable
	     */
	    NeverObservable.create = function () {
	        return new NeverObservable();
	    };
	    NeverObservable.prototype._subscribe = function (subscriber) {
	        noop_1.noop();
	    };
	    return NeverObservable;
	}(Observable_1.Observable));
	exports.NeverObservable = NeverObservable;
	//# sourceMappingURL=NeverObservable.js.map

/***/ },
/* 519 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;
	//# sourceMappingURL=noop.js.map

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var range_1 = __webpack_require__(521);
	Observable_1.Observable.range = range_1.range;
	//# sourceMappingURL=range.js.map

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RangeObservable_1 = __webpack_require__(522);
	exports.range = RangeObservable_1.RangeObservable.create;
	//# sourceMappingURL=range.js.map

/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var RangeObservable = (function (_super) {
	    __extends(RangeObservable, _super);
	    function RangeObservable(start, count, scheduler) {
	        _super.call(this);
	        this.start = start;
	        this._count = count;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits a sequence of numbers within a specified
	     * range.
	     *
	     * <span class="informal">Emits a sequence of numbers in a range.</span>
	     *
	     * <img src="./img/range.png" width="100%">
	     *
	     * `range` operator emits a range of sequential integers, in order, where you
	     * select the `start` of the range and its `length`. By default, uses no
	     * Scheduler and just delivers the notifications synchronously, but may use
	     * an optional Scheduler to regulate those deliveries.
	     *
	     * @example <caption>Emits the numbers 1 to 10</caption>
	     * var numbers = Rx.Observable.range(1, 10);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link interval}
	     *
	     * @param {number} [start=0] The value of the first integer in the sequence.
	     * @param {number} [count=0] The number of sequential integers to generate.
	     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
	     * the emissions of the notifications.
	     * @return {Observable} An Observable of numbers that emits a finite range of
	     * sequential integers.
	     * @static true
	     * @name range
	     * @owner Observable
	     */
	    RangeObservable.create = function (start, count, scheduler) {
	        if (start === void 0) { start = 0; }
	        if (count === void 0) { count = 0; }
	        return new RangeObservable(start, count, scheduler);
	    };
	    RangeObservable.dispatch = function (state) {
	        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };
	    RangeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var start = this.start;
	        var count = this._count;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, count: count, start: start, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                if (index++ >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return RangeObservable;
	}(Observable_1.Observable));
	exports.RangeObservable = RangeObservable;
	//# sourceMappingURL=RangeObservable.js.map

/***/ },
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var timer_1 = __webpack_require__(527);
	Observable_1.Observable.timer = timer_1.timer;
	//# sourceMappingURL=timer.js.map

/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var TimerObservable_1 = __webpack_require__(528);
	exports.timer = TimerObservable_1.TimerObservable.create;
	//# sourceMappingURL=timer.js.map

/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = __webpack_require__(509);
	var Observable_1 = __webpack_require__(38);
	var async_1 = __webpack_require__(510);
	var isScheduler_1 = __webpack_require__(358);
	var isDate_1 = __webpack_require__(529);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var TimerObservable = (function (_super) {
	    __extends(TimerObservable, _super);
	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === void 0) { dueTime = 0; }
	        _super.call(this);
	        this.period = -1;
	        this.dueTime = 0;
	        if (isNumeric_1.isNumeric(period)) {
	            this.period = Number(period) < 1 && 1 || Number(period);
	        }
	        else if (isScheduler_1.isScheduler(period)) {
	            scheduler = period;
	        }
	        if (!isScheduler_1.isScheduler(scheduler)) {
	            scheduler = async_1.async;
	        }
	        this.scheduler = scheduler;
	        this.dueTime = isDate_1.isDate(dueTime) ?
	            (+dueTime - this.scheduler.now()) :
	            dueTime;
	    }
	    /**
	     * Creates an Observable that starts emitting after an `initialDelay` and
	     * emits ever increasing numbers after each `period` of time thereafter.
	     *
	     * <span class="informal">Its like {@link interval}, but you can specify when
	     * should the emissions start.</span>
	     *
	     * <img src="./img/timer.png" width="100%">
	     *
	     * `timer` returns an Observable that emits an infinite sequence of ascending
	     * integers, with a constant interval of time, `period` of your choosing
	     * between those emissions. The first emission happens after the specified
	     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
	     * operator uses the `async` Scheduler to provide a notion of time, but you
	     * may pass any Scheduler to it. If `period` is not specified, the output
	     * Observable emits only one value, `0`. Otherwise, it emits an infinite
	     * sequence.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
	     * var numbers = Rx.Observable.timer(3000, 1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @example <caption>Emits one number after five seconds</caption>
	     * var numbers = Rx.Observable.timer(5000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link interval}
	     * @see {@link delay}
	     *
	     * @param {number|Date} initialDelay The initial delay time to wait before
	     * emitting the first value of `0`.
	     * @param {number} [period] The period of time between emissions of the
	     * subsequent numbers.
	     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a `0` after the
	     * `initialDelay` and ever increasing numbers after each `period` of time
	     * thereafter.
	     * @static true
	     * @name timer
	     * @owner Observable
	     */
	    TimerObservable.create = function (initialDelay, period, scheduler) {
	        if (initialDelay === void 0) { initialDelay = 0; }
	        return new TimerObservable(initialDelay, period, scheduler);
	    };
	    TimerObservable.dispatch = function (state) {
	        var index = state.index, period = state.period, subscriber = state.subscriber;
	        var action = this;
	        subscriber.next(index);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        else if (period === -1) {
	            return subscriber.complete();
	        }
	        state.index = index + 1;
	        action.schedule(state, period);
	    };
	    TimerObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
	        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
	            index: index, period: period, subscriber: subscriber
	        });
	    };
	    return TimerObservable;
	}(Observable_1.Observable));
	exports.TimerObservable = TimerObservable;
	//# sourceMappingURL=TimerObservable.js.map

/***/ },
/* 529 */,
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var zip_1 = __webpack_require__(531);
	Observable_1.Observable.zip = zip_1.zip;
	//# sourceMappingURL=zip.js.map

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var zip_1 = __webpack_require__(532);
	exports.zip = zip_1.zipStatic;
	//# sourceMappingURL=zip.js.map

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(355);
	var isArray_1 = __webpack_require__(45);
	var Subscriber_1 = __webpack_require__(42);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	var iterator_1 = __webpack_require__(371);
	/**
	 * @param observables
	 * @return {Observable<R>}
	 * @method zip
	 * @owner Observable
	 */
	function zipProto() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    observables.unshift(this);
	    return zipStatic.apply(this, observables);
	}
	exports.zipProto = zipProto;
	/* tslint:enable:max-line-length */
	/**
	 * @param observables
	 * @return {Observable<R>}
	 * @static true
	 * @name zip
	 * @owner Observable
	 */
	function zipStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = observables[observables.length - 1];
	    if (typeof project === 'function') {
	        observables.pop();
	    }
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
	}
	exports.zipStatic = zipStatic;
	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        this.project = project;
	    }
	    ZipOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ZipSubscriber(subscriber, this.project));
	    };
	    return ZipOperator;
	}());
	exports.ZipOperator = ZipOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipSubscriber = (function (_super) {
	    __extends(ZipSubscriber, _super);
	    function ZipSubscriber(destination, project, values) {
	        if (values === void 0) { values = Object.create(null); }
	        _super.call(this, destination);
	        this.index = 0;
	        this.iterators = [];
	        this.active = 0;
	        this.project = (typeof project === 'function') ? project : null;
	        this.values = values;
	    }
	    ZipSubscriber.prototype._next = function (value) {
	        var iterators = this.iterators;
	        var index = this.index++;
	        if (isArray_1.isArray(value)) {
	            iterators.push(new StaticArrayIterator(value));
	        }
	        else if (typeof value[iterator_1.$$iterator] === 'function') {
	            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
	        }
	        else {
	            iterators.push(new ZipBufferIterator(this.destination, this, value, index));
	        }
	    };
	    ZipSubscriber.prototype._complete = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        this.active = len;
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (iterator.stillUnsubscribed) {
	                this.add(iterator.subscribe(iterator, i));
	            }
	            else {
	                this.active--; // not an observable
	            }
	        }
	    };
	    ZipSubscriber.prototype.notifyInactive = function () {
	        this.active--;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ZipSubscriber.prototype.checkIterators = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        var destination = this.destination;
	        // abort if not all of them have values
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
	                return;
	            }
	        }
	        var shouldComplete = false;
	        var args = [];
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            var result = iterator.next();
	            // check to see if it's completed now that you've gotten
	            // the next value.
	            if (iterator.hasCompleted()) {
	                shouldComplete = true;
	            }
	            if (result.done) {
	                destination.complete();
	                return;
	            }
	            args.push(result.value);
	        }
	        if (this.project) {
	            this._tryProject(args);
	        }
	        else {
	            destination.next(args);
	        }
	        if (shouldComplete) {
	            destination.complete();
	        }
	    };
	    ZipSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return ZipSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ZipSubscriber = ZipSubscriber;
	var StaticIterator = (function () {
	    function StaticIterator(iterator) {
	        this.iterator = iterator;
	        this.nextResult = iterator.next();
	    }
	    StaticIterator.prototype.hasValue = function () {
	        return true;
	    };
	    StaticIterator.prototype.next = function () {
	        var result = this.nextResult;
	        this.nextResult = this.iterator.next();
	        return result;
	    };
	    StaticIterator.prototype.hasCompleted = function () {
	        var nextResult = this.nextResult;
	        return nextResult && nextResult.done;
	    };
	    return StaticIterator;
	}());
	var StaticArrayIterator = (function () {
	    function StaticArrayIterator(array) {
	        this.array = array;
	        this.index = 0;
	        this.length = 0;
	        this.length = array.length;
	    }
	    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
	        return this;
	    };
	    StaticArrayIterator.prototype.next = function (value) {
	        var i = this.index++;
	        var array = this.array;
	        return i < this.length ? { value: array[i], done: false } : { done: true };
	    };
	    StaticArrayIterator.prototype.hasValue = function () {
	        return this.array.length > this.index;
	    };
	    StaticArrayIterator.prototype.hasCompleted = function () {
	        return this.array.length === this.index;
	    };
	    return StaticArrayIterator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipBufferIterator = (function (_super) {
	    __extends(ZipBufferIterator, _super);
	    function ZipBufferIterator(destination, parent, observable, index) {
	        _super.call(this, destination);
	        this.parent = parent;
	        this.observable = observable;
	        this.index = index;
	        this.stillUnsubscribed = true;
	        this.buffer = [];
	        this.isComplete = false;
	    }
	    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
	        return this;
	    };
	    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
	    //    this is legit because `next()` will never be called by a subscription in this case.
	    ZipBufferIterator.prototype.next = function () {
	        var buffer = this.buffer;
	        if (buffer.length === 0 && this.isComplete) {
	            return { done: true };
	        }
	        else {
	            return { value: buffer.shift(), done: false };
	        }
	    };
	    ZipBufferIterator.prototype.hasValue = function () {
	        return this.buffer.length > 0;
	    };
	    ZipBufferIterator.prototype.hasCompleted = function () {
	        return this.buffer.length === 0 && this.isComplete;
	    };
	    ZipBufferIterator.prototype.notifyComplete = function () {
	        if (this.buffer.length > 0) {
	            this.isComplete = true;
	            this.parent.notifyInactive();
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.buffer.push(innerValue);
	        this.parent.checkIterators();
	    };
	    ZipBufferIterator.prototype.subscribe = function (value, index) {
	        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
	    };
	    return ZipBufferIterator;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=zip.js.map

/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var buffer_1 = __webpack_require__(534);
	Observable_1.Observable.prototype.buffer = buffer_1.buffer;
	//# sourceMappingURL=buffer.js.map

/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Buffers the source Observable values until `closingNotifier` emits.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when another Observable emits.</span>
	 *
	 * <img src="./img/buffer.png" width="100%">
	 *
	 * Buffers the incoming Observable values until the given `closingNotifier`
	 * Observable emits a value, at which point it emits the buffer on the output
	 * Observable and starts a new buffer internally, awaiting the next time
	 * `closingNotifier` emits.
	 *
	 * @example <caption>On every click, emit array of most recent interval events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var buffered = interval.buffer(clicks);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link window}
	 *
	 * @param {Observable<any>} closingNotifier An Observable that signals the
	 * buffer to be emitted on the output Observable.
	 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
	 * values.
	 * @method buffer
	 * @owner Observable
	 */
	function buffer(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}
	exports.buffer = buffer;
	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        this.closingNotifier = closingNotifier;
	    }
	    BufferOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
	    };
	    return BufferOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferSubscriber = (function (_super) {
	    __extends(BufferSubscriber, _super);
	    function BufferSubscriber(destination, closingNotifier) {
	        _super.call(this, destination);
	        this.buffer = [];
	        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
	    }
	    BufferSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };
	    return BufferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=buffer.js.map

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var bufferCount_1 = __webpack_require__(536);
	Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;
	//# sourceMappingURL=bufferCount.js.map

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Buffers the source Observable values until the size hits the maximum
	 * `bufferSize` given.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when its size reaches `bufferSize`.</span>
	 *
	 * <img src="./img/bufferCount.png" width="100%">
	 *
	 * Buffers a number of values from the source Observable by `bufferSize` then
	 * emits the buffer and clears it, and starts a new buffer each
	 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
	 * `null`, then new buffers are started immediately at the start of the source
	 * and when each buffer closes and is emitted.
	 *
	 * @example <caption>Emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>On every click, emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2, 1);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link pairwise}
	 * @see {@link windowCount}
	 *
	 * @param {number} bufferSize The maximum size of the buffer emitted.
	 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
	 * For example if `startBufferEvery` is `2`, then a new buffer will be started
	 * on every other value from the source. A new buffer is started at the
	 * beginning of the source by default.
	 * @return {Observable<T[]>} An Observable of arrays of buffered values.
	 * @method bufferCount
	 * @owner Observable
	 */
	function bufferCount(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}
	exports.bufferCount = bufferCount;
	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	    }
	    BufferCountOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery));
	    };
	    return BufferCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferCountSubscriber = (function (_super) {
	    __extends(BufferCountSubscriber, _super);
	    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _super.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [[]];
	        this.count = 0;
	    }
	    BufferCountSubscriber.prototype._next = function (value) {
	        var count = (this.count += 1);
	        var destination = this.destination;
	        var bufferSize = this.bufferSize;
	        var startBufferEvery = (this.startBufferEvery == null) ? bufferSize : this.startBufferEvery;
	        var buffers = this.buffers;
	        var len = buffers.length;
	        var remove = -1;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = 0; i < len; i++) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                remove = i;
	                destination.next(buffer);
	            }
	        }
	        if (remove !== -1) {
	            buffers.splice(remove, 1);
	        }
	    };
	    BufferCountSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=bufferCount.js.map

/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var bufferTime_1 = __webpack_require__(538);
	Observable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;
	//# sourceMappingURL=bufferTime.js.map

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var async_1 = __webpack_require__(510);
	/**
	 * Buffers the source Observable values for a specific time period.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * those arrays periodically in time.</span>
	 *
	 * <img src="./img/bufferTime.png" width="100%">
	 *
	 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
	 * Unless the optional argument `bufferCreationInterval` is given, it emits and
	 * resets the buffer every `bufferTimeSpan` milliseconds. If
	 * `bufferCreationInterval` is given, this operator opens the buffer every
	 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
	 * buffer every `bufferTimeSpan` milliseconds.
	 *
	 * @example <caption>Every second, emit an array of the recent click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(1000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(2000, 5000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link windowTime}
	 *
	 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
	 * @param {number} [bufferCreationInterval] The interval at which to start new
	 * buffers.
	 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
	 * intervals that determine buffer boundaries.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferTime
	 * @owner Observable
	 */
	function bufferTime(bufferTimeSpan, bufferCreationInterval, scheduler) {
	    if (bufferCreationInterval === void 0) { bufferCreationInterval = null; }
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler));
	}
	exports.bufferTime = bufferTime;
	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler) {
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	    }
	    BufferTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.scheduler));
	    };
	    return BufferTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferTimeSubscriber = (function (_super) {
	    __extends(BufferTimeSubscriber, _super);
	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _super.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	        this.buffers = [];
	        var buffer = this.openBuffer();
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            var closeState = { subscriber: this, buffer: buffer };
	            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	        }
	        else {
	            var timeSpanOnlyState = { subscriber: this, buffer: buffer, bufferTimeSpan: bufferTimeSpan };
	            this.add(scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	    }
	    BufferTimeSubscriber.prototype._next = function (value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };
	    BufferTimeSubscriber.prototype._error = function (err) {
	        this.buffers.length = 0;
	        _super.prototype._error.call(this, err);
	    };
	    BufferTimeSubscriber.prototype._complete = function () {
	        var _a = this, buffers = _a.buffers, destination = _a.destination;
	        while (buffers.length > 0) {
	            destination.next(buffers.shift());
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferTimeSubscriber.prototype._unsubscribe = function () {
	        this.buffers = null;
	    };
	    BufferTimeSubscriber.prototype.openBuffer = function () {
	        var buffer = [];
	        this.buffers.push(buffer);
	        return buffer;
	    };
	    BufferTimeSubscriber.prototype.closeBuffer = function (buffer) {
	        this.destination.next(buffer);
	        var buffers = this.buffers;
	        buffers.splice(buffers.indexOf(buffer), 1);
	    };
	    return BufferTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevBuffer = state.buffer;
	    if (prevBuffer) {
	        subscriber.closeBuffer(prevBuffer);
	    }
	    state.buffer = subscriber.openBuffer();
	    if (!subscriber.isUnsubscribed) {
	        this.schedule(state, state.bufferTimeSpan);
	    }
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
	    var buffer = subscriber.openBuffer();
	    var action = this;
	    if (!subscriber.isUnsubscribed) {
	        action.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, buffer: buffer }));
	        action.schedule(state, bufferCreationInterval);
	    }
	}
	function dispatchBufferClose(arg) {
	    var subscriber = arg.subscriber, buffer = arg.buffer;
	    subscriber.closeBuffer(buffer);
	}
	//# sourceMappingURL=bufferTime.js.map

/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var bufferToggle_1 = __webpack_require__(540);
	Observable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;
	//# sourceMappingURL=bufferToggle.js.map

/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(44);
	var subscribeToResult_1 = __webpack_require__(369);
	var OuterSubscriber_1 = __webpack_require__(368);
	/**
	 * Buffers the source Observable values starting from an emission from
	 * `openings` and ending when the output of `closingSelector` emits.
	 *
	 * <span class="informal">Collects values from the past as an array. Starts
	 * collecting only when `opening` emits, and calls the `closingSelector`
	 * function to get an Observable that tells when to close the buffer.</span>
	 *
	 * <img src="./img/bufferToggle.png" width="100%">
	 *
	 * Buffers values from the source by opening the buffer via signals from an
	 * Observable provided to `openings`, and closing and sending the buffers when
	 * a Subscribable or Promise returned by the `closingSelector` function emits.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var buffered = clicks.bufferToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferWhen}
	 * @see {@link windowToggle}
	 *
	 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
	 * buffers.
	 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
	 * which, when it emits, signals that the associated buffer should be emitted
	 * and cleared.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferToggle
	 * @owner Observable
	 */
	function bufferToggle(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}
	exports.bufferToggle = bufferToggle;
	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    BufferToggleOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return BufferToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferToggleSubscriber = (function (_super) {
	    __extends(BufferToggleSubscriber, _super);
	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(subscribeToResult_1.subscribeToResult(this, openings));
	    }
	    BufferToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        for (var i = 0; i < len; i++) {
	            contexts[i].buffer.push(value);
	        }
	    };
	    BufferToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._error.call(this, err);
	    };
	    BufferToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            this.destination.next(context.buffer);
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._complete.call(this);
	    };
	    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
	    };
	    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.closeBuffer(innerSub.context);
	    };
	    BufferToggleSubscriber.prototype.openBuffer = function (value) {
	        try {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = closingSelector.call(this, value);
	            if (closingNotifier) {
	                this.trySubscribe(closingNotifier);
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
	        var contexts = this.contexts;
	        if (contexts && context) {
	            var buffer = context.buffer, subscription = context.subscription;
	            this.destination.next(buffer);
	            contexts.splice(contexts.indexOf(context), 1);
	            this.remove(subscription);
	            subscription.unsubscribe();
	        }
	    };
	    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
	        var contexts = this.contexts;
	        var buffer = [];
	        var subscription = new Subscription_1.Subscription();
	        var context = { buffer: buffer, subscription: subscription };
	        contexts.push(context);
	        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
	        if (!innerSubscription || innerSubscription.isUnsubscribed) {
	            this.closeBuffer(context);
	        }
	        else {
	            innerSubscription.context = context;
	            this.add(innerSubscription);
	            subscription.add(innerSubscription);
	        }
	    };
	    return BufferToggleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=bufferToggle.js.map

/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var bufferWhen_1 = __webpack_require__(542);
	Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;
	//# sourceMappingURL=bufferWhen.js.map

/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(44);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Buffers the source Observable values, using a factory function of closing
	 * Observables to determine when to close, emit, and reset the buffer.
	 *
	 * <span class="informal">Collects values from the past as an array. When it
	 * starts collecting values, it calls a function that returns an Observable that
	 * tells when to close the buffer and restart collecting.</span>
	 *
	 * <img src="./img/bufferWhen.png" width="100%">
	 *
	 * Opens a buffer immediately, then closes the buffer when the observable
	 * returned by calling `closingSelector` function emits a value. When it closes
	 * the buffer, it immediately opens a new buffer and repeats the process.
	 *
	 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferWhen(() =>
	 *   Rx.Observable.interval(1000 + Math.random() * 4000)
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link windowWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals buffer closure.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferWhen
	 * @owner Observable
	 */
	function bufferWhen(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}
	exports.bufferWhen = bufferWhen;
	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    BufferWhenOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
	    };
	    return BufferWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferWhenSubscriber = (function (_super) {
	    __extends(BufferWhenSubscriber, _super);
	    function BufferWhenSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.subscribing = false;
	        this.openBuffer();
	    }
	    BufferWhenSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferWhenSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferWhenSubscriber.prototype._unsubscribe = function () {
	        this.buffer = null;
	        this.subscribing = false;
	    };
	    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openBuffer();
	    };
	    BufferWhenSubscriber.prototype.notifyComplete = function () {
	        if (this.subscribing) {
	            this.complete();
	        }
	        else {
	            this.openBuffer();
	        }
	    };
	    BufferWhenSubscriber.prototype.openBuffer = function () {
	        var closingSubscription = this.closingSubscription;
	        if (closingSubscription) {
	            this.remove(closingSubscription);
	            closingSubscription.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (this.buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1.errorObject) {
	            this.error(errorObject_1.errorObject.e);
	        }
	        else {
	            closingSubscription = new Subscription_1.Subscription();
	            this.closingSubscription = closingSubscription;
	            this.add(closingSubscription);
	            this.subscribing = true;
	            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
	            this.subscribing = false;
	        }
	    };
	    return BufferWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=bufferWhen.js.map

/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var cache_1 = __webpack_require__(544);
	Observable_1.Observable.prototype.cache = cache_1.cache;
	//# sourceMappingURL=cache.js.map

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var publishReplay_1 = __webpack_require__(545);
	/**
	 * @param bufferSize
	 * @param windowTime
	 * @param scheduler
	 * @return {Observable<any>}
	 * @method cache
	 * @owner Observable
	 */
	function cache(bufferSize, windowTime, scheduler) {
	    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	    return publishReplay_1.publishReplay.call(this, bufferSize, windowTime, scheduler).refCount();
	}
	exports.cache = cache;
	//# sourceMappingURL=cache.js.map

/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ReplaySubject_1 = __webpack_require__(546);
	var multicast_1 = __webpack_require__(361);
	/**
	 * @param bufferSize
	 * @param windowTime
	 * @param scheduler
	 * @return {ConnectableObservable<T>}
	 * @method publishReplay
	 * @owner Observable
	 */
	function publishReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));
	}
	exports.publishReplay = publishReplay;
	//# sourceMappingURL=publishReplay.js.map

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(37);
	var queue_1 = __webpack_require__(448);
	var observeOn_1 = __webpack_require__(413);
	/**
	 * @class ReplaySubject<T>
	 */
	var ReplaySubject = (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(bufferSize, windowTime, scheduler) {
	        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	        _super.call(this);
	        this.events = [];
	        this.scheduler = scheduler;
	        this.bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = windowTime < 1 ? 1 : windowTime;
	    }
	    ReplaySubject.prototype._next = function (value) {
	        var now = this._getNow();
	        this.events.push(new ReplayEvent(now, value));
	        this._trimBufferThenGetEvents(now);
	        _super.prototype._next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        var events = this._trimBufferThenGetEvents(this._getNow());
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
	        }
	        var index = -1;
	        var len = events.length;
	        while (++index < len && !subscriber.isUnsubscribed) {
	            subscriber.next(events[index].value);
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    ReplaySubject.prototype._getNow = function () {
	        return (this.scheduler || queue_1.queue).now();
	    };
	    ReplaySubject.prototype._trimBufferThenGetEvents = function (now) {
	        var bufferSize = this.bufferSize;
	        var _windowTime = this._windowTime;
	        var events = this.events;
	        var eventsCount = events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if ((now - events[spliceCount].time) < _windowTime) {
	                break;
	            }
	            spliceCount += 1;
	        }
	        if (eventsCount > bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - bufferSize);
	        }
	        if (spliceCount > 0) {
	            events.splice(0, spliceCount);
	        }
	        return events;
	    };
	    return ReplaySubject;
	}(Subject_1.Subject));
	exports.ReplaySubject = ReplaySubject;
	var ReplayEvent = (function () {
	    function ReplayEvent(time, value) {
	        this.time = time;
	        this.value = value;
	    }
	    return ReplayEvent;
	}());
	//# sourceMappingURL=ReplaySubject.js.map

/***/ },
/* 547 */,
/* 548 */,
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var combineAll_1 = __webpack_require__(550);
	Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;
	//# sourceMappingURL=combineAll.js.map

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var combineLatest_1 = __webpack_require__(488);
	/**
	 * Converts a higher-order Observable into a first-order Observable by waiting
	 * for the outer Observable to complete, then applying {@link combineLatest}.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by applying
	 * {@link combineLatest} when the Observable-of-Observables completes.</span>
	 *
	 * <img src="./img/combineAll.png" width="100%">
	 *
	 * Takes an Observable of Observables, and collects all Observables from it.
	 * Once the outer Observable completes, it subscribes to all collected
	 * Observables and combines their values using the {@link combineLatest}
	 * strategy, such that:
	 * - Every time an inner Observable emits, the output Observable emits.
	 * - When the returned observable emits, it emits all of the latest values by:
	 *   - If a `project` function is provided, it is called with each recent value
	 *     from each inner Observable in whatever order they arrived, and the result
	 *     of the `project` function is what is emitted by the output Observable.
	 *   - If there is no `project` function, an array of all of the most recent
	 *     values is emitted by the output Observable.
	 *
	 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev =>
	 *   Rx.Observable.interval(Math.random()*2000).take(3)
	 * ).take(2);
	 * var result = higherOrder.combineAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 * @see {@link mergeAll}
	 *
	 * @param {function} [project] An optional function to map the most recent
	 * values from each inner Observable into a new result. Takes each of the most
	 * recent values from each collected inner Observable as arguments, in order.
	 * @return {Observable} An Observable of projected results or arrays of recent
	 * values.
	 * @method combineAll
	 * @owner Observable
	 */
	function combineAll(project) {
	    return this.lift(new combineLatest_1.CombineLatestOperator(project));
	}
	exports.combineAll = combineAll;
	//# sourceMappingURL=combineAll.js.map

/***/ },
/* 551 */,
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var concatAll_1 = __webpack_require__(553);
	Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;
	//# sourceMappingURL=concatAll.js.map

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeAll_1 = __webpack_require__(367);
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * concatenating the inner Observables in order.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by putting one
	 * inner Observable after the other.</span>
	 *
	 * <img src="./img/concatAll.png" width="100%">
	 *
	 * Joins every Observable emitted by the source (a higher-order Observable), in
	 * a serial fashion. It subscribes to each inner Observable only after the
	 * previous inner Observable has completed, and merges all of their values into
	 * the returned observable.
	 *
	 * __Warning:__ If the source Observable emits Observables quickly and
	 * endlessly, and the inner Observables it emits generally complete slower than
	 * the source emits, you can run into memory issues as the incoming Observables
	 * collect in an unbounded buffer.
	 *
	 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
	 * var firstOrder = higherOrder.concatAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concat}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable emitting values from all the inner
	 * Observables concatenated.
	 * @method concatAll
	 * @owner Observable
	 */
	function concatAll() {
	    return this.lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatAll = concatAll;
	//# sourceMappingURL=concatAll.js.map

/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var concatMapTo_1 = __webpack_require__(555);
	Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;
	//# sourceMappingURL=concatMapTo.js.map

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMapTo_1 = __webpack_require__(556);
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in a serialized fashion on the output Observable.
	 *
	 * <span class="informal">It's like {@link concatMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/concatMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. Each new `innerObservable`
	 * instance emitted on the output Observable is concatenated with the previous
	 * `innerObservable` instance.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
	 * set to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link mergeMapTo}
	 * @see {@link switchMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An observable of values merged together by joining the
	 * passed observable with itself, one after the other, for each value emitted
	 * from the source.
	 * @method concatMapTo
	 * @owner Observable
	 */
	function concatMapTo(innerObservable, resultSelector) {
	    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
	}
	exports.concatMapTo = concatMapTo;
	//# sourceMappingURL=concatMapTo.js.map

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in the output Observable.
	 *
	 * <span class="informal">It's like {@link mergeMap}, but maps each value always
	 * to the same inner Observable.</span>
	 *
	 * <img src="./img/mergeMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then merges those resulting Observables into one
	 * single Observable, which is the output Observable.
	 *
	 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 * @see {@link switchMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable.
	 * @method mergeMapTo
	 * @owner Observable
	 */
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
	}
	exports.mergeMapTo = mergeMapTo;
	// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
	//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
	var MergeMapToOperator = (function () {
	    function MergeMapToOperator(ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapToOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
	    };
	    return MergeMapToOperator;
	}());
	exports.MergeMapToOperator = MergeMapToOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapToSubscriber = (function (_super) {
	    __extends(MergeMapToSubscriber, _super);
	    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapToSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = this.ish;
	            var destination = this.destination;
	            this.active++;
	            this._innerSub(ish, destination, resultSelector, value, index);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapToSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    MergeMapToSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapToSubscriber = MergeMapToSubscriber;
	//# sourceMappingURL=mergeMapTo.js.map

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var count_1 = __webpack_require__(558);
	Observable_1.Observable.prototype.count = count_1.count;
	//# sourceMappingURL=count.js.map

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Counts the number of emissions on the source and emits that number when the
	 * source completes.
	 *
	 * <span class="informal">Tells how many values were emitted, when the source
	 * completes.</span>
	 *
	 * <img src="./img/count.png" width="100%">
	 *
	 * `count` transforms an Observable that emits values into an Observable that
	 * emits a single value that represents the number of values emitted by the
	 * source Observable. If the source Observable terminates with an error, `count`
	 * will pass this error notification along without emitting an value first. If
	 * the source Observable does not terminate at all, `count` will neither emit
	 * a value nor terminate. This operator takes an optional `predicate` function
	 * as argument, in which case the output emission will represent the number of
	 * source values that matched `true` with the `predicate`.
	 *
	 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var secondsBeforeClick = seconds.takeUntil(clicks);
	 * var result = secondsBeforeClick.count();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
	 * var numbers = Rx.Observable.range(1, 7);
	 * var result = numbers.count(i => i % 2 === 1);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link max}
	 * @see {@link min}
	 * @see {@link reduce}
	 *
	 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
	 * boolean function to select what values are to be counted. It is provided with
	 * arguments of:
	 * - `value`: the value from the source Observable.
	 * - `index`: the (zero-based) "index" of the value from the source Observable.
	 * - `source`: the source Observable instance itself.
	 * @return {Observable} An Observable of one number that represents the count as
	 * described above.
	 * @method count
	 * @owner Observable
	 */
	function count(predicate) {
	    return this.lift(new CountOperator(predicate, this));
	}
	exports.count = count;
	var CountOperator = (function () {
	    function CountOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    CountOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
	    };
	    return CountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CountSubscriber = (function (_super) {
	    __extends(CountSubscriber, _super);
	    function CountSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.count = 0;
	        this.index = 0;
	    }
	    CountSubscriber.prototype._next = function (value) {
	        if (this.predicate) {
	            this._tryPredicate(value);
	        }
	        else {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._tryPredicate = function (value) {
	        var result;
	        try {
	            result = this.predicate(value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._complete = function () {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };
	    return CountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=count.js.map

/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var dematerialize_1 = __webpack_require__(560);
	Observable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;
	//# sourceMappingURL=dematerialize.js.map

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Returns an Observable that transforms Notification objects into the items or notifications they represent.
	 *
	 * @see {@link Notification}
	 *
	 * @return {Observable} an Observable that emits items and notifications embedded in Notification objects emitted by the source Observable.
	 * @method dematerialize
	 * @owner Observable
	 */
	function dematerialize() {
	    return this.lift(new DeMaterializeOperator());
	}
	exports.dematerialize = dematerialize;
	var DeMaterializeOperator = (function () {
	    function DeMaterializeOperator() {
	    }
	    DeMaterializeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DeMaterializeSubscriber(subscriber));
	    };
	    return DeMaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DeMaterializeSubscriber = (function (_super) {
	    __extends(DeMaterializeSubscriber, _super);
	    function DeMaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    DeMaterializeSubscriber.prototype._next = function (value) {
	        value.observe(this.destination);
	    };
	    return DeMaterializeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=dematerialize.js.map

/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var debounce_1 = __webpack_require__(562);
	Observable_1.Observable.prototype.debounce = debounce_1.debounce;
	//# sourceMappingURL=debounce.js.map

/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * determined by another Observable has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link debounceTime}, but the time span of
	 * emission silence is determined by a second Observable.</span>
	 *
	 * <img src="./img/debounce.png" width="100%">
	 *
	 * `debounce` delays values emitted by the source Observable, but drops previous
	 * pending delayed emissions if a new value arrives on the source Observable.
	 * This operator keeps track of the most recent value from the source
	 * Observable, and spawns a duration Observable by calling the
	 * `durationSelector` function. The value is emitted only when the duration
	 * Observable emits a value or completes, and if no other value was emitted on
	 * the source Observable since the duration Observable was spawned. If a new
	 * value appears before the duration Observable emits, the previous value will
	 * be dropped and will not be emitted on the output Observable.
	 *
	 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
	 * delay-like operator since output emissions do not necessarily occur at the
	 * same time as they did on the source Observable.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): Observable|Promise} durationSelector A function
	 * that receives a value from the source Observable, for computing the timeout
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified duration Observable returned by
	 * `durationSelector`, and may drop some values if they occur too frequently.
	 * @method debounce
	 * @owner Observable
	 */
	function debounce(durationSelector) {
	    return this.lift(new DebounceOperator(durationSelector));
	}
	exports.debounce = debounce;
	var DebounceOperator = (function () {
	    function DebounceOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    DebounceOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
	    };
	    return DebounceOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceSubscriber = (function (_super) {
	    __extends(DebounceSubscriber, _super);
	    function DebounceSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	        this.durationSubscription = null;
	    }
	    DebounceSubscriber.prototype._next = function (value) {
	        try {
	            var result = this.durationSelector.call(this, value);
	            if (result) {
	                this._tryNext(value, result);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DebounceSubscriber.prototype._complete = function () {
	        this.emitValue();
	        this.destination.complete();
	    };
	    DebounceSubscriber.prototype._tryNext = function (value, duration) {
	        var subscription = this.durationSubscription;
	        this.value = value;
	        this.hasValue = true;
	        if (subscription) {
	            subscription.unsubscribe();
	            this.remove(subscription);
	        }
	        subscription = subscribeToResult_1.subscribeToResult(this, duration);
	        if (!subscription.isUnsubscribed) {
	            this.add(this.durationSubscription = subscription);
	        }
	    };
	    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            var value = this.value;
	            var subscription = this.durationSubscription;
	            if (subscription) {
	                this.durationSubscription = null;
	                subscription.unsubscribe();
	                this.remove(subscription);
	            }
	            this.value = null;
	            this.hasValue = false;
	            _super.prototype._next.call(this, value);
	        }
	    };
	    return DebounceSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=debounce.js.map

/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var debounceTime_1 = __webpack_require__(564);
	Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
	//# sourceMappingURL=debounceTime.js.map

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var async_1 = __webpack_require__(510);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link delay}, but passes only the most
	 * recent value from each burst of emissions.</span>
	 *
	 * <img src="./img/debounceTime.png" width="100%">
	 *
	 * `debounceTime` delays values emitted by the source Observable, but drops
	 * previous pending delayed emissions if a new value arrives on the source
	 * Observable. This operator keeps track of the most recent value from the
	 * source Observable, and emits that only when `dueTime` enough time has passed
	 * without any other value appearing on the source Observable. If a new value
	 * appears before `dueTime` silence occurs, the previous value will be dropped
	 * and will not be emitted on the output Observable.
	 *
	 * This is a rate-limiting operator, because it is impossible for more than one
	 * value to be emitted in any time window of duration `dueTime`, but it is also
	 * a delay-like operator since output emissions do not occur at the same time as
	 * they did on the source Observable. Optionally takes a {@link Scheduler} for
	 * managing timers.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounceTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} dueTime The timeout duration in milliseconds (or the time
	 * unit determined internally by the optional `scheduler`) for the window of
	 * time required to wait for emission silence before emitting the most recent
	 * source value.
	 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
	 * managing the timers that handle the timeout for each value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified `dueTime`, and may drop some values if they occur
	 * too frequently.
	 * @method debounceTime
	 * @owner Observable
	 */
	function debounceTime(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	exports.debounceTime = debounceTime;
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceTimeSubscriber = (function (_super) {
	    __extends(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _super.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this.hasValue = false;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	            this.hasValue = false;
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.debouncedNext();
	}
	//# sourceMappingURL=debounceTime.js.map

/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var defaultIfEmpty_1 = __webpack_require__(566);
	Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
	//# sourceMappingURL=defaultIfEmpty.js.map

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Emits a given value if the source Observable completes without emitting any
	 * `next` value, otherwise mirrors the source Observable.
	 *
	 * <span class="informal">If the source Observable turns out to be empty, then
	 * this operator will emit a default value.</span>
	 *
	 * <img src="./img/defaultIfEmpty.png" width="100%">
	 *
	 * `defaultIfEmpty` emits the values emitted by the source Observable or a
	 * specified default value if the source Observable is empty (completes without
	 * having emitted any `next` value).
	 *
	 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
	 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link empty}
	 * @see {@link last}
	 *
	 * @param {any} [defaultValue=null] The default value used if the source
	 * Observable is empty.
	 * @return {Observable} An Observable that emits either the specified
	 * `defaultValue` if the source Observable emits no items, or the values emitted
	 * by the source Observable.
	 * @method defaultIfEmpty
	 * @owner Observable
	 */
	function defaultIfEmpty(defaultValue) {
	    if (defaultValue === void 0) { defaultValue = null; }
	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}
	exports.defaultIfEmpty = defaultIfEmpty;
	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        this.defaultValue = defaultValue;
	    }
	    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
	    };
	    return DefaultIfEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DefaultIfEmptySubscriber = (function (_super) {
	    __extends(DefaultIfEmptySubscriber, _super);
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _super.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }
	    DefaultIfEmptySubscriber.prototype._next = function (value) {
	        this.isEmpty = false;
	        this.destination.next(value);
	    };
	    DefaultIfEmptySubscriber.prototype._complete = function () {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	    return DefaultIfEmptySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=defaultIfEmpty.js.map

/***/ },
/* 567 */,
/* 568 */,
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var delayWhen_1 = __webpack_require__(570);
	Observable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;
	//# sourceMappingURL=delayWhen.js.map

/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var Observable_1 = __webpack_require__(38);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Delays the emission of items from the source Observable by a given time span
	 * determined by the emissions of another Observable.
	 *
	 * <span class="informal">It's like {@link delay}, but the time span of the
	 * delay duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/delayWhen.png" width="100%">
	 *
	 * `delayWhen` time shifts each emitted value from the source Observable by a
	 * time span determined by another Observable. When the source emits a value,
	 * the `delayDurationSelector` function is called with the source value as
	 * argument, and should return an Observable, called the "duration" Observable.
	 * The source value is emitted on the output Observable only when the duration
	 * Observable emits a value or completes.
	 *
	 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
	 * is an Observable. When `subscriptionDelay` emits its first value or
	 * completes, the source Observable is subscribed to and starts behaving like
	 * described in the previous paragraph. If `subscriptionDelay` is not provided,
	 * `delayWhen` will subscribe to the source Observable as soon as the output
	 * Observable is subscribed.
	 *
	 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delayWhen(event =>
	 *   Rx.Observable.interval(Math.random() * 5000)
	 * );
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounce}
	 * @see {@link delay}
	 *
	 * @param {function(value: T): Observable} delayDurationSelector A function that
	 * returns an Observable for each value emitted by the source Observable, which
	 * is then used to delay the emission of that item on the output Observable
	 * until the Observable returned from this function emits a value.
	 * @param {Observable} subscriptionDelay An Observable that triggers the
	 * subscription to the source Observable once it emits any value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by an amount of time specified by the Observable returned by
	 * `delayDurationSelector`.
	 * @method delayWhen
	 * @owner Observable
	 */
	function delayWhen(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return new SubscriptionDelayObservable(this, subscriptionDelay)
	            .lift(new DelayWhenOperator(delayDurationSelector));
	    }
	    return this.lift(new DelayWhenOperator(delayDurationSelector));
	}
	exports.delayWhen = delayWhen;
	var DelayWhenOperator = (function () {
	    function DelayWhenOperator(delayDurationSelector) {
	        this.delayDurationSelector = delayDurationSelector;
	    }
	    DelayWhenOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
	    };
	    return DelayWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelayWhenSubscriber = (function (_super) {
	    __extends(DelayWhenSubscriber, _super);
	    function DelayWhenSubscriber(destination, delayDurationSelector) {
	        _super.call(this, destination);
	        this.delayDurationSelector = delayDurationSelector;
	        this.completed = false;
	        this.delayNotifierSubscriptions = [];
	        this.values = [];
	    }
	    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(outerValue);
	        this.removeSubscription(innerSub);
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        var value = this.removeSubscription(innerSub);
	        if (value) {
	            this.destination.next(value);
	        }
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype._next = function (value) {
	        try {
	            var delayNotifier = this.delayDurationSelector(value);
	            if (delayNotifier) {
	                this.tryDelay(delayNotifier, value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DelayWhenSubscriber.prototype._complete = function () {
	        this.completed = true;
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
	        subscription.unsubscribe();
	        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
	        var value = null;
	        if (subscriptionIdx !== -1) {
	            value = this.values[subscriptionIdx];
	            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
	            this.values.splice(subscriptionIdx, 1);
	        }
	        return value;
	    };
	    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
	        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
	        this.add(notifierSubscription);
	        this.delayNotifierSubscriptions.push(notifierSubscription);
	        this.values.push(value);
	    };
	    DelayWhenSubscriber.prototype.tryComplete = function () {
	        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
	            this.destination.complete();
	        }
	    };
	    return DelayWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelayObservable = (function (_super) {
	    __extends(SubscriptionDelayObservable, _super);
	    function SubscriptionDelayObservable(source, subscriptionDelay) {
	        _super.call(this);
	        this.source = source;
	        this.subscriptionDelay = subscriptionDelay;
	    }
	    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
	        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
	    };
	    return SubscriptionDelayObservable;
	}(Observable_1.Observable));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelaySubscriber = (function (_super) {
	    __extends(SubscriptionDelaySubscriber, _super);
	    function SubscriptionDelaySubscriber(parent, source) {
	        _super.call(this);
	        this.parent = parent;
	        this.source = source;
	        this.sourceSubscribed = false;
	    }
	    SubscriptionDelaySubscriber.prototype._next = function (unused) {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype._error = function (err) {
	        this.unsubscribe();
	        this.parent.error(err);
	    };
	    SubscriptionDelaySubscriber.prototype._complete = function () {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
	        if (!this.sourceSubscribed) {
	            this.sourceSubscribed = true;
	            this.unsubscribe();
	            this.source.subscribe(this.parent);
	        }
	    };
	    return SubscriptionDelaySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=delayWhen.js.map

/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var distinctUntilChanged_1 = __webpack_require__(445);
	Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
	//# sourceMappingURL=distinctUntilChanged.js.map

/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var do_1 = __webpack_require__(573);
	Observable_1.Observable.prototype.do = do_1._do;
	//# sourceMappingURL=do.js.map

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Perform a side effect for every emission on the source Observable, but return
	 * an Observable that is identical to the source.
	 *
	 * <span class="informal">Intercepts each emission on the source and runs a
	 * function, but returns an output which is identical to the source.</span>
	 *
	 * <img src="./img/do.png" width="100%">
	 *
	 * Returns a mirrored Observable of the source Observable, but modified so that
	 * the provided Observer is called to perform a side effect for every value,
	 * error, and completion emitted by the source. Any errors that are thrown in
	 * the aforementioned Observer or handlers are safely sent down the error path
	 * of the output Observable.
	 *
	 * This operator is useful for debugging your Observables for the correct values
	 * or performing other side effects.
	 *
	 * Note: this is different to a `subscribe` on the Observable. If the Observable
	 * returned by `do` is not subscribed, the side effects specified by the
	 * Observer will never happen. `do` therefore simply spies on existing
	 * execution, it does not trigger an execution to happen like `subscribe` does.
	 *
	 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks
	 *   .do(ev => console.log(ev))
	 *   .map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 * @see {@link subscribe}
	 *
	 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
	 * callback for `next`.
	 * @param {function} [error] Callback for errors in the source.
	 * @param {function} [complete] Callback for the completion of the source.
	 * @return {Observable} An Observable identical to the source, but runs the
	 * specified Observer or callback(s) for each item.
	 * @method do
	 * @name do
	 * @owner Observable
	 */
	function _do(nextOrObserver, error, complete) {
	    return this.lift(new DoOperator(nextOrObserver, error, complete));
	}
	exports._do = _do;
	var DoOperator = (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DoSubscriber = (function (_super) {
	    __extends(DoSubscriber, _super);
	    function DoSubscriber(destination, nextOrObserver, error, complete) {
	        _super.call(this, destination);
	        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	        safeSubscriber.syncErrorThrowable = true;
	        this.add(safeSubscriber);
	        this.safeSubscriber = safeSubscriber;
	    }
	    DoSubscriber.prototype._next = function (value) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.next(value);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.next(value);
	        }
	    };
	    DoSubscriber.prototype._error = function (err) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.error(err);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.error(err);
	        }
	    };
	    DoSubscriber.prototype._complete = function () {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.complete();
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return DoSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=do.js.map

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var expand_1 = __webpack_require__(575);
	Observable_1.Observable.prototype.expand = expand_1.expand;
	//# sourceMappingURL=expand.js.map

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Returns an Observable where for each item in the source Observable, the supplied function is applied to each item,
	 * resulting in a new value to then be applied again with the function.
	 * @param {function} project the function for projecting the next emitted item of the Observable.
	 * @param {number} [concurrent] the max number of observables that can be created concurrently. defaults to infinity.
	 * @param {Scheduler} [scheduler] The Scheduler to use for managing the expansions.
	 * @return {Observable} an Observable containing the expansions of the source Observable.
	 * @method expand
	 * @owner Observable
	 */
	function expand(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (scheduler === void 0) { scheduler = undefined; }
	    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
	    return this.lift(new ExpandOperator(project, concurrent, scheduler));
	}
	exports.expand = expand;
	var ExpandOperator = (function () {
	    function ExpandOperator(project, concurrent, scheduler) {
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	    }
	    ExpandOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
	    };
	    return ExpandOperator;
	}());
	exports.ExpandOperator = ExpandOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ExpandSubscriber = (function (_super) {
	    __extends(ExpandSubscriber, _super);
	    function ExpandSubscriber(destination, project, concurrent, scheduler) {
	        _super.call(this, destination);
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this.active = 0;
	        this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            this.buffer = [];
	        }
	    }
	    ExpandSubscriber.dispatch = function (arg) {
	        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
	        subscriber.subscribeToProjection(result, value, index);
	    };
	    ExpandSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (destination.isUnsubscribed) {
	            this._complete();
	            return;
	        }
	        var index = this.index++;
	        if (this.active < this.concurrent) {
	            destination.next(value);
	            var result = tryCatch_1.tryCatch(this.project)(value, index);
	            if (result === errorObject_1.errorObject) {
	                destination.error(errorObject_1.errorObject.e);
	            }
	            else if (!this.scheduler) {
	                this.subscribeToProjection(result, value, index);
	            }
	            else {
	                var state = { subscriber: this, result: result, value: value, index: index };
	                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	        this.active++;
	        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    ExpandSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._next(innerValue);
	    };
	    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return ExpandSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.ExpandSubscriber = ExpandSubscriber;
	//# sourceMappingURL=expand.js.map

/***/ },
/* 576 */,
/* 577 */,
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var finally_1 = __webpack_require__(579);
	Observable_1.Observable.prototype.finally = finally_1._finally;
	//# sourceMappingURL=finally.js.map

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var Subscription_1 = __webpack_require__(44);
	/**
	 * Returns an Observable that mirrors the source Observable, but will call a specified function when
	 * the source terminates on complete or error.
	 * @param {function} finallySelector function to be called when source terminates.
	 * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.
	 * @method finally
	 * @owner Observable
	 */
	function _finally(finallySelector) {
	    return this.lift(new FinallyOperator(finallySelector));
	}
	exports._finally = _finally;
	var FinallyOperator = (function () {
	    function FinallyOperator(finallySelector) {
	        this.finallySelector = finallySelector;
	    }
	    FinallyOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new FinallySubscriber(subscriber, this.finallySelector));
	    };
	    return FinallyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FinallySubscriber = (function (_super) {
	    __extends(FinallySubscriber, _super);
	    function FinallySubscriber(destination, finallySelector) {
	        _super.call(this, destination);
	        this.add(new Subscription_1.Subscription(finallySelector));
	    }
	    return FinallySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=finally.js.map

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var first_1 = __webpack_require__(581);
	Observable_1.Observable.prototype.first = first_1.first;
	//# sourceMappingURL=first.js.map

/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var EmptyError_1 = __webpack_require__(582);
	/**
	 * Emits only the first value (or the first value that meets some condition)
	 * emitted by the source Observable.
	 *
	 * <span class="informal">Emits only the first value. Or emits only the first
	 * value that passes some test.</span>
	 *
	 * <img src="./img/first.png" width="100%">
	 *
	 * If called with no arguments, `first` emits the first value of the source
	 * Observable, then completes. If called with a `predicate` function, `first`
	 * emits the first value of the source that matches the specified condition. It
	 * may also take a `resultSelector` function to produce the output value from
	 * the input value, and a `defaultValue` to emit in case the source completes
	 * before it is able to emit a valid value. Throws an error if `defaultValue`
	 * was not provided and a matching element is not found.
	 *
	 * @example <caption>Emit only the first click that happens on the DOM</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Emits the first click that happens on a DIV</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link take}
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
	 * An optional function called with each item to test for condition matching.
	 * @param {function(value: T, index: number): R} [resultSelector] A function to
	 * produce the value on the output Observable based on the values
	 * and the indices of the source Observable. The arguments passed to this
	 * function are:
	 * - `value`: the value that was emitted on the source.
	 * - `index`: the "index" of the value from the source.
	 * @param {R} [defaultValue] The default value emitted in case no valid value
	 * was found on the source.
	 * @return {Observable<T|R>} an Observable of the first item that matches the
	 * condition.
	 * @method first
	 * @owner Observable
	 */
	function first(predicate, resultSelector, defaultValue) {
	    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.first = first;
	var FirstOperator = (function () {
	    function FirstOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    FirstOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return FirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FirstSubscriber = (function (_super) {
	    __extends(FirstSubscriber, _super);
	    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.index = 0;
	        this.hasCompleted = false;
	    }
	    FirstSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._emit = function (value, index) {
	        if (this.resultSelector) {
	            this._tryResultSelector(value, index);
	            return;
	        }
	        this._emitFinal(value);
	    };
	    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this._emitFinal(result);
	    };
	    FirstSubscriber.prototype._emitFinal = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	        this.hasCompleted = true;
	    };
	    FirstSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
	            destination.next(this.defaultValue);
	            destination.complete();
	        }
	        else if (!this.hasCompleted) {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return FirstSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=first.js.map

/***/ },
/* 582 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an Observable or a sequence was queried but has no
	 * elements.
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link single}
	 *
	 * @class EmptyError
	 */
	var EmptyError = (function (_super) {
	    __extends(EmptyError, _super);
	    function EmptyError() {
	        _super.call(this, 'no elements in sequence');
	        this.name = 'EmptyError';
	    }
	    return EmptyError;
	}(Error));
	exports.EmptyError = EmptyError;
	//# sourceMappingURL=EmptyError.js.map

/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var groupBy_1 = __webpack_require__(584);
	Observable_1.Observable.prototype.groupBy = groupBy_1.groupBy;
	//# sourceMappingURL=groupBy.js.map

/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var Subscription_1 = __webpack_require__(44);
	var Observable_1 = __webpack_require__(38);
	var Subject_1 = __webpack_require__(37);
	var Map_1 = __webpack_require__(585);
	var FastMap_1 = __webpack_require__(587);
	/**
	 * Groups the items emitted by an Observable according to a specified criterion,
	 * and emits these grouped items as `GroupedObservables`, one
	 * {@link GroupedObservable} per group.
	 *
	 * <img src="./img/groupBy.png" width="100%">
	 *
	 * @param {function(value: T): K} keySelector a function that extracts the key
	 * for each item.
	 * @param {function(value: T): R} [elementSelector] a function that extracts the
	 * return element for each item.
	 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
	 * a function that returns an Observable to determine how long each group should
	 * exist.
	 * @return {Observable<GroupedObservable<K,R>>} an Observable that emits
	 * GroupedObservables, each of which corresponds to a unique key value and each
	 * of which emits those items from the source Observable that share that key
	 * value.
	 * @method groupBy
	 * @owner Observable
	 */
	function groupBy(keySelector, elementSelector, durationSelector) {
	    return this.lift(new GroupByOperator(this, keySelector, elementSelector, durationSelector));
	}
	exports.groupBy = groupBy;
	var GroupByOperator = (function () {
	    function GroupByOperator(source, keySelector, elementSelector, durationSelector) {
	        this.source = source;
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	    }
	    GroupByOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector));
	    };
	    return GroupByOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupBySubscriber = (function (_super) {
	    __extends(GroupBySubscriber, _super);
	    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector) {
	        _super.call(this);
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.groups = null;
	        this.attemptedToUnsubscribe = false;
	        this.count = 0;
	        this.destination = destination;
	        this.add(destination);
	    }
	    GroupBySubscriber.prototype._next = function (value) {
	        var key;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this._group(value, key);
	    };
	    GroupBySubscriber.prototype._group = function (value, key) {
	        var groups = this.groups;
	        if (!groups) {
	            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
	        }
	        var group = groups.get(key);
	        if (!group) {
	            groups.set(key, group = new Subject_1.Subject());
	            var groupedObservable = new GroupedObservable(key, group, this);
	            if (this.durationSelector) {
	                this._selectDuration(key, group);
	            }
	            this.destination.next(groupedObservable);
	        }
	        if (this.elementSelector) {
	            this._selectElement(value, group);
	        }
	        else {
	            this.tryGroupNext(value, group);
	        }
	    };
	    GroupBySubscriber.prototype._selectElement = function (value, group) {
	        var result;
	        try {
	            result = this.elementSelector(value);
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this.tryGroupNext(result, group);
	    };
	    GroupBySubscriber.prototype._selectDuration = function (key, group) {
	        var duration;
	        try {
	            duration = this.durationSelector(new GroupedObservable(key, group));
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
	    };
	    GroupBySubscriber.prototype.tryGroupNext = function (value, group) {
	        if (!group.isUnsubscribed) {
	            group.next(value);
	        }
	    };
	    GroupBySubscriber.prototype._error = function (err) {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	            });
	            groups.clear();
	        }
	        this.destination.error(err);
	    };
	    GroupBySubscriber.prototype._complete = function () {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	            });
	            groups.clear();
	        }
	        this.destination.complete();
	    };
	    GroupBySubscriber.prototype.removeGroup = function (key) {
	        this.groups.delete(key);
	    };
	    GroupBySubscriber.prototype.unsubscribe = function () {
	        if (!this.isUnsubscribed && !this.attemptedToUnsubscribe) {
	            this.attemptedToUnsubscribe = true;
	            if (this.count === 0) {
	                _super.prototype.unsubscribe.call(this);
	            }
	        }
	    };
	    return GroupBySubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupDurationSubscriber = (function (_super) {
	    __extends(GroupDurationSubscriber, _super);
	    function GroupDurationSubscriber(key, group, parent) {
	        _super.call(this);
	        this.key = key;
	        this.group = group;
	        this.parent = parent;
	    }
	    GroupDurationSubscriber.prototype._next = function (value) {
	        this.tryComplete();
	    };
	    GroupDurationSubscriber.prototype._error = function (err) {
	        this.tryError(err);
	    };
	    GroupDurationSubscriber.prototype._complete = function () {
	        this.tryComplete();
	    };
	    GroupDurationSubscriber.prototype.tryError = function (err) {
	        var group = this.group;
	        if (!group.isUnsubscribed) {
	            group.error(err);
	        }
	        this.parent.removeGroup(this.key);
	    };
	    GroupDurationSubscriber.prototype.tryComplete = function () {
	        var group = this.group;
	        if (!group.isUnsubscribed) {
	            group.complete();
	        }
	        this.parent.removeGroup(this.key);
	    };
	    return GroupDurationSubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * An Observable representing values belonging to the same group represented by
	 * a common key. The values emitted by a GroupedObservable come from the source
	 * Observable. The common key is available as the field `key` on a
	 * GroupedObservable instance.
	 *
	 * @class GroupedObservable<K, T>
	 */
	var GroupedObservable = (function (_super) {
	    __extends(GroupedObservable, _super);
	    function GroupedObservable(key, groupSubject, refCountSubscription) {
	        _super.call(this);
	        this.key = key;
	        this.groupSubject = groupSubject;
	        this.refCountSubscription = refCountSubscription;
	    }
	    GroupedObservable.prototype._subscribe = function (subscriber) {
	        var subscription = new Subscription_1.Subscription();
	        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
	        if (refCountSubscription && !refCountSubscription.isUnsubscribed) {
	            subscription.add(new InnerRefCountSubscription(refCountSubscription));
	        }
	        subscription.add(groupSubject.subscribe(subscriber));
	        return subscription;
	    };
	    return GroupedObservable;
	}(Observable_1.Observable));
	exports.GroupedObservable = GroupedObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerRefCountSubscription = (function (_super) {
	    __extends(InnerRefCountSubscription, _super);
	    function InnerRefCountSubscription(parent) {
	        _super.call(this);
	        this.parent = parent;
	        parent.count++;
	    }
	    InnerRefCountSubscription.prototype.unsubscribe = function () {
	        var parent = this.parent;
	        if (!parent.isUnsubscribed && !this.isUnsubscribed) {
	            _super.prototype.unsubscribe.call(this);
	            parent.count -= 1;
	            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
	                parent.unsubscribe();
	            }
	        }
	    };
	    return InnerRefCountSubscription;
	}(Subscription_1.Subscription));
	//# sourceMappingURL=groupBy.js.map

/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(39);
	var MapPolyfill_1 = __webpack_require__(586);
	exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();
	//# sourceMappingURL=Map.js.map

/***/ },
/* 586 */
/***/ function(module, exports) {

	"use strict";
	var MapPolyfill = (function () {
	    function MapPolyfill() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    MapPolyfill.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    MapPolyfill.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        }
	        else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    MapPolyfill.prototype.delete = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    MapPolyfill.prototype.clear = function () {
	        this._keys.length = 0;
	        this._values.length = 0;
	        this.size = 0;
	    };
	    MapPolyfill.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return MapPolyfill;
	}());
	exports.MapPolyfill = MapPolyfill;
	//# sourceMappingURL=MapPolyfill.js.map

/***/ },
/* 587 */
/***/ function(module, exports) {

	"use strict";
	var FastMap = (function () {
	    function FastMap() {
	        this.values = {};
	    }
	    FastMap.prototype.delete = function (key) {
	        this.values[key] = null;
	        return true;
	    };
	    FastMap.prototype.set = function (key, value) {
	        this.values[key] = value;
	        return this;
	    };
	    FastMap.prototype.get = function (key) {
	        return this.values[key];
	    };
	    FastMap.prototype.forEach = function (cb, thisArg) {
	        var values = this.values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key) && values[key] !== null) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };
	    FastMap.prototype.clear = function () {
	        this.values = {};
	    };
	    return FastMap;
	}());
	exports.FastMap = FastMap;
	//# sourceMappingURL=FastMap.js.map

/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var ignoreElements_1 = __webpack_require__(589);
	Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;
	//# sourceMappingURL=ignoreElements.js.map

/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var noop_1 = __webpack_require__(519);
	/**
	 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
	 *
	 * <img src="./img/ignoreElements.png" width="100%">
	 *
	 * @return {Observable} an empty Observable that only calls `complete`
	 * or `error`, based on which one is called by the source Observable.
	 * @method ignoreElements
	 * @owner Observable
	 */
	function ignoreElements() {
	    return this.lift(new IgnoreElementsOperator());
	}
	exports.ignoreElements = ignoreElements;
	;
	var IgnoreElementsOperator = (function () {
	    function IgnoreElementsOperator() {
	    }
	    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new IgnoreElementsSubscriber(subscriber));
	    };
	    return IgnoreElementsOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IgnoreElementsSubscriber = (function (_super) {
	    __extends(IgnoreElementsSubscriber, _super);
	    function IgnoreElementsSubscriber() {
	        _super.apply(this, arguments);
	    }
	    IgnoreElementsSubscriber.prototype._next = function (unused) {
	        noop_1.noop();
	    };
	    return IgnoreElementsSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=ignoreElements.js.map

/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var audit_1 = __webpack_require__(591);
	Observable_1.Observable.prototype.audit = audit_1.audit;
	//# sourceMappingURL=audit.js.map

/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Ignores source values for a duration determined by another Observable, then
	 * emits the most recent value from the source Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link auditTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/audit.png" width="100%">
	 *
	 * `audit` is similar to `throttle`, but emits the last value from the silenced
	 * time window, instead of the first value. `audit` emits the most recent value
	 * from the source Observable on the output Observable as soon as its internal
	 * timer becomes disabled, and ignores source values while the timer is enabled.
	 * Initially, the timer is disabled. As soon as the first source value arrives,
	 * the timer is enabled by calling the `durationSelector` function with the
	 * source value, which returns the "duration" Observable. When the duration
	 * Observable emits a value or completes, the timer is disabled, then the most
	 * recent source value is emitted on the output Observable, and this process
	 * repeats for the next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): Observable|Promise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method audit
	 * @owner Observable
	 */
	function audit(durationSelector) {
	    return this.lift(new AuditOperator(durationSelector));
	}
	exports.audit = audit;
	var AuditOperator = (function () {
	    function AuditOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    AuditOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new AuditSubscriber(subscriber, this.durationSelector));
	    };
	    return AuditOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditSubscriber = (function (_super) {
	    __extends(AuditSubscriber, _super);
	    function AuditSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	    }
	    AuditSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
	            if (duration === errorObject_1.errorObject) {
	                this.destination.error(errorObject_1.errorObject.e);
	            }
	            else {
	                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	            }
	        }
	    };
	    AuditSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        this.clearThrottle();
	    };
	    AuditSubscriber.prototype.notifyComplete = function () {
	        this.clearThrottle();
	    };
	    return AuditSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=audit.js.map

/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var auditTime_1 = __webpack_require__(593);
	Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;
	//# sourceMappingURL=auditTime.js.map

/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(510);
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Ignores source values for `duration` milliseconds, then emits the most recent
	 * value from the source Observable, then repeats this process.
	 *
	 * <span class="informal">When it sees a source values, it ignores that plus
	 * the next ones for `duration` milliseconds, and then it emits the most recent
	 * value from the source.</span>
	 *
	 * <img src="./img/auditTime.png" width="100%">
	 *
	 * `auditTime` is similar to `throttleTime`, but emits the last value from the
	 * silenced time window, instead of the first value. `auditTime` emits the most
	 * recent value from the source Observable on the output Observable as soon as
	 * its internal timer becomes disabled, and ignores source values while the
	 * timer is enabled. Initially, the timer is disabled. As soon as the first
	 * source value arrives, the timer is enabled. After `duration` milliseconds (or
	 * the time unit determined internally by the optional `scheduler`) has passed,
	 * the timer is disabled, then the most recent source value is emitted on the
	 * output Observable, and this process repeats for the next source value.
	 * Optionally takes a {@link Scheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.auditTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} duration Time to wait before emitting the most recent source
	 * value, measured in milliseconds or the time unit determined internally
	 * by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
	 * managing the timers that handle the rate-limiting behavior.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method auditTime
	 * @owner Observable
	 */
	function auditTime(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new AuditTimeOperator(duration, scheduler));
	}
	exports.auditTime = auditTime;
	var AuditTimeOperator = (function () {
	    function AuditTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    AuditTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return AuditTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditTimeSubscriber = (function (_super) {
	    __extends(AuditTimeSubscriber, _super);
	    function AuditTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	    }
	    AuditTimeSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));
	        }
	    };
	    AuditTimeSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    return AuditTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.clearThrottle();
	}
	//# sourceMappingURL=auditTime.js.map

/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var last_1 = __webpack_require__(595);
	Observable_1.Observable.prototype.last = last_1.last;
	//# sourceMappingURL=last.js.map

/***/ },
/* 595 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var EmptyError_1 = __webpack_require__(582);
	/**
	 * Returns an Observable that emits only the last item emitted by the source Observable.
	 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
	 * the last item from the source Observable, the resulting Observable will emit the last item
	 * from the source Observable that satisfies the predicate.
	 *
	 * <img src="./img/last.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {function} predicate - the condition any source emitted item has to satisfy.
	 * @return {Observable} an Observable that emits only the last item satisfying the given condition
	 * from the source, or an NoSuchElementException if no such items are emitted.
	 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
	 * @method last
	 * @owner Observable
	 */
	function last(predicate, resultSelector, defaultValue) {
	    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.last = last;
	var LastOperator = (function () {
	    function LastOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    LastOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return LastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var LastSubscriber = (function (_super) {
	    __extends(LastSubscriber, _super);
	    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.hasValue = false;
	        this.index = 0;
	        if (typeof defaultValue !== 'undefined') {
	            this.lastValue = defaultValue;
	            this.hasValue = true;
	        }
	    }
	    LastSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.lastValue = result;
	        this.hasValue = true;
	    };
	    LastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.hasValue) {
	            destination.next(this.lastValue);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return LastSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=last.js.map

/***/ },
/* 596 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var let_1 = __webpack_require__(597);
	Observable_1.Observable.prototype.let = let_1.letProto;
	Observable_1.Observable.prototype.letBind = let_1.letProto;
	//# sourceMappingURL=let.js.map

/***/ },
/* 597 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @param func
	 * @return {Observable<R>}
	 * @method let
	 * @owner Observable
	 */
	function letProto(func) {
	    return func(this);
	}
	exports.letProto = letProto;
	//# sourceMappingURL=let.js.map

/***/ },
/* 598 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var mapTo_1 = __webpack_require__(599);
	Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;
	//# sourceMappingURL=mapTo.js.map

/***/ },
/* 599 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Emits the given constant value on the output Observable every time the source
	 * Observable emits a value.
	 *
	 * <span class="informal">Like {@link map}, but it maps every source value to
	 * the same output value every time.</span>
	 *
	 * <img src="./img/mapTo.png" width="100%">
	 *
	 * Takes a constant `value` as argument, and emits that whenever the source
	 * Observable emits a value. In other words, ignores the actual source value,
	 * and simply uses the emission moment to know when to emit the given `value`.
	 *
	 * @example <caption>Map every every click to the string 'Hi'</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var greetings = clicks.mapTo('Hi');
	 * greetings.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {any} value The value to map each source value to.
	 * @return {Observable} An Observable that emits the given `value` every time
	 * the source Observable emits something.
	 * @method mapTo
	 * @owner Observable
	 */
	function mapTo(value) {
	    return this.lift(new MapToOperator(value));
	}
	exports.mapTo = mapTo;
	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        this.value = value;
	    }
	    MapToOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new MapToSubscriber(subscriber, this.value));
	    };
	    return MapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapToSubscriber = (function (_super) {
	    __extends(MapToSubscriber, _super);
	    function MapToSubscriber(destination, value) {
	        _super.call(this, destination);
	        this.value = value;
	    }
	    MapToSubscriber.prototype._next = function (x) {
	        this.destination.next(this.value);
	    };
	    return MapToSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=mapTo.js.map

/***/ },
/* 600 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var materialize_1 = __webpack_require__(601);
	Observable_1.Observable.prototype.materialize = materialize_1.materialize;
	//# sourceMappingURL=materialize.js.map

/***/ },
/* 601 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var Notification_1 = __webpack_require__(414);
	/**
	 * Returns an Observable that represents all of the emissions and notifications
	 * from the source Observable into emissions marked with their original types
	 * within a `Notification` objects.
	 *
	 * <img src="./img/materialize.png" width="100%">
	 *
	 * @see {@link Notification}
	 *
	 * @scheduler materialize does not operate by default on a particular Scheduler.
	 * @return {Observable<Notification<T>>} an Observable that emits items that are the result of
	 * materializing the items and notifications of the source Observable.
	 * @method materialize
	 * @owner Observable
	 */
	function materialize() {
	    return this.lift(new MaterializeOperator());
	}
	exports.materialize = materialize;
	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	    }
	    MaterializeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new MaterializeSubscriber(subscriber));
	    };
	    return MaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MaterializeSubscriber = (function (_super) {
	    __extends(MaterializeSubscriber, _super);
	    function MaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    MaterializeSubscriber.prototype._next = function (value) {
	        this.destination.next(Notification_1.Notification.createNext(value));
	    };
	    MaterializeSubscriber.prototype._error = function (err) {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createError(err));
	        destination.complete();
	    };
	    MaterializeSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createComplete());
	        destination.complete();
	    };
	    return MaterializeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=materialize.js.map

/***/ },
/* 602 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var mergeMapTo_1 = __webpack_require__(556);
	Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
	Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;
	//# sourceMappingURL=mergeMapTo.js.map

/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var multicast_1 = __webpack_require__(361);
	Observable_1.Observable.prototype.multicast = multicast_1.multicast;
	//# sourceMappingURL=multicast.js.map

/***/ },
/* 604 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var observeOn_1 = __webpack_require__(413);
	Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;
	//# sourceMappingURL=observeOn.js.map

/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var partition_1 = __webpack_require__(606);
	Observable_1.Observable.prototype.partition = partition_1.partition;
	//# sourceMappingURL=partition.js.map

/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var not_1 = __webpack_require__(607);
	var filter_1 = __webpack_require__(577);
	/**
	 * Splits the source Observable into two, one with values that satisfy a
	 * predicate, and another with values that don't satisfy the predicate.
	 *
	 * <span class="informal">It's like {@link filter}, but returns two Observables:
	 * one like the output of {@link filter}, and the other with values that did not
	 * pass the condition.</span>
	 *
	 * <img src="./img/partition.png" width="100%">
	 *
	 * `partition` outputs an array with two Observables that partition the values
	 * from the source Observable through the given `predicate` function. The first
	 * Observable in that array emits source values for which the predicate argument
	 * returns true. The second Observable emits source values for which the
	 * predicate returns false. The first behaves like {@link filter} and the second
	 * behaves like {@link filter} with the predicate negated.
	 *
	 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
	 * var clicksOnDivs = parts[0];
	 * var clicksElsewhere = parts[1];
	 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
	 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
	 *
	 * @see {@link filter}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted on the first Observable in the returned array, if
	 * `false` the value is emitted on the second Observable in the array. The
	 * `index` parameter is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
	 * with values that passed the predicate, and another with values that did not
	 * pass the predicate.
	 * @method partition
	 * @owner Observable
	 */
	function partition(predicate, thisArg) {
	    return [
	        filter_1.filter.call(this, predicate),
	        filter_1.filter.call(this, not_1.not(predicate, thisArg))
	    ];
	}
	exports.partition = partition;
	//# sourceMappingURL=partition.js.map

/***/ },
/* 607 */
/***/ function(module, exports) {

	"use strict";
	function not(pred, thisArg) {
	    function notPred() {
	        return !(notPred.pred.apply(notPred.thisArg, arguments));
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}
	exports.not = not;
	//# sourceMappingURL=not.js.map

/***/ },
/* 608 */,
/* 609 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var publish_1 = __webpack_require__(610);
	Observable_1.Observable.prototype.publish = publish_1.publish;
	//# sourceMappingURL=publish.js.map

/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subject_1 = __webpack_require__(37);
	var multicast_1 = __webpack_require__(361);
	/**
	 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
	 * before it begins emitting items to those Observers that have subscribed to it.
	 *
	 * <img src="./img/publish.png" width="100%">
	 *
	 * @return a ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
	 * @method publish
	 * @owner Observable
	 */
	function publish() {
	    return multicast_1.multicast.call(this, new Subject_1.Subject());
	}
	exports.publish = publish;
	//# sourceMappingURL=publish.js.map

/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var publishBehavior_1 = __webpack_require__(612);
	Observable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;
	//# sourceMappingURL=publishBehavior.js.map

/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BehaviorSubject_1 = __webpack_require__(422);
	var multicast_1 = __webpack_require__(361);
	/**
	 * @param value
	 * @return {ConnectableObservable<T>}
	 * @method publishBehavior
	 * @owner Observable
	 */
	function publishBehavior(value) {
	    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));
	}
	exports.publishBehavior = publishBehavior;
	//# sourceMappingURL=publishBehavior.js.map

/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var publishReplay_1 = __webpack_require__(545);
	Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;
	//# sourceMappingURL=publishReplay.js.map

/***/ },
/* 614 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var publishLast_1 = __webpack_require__(615);
	Observable_1.Observable.prototype.publishLast = publishLast_1.publishLast;
	//# sourceMappingURL=publishLast.js.map

/***/ },
/* 615 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncSubject_1 = __webpack_require__(483);
	var multicast_1 = __webpack_require__(361);
	/**
	 * @return {ConnectableObservable<T>}
	 * @method publishLast
	 * @owner Observable
	 */
	function publishLast() {
	    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());
	}
	exports.publishLast = publishLast;
	//# sourceMappingURL=publishLast.js.map

/***/ },
/* 616 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var race_1 = __webpack_require__(515);
	Observable_1.Observable.prototype.race = race_1.race;
	//# sourceMappingURL=race.js.map

/***/ },
/* 617 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var reduce_1 = __webpack_require__(618);
	Observable_1.Observable.prototype.reduce = reduce_1.reduce;
	//# sourceMappingURL=reduce.js.map

/***/ },
/* 618 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Returns an Observable that applies a specified accumulator function to the first item emitted by a source Observable,
	 * then feeds the result of that function along with the second item emitted by the source Observable into the same
	 * function, and so on until all items have been emitted by the source Observable, and emits the final result from
	 * the final call to your function as its sole item.
	 * This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate," "compress," or
	 * "inject" in other programming contexts.
	 *
	 * <img src="./img/reduce.png" width="100%">
	 *
	 * @param {initialValue} the initial (seed) accumulator value
	 * @param {accumulator} an accumulator function to be invoked on each item emitted by the source Observable, the
	 * result of which will be used in the next accumulator call.
	 * @return {Observable} an Observable that emits a single item that is the result of accumulating the output from the
	 * items emitted by the source Observable.
	 * @method reduce
	 * @owner Observable
	 */
	function reduce(project, seed) {
	    return this.lift(new ReduceOperator(project, seed));
	}
	exports.reduce = reduce;
	var ReduceOperator = (function () {
	    function ReduceOperator(project, seed) {
	        this.project = project;
	        this.seed = seed;
	    }
	    ReduceOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ReduceSubscriber(subscriber, this.project, this.seed));
	    };
	    return ReduceOperator;
	}());
	exports.ReduceOperator = ReduceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ReduceSubscriber = (function (_super) {
	    __extends(ReduceSubscriber, _super);
	    function ReduceSubscriber(destination, project, seed) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.acc = seed;
	        this.project = project;
	        this.hasSeed = typeof seed !== 'undefined';
	    }
	    ReduceSubscriber.prototype._next = function (value) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            this._tryReduce(value);
	        }
	        else {
	            this.acc = value;
	            this.hasValue = true;
	        }
	    };
	    ReduceSubscriber.prototype._tryReduce = function (value) {
	        var result;
	        try {
	            result = this.project(this.acc, value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.acc = result;
	    };
	    ReduceSubscriber.prototype._complete = function () {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	    return ReduceSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ReduceSubscriber = ReduceSubscriber;
	//# sourceMappingURL=reduce.js.map

/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var repeat_1 = __webpack_require__(620);
	Observable_1.Observable.prototype.repeat = repeat_1.repeat;
	//# sourceMappingURL=repeat.js.map

/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var EmptyObservable_1 = __webpack_require__(357);
	/**
	 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times,
	 * on a particular Scheduler.
	 *
	 * <img src="./img/repeat.png" width="100%">
	 *
	 * @param {Scheduler} [scheduler] the Scheduler to emit the items on.
	 * @param {number} [count] the number of times the source Observable items are repeated, a count of 0 will yield
	 * an empty Observable.
	 * @return {Observable} an Observable that repeats the stream of items emitted by the source Observable at most
	 * count times.
	 * @method repeat
	 * @owner Observable
	 */
	function repeat(count) {
	    if (count === void 0) { count = -1; }
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else if (count < 0) {
	        return this.lift(new RepeatOperator(-1, this));
	    }
	    else {
	        return this.lift(new RepeatOperator(count - 1, this));
	    }
	}
	exports.repeat = repeat;
	var RepeatOperator = (function () {
	    function RepeatOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RepeatOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
	    };
	    return RepeatOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatSubscriber = (function (_super) {
	    __extends(RepeatSubscriber, _super);
	    function RepeatSubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RepeatSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.complete.call(this);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            this.unsubscribe();
	            this.isStopped = false;
	            this.isUnsubscribed = false;
	            source.subscribe(this);
	        }
	    };
	    return RepeatSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=repeat.js.map

/***/ },
/* 621 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var retry_1 = __webpack_require__(622);
	Observable_1.Observable.prototype.retry = retry_1.retry;
	//# sourceMappingURL=retry.js.map

/***/ },
/* 622 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls `error` and the
	 * predicate returns true for that specific exception and retry count.
	 * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of
	 * count resubscriptions (given as a number parameter) rather than propagating the `error` call.
	 *
	 * <img src="./img/retry.png" width="100%">
	 *
	 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
	 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
	 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
	 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
	 * @param {number} number of retry attempts before failing.
	 * @return {Observable} the source Observable modified with the retry logic.
	 * @method retry
	 * @owner Observable
	 */
	function retry(count) {
	    if (count === void 0) { count = -1; }
	    return this.lift(new RetryOperator(count, this));
	}
	exports.retry = retry;
	var RetryOperator = (function () {
	    function RetryOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RetryOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new RetrySubscriber(subscriber, this.count, this.source));
	    };
	    return RetryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetrySubscriber = (function (_super) {
	    __extends(RetrySubscriber, _super);
	    function RetrySubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RetrySubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.error.call(this, err);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            this.unsubscribe();
	            this.isStopped = false;
	            this.isUnsubscribed = false;
	            source.subscribe(this);
	        }
	    };
	    return RetrySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=retry.js.map

/***/ },
/* 623 */,
/* 624 */,
/* 625 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var sample_1 = __webpack_require__(626);
	Observable_1.Observable.prototype.sample = sample_1.sample;
	//# sourceMappingURL=sample.js.map

/***/ },
/* 626 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Emits the most recently emitted value from the source Observable whenever
	 * another Observable, the `notifier`, emits.
	 *
	 * <span class="informal">It's like {@link sampleTime}, but samples whenever
	 * the `notifier` Observable emits something.</span>
	 *
	 * <img src="./img/sample.png" width="100%">
	 *
	 * Whenever the `notifier` Observable emits a value or completes, `sample`
	 * looks at the source Observable and emits whichever value it has most recently
	 * emitted since the previous sampling, unless the source has not emitted
	 * anything since the previous sampling. The `notifier` is subscribed to as soon
	 * as the output Observable is subscribed.
	 *
	 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = seconds.sample(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {Observable<any>} notifier The Observable to use for sampling the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable whenever the notifier Observable
	 * emits value or completes.
	 * @method sample
	 * @owner Observable
	 */
	function sample(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}
	exports.sample = sample;
	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SampleOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SampleSubscriber(subscriber, this.notifier));
	    };
	    return SampleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleSubscriber = (function (_super) {
	    __extends(SampleSubscriber, _super);
	    function SampleSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    SampleSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	    };
	    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.value);
	        }
	    };
	    return SampleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=sample.js.map

/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var sampleTime_1 = __webpack_require__(628);
	Observable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;
	//# sourceMappingURL=sampleTime.js.map

/***/ },
/* 628 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var async_1 = __webpack_require__(510);
	/**
	 * Emits the most recently emitted value from the source Observable within
	 * periodic time intervals.
	 *
	 * <span class="informal">Samples the source Observable at periodic time
	 * intervals, emitting what it samples.</span>
	 *
	 * <img src="./img/sampleTime.png" width="100%">
	 *
	 * `sampleTime` periodically looks at the source Observable and emits whichever
	 * value it has most recently emitted since the previous sampling, unless the
	 * source has not emitted anything since the previous sampling. The sampling
	 * happens periodically in time every `period` milliseconds (or the time unit
	 * defined by the optional `scheduler` argument). The sampling starts as soon as
	 * the output Observable is subscribed.
	 *
	 * @example <caption>Every second, emit the most recent click at most once</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.sampleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {number} period The sampling period expressed in milliseconds or the
	 * time unit determined internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable at the specified time interval.
	 * @method sampleTime
	 * @owner Observable
	 */
	function sampleTime(period, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new SampleTimeOperator(period, scheduler));
	}
	exports.sampleTime = sampleTime;
	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(period, scheduler) {
	        this.period = period;
	        this.scheduler = scheduler;
	    }
	    SampleTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
	    };
	    return SampleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleTimeSubscriber = (function (_super) {
	    __extends(SampleTimeSubscriber, _super);
	    function SampleTimeSubscriber(destination, period, scheduler) {
	        _super.call(this, destination);
	        this.period = period;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
	    }
	    SampleTimeSubscriber.prototype._next = function (value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	    SampleTimeSubscriber.prototype.notifyNext = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.lastValue);
	        }
	    };
	    return SampleTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNotification(state) {
	    var subscriber = state.subscriber, period = state.period;
	    subscriber.notifyNext();
	    this.schedule(state, period);
	}
	//# sourceMappingURL=sampleTime.js.map

/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var single_1 = __webpack_require__(630);
	Observable_1.Observable.prototype.single = single_1.single;
	//# sourceMappingURL=single.js.map

/***/ },
/* 630 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var EmptyError_1 = __webpack_require__(582);
	/**
	 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
	 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
	 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
	 *
	 * <img src="./img/single.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {Function} a predicate function to evaluate items emitted by the source Observable.
	 * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches
	 * the predicate.
	 .
	 * @method single
	 * @owner Observable
	 */
	function single(predicate) {
	    return this.lift(new SingleOperator(predicate, this));
	}
	exports.single = single;
	var SingleOperator = (function () {
	    function SingleOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    SingleOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
	    };
	    return SingleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SingleSubscriber = (function (_super) {
	    __extends(SingleSubscriber, _super);
	    function SingleSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.seenValue = false;
	        this.index = 0;
	    }
	    SingleSubscriber.prototype.applySingleValue = function (value) {
	        if (this.seenValue) {
	            this.destination.error('Sequence contains more than one element');
	        }
	        else {
	            this.seenValue = true;
	            this.singleValue = value;
	        }
	    };
	    SingleSubscriber.prototype._next = function (value) {
	        var predicate = this.predicate;
	        this.index++;
	        if (predicate) {
	            this.tryNext(value);
	        }
	        else {
	            this.applySingleValue(value);
	        }
	    };
	    SingleSubscriber.prototype.tryNext = function (value) {
	        try {
	            var result = this.predicate(value, this.index, this.source);
	            if (result) {
	                this.applySingleValue(value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    SingleSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index > 0) {
	            destination.next(this.seenValue ? this.singleValue : undefined);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return SingleSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=single.js.map

/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var skip_1 = __webpack_require__(632);
	Observable_1.Observable.prototype.skip = skip_1.skip;
	//# sourceMappingURL=skip.js.map

/***/ },
/* 632 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Returns an Observable that skips `n` items emitted by an Observable.
	 *
	 * <img src="./img/skip.png" width="100%">
	 *
	 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
	 * @return {Observable} an Observable that skips values emitted by the source Observable.
	 *
	 * @method skip
	 * @owner Observable
	 */
	function skip(total) {
	    return this.lift(new SkipOperator(total));
	}
	exports.skip = skip;
	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        this.total = total;
	    }
	    SkipOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SkipSubscriber(subscriber, this.total));
	    };
	    return SkipOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipSubscriber = (function (_super) {
	    __extends(SkipSubscriber, _super);
	    function SkipSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    SkipSubscriber.prototype._next = function (x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	    return SkipSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=skip.js.map

/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var skipUntil_1 = __webpack_require__(634);
	Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;
	//# sourceMappingURL=skipUntil.js.map

/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
	 *
	 * <img src="./img/skipUntil.png" width="100%">
	 *
	 * @param {Observable} the second Observable that has to emit an item before the source Observable's elements begin to
	 * be mirrored by the resulting Observable.
	 * @return {Observable<T>} an Observable that skips items from the source Observable until the second Observable emits
	 * an item, then emits the remaining items.
	 * @method skipUntil
	 * @owner Observable
	 */
	function skipUntil(notifier) {
	    return this.lift(new SkipUntilOperator(notifier));
	}
	exports.skipUntil = skipUntil;
	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SkipUntilOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
	    };
	    return SkipUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipUntilSubscriber = (function (_super) {
	    __extends(SkipUntilSubscriber, _super);
	    function SkipUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.isInnerStopped = false;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    SkipUntilSubscriber.prototype._next = function (value) {
	        if (this.hasValue) {
	            _super.prototype._next.call(this, value);
	        }
	    };
	    SkipUntilSubscriber.prototype._complete = function () {
	        if (this.isInnerStopped) {
	            _super.prototype._complete.call(this);
	        }
	        else {
	            this.unsubscribe();
	        }
	    };
	    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.hasValue = true;
	    };
	    SkipUntilSubscriber.prototype.notifyComplete = function () {
	        this.isInnerStopped = true;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    return SkipUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=skipUntil.js.map

/***/ },
/* 635 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var skipWhile_1 = __webpack_require__(636);
	Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;
	//# sourceMappingURL=skipWhile.js.map

/***/ },
/* 636 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
	 * true, but emits all further source items as soon as the condition becomes false.
	 *
	 * <img src="./img/skipWhile.png" width="100%">
	 *
	 * @param {Function} predicate - a function to test each item emitted from the source Observable.
	 * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the
	 * specified predicate becomes false.
	 * @method skipWhile
	 * @owner Observable
	 */
	function skipWhile(predicate) {
	    return this.lift(new SkipWhileOperator(predicate));
	}
	exports.skipWhile = skipWhile;
	var SkipWhileOperator = (function () {
	    function SkipWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    SkipWhileOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
	    };
	    return SkipWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipWhileSubscriber = (function (_super) {
	    __extends(SkipWhileSubscriber, _super);
	    function SkipWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.skipping = true;
	        this.index = 0;
	    }
	    SkipWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (this.skipping) {
	            this.tryCallPredicate(value);
	        }
	        if (!this.skipping) {
	            destination.next(value);
	        }
	    };
	    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
	        try {
	            var result = this.predicate(value, this.index++);
	            this.skipping = Boolean(result);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    return SkipWhileSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=skipWhile.js.map

/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var startWith_1 = __webpack_require__(638);
	Observable_1.Observable.prototype.startWith = startWith_1.startWith;
	//# sourceMappingURL=startWith.js.map

/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(355);
	var ScalarObservable_1 = __webpack_require__(356);
	var EmptyObservable_1 = __webpack_require__(357);
	var concat_1 = __webpack_require__(402);
	var isScheduler_1 = __webpack_require__(358);
	/**
	 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
	 * source Observable.
	 *
	 * <img src="./img/startWith.png" width="100%">
	 *
	 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
	 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
	 * emitted by the source Observable.
	 * @method startWith
	 * @owner Observable
	 */
	function startWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i - 0] = arguments[_i];
	    }
	    var scheduler = array[array.length - 1];
	    if (isScheduler_1.isScheduler(scheduler)) {
	        array.pop();
	    }
	    else {
	        scheduler = null;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
	    }
	    else if (len > 1) {
	        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
	    }
	    else {
	        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
	    }
	}
	exports.startWith = startWith;
	//# sourceMappingURL=startWith.js.map

/***/ },
/* 639 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var subscribeOn_1 = __webpack_require__(640);
	Observable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;
	//# sourceMappingURL=subscribeOn.js.map

/***/ },
/* 640 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var SubscribeOnObservable_1 = __webpack_require__(641);
	/**
	 * Asynchronously subscribes Observers to this Observable on the specified Scheduler.
	 *
	 * <img src="./img/subscribeOn.png" width="100%">
	 *
	 * @param {Scheduler} the Scheduler to perform subscription actions on.
	 * @return {Observable<T>} the source Observable modified so that its subscriptions happen on the specified Scheduler
	 .
	 * @method subscribeOn
	 * @owner Observable
	 */
	function subscribeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return new SubscribeOnObservable_1.SubscribeOnObservable(this, delay, scheduler);
	}
	exports.subscribeOn = subscribeOn;
	//# sourceMappingURL=subscribeOn.js.map

/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(38);
	var asap_1 = __webpack_require__(642);
	var isNumeric_1 = __webpack_require__(509);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var SubscribeOnObservable = (function (_super) {
	    __extends(SubscribeOnObservable, _super);
	    function SubscribeOnObservable(source, delayTime, scheduler) {
	        if (delayTime === void 0) { delayTime = 0; }
	        if (scheduler === void 0) { scheduler = asap_1.asap; }
	        _super.call(this);
	        this.source = source;
	        this.delayTime = delayTime;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
	            this.delayTime = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = asap_1.asap;
	        }
	    }
	    SubscribeOnObservable.create = function (source, delay, scheduler) {
	        if (delay === void 0) { delay = 0; }
	        if (scheduler === void 0) { scheduler = asap_1.asap; }
	        return new SubscribeOnObservable(source, delay, scheduler);
	    };
	    SubscribeOnObservable.dispatch = function (arg) {
	        var source = arg.source, subscriber = arg.subscriber;
	        return source.subscribe(subscriber);
	    };
	    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        });
	    };
	    return SubscribeOnObservable;
	}(Observable_1.Observable));
	exports.SubscribeOnObservable = SubscribeOnObservable;
	//# sourceMappingURL=SubscribeOnObservable.js.map

/***/ },
/* 642 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsapScheduler_1 = __webpack_require__(643);
	exports.asap = new AsapScheduler_1.AsapScheduler();
	//# sourceMappingURL=asap.js.map

/***/ },
/* 643 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsapAction_1 = __webpack_require__(644);
	var QueueScheduler_1 = __webpack_require__(449);
	var AsapScheduler = (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        _super.apply(this, arguments);
	    }
	    AsapScheduler.prototype.scheduleNow = function (work, state) {
	        return new AsapAction_1.AsapAction(this, work).schedule(state);
	    };
	    return AsapScheduler;
	}(QueueScheduler_1.QueueScheduler));
	exports.AsapScheduler = AsapScheduler;
	//# sourceMappingURL=AsapScheduler.js.map

/***/ },
/* 644 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Immediate_1 = __webpack_require__(645);
	var FutureAction_1 = __webpack_require__(451);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsapAction = (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction() {
	        _super.apply(this, arguments);
	    }
	    AsapAction.prototype._schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype._schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        if (!scheduler.scheduledId) {
	            scheduler.scheduledId = Immediate_1.Immediate.setImmediate(function () {
	                scheduler.scheduledId = null;
	                scheduler.flush();
	            });
	        }
	        return this;
	    };
	    AsapAction.prototype._unsubscribe = function () {
	        var scheduler = this.scheduler;
	        var scheduledId = scheduler.scheduledId, actions = scheduler.actions;
	        _super.prototype._unsubscribe.call(this);
	        if (actions.length === 0) {
	            scheduler.active = false;
	            if (scheduledId != null) {
	                scheduler.scheduledId = null;
	                Immediate_1.Immediate.clearImmediate(scheduledId);
	            }
	        }
	    };
	    return AsapAction;
	}(FutureAction_1.FutureAction));
	exports.AsapAction = AsapAction;
	//# sourceMappingURL=AsapAction.js.map

/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**
	Some credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	"use strict";
	var root_1 = __webpack_require__(39);
	var ImmediateDefinition = (function () {
	    function ImmediateDefinition(root) {
	        this.root = root;
	        if (root.setImmediate && typeof root.setImmediate === 'function') {
	            this.setImmediate = root.setImmediate.bind(root);
	            this.clearImmediate = root.clearImmediate.bind(root);
	        }
	        else {
	            this.nextHandle = 1;
	            this.tasksByHandle = {};
	            this.currentlyRunningATask = false;
	            // Don't get fooled by e.g. browserify environments.
	            if (this.canUseProcessNextTick()) {
	                // For Node.js before 0.9
	                this.setImmediate = this.createProcessNextTickSetImmediate();
	            }
	            else if (this.canUsePostMessage()) {
	                // For non-IE10 modern browsers
	                this.setImmediate = this.createPostMessageSetImmediate();
	            }
	            else if (this.canUseMessageChannel()) {
	                // For web workers, where supported
	                this.setImmediate = this.createMessageChannelSetImmediate();
	            }
	            else if (this.canUseReadyStateChange()) {
	                // For IE 68
	                this.setImmediate = this.createReadyStateChangeSetImmediate();
	            }
	            else {
	                // For older browsers
	                this.setImmediate = this.createSetTimeoutSetImmediate();
	            }
	            var ci = function clearImmediate(handle) {
	                delete clearImmediate.instance.tasksByHandle[handle];
	            };
	            ci.instance = this;
	            this.clearImmediate = ci;
	        }
	    }
	    ImmediateDefinition.prototype.identify = function (o) {
	        return this.root.Object.prototype.toString.call(o);
	    };
	    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
	        return this.identify(this.root.process) === '[object process]';
	    };
	    ImmediateDefinition.prototype.canUseMessageChannel = function () {
	        return Boolean(this.root.MessageChannel);
	    };
	    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
	        var document = this.root.document;
	        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
	    };
	    ImmediateDefinition.prototype.canUsePostMessage = function () {
	        var root = this.root;
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `root.postMessage` means something completely different and can't be used for this purpose.
	        if (root.postMessage && !root.importScripts) {
	            var postMessageIsAsynchronous_1 = true;
	            var oldOnMessage = root.onmessage;
	            root.onmessage = function () {
	                postMessageIsAsynchronous_1 = false;
	            };
	            root.postMessage('', '*');
	            root.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous_1;
	        }
	        return false;
	    };
	    // This function accepts the same arguments as setImmediate, but
	    // returns a function that requires no arguments.
	    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var fn = function result() {
	            var _a = result, handler = _a.handler, args = _a.args;
	            if (typeof handler === 'function') {
	                handler.apply(undefined, args);
	            }
	            else {
	                (new Function('' + handler))();
	            }
	        };
	        fn.handler = handler;
	        fn.args = args;
	        return fn;
	    };
	    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
	        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
	        return this.nextHandle++;
	    };
	    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	        var root = this.root;
	        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
	        var onGlobalMessage = function globalMessageHandler(event) {
	            var instance = globalMessageHandler.instance;
	            if (event.source === root &&
	                typeof event.data === 'string' &&
	                event.data.indexOf(messagePrefix) === 0) {
	                instance.runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	        onGlobalMessage.instance = this;
	        root.addEventListener('message', onGlobalMessage, false);
	        var fn = function setImmediate() {
	            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.postMessage(messagePrefix + handle, '*');
	            return handle;
	        };
	        fn.instance = this;
	        fn.messagePrefix = messagePrefix;
	        return fn;
	    };
	    ImmediateDefinition.prototype.runIfPresent = function (handle) {
	        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (this.currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // 'too much recursion' error.
	            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
	        }
	        else {
	            var task = this.tasksByHandle[handle];
	            if (task) {
	                this.currentlyRunningATask = true;
	                try {
	                    task();
	                }
	                finally {
	                    this.clearImmediate(handle);
	                    this.currentlyRunningATask = false;
	                }
	            }
	        }
	    };
	    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
	        var _this = this;
	        var channel = new this.root.MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            _this.runIfPresent(handle);
	        };
	        var fn = function setImmediate() {
	            var _a = setImmediate, channel = _a.channel, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            channel.port2.postMessage(handle);
	            return handle;
	        };
	        fn.channel = channel;
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var root = instance.root;
	            var doc = root.document;
	            var html = doc.documentElement;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement('script');
	            script.onreadystatechange = function () {
	                instance.runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    return ImmediateDefinition;
	}());
	exports.ImmediateDefinition = ImmediateDefinition;
	exports.Immediate = new ImmediateDefinition(root_1.root);
	//# sourceMappingURL=Immediate.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(646).clearImmediate, __webpack_require__(646).setImmediate))

/***/ },
/* 646 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(647).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(646).setImmediate, __webpack_require__(646).clearImmediate))

/***/ },
/* 647 */,
/* 648 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var switch_1 = __webpack_require__(649);
	Observable_1.Observable.prototype.switch = switch_1._switch;
	//# sourceMappingURL=switch.js.map

/***/ },
/* 649 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * subscribing to only the most recently emitted of those inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * previous inner Observable once a new one appears.</span>
	 *
	 * <img src="./img/switch.png" width="100%">
	 *
	 * `switch` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable subscribes to the inner Observable and
	 * begins emitting the items emitted by that. So far, it behaves
	 * like {@link mergeAll}. However, when a new inner Observable is emitted,
	 * `switch` unsubscribes from the earlier-emitted inner Observable and
	 * subscribes to the new inner Observable and begins emitting items from it. It
	 * continues to behave like this for subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * // Each click event is mapped to an Observable that ticks every second
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var switched = higherOrder.switch();
	 * // The outcome is that `switched` is essentially a timer that restarts
	 * // on every click. The interval Observables from older clicks do not merge
	 * // with the current interval Observable.
	 * switched.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switchMap}
	 * @see {@link switchMapTo}
	 * @see {@link zipAll}
	 *
	 * @return {Observable<T>} An Observable that emits the items emitted by the
	 * Observable most recently emitted by the source Observable.
	 * @method switch
	 * @name switch
	 * @owner Observable
	 */
	function _switch() {
	    return this.lift(new SwitchOperator());
	}
	exports._switch = _switch;
	var SwitchOperator = (function () {
	    function SwitchOperator() {
	    }
	    SwitchOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SwitchSubscriber(subscriber));
	    };
	    return SwitchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchSubscriber = (function (_super) {
	    __extends(SwitchSubscriber, _super);
	    function SwitchSubscriber(destination) {
	        _super.call(this, destination);
	        this.active = 0;
	        this.hasCompleted = false;
	    }
	    SwitchSubscriber.prototype._next = function (value) {
	        this.unsubscribeInner();
	        this.active++;
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
	    };
	    SwitchSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    SwitchSubscriber.prototype.unsubscribeInner = function () {
	        this.active = this.active > 0 ? this.active - 1 : 0;
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	            this.remove(innerSubscription);
	        }
	    };
	    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    SwitchSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchSubscriber.prototype.notifyComplete = function () {
	        this.unsubscribeInner();
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return SwitchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switch.js.map

/***/ },
/* 650 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var switchMap_1 = __webpack_require__(651);
	Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
	//# sourceMappingURL=switchMap.js.map

/***/ },
/* 651 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	exports.switchMap = switchMap;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.isUnsubscribed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMap.js.map

/***/ },
/* 652 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var switchMapTo_1 = __webpack_require__(653);
	Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
	//# sourceMappingURL=switchMapTo.js.map

/***/ },
/* 653 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Projects each source value to the same Observable which is flattened multiple
	 * times with {@link switch} in the output Observable.
	 *
	 * <span class="informal">It's like {@link switchMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/switchMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. The output Observables
	 * emits values only from the most recently emitted instance of
	 * `innerObservable`.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link switch}
	 * @see {@link switchMap}
	 * @see {@link mergeMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` every time a value is emitted on the source Observable.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable, and taking only the values
	 * from the most recently projected inner Observable.
	 * @method switchMapTo
	 * @owner Observable
	 */
	function switchMapTo(innerObservable, resultSelector) {
	    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
	}
	exports.switchMapTo = switchMapTo;
	var SwitchMapToOperator = (function () {
	    function SwitchMapToOperator(observable, resultSelector) {
	        this.observable = observable;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapToOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
	    };
	    return SwitchMapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapToSubscriber = (function (_super) {
	    __extends(SwitchMapToSubscriber, _super);
	    function SwitchMapToSubscriber(destination, inner, resultSelector) {
	        _super.call(this, destination);
	        this.inner = inner;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapToSubscriber.prototype._next = function (value) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
	    };
	    SwitchMapToSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.isUnsubscribed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    return SwitchMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMapTo.js.map

/***/ },
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var takeLast_1 = __webpack_require__(658);
	Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;
	//# sourceMappingURL=takeLast.js.map

/***/ },
/* 658 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var ArgumentOutOfRangeError_1 = __webpack_require__(656);
	var EmptyObservable_1 = __webpack_require__(357);
	/**
	 * Emits only the last `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Remembers the latest `count` values, then emits those
	 * only when the source completes.</span>
	 *
	 * <img src="./img/takeLast.png" width="100%">
	 *
	 * `takeLast` returns an Observable that emits at most the last `count` values
	 * emitted by the source Observable. If the source emits fewer than `count`
	 * values then all of its values are emitted. This operator must wait until the
	 * `complete` notification emission from the source in order to emit the `next`
	 * values on the output Observable, because otherwise it is impossible to know
	 * whether or not more values will be emitted on the source. For this reason,
	 * all values are emitted synchronously, followed by the complete notification.
	 *
	 * @example <caption>Take the last 3 values of an Observable with many values</caption>
	 * var many = Rx.Observable.range(1, 100);
	 * var lastThree = many.takeLast(3);
	 * lastThree.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of values to emit from the end of
	 * the sequence of values emitted by the source Observable.
	 * @return {Observable<T>} An Observable that emits at most the last count
	 * values emitted by the source Observable.
	 * @method takeLast
	 * @owner Observable
	 */
	function takeLast(count) {
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeLastOperator(count));
	    }
	}
	exports.takeLast = takeLast;
	var TakeLastOperator = (function () {
	    function TakeLastOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeLastOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TakeLastSubscriber(subscriber, this.total));
	    };
	    return TakeLastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeLastSubscriber = (function (_super) {
	    __extends(TakeLastSubscriber, _super);
	    function TakeLastSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.ring = new Array();
	        this.count = 0;
	    }
	    TakeLastSubscriber.prototype._next = function (value) {
	        var ring = this.ring;
	        var total = this.total;
	        var count = this.count++;
	        if (ring.length < total) {
	            ring.push(value);
	        }
	        else {
	            var index = count % total;
	            ring[index] = value;
	        }
	    };
	    TakeLastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var count = this.count;
	        if (count > 0) {
	            var total = this.count >= this.total ? this.total : this.count;
	            var ring = this.ring;
	            for (var i = 0; i < total; i++) {
	                var idx = (count++) % total;
	                destination.next(ring[idx]);
	            }
	        }
	        destination.complete();
	    };
	    return TakeLastSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=takeLast.js.map

/***/ },
/* 659 */,
/* 660 */,
/* 661 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var takeWhile_1 = __webpack_require__(662);
	Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;
	//# sourceMappingURL=takeWhile.js.map

/***/ },
/* 662 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * Emits values emitted by the source Observable so long as each value satisfies
	 * the given `predicate`, and then completes as soon as this `predicate` is not
	 * satisfied.
	 *
	 * <span class="informal">Takes values from the source only while they pass the
	 * condition given. When the first value does not satisfy, it completes.</span>
	 *
	 * <img src="./img/takeWhile.png" width="100%">
	 *
	 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
	 * emitted on the source is given to the `predicate` function which returns a
	 * boolean, representing a condition to be satisfied by the source values. The
	 * output Observable emits the source values until such time as the `predicate`
	 * returns false, at which point `takeWhile` stops mirroring the source
	 * Observable and completes the output Observable.
	 *
	 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.takeWhile(ev => ev.clientX > 200);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates a value emitted by the source Observable and returns a boolean.
	 * Also takes the (zero-based) index as the second argument.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable so long as each value satisfies the condition defined by the
	 * `predicate`, then completes.
	 * @method takeWhile
	 * @owner Observable
	 */
	function takeWhile(predicate) {
	    return this.lift(new TakeWhileOperator(predicate));
	}
	exports.takeWhile = takeWhile;
	var TakeWhileOperator = (function () {
	    function TakeWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    TakeWhileOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
	    };
	    return TakeWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeWhileSubscriber = (function (_super) {
	    __extends(TakeWhileSubscriber, _super);
	    function TakeWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.index = 0;
	    }
	    TakeWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        var result;
	        try {
	            result = this.predicate(value, this.index++);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this.nextOrComplete(value, result);
	    };
	    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
	        var destination = this.destination;
	        if (Boolean(predicateResult)) {
	            destination.next(value);
	        }
	        else {
	            destination.complete();
	        }
	    };
	    return TakeWhileSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=takeWhile.js.map

/***/ },
/* 663 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var throttle_1 = __webpack_require__(664);
	Observable_1.Observable.prototype.throttle = throttle_1.throttle;
	//# sourceMappingURL=throttle.js.map

/***/ },
/* 664 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for a duration determined by another Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link throttleTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/throttle.png" width="100%">
	 *
	 * `throttle` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled by calling the `durationSelector` function with the source value,
	 * which returns the "duration" Observable. When the duration Observable emits a
	 * value or completes, the timer is disabled, and this process repeats for the
	 * next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {function(value: T): Observable|Promise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttle
	 * @owner Observable
	 */
	function throttle(durationSelector) {
	    return this.lift(new ThrottleOperator(durationSelector));
	}
	exports.throttle = throttle;
	var ThrottleOperator = (function () {
	    function ThrottleOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    ThrottleOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ThrottleSubscriber(subscriber, this.durationSelector));
	    };
	    return ThrottleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleSubscriber = (function (_super) {
	    __extends(ThrottleSubscriber, _super);
	    function ThrottleSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.durationSelector = durationSelector;
	    }
	    ThrottleSubscriber.prototype._next = function (value) {
	        if (!this.throttled) {
	            this.tryDurationSelector(value);
	        }
	    };
	    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
	        var duration = null;
	        try {
	            duration = this.durationSelector(value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.emitAndThrottle(value, duration);
	    };
	    ThrottleSubscriber.prototype.emitAndThrottle = function (value, duration) {
	        this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	        this.destination.next(value);
	    };
	    ThrottleSubscriber.prototype._unsubscribe = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	    };
	    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._unsubscribe();
	    };
	    ThrottleSubscriber.prototype.notifyComplete = function () {
	        this._unsubscribe();
	    };
	    return ThrottleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=throttle.js.map

/***/ },
/* 665 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var throttleTime_1 = __webpack_require__(666);
	Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;
	//# sourceMappingURL=throttleTime.js.map

/***/ },
/* 666 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var async_1 = __webpack_require__(510);
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for `duration` milliseconds, then repeats this process.
	 *
	 * <span class="informal">Lets a value pass, then ignores source values for the
	 * next `duration` milliseconds.</span>
	 *
	 * <img src="./img/throttleTime.png" width="100%">
	 *
	 * `throttleTime` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled. After `duration` milliseconds (or the time unit determined
	 * internally by the optional `scheduler`) has passed, the timer is disabled,
	 * and this process repeats for the next source value. Optionally takes a
	 * {@link Scheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {number} duration Time to wait before emitting another value after
	 * emitting the last value, measured in milliseconds or the time unit determined
	 * internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttleTime
	 * @owner Observable
	 */
	function throttleTime(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new ThrottleTimeOperator(duration, scheduler));
	}
	exports.throttleTime = throttleTime;
	var ThrottleTimeOperator = (function () {
	    function ThrottleTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return ThrottleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleTimeSubscriber = (function (_super) {
	    __extends(ThrottleTimeSubscriber, _super);
	    function ThrottleTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    ThrottleTimeSubscriber.prototype._next = function (value) {
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
	            this.destination.next(value);
	        }
	    };
	    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            throttled.unsubscribe();
	            this.remove(throttled);
	            this.throttled = null;
	        }
	    };
	    return ThrottleTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(arg) {
	    var subscriber = arg.subscriber;
	    subscriber.clearThrottle();
	}
	//# sourceMappingURL=throttleTime.js.map

/***/ },
/* 667 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var timeout_1 = __webpack_require__(668);
	Observable_1.Observable.prototype.timeout = timeout_1.timeout;
	//# sourceMappingURL=timeout.js.map

/***/ },
/* 668 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(510);
	var isDate_1 = __webpack_require__(529);
	var Subscriber_1 = __webpack_require__(42);
	/**
	 * @param due
	 * @param errorToSend
	 * @param scheduler
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeout
	 * @owner Observable
	 */
	function timeout(due, errorToSend, scheduler) {
	    if (errorToSend === void 0) { errorToSend = null; }
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteTimeout = isDate_1.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, errorToSend, scheduler));
	}
	exports.timeout = timeout;
	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, absoluteTimeout, errorToSend, scheduler) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	    }
	    TimeoutOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.errorToSend, this.scheduler));
	    };
	    return TimeoutOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutSubscriber = (function (_super) {
	    __extends(TimeoutSubscriber, _super);
	    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, errorToSend, scheduler) {
	        _super.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this._previousIndex = 0;
	        this._hasCompleted = false;
	        this.scheduleTimeout();
	    }
	    Object.defineProperty(TimeoutSubscriber.prototype, "previousIndex", {
	        get: function () {
	            return this._previousIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TimeoutSubscriber.prototype, "hasCompleted", {
	        get: function () {
	            return this._hasCompleted;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TimeoutSubscriber.dispatchTimeout = function (state) {
	        var source = state.subscriber;
	        var currentIndex = state.index;
	        if (!source.hasCompleted && source.previousIndex === currentIndex) {
	            source.notifyTimeout();
	        }
	    };
	    TimeoutSubscriber.prototype.scheduleTimeout = function () {
	        var currentIndex = this.index;
	        this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, { subscriber: this, index: currentIndex });
	        this.index++;
	        this._previousIndex = currentIndex;
	    };
	    TimeoutSubscriber.prototype._next = function (value) {
	        this.destination.next(value);
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	    };
	    TimeoutSubscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this._hasCompleted = true;
	    };
	    TimeoutSubscriber.prototype._complete = function () {
	        this.destination.complete();
	        this._hasCompleted = true;
	    };
	    TimeoutSubscriber.prototype.notifyTimeout = function () {
	        this.error(this.errorToSend || new Error('timeout'));
	    };
	    return TimeoutSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=timeout.js.map

/***/ },
/* 669 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var timeoutWith_1 = __webpack_require__(670);
	Observable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;
	//# sourceMappingURL=timeoutWith.js.map

/***/ },
/* 670 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(510);
	var isDate_1 = __webpack_require__(529);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * @param due
	 * @param withObservable
	 * @param scheduler
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeoutWith
	 * @owner Observable
	 */
	function timeoutWith(due, withObservable, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteTimeout = isDate_1.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
	}
	exports.timeoutWith = timeoutWith;
	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }
	    TimeoutWithOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
	    };
	    return TimeoutWithOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutWithSubscriber = (function (_super) {
	    __extends(TimeoutWithSubscriber, _super);
	    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	        _super.call(this);
	        this.destination = destination;
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        this.timeoutSubscription = undefined;
	        this.index = 0;
	        this._previousIndex = 0;
	        this._hasCompleted = false;
	        destination.add(this);
	        this.scheduleTimeout();
	    }
	    Object.defineProperty(TimeoutWithSubscriber.prototype, "previousIndex", {
	        get: function () {
	            return this._previousIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TimeoutWithSubscriber.prototype, "hasCompleted", {
	        get: function () {
	            return this._hasCompleted;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TimeoutWithSubscriber.dispatchTimeout = function (state) {
	        var source = state.subscriber;
	        var currentIndex = state.index;
	        if (!source.hasCompleted && source.previousIndex === currentIndex) {
	            source.handleTimeout();
	        }
	    };
	    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
	        var currentIndex = this.index;
	        var timeoutState = { subscriber: this, index: currentIndex };
	        this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, timeoutState);
	        this.index++;
	        this._previousIndex = currentIndex;
	    };
	    TimeoutWithSubscriber.prototype._next = function (value) {
	        this.destination.next(value);
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	    };
	    TimeoutWithSubscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this._hasCompleted = true;
	    };
	    TimeoutWithSubscriber.prototype._complete = function () {
	        this.destination.complete();
	        this._hasCompleted = true;
	    };
	    TimeoutWithSubscriber.prototype.handleTimeout = function () {
	        if (!this.isUnsubscribed) {
	            var withObservable = this.withObservable;
	            this.unsubscribe();
	            this.destination.add(this.timeoutSubscription = subscribeToResult_1.subscribeToResult(this, withObservable));
	        }
	    };
	    return TimeoutWithSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=timeoutWith.js.map

/***/ },
/* 671 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var window_1 = __webpack_require__(672);
	Observable_1.Observable.prototype.window = window_1.window;
	//# sourceMappingURL=window.js.map

/***/ },
/* 672 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(37);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Branch out the source Observable values as a nested Observable whenever
	 * `windowBoundaries` emits.
	 *
	 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
	 * instead of an array.</span>
	 *
	 * <img src="./img/window.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping
	 * windows. It emits the current window and opens a new one whenever the
	 * Observable `windowBoundaries` emits an item. Because each window is an
	 * Observable, the output is a higher-order Observable.
	 *
	 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var result = clicks.window(interval)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link buffer}
	 *
	 * @param {Observable<any>} windowBoundaries An Observable that completes the
	 * previous window and starts a new window.
	 * @return {Observable<Observable<T>>} An Observable of windows, which are
	 * Observables emitting values of the source Observable.
	 * @method window
	 * @owner Observable
	 */
	function window(windowBoundaries) {
	    return this.lift(new WindowOperator(windowBoundaries));
	}
	exports.window = window;
	var WindowOperator = (function () {
	    function WindowOperator(windowBoundaries) {
	        this.windowBoundaries = windowBoundaries;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new WindowSubscriber(subscriber, this.windowBoundaries));
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination, windowBoundaries) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowBoundaries = windowBoundaries;
	        this.add(subscribeToResult_1.subscribeToResult(this, windowBoundaries));
	        this.openWindow();
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow();
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this._complete();
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	    };
	    WindowSubscriber.prototype.openWindow = function () {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var destination = this.destination;
	        var newWindow = this.window = new Subject_1.Subject();
	        destination.add(newWindow);
	        destination.next(newWindow);
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=window.js.map

/***/ },
/* 673 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var windowCount_1 = __webpack_require__(674);
	Observable_1.Observable.prototype.windowCount = windowCount_1.windowCount;
	//# sourceMappingURL=windowCount.js.map

/***/ },
/* 674 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var Subject_1 = __webpack_require__(37);
	/**
	 * Branch out the source Observable values as a nested Observable with each
	 * nested Observable emitting at most `windowSize` values.
	 *
	 * <span class="informal">It's like {@link bufferCount}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowCount.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows every `startWindowEvery`
	 * items, each containing no more than `windowSize` items. When the source
	 * Observable completes or encounters an error, the output Observable emits
	 * the current window and propagates the notification from the source
	 * Observable. If `startWindowEvery` is not provided, then new windows are
	 * started immediately at the start of the source and when each window completes
	 * with size `windowSize`.
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(3)
	 *   .map(win => win.skip(1)) // skip first of every 3 clicks
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(2, 3)
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link bufferCount}
	 *
	 * @param {number} windowSize The maximum number of values emitted by each
	 * window.
	 * @param {number} [startWindowEvery] Interval at which to start a new window.
	 * For example if `startWindowEvery` is `2`, then a new window will be started
	 * on every other value from the source. A new window is started at the
	 * beginning of the source by default.
	 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
	 * are Observable of values.
	 * @method windowCount
	 * @owner Observable
	 */
	function windowCount(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}
	exports.windowCount = windowCount;
	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }
	    WindowCountOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
	    };
	    return WindowCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowCountSubscriber = (function (_super) {
	    __extends(WindowCountSubscriber, _super);
	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [new Subject_1.Subject()];
	        this.count = 0;
	        var firstWindow = this.windows[0];
	        destination.add(firstWindow);
	        destination.next(firstWindow);
	    }
	    WindowCountSubscriber.prototype._next = function (value) {
	        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
	        var destination = this.destination;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	        var c = this.count - windowSize + 1;
	        if (c >= 0 && c % startWindowEvery === 0) {
	            windows.shift().complete();
	        }
	        if (++this.count % startWindowEvery === 0) {
	            var window_1 = new Subject_1.Subject();
	            windows.push(window_1);
	            destination.add(window_1);
	            destination.next(window_1);
	        }
	    };
	    WindowCountSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	    WindowCountSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };
	    return WindowCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=windowCount.js.map

/***/ },
/* 675 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var windowTime_1 = __webpack_require__(676);
	Observable_1.Observable.prototype.windowTime = windowTime_1.windowTime;
	//# sourceMappingURL=windowTime.js.map

/***/ },
/* 676 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(42);
	var Subject_1 = __webpack_require__(37);
	var async_1 = __webpack_require__(510);
	/**
	 * Branch out the source Observable values as a nested Observable periodically
	 * in time.
	 *
	 * <span class="informal">It's like {@link bufferTime}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowTime.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable starts a new window periodically, as
	 * determined by the `windowCreationInterval` argument. It emits each window
	 * after a fixed timespan, specified by the `windowTimeSpan` argument. When the
	 * source Observable completes or encounters an error, the output Observable
	 * emits the current window and propagates the notification from the source
	 * Observable. If `windowCreationInterval` is not provided, the output
	 * Observable starts a new window when the previous window of duration
	 * `windowTimeSpan` completes.
	 *
	 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowTime(1000)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowTime(1000, 5000)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link bufferTime}
	 *
	 * @param {number} windowTimeSpan The amount of time to fill each window.
	 * @param {number} [windowCreationInterval] The interval at which to start new
	 * windows.
	 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
	 * intervals that determine window boundaries.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowTime
	 * @owner Observable
	 */
	function windowTime(windowTimeSpan, windowCreationInterval, scheduler) {
	    if (windowCreationInterval === void 0) { windowCreationInterval = null; }
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
	}
	exports.windowTime = windowTime;
	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	    }
	    WindowTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler));
	    };
	    return WindowTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowTimeSubscriber = (function (_super) {
	    __extends(WindowTimeSubscriber, _super);
	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	        this.windows = [];
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var window_1 = this.openWindow();
	            var closeState = { subscriber: this, window: window_1, context: null };
	            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	        }
	        else {
	            var window_2 = this.openWindow();
	            var timeSpanOnlyState = { subscriber: this, window: window_2, windowTimeSpan: windowTimeSpan };
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	        }
	    }
	    WindowTimeSubscriber.prototype._next = function (value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            var window_3 = windows[i];
	            if (!window_3.isUnsubscribed) {
	                window_3.next(value);
	            }
	        }
	    };
	    WindowTimeSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	    WindowTimeSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            var window_4 = windows.shift();
	            if (!window_4.isUnsubscribed) {
	                window_4.complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowTimeSubscriber.prototype.openWindow = function () {
	        var window = new Subject_1.Subject();
	        this.windows.push(window);
	        var destination = this.destination;
	        destination.add(window);
	        destination.next(window);
	        return window;
	    };
	    WindowTimeSubscriber.prototype.closeWindow = function (window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };
	    return WindowTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
	    if (window) {
	        window.complete();
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    var timeSpanState = { subscriber: subscriber, window: window, context: context };
	    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	    action.add(context.subscription);
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(arg) {
	    var subscriber = arg.subscriber, window = arg.window, context = arg.context;
	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}
	//# sourceMappingURL=windowTime.js.map

/***/ },
/* 677 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var windowToggle_1 = __webpack_require__(678);
	Observable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;
	//# sourceMappingURL=windowToggle.js.map

/***/ },
/* 678 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(37);
	var Subscription_1 = __webpack_require__(44);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Branch out the source Observable values as a nested Observable starting from
	 * an emission from `openings` and ending when the output of `closingSelector`
	 * emits.
	 *
	 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowToggle.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows that contain those items
	 * emitted by the source Observable between the time when the `openings`
	 * Observable emits an item and when the Observable returned by
	 * `closingSelector` emits an item.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var result = clicks.windowToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * ).mergeAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowWhen}
	 * @see {@link bufferToggle}
	 *
	 * @param {Observable<O>} openings An observable of notifications to start new
	 * windows.
	 * @param {function(value: O): Observable} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns an Observable,
	 * which, when it emits (either `next` or `complete`), signals that the
	 * associated window should complete.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowToggle
	 * @owner Observable
	 */
	function windowToggle(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}
	exports.windowToggle = windowToggle;
	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    WindowToggleOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return WindowToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowToggleSubscriber = (function (_super) {
	    __extends(WindowToggleSubscriber, _super);
	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
	    }
	    WindowToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        if (contexts) {
	            var len = contexts.length;
	            for (var i = 0; i < len; i++) {
	                contexts[i].window.next(value);
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.error(err);
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._error.call(this, err);
	    };
	    WindowToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.complete();
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    WindowToggleSubscriber.prototype._unsubscribe = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.unsubscribe();
	                context.subscription.unsubscribe();
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (outerValue === this.openings) {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
	            if (closingNotifier === errorObject_1.errorObject) {
	                return this.error(errorObject_1.errorObject.e);
	            }
	            else {
	                var window_1 = new Subject_1.Subject();
	                var subscription = new Subscription_1.Subscription();
	                var context = { window: window_1, subscription: subscription };
	                this.contexts.push(context);
	                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
	                if (innerSubscription.isUnsubscribed) {
	                    this.closeWindow(this.contexts.length - 1);
	                }
	                else {
	                    innerSubscription.context = context;
	                    subscription.add(innerSubscription);
	                }
	                this.destination.next(window_1);
	            }
	        }
	        else {
	            this.closeWindow(this.contexts.indexOf(outerValue));
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyError = function (err) {
	        this.error(err);
	    };
	    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
	        if (inner !== this.openSubscription) {
	            this.closeWindow(this.contexts.indexOf(inner.context));
	        }
	    };
	    WindowToggleSubscriber.prototype.closeWindow = function (index) {
	        if (index === -1) {
	            return;
	        }
	        var contexts = this.contexts;
	        var context = contexts[index];
	        var window = context.window, subscription = context.subscription;
	        contexts.splice(index, 1);
	        window.complete();
	        subscription.unsubscribe();
	    };
	    return WindowToggleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=windowToggle.js.map

/***/ },
/* 679 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var windowWhen_1 = __webpack_require__(680);
	Observable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;
	//# sourceMappingURL=windowWhen.js.map

/***/ },
/* 680 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(37);
	var tryCatch_1 = __webpack_require__(47);
	var errorObject_1 = __webpack_require__(48);
	var OuterSubscriber_1 = __webpack_require__(368);
	var subscribeToResult_1 = __webpack_require__(369);
	/**
	 * Branch out the source Observable values as a nested Observable using a
	 * factory function of closing Observables to determine when to start a new
	 * window.
	 *
	 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowWhen.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping windows.
	 * It emits the current window and opens a new one whenever the Observable
	 * produced by the specified `closingSelector` function emits an item. The first
	 * window is opened immediately when subscribing to the output Observable.
	 *
	 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks
	 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link bufferWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals (on either `next` or
	 * `complete`) when to close the previous window and start a new one.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowWhen
	 * @owner Observable
	 */
	function windowWhen(closingSelector) {
	    return this.lift(new WindowOperator(closingSelector));
	}
	exports.windowWhen = windowWhen;
	var WindowOperator = (function () {
	    function WindowOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new WindowSubscriber(subscriber, this.closingSelector));
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.closingSelector = closingSelector;
	        this.openWindow();
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
	        if (this.closingNotification) {
	            this.closingNotification.unsubscribe();
	        }
	    };
	    WindowSubscriber.prototype.openWindow = function (innerSub) {
	        if (innerSub === void 0) { innerSub = null; }
	        if (innerSub) {
	            this.remove(innerSub);
	            innerSub.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var window = this.window = new Subject_1.Subject();
	        this.destination.next(window);
	        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1.errorObject) {
	            var err = errorObject_1.errorObject.e;
	            this.destination.error(err);
	            this.window.error(err);
	        }
	        else {
	            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
	            this.add(window);
	        }
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=windowWhen.js.map

/***/ },
/* 681 */,
/* 682 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var zip_1 = __webpack_require__(532);
	Observable_1.Observable.prototype.zip = zip_1.zipProto;
	//# sourceMappingURL=zip.js.map

/***/ },
/* 683 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(38);
	var zipAll_1 = __webpack_require__(684);
	Observable_1.Observable.prototype.zipAll = zipAll_1.zipAll;
	//# sourceMappingURL=zipAll.js.map

/***/ },
/* 684 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var zip_1 = __webpack_require__(532);
	/**
	 * @param project
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method zipAll
	 * @owner Observable
	 */
	function zipAll(project) {
	    return this.lift(new zip_1.ZipOperator(project));
	}
	exports.zipAll = zipAll;
	//# sourceMappingURL=zipAll.js.map

/***/ },
/* 685 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(42);
	var Operator = (function () {
	    function Operator() {
	    }
	    Operator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new Subscriber_1.Subscriber(subscriber));
	    };
	    return Operator;
	}());
	exports.Operator = Operator;
	//# sourceMappingURL=Operator.js.map

/***/ },
/* 686 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var dropdown_component_1 = __webpack_require__(687);
	var dropdown_toggle_component_1 = __webpack_require__(688);
	exports.DROPDOWN_DIRECTIVES = [dropdown_component_1.DropdownComponent, dropdown_toggle_component_1.DropdownToggleComponent];


/***/ },
/* 687 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var dropdown_toggle_component_1 = __webpack_require__(688);
	var DropdownComponent = (function () {
	    function DropdownComponent(renderer) {
	        var _this = this;
	        this.renderer = renderer;
	        this.open = false;
	        this.mouseEvent = false;
	        this.selfClick = false;
	        this.delay = 500;
	        this.documentClickListener = this.renderer.listenGlobal('body', 'click', function () {
	            if (!_this.selfClick) {
	                _this.open = false;
	            }
	            else {
	                _this.selfClick = false;
	            }
	        });
	        this.documentKeyupListener = this.renderer.listenGlobal('body', 'keyup', function (event) {
	            if (event.code === 'Escape') {
	                _this.open = false;
	            }
	        });
	    }
	    Object.defineProperty(DropdownComponent.prototype, "isOpen", {
	        get: function () { return this.open; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    DropdownComponent.prototype.onMouseEnter = function ($event) {
	        var _this = this;
	        if (this.mouseEvent) {
	            clearTimeout(this.time);
	            this.time = setTimeout(function () { return _this.open = true; }, this.delay);
	        }
	    };
	    DropdownComponent.prototype.onMouseLeave = function ($event) {
	        var _this = this;
	        if (this.mouseEvent) {
	            clearTimeout(this.time);
	            this.time = setTimeout(function () { return _this.open = false; }, this.delay);
	        }
	    };
	    DropdownComponent.prototype.onClick = function ($event) {
	        this.selfClick = true;
	    };
	    DropdownComponent.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this.toggleComponent.forEach(function (it) { return it.toggle.subscribe(function (event) {
	            _this.toggleDropdown(event);
	        }); });
	    };
	    DropdownComponent.prototype.ngOnDestroy = function () {
	        this.documentClickListener();
	    };
	    DropdownComponent.prototype.toggleDropdown = function (event) {
	        this.open = !this.open;
	        event.preventDefault();
	    };
	    __decorate([
	        core_1.HostBinding('class.dropdown'), 
	        __metadata('design:type', Object)
	    ], DropdownComponent.prototype, "true", void 0);
	    __decorate([
	        core_1.HostBinding('class.open'), 
	        __metadata('design:type', Object)
	    ], DropdownComponent.prototype, "isOpen", null);
	    __decorate([
	        core_1.HostListener('mouseenter', ['$event']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [MouseEvent]), 
	        __metadata('design:returntype', void 0)
	    ], DropdownComponent.prototype, "onMouseEnter", null);
	    __decorate([
	        core_1.HostListener('mouseleave', ['$event']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [MouseEvent]), 
	        __metadata('design:returntype', void 0)
	    ], DropdownComponent.prototype, "onMouseLeave", null);
	    __decorate([
	        core_1.HostListener('click', ['$event']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [MouseEvent]), 
	        __metadata('design:returntype', void 0)
	    ], DropdownComponent.prototype, "onClick", null);
	    __decorate([
	        core_1.ContentChildren(dropdown_toggle_component_1.DropdownToggleComponent), 
	        __metadata('design:type', core_1.QueryList)
	    ], DropdownComponent.prototype, "toggleComponent", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], DropdownComponent.prototype, "open", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], DropdownComponent.prototype, "mouseEvent", void 0);
	    DropdownComponent = __decorate([
	        core_1.Component({
	            selector: '[dropdown]',
	            template: "<ng-content></ng-content>"
	        }), 
	        __metadata('design:paramtypes', [core_1.Renderer])
	    ], DropdownComponent);
	    return DropdownComponent;
	}());
	exports.DropdownComponent = DropdownComponent;


/***/ },
/* 688 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var DropdownToggleComponent = (function () {
	    function DropdownToggleComponent() {
	        this.toggle = new core_1.EventEmitter();
	    }
	    DropdownToggleComponent.prototype.onClick = function ($event) {
	        this.toggle.emit($event);
	    };
	    __decorate([
	        core_1.HostBinding('class.dropdown-toggle'), 
	        __metadata('design:type', Object)
	    ], DropdownToggleComponent.prototype, "true", void 0);
	    __decorate([
	        core_1.HostListener('click', ['$event']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [MouseEvent]), 
	        __metadata('design:returntype', void 0)
	    ], DropdownToggleComponent.prototype, "onClick", null);
	    DropdownToggleComponent = __decorate([
	        core_1.Component({
	            selector: '[dropdown-toggle]',
	            template: "<ng-content></ng-content>"
	        }), 
	        __metadata('design:paramtypes', [])
	    ], DropdownToggleComponent);
	    return DropdownToggleComponent;
	}());
	exports.DropdownToggleComponent = DropdownToggleComponent;


/***/ },
/* 689 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var project_service_1 = __webpack_require__(458);
	var NavComponent = (function () {
	    function NavComponent(store, projectService) {
	        this.store = store;
	        this.projectService = projectService;
	    }
	    NavComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.store.select('projects').subscribe(function (state) {
	            _this.projects = state.projects;
	        });
	        this.loadNavProjects();
	    };
	    NavComponent.prototype.ngOnDestroy = function () {
	        this.storeSub && this.storeSub.unsubscribe();
	    };
	    NavComponent.prototype.loadNavProjects = function () {
	        var _this = this;
	        this.projectService.fetchProjects().subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	    };
	    NavComponent = __decorate([
	        core_1.Component({
	            selector: '[data-component=nav]',
	            template: "\n        <ul>\n            <li>\n                <a [routerLink]=\"['/tasks', 'my']\" class=\"nav-link\">\n                    <i class=\"fa fa-pencil\"></i>\n                    <span>{{'my_tasks' | translate}}</span>\n                </a>\n            </li>\n            <li>\n                <a [routerLink]=\"['/tasks', 'inbox']\" class=\"nav-link\">\n                    <i class=\"fa fa-inbox\"></i>\n                    <span>{{'tasks_assigned_to_me' | translate}}</span>\n                </a>\n            </li>\n            <li>\n                <a [routerLink]=\"['/']\" class=\"nav-link\">\n                    <i class=\"fa fa-dashboard\"></i>\n                    <span>{{'dashboard' | translate}}</span>\n                </a>\n            </li>\n            <li class=\"divider\"></li>\n            <li>\n                <a [routerLink]=\"['/projects']\" class=\"nav-link\">\n                    <i class=\"fa fa-puzzle-piece\"></i>\n                    <span>{{'projects' | translate}}</span>\n                </a>\n                <ul>\n                    <li *ngFor=\"let project of projects\">\n                        <a [routerLink]=\"['/project', project.id, 'tasks']\" class=\"nav-link\">\n                            <i class=\"fa fa-file-text-o\"></i>\n                            <span>{{project.name}}</span>\n                        </a>\n                    </li>\n                </ul>\n            </li>\n        </ul>\n    ",
	            directives: [router_1.ROUTER_DIRECTIVES],
	            pipes: [ng2_translate_1.TranslatePipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, project_service_1.ProjectService])
	    ], NavComponent);
	    return NavComponent;
	}());
	exports.NavComponent = NavComponent;


/***/ },
/* 690 */
/***/ function(module, exports) {

	module.exports = "<notification></notification>\r\n<div class=\"layout\" [class.hidden]=\"!isReady\">\r\n    <div class=\"content-overlay\" (mousedown)=\"hideNav($event)\" (touchstart)=\"hideNav($event)\"></div>\r\n    <header class=\"header navbar navbar-fixed-top\">\r\n        <div class=\"container\">\r\n            <div class=\"navbar-header\">\r\n                <button class=\"btn-side-nav-toggle\" type=\"button\" (click)=\"toggleNav()\"></button>\r\n                <img class=\"brand-logo\" alt=\"logo\" src=\"img/logo.png\" />\r\n                <span class=\"brand-title\">\r\n                    {{HEADER_TITLE}}\r\n                </span>\r\n            </div>\r\n            <nav class=\"navbar-nav navbar-right\">\r\n                <ul class=\"nav nav-inline navbar-right\">\r\n                    <li dropdown class=\"dropdown\">\r\n                        <a dropdown-toggle href=\"#\" class=\"dropdown-toggle\" (click)=\"preventDefault($event)\">\r\n                            <i class=\"fa fa-user\"></i>\r\n                        </a>\r\n                        <ul class=\"dropdown-menu right\">\r\n                            <li>\r\n                                <a class=\"user-profile\" [routerLink]=\"['user-profile']\">\r\n                                    <i class=\"fa fa-user\"></i>\r\n                                    <span>{{loggedUser.name}}</span>\r\n                                </a>\r\n                            </li>\r\n                            <li class=\"divider\"></li>\r\n                            <li>\r\n                                <a class=\"ws\" href=\"{{workspaceUrl}}\">\r\n                                    <i class=\"fa fa-th\"></i>\r\n                                    <span>{{'workspace' | translate}}</span>\r\n                                </a>\r\n                            </li>\r\n                        </ul>\r\n                    </li>\r\n                </ul>\r\n                <form class=\"navbar-form navbar-search\" name=\"ft-search\" (submit)=\"ftSearch()\">\r\n                    <input type=\"hidden\" name=\"id\" value=\"search\" />\r\n                    <input type=\"search\" class=\"q\" name=\"keyword\" value=\"{{search_keyword}}\" placeholder=\"{{'search' | translate}}\" required autocomplete=\"off\" (focus)=\"searchToggle()\" (blur)=\"searchToggle()\" />\r\n                    <button type=\"reset\">\r\n                        <i class=\"fa fa-times\"></i>\r\n                    </button>\r\n                    <input type=\"submit\" value=\"search\" />\r\n                </form>\r\n            </nav>\r\n        </div>\r\n    </header>\r\n    <section class=\"container\">\r\n        <nav data-component=\"nav\" class=\"aside side-nav\"></nav>\r\n        <main class=\"content\">\r\n            <router-outlet></router-outlet>\r\n        </main>\r\n    </section>\r\n</div>\r\n"

/***/ },
/* 691 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var router_1 = __webpack_require__(394);
	var auth_guard_1 = __webpack_require__(692);
	var dashboard_1 = __webpack_require__(693);
	var projects_1 = __webpack_require__(695);
	var project_1 = __webpack_require__(811);
	var tasks_1 = __webpack_require__(820);
	var task_1 = __webpack_require__(825);
	var user_profile_1 = __webpack_require__(837);
	var login_1 = __webpack_require__(839);
	var routes = [
	    { path: '', component: dashboard_1.DashboardComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'dashboard', component: dashboard_1.DashboardComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'projects/:projectId', component: project_1.ProjectComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'projects', component: projects_1.ProjectsComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'project/:projectId/tasks', component: tasks_1.TasksComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'tasks/:for', component: tasks_1.TasksComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'tasks', component: tasks_1.TasksComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'task/:taskId/:new', component: task_1.TaskComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'task/:taskId', component: task_1.TaskComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'user-profile', component: user_profile_1.UserProfileComponent, canActivate: [auth_guard_1.AuthGuard] },
	    { path: 'login', component: login_1.LoginComponent },
	    { path: '**', component: dashboard_1.DashboardComponent, canActivate: [auth_guard_1.AuthGuard] }
	];
	exports.APP_ROUTER_PROVIDERS = [
	    router_1.provideRouter(routes),
	    auth_guard_1.AuthGuard
	];


/***/ },
/* 692 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var services_1 = __webpack_require__(453);
	var AuthGuard = (function () {
	    function AuthGuard(appService, router) {
	        this.appService = appService;
	        this.router = router;
	    }
	    AuthGuard.prototype.canActivate = function (next, state) {
	        if (this.appService.isLogged) {
	            return true;
	        }
	        return true;
	    };
	    AuthGuard = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [services_1.AppService, router_1.Router])
	    ], AuthGuard);
	    return AuthGuard;
	}());
	exports.AuthGuard = AuthGuard;


/***/ },
/* 693 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var ng2_translate_1 = __webpack_require__(350);
	var project_select_1 = __webpack_require__(694);
	var utils_1 = __webpack_require__(456);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var DashboardComponent = (function () {
	    function DashboardComponent(http) {
	        this.http = http;
	        this.fetchDashboardProjects();
	    }
	    DashboardComponent.prototype.fetchDashboardProjects = function () {
	        var _this = this;
	        this.http.get('p?id=dashboard', { headers: HEADERS })
	            .map(function (response) { return utils_1.parseResponseObjects(response.json().objects).project; })
	            .subscribe(function (data) {
	            _this.projects = data ? data.list : [];
	        });
	    };
	    DashboardComponent.prototype.addProjectToDashboard = function () {
	        var _this = this;
	        this.http.post('p?id=dashboard', "projectId=" + this.projectId, { headers: HEADERS })
	            .map(function (response) { return response.json(); })
	            .subscribe(function (data) {
	            _this.fetchDashboardProjects();
	        });
	    };
	    DashboardComponent.prototype.deleteProjectFromDashboard = function (projectId) {
	        var _this = this;
	        this.http.delete("p?id=dashboard&projectId=" + projectId, { headers: HEADERS })
	            .map(function (response) { return response.json(); })
	            .subscribe(function (data) {
	            _this.fetchDashboardProjects();
	        });
	    };
	    DashboardComponent.prototype.selectProject = function (project) {
	        this.projectId = project.id;
	        document.body.click();
	    };
	    DashboardComponent = __decorate([
	        core_1.Component({
	            selector: '[dashboard]',
	            template: "\n        <div class=\"content-header\">\n            <h1 class=\"header-title\">\n                {{'dashboard' | translate}}\n            </h1>\n        </div>\n        <div class=\"content-body\">\n            <div class=\"dashboard\" *ngFor=\"let project of projects\">\n                <header>\n                    <span>{{project.name}}</span>\n                    <button (click)=\"deleteProjectFromDashboard(project.id)\">delete</button>\n                </header>\n                <section>\n                    project data\n                </section>\n            </div>\n            <div class=\"span3\">\n                <project-select (onSelect)=\"selectProject($event)\"></project-select>\n                <button class=\"btn\" type=\"button\" (click)=\"addProjectToDashboard()\">{{'dashboard_add_project' | translate}}</button>\n            </div>\n        </div>\n    ",
	            directives: [project_select_1.ProjectSelectComponent],
	            pipes: [ng2_translate_1.TranslatePipe]
	        }), 
	        __metadata('design:paramtypes', [http_1.Http])
	    ], DashboardComponent);
	    return DashboardComponent;
	}());
	exports.DashboardComponent = DashboardComponent;


/***/ },
/* 694 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var dropdown_1 = __webpack_require__(686);
	var ProjectSelectComponent = (function () {
	    function ProjectSelectComponent(store) {
	        this.store = store;
	        this.onSelect = new core_1.EventEmitter();
	    }
	    ProjectSelectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('projects').subscribe(function (state) {
	            _this.projects = state.projects;
	            _this.project = state.projects.filter(function (it) { return it.id == _this.projectId; })[0];
	        });
	    };
	    ProjectSelectComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    ProjectSelectComponent.prototype.select = function (m) {
	        this.project = m;
	        this.onSelect.emit(this.project);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], ProjectSelectComponent.prototype, "projectId", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], ProjectSelectComponent.prototype, "onSelect", void 0);
	    ProjectSelectComponent = __decorate([
	        core_1.Component({
	            selector: 'project-select',
	            directives: [dropdown_1.DROPDOWN_DIRECTIVES],
	            pipes: [ng2_translate_1.TranslatePipe],
	            template: "\n        <div dropdown class=\"select\">\n            <div dropdown-toggle class=\"select-selection input\">\n                <span>{{project?.name}}</span>\n            </div>\n            <div class=\"dropdown-menu select-dropdown\">\n                <ul class=\"select-list scroll-shadow\">\n                    <li class=\"select-option\" [class.selected]=\"projectId == m.id\" *ngFor=\"let m of projects\" (click)=\"select(m)\">\n                        {{m.name}}\n                    </li>\n                </ul>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], ProjectSelectComponent);
	    return ProjectSelectComponent;
	}());
	exports.ProjectSelectComponent = ProjectSelectComponent;


/***/ },
/* 695 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var notification_1 = __webpack_require__(376);
	var pipes_1 = __webpack_require__(696);
	var pagination_1 = __webpack_require__(804);
	var project_service_1 = __webpack_require__(458);
	var project_row_1 = __webpack_require__(806);
	var ProjectsComponent = (function () {
	    function ProjectsComponent(store, router, projectService, notifyService) {
	        this.store = store;
	        this.router = router;
	        this.projectService = projectService;
	        this.notifyService = notifyService;
	        this.title = 'projects';
	        this.params = {};
	        this.meta = {};
	        this.requestProcess = true;
	    }
	    ProjectsComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.storeSub = this.store.select('projects').subscribe(function (data) {
	            if (data) {
	                _this.projects = data.projects;
	                _this.meta = data.meta;
	                _this.requestProcess = false;
	            }
	        });
	        this.loadData();
	    };
	    ProjectsComponent.prototype.ngOnDestroy = function () {
	        this.storeSub && this.storeSub.unsubscribe();
	    };
	    ProjectsComponent.prototype.loadData = function (params) {
	        var _this = this;
	        this.projectService.fetchProjects(params).subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	    };
	    ProjectsComponent.prototype.goToPage = function (params) {
	        this.loadData({
	            page: params.page
	        });
	    };
	    ProjectsComponent.prototype.newProject = function () {
	        this.router.navigate(['/projects', 'new']);
	    };
	    ProjectsComponent.prototype.deleteProject = function () {
	    };
	    ProjectsComponent = __decorate([
	        core_1.Component({
	            selector: 'project-list',
	            template: __webpack_require__(810),
	            directives: [
	                router_1.ROUTER_DIRECTIVES,
	                pagination_1.PaginationComponent,
	                project_row_1.ProjectRowComponent
	            ],
	            pipes: [pipes_1.DateFormatPipe, ng2_translate_1.TranslatePipe, pipes_1.TextTransformPipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, router_1.Router, project_service_1.ProjectService, notification_1.NotificationService])
	    ], ProjectsComponent);
	    return ProjectsComponent;
	}());
	exports.ProjectsComponent = ProjectsComponent;


/***/ },
/* 696 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var date_format_pipe_1 = __webpack_require__(697);
	exports.DateFormatPipe = date_format_pipe_1.DateFormatPipe;
	var text_transform_pipe_1 = __webpack_require__(801);
	exports.TextTransformPipe = text_transform_pipe_1.TextTransformPipe;
	var values_pipe_1 = __webpack_require__(802);
	exports.ValuesPipe = values_pipe_1.ValuesPipe;
	var keys_pipe_1 = __webpack_require__(803);
	exports.KeysPipe = keys_pipe_1.KeysPipe;


/***/ },
/* 697 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var moment = __webpack_require__(698);
	var DateFormatPipe = (function () {
	    function DateFormatPipe() {
	    }
	    DateFormatPipe.prototype.transform = function (date, format) {
	        if (!date) {
	            return '';
	        }
	        if (!format) {
	            format = 'DD.MM.YYYY HH:mm';
	        }
	        var md = moment(date, format);
	        if (md.isValid()) {
	            return md.format(format);
	        }
	        return '';
	    };
	    DateFormatPipe = __decorate([
	        core_1.Pipe({ name: 'dateFmt' }), 
	        __metadata('design:paramtypes', [])
	    ], DateFormatPipe);
	    return DateFormatPipe;
	}());
	exports.DateFormatPipe = DateFormatPipe;


/***/ },
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var TextTransformPipe = (function () {
	    function TextTransformPipe() {
	    }
	    TextTransformPipe.prototype.transform = function (text, transform) {
	        switch (transform) {
	            case 'L':
	                return text.toLowerCase();
	            case 'U':
	                return text.toUpperCase();
	            default:
	                return text;
	        }
	    };
	    TextTransformPipe = __decorate([
	        core_1.Pipe({ name: 'text' }), 
	        __metadata('design:paramtypes', [])
	    ], TextTransformPipe);
	    return TextTransformPipe;
	}());
	exports.TextTransformPipe = TextTransformPipe;


/***/ },
/* 802 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var ValuesPipe = (function () {
	    function ValuesPipe() {
	    }
	    ValuesPipe.prototype.transform = function (values, args) {
	        return Object.keys(values).map(function (key) { return values[key]; });
	    };
	    ValuesPipe = __decorate([
	        core_1.Pipe({ name: 'values' }), 
	        __metadata('design:paramtypes', [])
	    ], ValuesPipe);
	    return ValuesPipe;
	}());
	exports.ValuesPipe = ValuesPipe;


/***/ },
/* 803 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var KeysPipe = (function () {
	    function KeysPipe() {
	    }
	    KeysPipe.prototype.transform = function (value, args) {
	        var keys = [];
	        for (var key in value) {
	            keys.push(key);
	        }
	        return keys;
	    };
	    KeysPipe = __decorate([
	        core_1.Pipe({ name: 'keys' }), 
	        __metadata('design:paramtypes', [])
	    ], KeysPipe);
	    return KeysPipe;
	}());
	exports.KeysPipe = KeysPipe;


/***/ },
/* 804 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(805));


/***/ },
/* 805 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var PaginationComponent = (function () {
	    function PaginationComponent() {
	        this.maxPageControl = 5;
	        this.totalPages = -1;
	        this.change = new core_1.EventEmitter();
	        this.initialized = 0;
	        this.currentPage = 0;
	        this.startPage = 0;
	        this.stopPage = 0;
	        this.pages = [];
	    }
	    Object.defineProperty(PaginationComponent.prototype, "isHidden", {
	        get: function () { return this.totalPages < 2; },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Object.defineProperty(PaginationComponent.prototype, "page", {
	        set: function (value) {
	            this.currentPage = +value;
	            if (this.initialized < 2) {
	                ++this.initialized;
	                this.pagination();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PaginationComponent.prototype.toPage = function (event, page) {
	        event.preventDefault();
	        this.currentPage = +page;
	        this.change.emit({ page: page });
	        this.pagination();
	    };
	    PaginationComponent.prototype.pagination = function () {
	        this.pages = [];
	        if (this.totalPages <= 1) {
	            return;
	        }
	        this.maxPageControl = +this.maxPageControl;
	        this.totalPages = +this.totalPages;
	        this.currentPage = +this.currentPage;
	        var perPage = Math.floor(this.maxPageControl / 2);
	        this.startPage = (this.currentPage - perPage);
	        this.stopPage = (this.currentPage + perPage);
	        if (this.startPage <= perPage) {
	            this.startPage = 1;
	        }
	        else if (this.currentPage == this.totalPages) {
	            this.startPage = this.totalPages - this.maxPageControl;
	        }
	        if (this.stopPage > (this.totalPages - perPage)) {
	            this.stopPage = this.totalPages;
	        }
	        else if (this.currentPage == 1) {
	            this.stopPage = this.maxPageControl + 1;
	        }
	        if ((this.maxPageControl + perPage) >= this.totalPages) {
	            this.startPage = 1;
	            this.stopPage = this.totalPages;
	        }
	        for (var p = this.startPage; p <= this.stopPage; p++) {
	            this.pages.push(p);
	        }
	    };
	    __decorate([
	        core_1.HostBinding('hidden'), 
	        __metadata('design:type', Object)
	    ], PaginationComponent.prototype, "isHidden", null);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Number)
	    ], PaginationComponent.prototype, "maxPageControl", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Number)
	    ], PaginationComponent.prototype, "totalPages", void 0);
	    __decorate([
	        core_1.Input('page'), 
	        __metadata('design:type', String), 
	        __metadata('design:paramtypes', [String])
	    ], PaginationComponent.prototype, "page", null);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], PaginationComponent.prototype, "change", void 0);
	    PaginationComponent = __decorate([
	        core_1.Component({
	            selector: 'pagination',
	            template: "\n        <div class=\"pagination\" *ngIf=\"totalPages > 1\">\n            <a href=\"#\" *ngIf=\"startPage > 1\" (click)=\"toPage($event, 1)\">1</a>\n            <span *ngIf=\"startPage > 1\">...</span>\n            <a [class.page-active]=\"p == currentPage\" href=\"#\" *ngFor=\"let p of pages\" (click)=\"toPage($event, p)\">{{p}}</a>\n            <span *ngIf=\"stopPage < totalPages\">...</span>\n            <a *ngIf=\"stopPage < totalPages\" href=\"#\" (click)=\"toPage($event, totalPages)\">{{totalPages}}</a>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [])
	    ], PaginationComponent);
	    return PaginationComponent;
	}());
	exports.PaginationComponent = PaginationComponent;


/***/ },
/* 806 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var ng2_translate_1 = __webpack_require__(350);
	var pipes_1 = __webpack_require__(696);
	var customer_cell_1 = __webpack_require__(807);
	var user_cell_1 = __webpack_require__(808);
	var project_1 = __webpack_require__(464);
	var ProjectRowComponent = (function () {
	    function ProjectRowComponent() {
	        this.selected = false;
	    }
	    ProjectRowComponent.prototype.toggleSelected = function () {
	        this.selected = !this.selected;
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', project_1.Project)
	    ], ProjectRowComponent.prototype, "project", void 0);
	    ProjectRowComponent = __decorate([
	        core_1.Component({
	            selector: 'project-row',
	            template: __webpack_require__(809),
	            directives: [router_1.ROUTER_DIRECTIVES, customer_cell_1.CustomerCellComponent, user_cell_1.UserCellComponent],
	            pipes: [pipes_1.DateFormatPipe, ng2_translate_1.TranslatePipe, pipes_1.TextTransformPipe]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], ProjectRowComponent);
	    return ProjectRowComponent;
	}());
	exports.ProjectRowComponent = ProjectRowComponent;


/***/ },
/* 807 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var CustomerCellComponent = (function () {
	    function CustomerCellComponent(store) {
	        this.store = store;
	    }
	    CustomerCellComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('staff').subscribe(function (state) {
	            _this.customer = state.organizations.filter(function (it) { return it.id == _this.customerId; })[0];
	        });
	    };
	    CustomerCellComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], CustomerCellComponent.prototype, "customerId", void 0);
	    CustomerCellComponent = __decorate([
	        core_1.Component({
	            selector: 'customer-cell',
	            template: "{{ customer?.name }}"
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], CustomerCellComponent);
	    return CustomerCellComponent;
	}());
	exports.CustomerCellComponent = CustomerCellComponent;


/***/ },
/* 808 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var UserCellComponent = (function () {
	    function UserCellComponent(store) {
	        this.store = store;
	    }
	    UserCellComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('staff').subscribe(function (state) {
	            if (state && state.users) {
	                _this.user = state.users.filter(function (it) { return it.id == _this.userId; })[0];
	            }
	        });
	    };
	    UserCellComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], UserCellComponent.prototype, "userId", void 0);
	    UserCellComponent = __decorate([
	        core_1.Component({
	            selector: 'user-cell',
	            template: "{{ user?.login }}"
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], UserCellComponent);
	    return UserCellComponent;
	}());
	exports.UserCellComponent = UserCellComponent;


/***/ },
/* 809 */
/***/ function(module, exports) {

	module.exports = "<div class=\"entry-wrap\" [class.active]=\"selected\">\r\n    <div class=\"entry\">\r\n        <label class=\"entry-select\">\r\n            <input type=\"checkbox\" name=\"project-id\" value=\"{{project.id}}\" (change)=\"toggleSelected()\" [checked]=\"selected\" />\r\n        </label>\r\n        <a class=\"entry-link\" [routerLink]=\"['./', project.id]\">\r\n            <div class=\"entry-fields\">\r\n                <span class=\"vw-project-name\">{{project.name}}</span>\r\n                <span class=\"vw-project-status\">{{project.status | text:'L' | translate}}</span>\r\n                <span class=\"vw-icon\">\r\n                    <i class=\"fa fa-paperclip\" *ngIf=\"project.hasAttachments\"></i>\r\n                </span>\r\n                <span class=\"vw-project-customer\">\r\n                    <customer-cell [customerId]=\"project.customerId\"></customer-cell>\r\n                </span>\r\n                <span class=\"vw-user-manager\">\r\n                    <user-cell [userId]=\"project.managerUserId\"></user-cell>\r\n                </span>\r\n                <span class=\"vw-user-programmer\">\r\n                    <user-cell [userId]=\"project.programmerUserId\"></user-cell>\r\n                </span>\r\n                <span class=\"vw-user-tester\">\r\n                    <user-cell [userId]=\"project.testerUserId\"></user-cell>\r\n                </span>\r\n                <span class=\"vw-date\">{{project.finishDate | dateFmt}}</span>\r\n            </div>\r\n        </a>\r\n    </div>\r\n</div>\r\n"

/***/ },
/* 810 */
/***/ function(module, exports) {

	module.exports = "<div class=\"content-header\">\r\n    <h1 class=\"header-title\">\r\n        {{title | translate}}\r\n    </h1>\r\n    <div class=\"content-actions\">\r\n        <button class=\"btn\" type=\"button\" (click)=\"newProject()\">\r\n            {{'new_project' | translate}}\r\n        </button>\r\n        <pagination [totalPages]=\"meta.totalPages\" [page]=\"meta.page\" (change)=\"goToPage($event)\"></pagination>\r\n    </div>\r\n</div>\r\n<div class=\"content-body\">\r\n    <div class=\"view view-project\" [class.load]=\"requestProcess\">\r\n        <header class=\"entries-head\">\r\n            <div class=\"head-wrap\">\r\n                <label class=\"entry-select\">\r\n                    <input type=\"checkbox\" class=\"all\" />\r\n                </label>\r\n                <div class=\"entry-captions\">\r\n                    <span class=\"vw-project-name\">{{'name' | translate}}</span>\r\n                    <span class=\"vw-project-status\">{{'status' | translate}}</span>\r\n                    <span class=\"vw-icon\"><i class=\"fa fa-paperclip\"></i></span>\r\n                    <span class=\"vw-project-customer\">{{'customer' | translate}}</span>\r\n                    <span class=\"vw-user-manager\">{{'manager' | translate}}</span>\r\n                    <span class=\"vw-user-programmer\">{{'programmer' | translate}}</span>\r\n                    <span class=\"vw-user-tester\">{{'tester' | translate}}</span>\r\n                    <span class=\"vw-date\">{{'finish_date' | translate}}</span>\r\n                </div>\r\n            </div>\r\n        </header>\r\n        <div class=\"entries\">\r\n            <project-row [project]=\"project\" *ngFor=\"let project of projects\"></project-row>\r\n        </div>\r\n    </div>\r\n</div>\r\n<router-outlet></router-outlet>\r\n"

/***/ },
/* 811 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var common_1 = __webpack_require__(2);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var notification_1 = __webpack_require__(376);
	var datepicker_1 = __webpack_require__(812);
	var dropdown_1 = __webpack_require__(686);
	var markdown_1 = __webpack_require__(380);
	var switch_button_1 = __webpack_require__(814);
	var customer_select_1 = __webpack_require__(816);
	var user_select_1 = __webpack_require__(817);
	var attachments_1 = __webpack_require__(818);
	var pipes_1 = __webpack_require__(696);
	var services_1 = __webpack_require__(453);
	var models_1 = __webpack_require__(460);
	var ProjectComponent = (function () {
	    function ProjectComponent(store, router, route, formBuilder, translate, appService, projectService, staffService, notifyService) {
	        this.store = store;
	        this.router = router;
	        this.route = route;
	        this.formBuilder = formBuilder;
	        this.translate = translate;
	        this.appService = appService;
	        this.projectService = projectService;
	        this.staffService = staffService;
	        this.notifyService = notifyService;
	        this.isReady = false;
	    }
	    ProjectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.form = this.formBuilder.group({
	            name: ['', common_1.Validators.required],
	            status: [''],
	            customerUserId: [''],
	            managerUserId: [''],
	            programmerUserId: [''],
	            testerUserId: [''],
	            observerUserIds: [''],
	            comment: [''],
	            finishDate: [''],
	            attachments: ['']
	        });
	        this.sub = this.route.params.subscribe(function (params) {
	            _this.projectService.fetchProjectById(params['projectId']).subscribe(function (action) {
	                _this.project = action.payload.project;
	                _this.loadData();
	                _this.isReady = true;
	            }, function (error) { return _this.handleXhrError(error); });
	        });
	    };
	    ProjectComponent.prototype.loadData = function () {
	        var _this = this;
	        this.projectService.getProjectStatusTypes().subscribe(function (pst) { return _this.projectStatusTypes = pst; });
	    };
	    ProjectComponent.prototype.updateProjectComment = function (text) {
	        this.project.comment = text;
	    };
	    ProjectComponent.prototype.setFinishDate = function (date) {
	        this.project.finishDate = date;
	    };
	    ProjectComponent.prototype.saveProject = function () {
	        var _this = this;
	        var noty = this.notifyService.process(this.translate.instant('wait_while_document_save')).show();
	        this.projectService.saveProject(this.project).subscribe(function (response) {
	            console.log(response);
	            noty.set({ type: 'success', message: response.message }).remove(1500);
	            _this.close();
	            return response;
	        }, function (error) {
	            console.log(error);
	            noty.set({ type: 'error', message: error.message }).remove(1500);
	            _this.errorSaveProject(error);
	            return error;
	        }, function () { return noty.remove(1500); });
	    };
	    ProjectComponent.prototype.errorSaveProject = function (errorResponse) {
	        console.log(errorResponse);
	    };
	    ProjectComponent.prototype.deleteProject = function () {
	        var _this = this;
	        this.projectService.deleteProject([this.project]).subscribe(function (data) {
	            _this.close();
	        });
	    };
	    ProjectComponent.prototype.close = function () {
	        this.router.navigate(['/projects']);
	    };
	    ProjectComponent.prototype.handleXhrError = function (errorResponse) {
	        console.log(errorResponse);
	        if (errorResponse.status === 401) {
	            this.router.navigate(['/login']);
	        }
	    };
	    ProjectComponent.prototype.setStatus = function (value) {
	        this.project.status = value;
	    };
	    ProjectComponent.prototype.closeDropdown = function () {
	        document.body.click();
	    };
	    ProjectComponent.prototype.selectCustomer = function (customer) {
	        this.project.customerId = customer.id;
	        this.closeDropdown();
	    };
	    ProjectComponent.prototype.selectManager = function (user) {
	        this.project.managerUserId = user.id;
	        this.closeDropdown();
	    };
	    ProjectComponent.prototype.selectProgrammer = function (user) {
	        this.project.programmerUserId = user.id;
	        this.closeDropdown();
	    };
	    ProjectComponent.prototype.selectTester = function (user) {
	        this.project.testerUserId = user.id;
	        this.closeDropdown();
	    };
	    ProjectComponent.prototype.selectObserver = function (observer) {
	        if (!this.project.observerUserIds) {
	            this.project.observerUserIds = [];
	        }
	        this.project.observerUserIds.push(observer.id);
	        this.closeDropdown();
	    };
	    ProjectComponent.prototype.removeObserver = function (observer, $event) {
	        var _this = this;
	        this.project.observerUserIds.forEach(function (id, index) {
	            if (id === observer.id) {
	                _this.project.observerUserIds.splice(index, 1);
	            }
	        });
	        $event.stopPropagation();
	        this.closeDropdown();
	    };
	    ProjectComponent.prototype.addAttachment = function (file) {
	        var att = new models_1.Attachment();
	        att.realFileName = file.files[0];
	        if (!this.project.attachments) {
	            this.project.attachments = [];
	        }
	        if (!this.project.fsid) {
	            this.project.fsid = '' + Date.now();
	        }
	        this.project.attachments.push(att);
	    };
	    ProjectComponent.prototype.deleteAttachment = function (attachment) {
	        var _this = this;
	        this.projectService.deleteProjectAttachment(this.project, attachment).subscribe(function (r) {
	            _this.project.attachments = _this.project.attachments.filter(function (it) { return it.id != attachment.id; });
	        });
	    };
	    ProjectComponent = __decorate([
	        core_1.Component({
	            selector: 'project',
	            styles: ["project { display: block; }"],
	            template: __webpack_require__(819),
	            directives: [
	                router_1.ROUTER_DIRECTIVES,
	                common_1.FORM_DIRECTIVES,
	                dropdown_1.DROPDOWN_DIRECTIVES,
	                switch_button_1.SwitchButtonComponent,
	                customer_select_1.CustomerSelectComponent,
	                user_select_1.UserSelectComponent,
	                attachments_1.AttachmentsComponent,
	                markdown_1.MarkdownEditorComponent,
	                datepicker_1.DatepickerDirective
	            ],
	            providers: [common_1.FormBuilder],
	            pipes: [ng2_translate_1.TranslatePipe, pipes_1.TextTransformPipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, router_1.Router, router_1.ActivatedRoute, common_1.FormBuilder, ng2_translate_1.TranslateService, services_1.AppService, services_1.ProjectService, services_1.StaffService, notification_1.NotificationService])
	    ], ProjectComponent);
	    return ProjectComponent;
	}());
	exports.ProjectComponent = ProjectComponent;


/***/ },
/* 812 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var Pikaday = __webpack_require__(813);
	var DatepickerDirective = (function () {
	    function DatepickerDirective(elementRef) {
	        this.elementRef = elementRef;
	        this.format = 'DD.MM.YYYY HH:mm';
	        this.select = new core_1.EventEmitter();
	    }
	    DatepickerDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this.picker = new Pikaday({
	            field: this.elementRef.nativeElement,
	            format: this.format,
	            onSelect: function () {
	                _this.select.emit(_this.picker.toString(_this.format));
	            }
	        });
	    };
	    DatepickerDirective.prototype.ngOnDestroy = function () {
	        this.picker.destroy();
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], DatepickerDirective.prototype, "format", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], DatepickerDirective.prototype, "select", void 0);
	    DatepickerDirective = __decorate([
	        core_1.Directive({
	            selector: '[datepicker]'
	        }), 
	        __metadata('design:paramtypes', [core_1.ElementRef])
	    ], DatepickerDirective);
	    return DatepickerDirective;
	}());
	exports.DatepickerDirective = DatepickerDirective;


/***/ },
/* 813 */,
/* 814 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(815));


/***/ },
/* 815 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var SwitchButtonComponent = (function () {
	    function SwitchButtonComponent() {
	        this.class = 'input';
	        this.name = 'swb' + Math.random();
	        this.multi = false;
	        this.disabled = false;
	        this.checkDefault = true;
	    }
	    SwitchButtonComponent.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        [].concat(this.items).forEach(function (it) {
	            if (_this.checkDefault && it.value == _this.model[_this.value]) {
	                _this.checkDefault = false;
	            }
	        });
	    };
	    SwitchButtonComponent.prototype.select = function (value) {
	        this.model[this.value] = value;
	    };
	    SwitchButtonComponent.prototype.isSelected = function (item) {
	        return item.value == this.model[this.value] || (this.checkDefault && item.default);
	    };
	    __decorate([
	        core_1.HostBinding('class.switch-button'), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "true", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "model", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "value", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "items", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "class", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "name", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "multi", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], SwitchButtonComponent.prototype, "disabled", void 0);
	    SwitchButtonComponent = __decorate([
	        core_1.Component({
	            selector: 'switch-button',
	            template: "\n        <label\n             [ngClass]=\"class\"\n             [class.active]=\"isSelected(item)\"\n             [class.disabled]=\"disabled || item.disabled\"\n             *ngFor=\"let item of items\">\n            <input\n                type=\"{{multi ? 'checkbox' : 'radio'}}\"\n                name=\"{{name}}\"\n                value=\"{{item.value}}\"\n                [checked]=\"isSelected(item)\"\n                [disabled]=\"disabled || item.disabled\"\n                (change)=\"select(item.value)\" />\n            <i class=\"fa fa-{{item.icon}}\" *ngIf=\"item.icon\"></i>\n            <span>{{item.text}}</span>\n        </label>\n    "
	        }), 
	        __metadata('design:paramtypes', [])
	    ], SwitchButtonComponent);
	    return SwitchButtonComponent;
	}());
	exports.SwitchButtonComponent = SwitchButtonComponent;


/***/ },
/* 816 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var dropdown_1 = __webpack_require__(686);
	var CustomerSelectComponent = (function () {
	    function CustomerSelectComponent(store) {
	        this.store = store;
	        this.onSelect = new core_1.EventEmitter();
	    }
	    CustomerSelectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('staff').subscribe(function (state) {
	            _this.customers = state.organizations;
	            _this.customer = state.organizations.filter(function (it) { return it.id == _this.customerId; })[0];
	        });
	    };
	    CustomerSelectComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    CustomerSelectComponent.prototype.select = function (m) {
	        this.customer = m;
	        this.onSelect.emit(this.customer);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], CustomerSelectComponent.prototype, "customerId", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], CustomerSelectComponent.prototype, "onSelect", void 0);
	    CustomerSelectComponent = __decorate([
	        core_1.Component({
	            selector: 'customer-select',
	            directives: [dropdown_1.DROPDOWN_DIRECTIVES],
	            pipes: [ng2_translate_1.TranslatePipe],
	            template: "\n        <div dropdown class=\"select\">\n            <div dropdown-toggle class=\"select-selection input\">\n                <span>{{customer?.name}}</span>\n            </div>\n            <div class=\"dropdown-menu select-dropdown\">\n                <!-- <div class=\"select-search\">\n                    <input name=\"keyword\" placeholder=\"{{'search' | translate}}\" (keyup)=\"searchCustomer($event)\" />\n                </div> -->\n                <ul class=\"select-list scroll-shadow\">\n                    <li class=\"select-option\" [class.selected]=\"customer?.id == m.id\" *ngFor=\"let m of customers\" (click)=\"select(m)\">\n                        {{m.name}}\n                    </li>\n                </ul>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], CustomerSelectComponent);
	    return CustomerSelectComponent;
	}());
	exports.CustomerSelectComponent = CustomerSelectComponent;


/***/ },
/* 817 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var dropdown_1 = __webpack_require__(686);
	var UserSelectComponent = (function () {
	    function UserSelectComponent(store) {
	        this.store = store;
	        this.onSelect = new core_1.EventEmitter();
	    }
	    UserSelectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('staff').subscribe(function (state) {
	            _this.users = state.users;
	            _this.user = state.users.filter(function (it) { return it.id == _this.userId; })[0];
	        });
	    };
	    UserSelectComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    UserSelectComponent.prototype.select = function (m) {
	        this.user = m;
	        this.onSelect.emit(this.user);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], UserSelectComponent.prototype, "userId", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], UserSelectComponent.prototype, "onSelect", void 0);
	    UserSelectComponent = __decorate([
	        core_1.Component({
	            selector: 'user-select',
	            directives: [dropdown_1.DROPDOWN_DIRECTIVES],
	            pipes: [ng2_translate_1.TranslatePipe],
	            template: "\n        <div dropdown class=\"select\">\n            <div dropdown-toggle class=\"select-selection input\">\n                <span>{{user?.userName || user?.login}}</span>\n            </div>\n            <div class=\"dropdown-menu select-dropdown\">\n                <ul class=\"select-list scroll-shadow\">\n                    <li class=\"select-option\" [class.selected]=\"userId == m.id\" *ngFor=\"let m of users\" (click)=\"select(m)\">\n                        {{m.name || m.login}}\n                    </li>\n                </ul>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], UserSelectComponent);
	    return UserSelectComponent;
	}());
	exports.UserSelectComponent = UserSelectComponent;


/***/ },
/* 818 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var ng2_translate_1 = __webpack_require__(350);
	var services_1 = __webpack_require__(453);
	var AttachmentsComponent = (function () {
	    function AttachmentsComponent(http, uploadService) {
	        this.http = http;
	        this.uploadService = uploadService;
	        this.upload = new core_1.EventEmitter();
	        this.delete = new core_1.EventEmitter();
	        this.progress = 0;
	    }
	    AttachmentsComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.uploadService.progress$.subscribe(function (progress) {
	            if (progress > 0 && progress < 100) {
	                _this.progress = progress;
	            }
	            else {
	                _this.progress = 0;
	            }
	        });
	    };
	    AttachmentsComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    AttachmentsComponent.prototype.uploadFile = function ($event) {
	        var _this = this;
	        var files = $event.target.files;
	        this.uploadService.makeFileRequest('UploadFile?time=' + Date.now(), { fsid: this.entity.fsid }, files).subscribe(function (response) {
	            _this.upload.emit(response);
	        });
	    };
	    AttachmentsComponent.prototype.deleteAttach = function (att, $event) {
	        this.delete.emit(att);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], AttachmentsComponent.prototype, "entity", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], AttachmentsComponent.prototype, "upload", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], AttachmentsComponent.prototype, "delete", void 0);
	    AttachmentsComponent = __decorate([
	        core_1.Component({
	            selector: 'attachments',
	            pipes: [ng2_translate_1.TranslatePipe],
	            host: {
	                '[class.attachments]': 'true'
	            },
	            template: "\n        <label class=\"btn btn-upload\" title=\"{{'attach_file' | translate}}\">\n            <i class=\"fa fa-paperclip\"></i>\n            <span>{{'attach_file' | translate}}</span>\n            <input type=\"file\" (change)=\"uploadFile($event)\" style=\"display:none;\"/>\n        </label>\n        <div class=\"attach-list\">\n            <div class=\"attach-item\" *ngFor=\"let att of entity.attachments\">\n                <a class=\"attach-name\" href=\"{{entity.url}}&attachment={{att.id}}\">\n                    {{att.realFileName}}\n                </a>\n                <button class=\"btn btn-sm btn-link btn-remove\" (click)=\"deleteAttach(att, $event)\">\n                    <i class=\"fa fa-times\"></i>\n                </button>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [http_1.Http, services_1.UploadService])
	    ], AttachmentsComponent);
	    return AttachmentsComponent;
	}());
	exports.AttachmentsComponent = AttachmentsComponent;


/***/ },
/* 819 */
/***/ function(module, exports) {

	module.exports = "<form class=\"form\" [ngFormModel]=\"form\" *ngIf=\"isReady\">\r\n    <header class=\"content-header\">\r\n        <button class=\"btn-back\" type=\"button\" (click)=\"close($event)\">\r\n            <i class=\"fa fa-chevron-left\"></i>\r\n        </button>\r\n        <h1 class=\"header-title\">\r\n            {{(project.id ? 'project' : 'new_project') | translate}}\r\n        </h1>\r\n        <div class=\"content-actions\">\r\n            <button class=\"btn btn-primary\" type=\"button\" [disabled]=\"!form.valid\" (click)=\"saveProject()\">\r\n                {{'save_close' | translate}}\r\n            </button>\r\n            <button class=\"btn\" type=\"button\" (click)=\"close($event)\">\r\n                {{'close' | translate}}\r\n            </button>\r\n            <div dropdown class=\"buttons\">\r\n                <div dropdown-toggle>\r\n                    <span class=\"btn\">...</span>\r\n                </div>\r\n                <div class=\"dropdown-menu\">\r\n                    <button class=\"btn\" type=\"button\" (click)=\"deleteProject()\">\r\n                        {{'delete' | translate}}\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </header>\r\n    <section class=\"content-body\">\r\n        <fieldset class=\"fieldset\">\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'name' | translate}}\r\n                </div>\r\n                <div class=\"controls\" [class.has-error]=\"!form.controls.name.valid\">\r\n                    <input class=\"span8\" [(ngModel)]=\"project.name\" ngControl=\"name\" />\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'customer' | translate}}\r\n                </div>\r\n                <div class=\"controls\" [class.has-error]=\"!form.controls.customerUserId.valid\">\r\n                    <div class=\"span8\">\r\n                        <customer-select [customerId]=\"project.customerId\" (onSelect)=\"selectCustomer($event)\"></customer-select>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'manager' | translate}}\r\n                </div>\r\n                <div class=\"controls\" [class.has-error]=\"!form.controls.managerUserId.valid\">\r\n                    <div class=\"span8\">\r\n                        <user-select [userId]=\"project.managerUserId\" (onSelect)=\"selectManager($event)\"></user-select>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'programmer' | translate}}\r\n                </div>\r\n                <div class=\"controls\" [class.has-error]=\"!form.controls.programmerUserId.valid\">\r\n                    <div class=\"span8\">\r\n                        <user-select [userId]=\"project.programmerUserId\" (onSelect)=\"selectProgrammer($event)\"></user-select>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'tester' | translate}}\r\n                </div>\r\n                <div class=\"controls\" [class.has-error]=\"!form.controls.testerUserId.valid\">\r\n                    <div class=\"span8\">\r\n                        <user-select [userId]=\"project.testerUserId\" (onSelect)=\"selectTester($event)\"></user-select>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'observers' | translate}}\r\n                </div>\r\n                <div class=\"controls\">\r\n                    <div class=\"span8\">\r\n                        <user-select [userId]=\"project.observerUserIds\" (onSelect)=\"selectObserver($event)\"></user-select>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'status' | translate}}\r\n                </div>\r\n                <div class=\"controls\">\r\n                    <switch-button [model]=\"project\" value=\"status\" [items]=\"projectStatusTypes\"></switch-button>\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'finish_date' | translate}}\r\n                </div>\r\n                <div class=\"controls\">\r\n                    <input class=\"span2\" datepicker (select)=\"setFinishDate($event)\" [(ngModel)]=\"project.finishDate\" ngControl=\"finishDate\" />\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"control-label\">\r\n                    {{'comment' | translate}}\r\n                </div>\r\n                <div class=\"controls\" [class.has-error]=\"!form.controls.comment.valid\">\r\n                    <div class=\"span8\">\r\n                        <markdown-editor [markdown]=\"project.comment || ''\" editable=\"true\" updateTimeout=\"300\" (update)=\"updateProjectComment($event)\"></markdown-editor>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </fieldset>\r\n        <attachments [entity]=\"project\" (upload)=\"addAttachment($event)\" (delete)=\"deleteAttachment($event)\"></attachments>\r\n    </section>\r\n</form>\r\n"

/***/ },
/* 820 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var notification_1 = __webpack_require__(376);
	var pipes_1 = __webpack_require__(696);
	var pagination_1 = __webpack_require__(804);
	var task_service_1 = __webpack_require__(471);
	var task_row_1 = __webpack_require__(821);
	var TasksComponent = (function () {
	    function TasksComponent(store, router, route, taskService, notifyService) {
	        this.store = store;
	        this.router = router;
	        this.route = route;
	        this.taskService = taskService;
	        this.notifyService = notifyService;
	        this.params = {};
	        this.meta = {};
	        this.requestProcess = true;
	    }
	    TasksComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.storeSub = this.store.select('tasks').subscribe(function (data) {
	            if (data) {
	                _this.tasks = data.tasks;
	                _this.meta = data.meta;
	                _this.requestProcess = false;
	            }
	        });
	        this.paramsSub = this.route.params.subscribe(function (params) {
	            var taskFor = params['for'];
	            var projectId = params['projectId'];
	            switch (taskFor) {
	                case 'inbox':
	                    _this.title = 'tasks_assigned_to_me';
	                    break;
	                case 'my':
	                    _this.title = 'my_tasks';
	                    break;
	                default:
	                    _this.title = 'tasks';
	                    break;
	            }
	            _this.params = params;
	            _this.loadData(_this.params);
	        });
	    };
	    TasksComponent.prototype.ngOnDestroy = function () {
	        this.storeSub.unsubscribe();
	        this.paramsSub.unsubscribe();
	    };
	    TasksComponent.prototype.loadData = function (params) {
	        var _this = this;
	        this.requestProcess = true;
	        this.taskService.fetchTasks(params).subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	    };
	    TasksComponent.prototype.goToPage = function (params) {
	        this.loadData({
	            page: params.page
	        });
	    };
	    TasksComponent.prototype.newTask = function () {
	        this.router.navigate(['/task', 'new']);
	    };
	    TasksComponent.prototype.deleteTask = function (task) {
	        this.taskService.deleteTask([task]).subscribe();
	    };
	    TasksComponent = __decorate([
	        core_1.Component({
	            selector: 'tasks',
	            template: __webpack_require__(824),
	            directives: [router_1.ROUTER_DIRECTIVES, pagination_1.PaginationComponent, task_row_1.TaskRowComponent],
	            pipes: [pipes_1.DateFormatPipe, ng2_translate_1.TranslatePipe, pipes_1.TextTransformPipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, router_1.Router, router_1.ActivatedRoute, task_service_1.TaskService, notification_1.NotificationService])
	    ], TasksComponent);
	    return TasksComponent;
	}());
	exports.TasksComponent = TasksComponent;


/***/ },
/* 821 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var ng2_translate_1 = __webpack_require__(350);
	var user_cell_1 = __webpack_require__(808);
	var tags_cell_1 = __webpack_require__(822);
	var pipes_1 = __webpack_require__(696);
	var task_1 = __webpack_require__(465);
	var TaskRowComponent = (function () {
	    function TaskRowComponent() {
	        this.selected = false;
	    }
	    TaskRowComponent.prototype.toggleSelected = function () {
	        this.selected = !this.selected;
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', task_1.Task)
	    ], TaskRowComponent.prototype, "task", void 0);
	    TaskRowComponent = __decorate([
	        core_1.Component({
	            selector: 'task-row',
	            template: __webpack_require__(823),
	            directives: [router_1.ROUTER_DIRECTIVES, user_cell_1.UserCellComponent, tags_cell_1.TagsCellComponent],
	            pipes: [pipes_1.DateFormatPipe, ng2_translate_1.TranslatePipe, pipes_1.TextTransformPipe]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], TaskRowComponent);
	    return TaskRowComponent;
	}());
	exports.TaskRowComponent = TaskRowComponent;


/***/ },
/* 822 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var TagsCellComponent = (function () {
	    function TagsCellComponent(store) {
	        this.store = store;
	    }
	    TagsCellComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('reference').subscribe(function (state) {
	            if (state && state.tags) {
	                _this.tags = state.tags.filter(function (it) { return _this.tagIds.indexOf(it.id) != -1; });
	            }
	        });
	    };
	    TagsCellComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array)
	    ], TagsCellComponent.prototype, "tagIds", void 0);
	    TagsCellComponent = __decorate([
	        core_1.Component({
	            selector: 'tags-cell',
	            template: "<span class=\"tag\" [style.color]=\"tag.color\" *ngFor=\"let tag of tags\">{{tag.name}}</span>"
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], TagsCellComponent);
	    return TagsCellComponent;
	}());
	exports.TagsCellComponent = TagsCellComponent;


/***/ },
/* 823 */
/***/ function(module, exports) {

	module.exports = "<div class=\"entry-wrap\" [class.active]=\"selected\">\r\n    <div class=\"entry\">\r\n        <label class=\"entry-select\">\r\n            <input type=\"checkbox\" name=\"task-id\" value=\"{{task.id}}\" (change)=\"toggleSelected()\" [checked]=\"selected\" />\r\n        </label>\r\n        <a class=\"entry-link\" [routerLink]=\"['/task', task.id]\">\r\n            <div class=\"entry-fields\">\r\n                <span class=\"vw-task-body\">{{task.title}}</span>\r\n                <span class=\"vw-task-status\">{{task.status | text:'L' | translate}}</span>\r\n                <span class=\"vw-task-priority\">{{task.priority | text:'L' | translate}}</span>\r\n                <span class=\"vw-task-assignee\">\r\n                    <user-cell [userId]=\"task.assigneeUserId\"></user-cell>\r\n                </span>\r\n                <span class=\"vw-date\">{{task.startDate | dateFmt}}</span>\r\n                <span class=\"vw-date\">{{task.dueDate | dateFmt}}</span>\r\n                <span class=\"vw-tags\">\r\n                    <tags-cell [tagIds]=\"task.tagIds\"></tags-cell>\r\n                </span>\r\n            </div>\r\n        </a>\r\n    </div>\r\n</div>\r\n"

/***/ },
/* 824 */
/***/ function(module, exports) {

	module.exports = "<div class=\"content-header\">\r\n    <h1 class=\"header-title\">\r\n        {{title | translate}}\r\n    </h1>\r\n    <div class=\"content-actions\">\r\n        <button class=\"btn\" type=\"button\" (click)=\"newTask()\">\r\n            {{'new_task' | translate}}\r\n        </button>\r\n        <pagination [totalPages]=\"meta.totalPages\" [page]=\"meta.page\" (change)=\"goToPage($event)\"></pagination>\r\n    </div>\r\n</div>\r\n<div class=\"content-body\">\r\n    <div class=\"view view-task\" [class.load]=\"requestProcess\">\r\n        <header class=\"entries-head\">\r\n            <div class=\"head-wrap\">\r\n                <label class=\"entry-select\">\r\n                    <input type=\"checkbox\" class=\"all\" />\r\n                </label>\r\n                <div class=\"entry-captions\">\r\n                    <span class=\"vw-task-body\">{{'task_title' | translate}}</span>\r\n                    <span class=\"vw-task-status\">{{'status' | translate}}</span>\r\n                    <span class=\"vw-task-priority\">{{'priority' | translate}}</span>\r\n                    <span class=\"vw-task-assignee\">{{'assignee_user' | translate}}</span>\r\n                    <span class=\"vw-date\">{{'start_date' | translate}}</span>\r\n                    <span class=\"vw-date\">{{'due_date' | translate}}</span>\r\n                    <span class=\"vw-tags\">{{'tags' | translate}}</span>\r\n                </div>\r\n            </div>\r\n        </header>\r\n        <div class=\"entries\">\r\n            <task-row [task]=\"task\" *ngFor=\"let task of tasks\"></task-row>\r\n        </div>\r\n    </div>\r\n</div>\r\n<router-outlet></router-outlet>\r\n"

/***/ },
/* 825 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var router_1 = __webpack_require__(394);
	var common_1 = __webpack_require__(2);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var notification_1 = __webpack_require__(376);
	var datepicker_1 = __webpack_require__(812);
	var tabs_1 = __webpack_require__(826);
	var dropdown_1 = __webpack_require__(686);
	var markdown_1 = __webpack_require__(380);
	var switch_button_1 = __webpack_require__(814);
	var user_select_1 = __webpack_require__(817);
	var project_select_1 = __webpack_require__(694);
	var task_type_select_1 = __webpack_require__(829);
	var tags_select_1 = __webpack_require__(830);
	var task_requests_1 = __webpack_require__(831);
	var task_request_1 = __webpack_require__(832);
	var attachments_1 = __webpack_require__(818);
	var comments_1 = __webpack_require__(834);
	var task_reducer_1 = __webpack_require__(473);
	var pipes_1 = __webpack_require__(696);
	var services_1 = __webpack_require__(453);
	var models_1 = __webpack_require__(460);
	var TaskComponent = (function () {
	    function TaskComponent(store, router, route, formBuilder, translate, appService, projectService, taskService, referenceService, notifyService) {
	        var _this = this;
	        this.store = store;
	        this.router = router;
	        this.route = route;
	        this.formBuilder = formBuilder;
	        this.translate = translate;
	        this.appService = appService;
	        this.projectService = projectService;
	        this.taskService = taskService;
	        this.referenceService = referenceService;
	        this.notifyService = notifyService;
	        this.isReady = false;
	        this.isNew = true;
	        this.isSubtask = false;
	        this.rights = {
	            addSubtask: false,
	            doRequest: false,
	            doResolution: false,
	            addComment: false,
	            removeTask: false
	        };
	        this.showRequest = false;
	        this.hasUnResolvedRequest = true;
	        this.hasAcceptedRequestResolution = false;
	        this.store.select('task').subscribe(function (state) {
	            _this.comments = state.comments;
	            _this.requests = state.requests;
	            if (!_this.requests) {
	                _this.hasUnResolvedRequest = false;
	            }
	            else {
	                _this.requests.forEach(function (it) {
	                    if (it.resolution == 'UNKNOWN') {
	                        _this.hasUnResolvedRequest = true;
	                    }
	                    if (it.resolution == 'ACCEPT') {
	                        _this.hasAcceptedRequestResolution = true;
	                    }
	                });
	            }
	        });
	        this.form = formBuilder.group({
	            title: [''],
	            projectId: [''],
	            taskTypeId: [''],
	            status: [''],
	            priority: [''],
	            body: [''],
	            assigneeUserId: [''],
	            startDate: [''],
	            dueDate: [''],
	            tagIds: [''],
	            attachments: ['']
	        });
	    }
	    TaskComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.route.params.subscribe(function (params) {
	            _this.isNew = (params['taskId'] === 'new') || (params['taskId'] && params['new'] === 'new');
	            _this.isSubtask = params['taskId'] && params['new'] === 'new';
	            _this.taskService.fetchTaskById(params['taskId']).subscribe(function (action) {
	                if (_this.isSubtask) {
	                    _this.parentTask = action.payload.task;
	                    _this.task = new models_1.Task();
	                    _this.task.parentTaskId = _this.parentTask.id;
	                }
	                else {
	                    _this.task = action.payload.task;
	                    _this.isSubtask = !!_this.task.parentTaskId;
	                }
	                if (!_this.isNew) {
	                    _this.loadComments(1);
	                    _this.loadRequests(1);
	                }
	                _this.isReady = true;
	            }, function (errorResponse) { return _this.handleXhrError(errorResponse); });
	        });
	        this.taskService.getTaskStatusTypes().subscribe(function (tst) { return _this.taskStatusTypes = tst; });
	        this.taskService.getTaskPriorityTypes().subscribe(function (tpt) { return _this.taskPriorityTypes = tpt; });
	    };
	    TaskComponent.prototype.getTitle = function () {
	        if (this.isNew && this.isSubtask) {
	            return 'new_subtask';
	        }
	        else if (this.isNew) {
	            return 'new_task';
	        }
	        else if (this.isSubtask) {
	            return 'sub_task';
	        }
	        else {
	            return 'task';
	        }
	    };
	    TaskComponent.prototype.setStartDate = function (date) {
	        this.task.startDate = date;
	    };
	    TaskComponent.prototype.setDueDate = function (date) {
	        this.task.dueDate = date;
	    };
	    TaskComponent.prototype.updateTaskBody = function (text) {
	        this.task.body = text;
	    };
	    TaskComponent.prototype.saveTask = function () {
	        var _this = this;
	        var noty = this.notifyService.process(this.translate.instant('wait_while_document_save')).show();
	        this.taskService.saveTask(this.task).subscribe(function (response) {
	            noty.set({ type: 'success', message: response.message }).remove(1500);
	            _this.close();
	        }, function (error) {
	            noty.set({ type: 'error', message: error.message }).remove(1500);
	            _this.errorSaveTask(error);
	        });
	    };
	    TaskComponent.prototype.deleteTask = function () {
	        var _this = this;
	        this.taskService.deleteTask([this.task]).subscribe(function (data) {
	            _this.close();
	        });
	    };
	    TaskComponent.prototype.addSubtask = function () {
	        this.router.navigate(['/task', this.task.id, '/new']);
	    };
	    TaskComponent.prototype.loadComments = function (page) {
	        var _this = this;
	        this.taskService.fetchComments(this.task, page).subscribe(function (action) { return _this.store.dispatch(action); });
	    };
	    TaskComponent.prototype.saveComment = function (comment) {
	        var _this = this;
	        this.taskService.saveComment(this.task, comment).subscribe(function (r) {
	            _this.loadComments(1);
	        });
	    };
	    TaskComponent.prototype.deleteComment = function (comment) {
	        var _this = this;
	        this.taskService.deleteComment(comment).subscribe(function (response) {
	            _this.loadComments(1);
	        });
	    };
	    TaskComponent.prototype.loadRequests = function (page) {
	        var _this = this;
	        this.taskService.fetchTaskRequests(this.task, page).subscribe(function (action) {
	            _this.store.dispatch(action);
	        });
	    };
	    TaskComponent.prototype.acceptRequest = function (request) {
	        var _this = this;
	        this.taskService.doRequestResolution(request, 'ACCEPT').subscribe(function (action) {
	            _this.store.dispatch(action);
	            _this.loadRequests(1);
	        });
	    };
	    TaskComponent.prototype.declineRequest = function (request) {
	        var _this = this;
	        this.taskService.doRequestResolution(request, 'DECLINE').subscribe(function (action) {
	            _this.store.dispatch(action);
	            _this.loadRequests(1);
	        });
	    };
	    TaskComponent.prototype.errorSaveTask = function (errorResponse) {
	        console.log(errorResponse);
	    };
	    TaskComponent.prototype.close = function () {
	        this.router.navigate(['/tasks']);
	    };
	    TaskComponent.prototype.handleXhrError = function (errorResponse) {
	        if (errorResponse.status === 401) {
	            this.router.navigate(['/login']);
	        }
	    };
	    TaskComponent.prototype.canRequestAction = function () {
	        return (this.task && this.task.id && this.task.status != 'FINISHED') && !this.hasUnResolvedRequest && !this.hasAcceptedRequestResolution;
	    };
	    TaskComponent.prototype.newRequest = function () {
	        this.store.dispatch({ type: task_reducer_1.TASK_REQUEST_NEW, payload: this.task });
	    };
	    TaskComponent.prototype.getTaskStatusType = function () {
	        var _this = this;
	        return this.taskStatusTypes.filter(function (it) { return it.value == _this.task.status; })[0].text;
	    };
	    TaskComponent.prototype.setStatus = function (value) {
	        this.task.status = value;
	    };
	    TaskComponent.prototype.setPriority = function (value) {
	        this.task.priority = value;
	    };
	    TaskComponent.prototype.closeDropdown = function () {
	        document.body.click();
	    };
	    TaskComponent.prototype.selectProject = function (project) {
	        this.task.projectId = project.id;
	        this.closeDropdown();
	    };
	    TaskComponent.prototype.selectTaskType = function (taskType) {
	        this.task.taskTypeId = taskType.id;
	        this.closeDropdown();
	    };
	    TaskComponent.prototype.selectAssigneeUser = function (assigneeUser) {
	        this.task.assigneeUserId = assigneeUser.id;
	        this.closeDropdown();
	    };
	    TaskComponent.prototype.setTags = function (tags) {
	        this.task.tagIds = tags.map(function (it) { return it.id; });
	    };
	    TaskComponent.prototype.selectTag = function (tag) {
	        if (!this.task.tagIds) {
	            this.task.tagIds = [];
	        }
	        this.task.tagIds.push(tag.id);
	        this.closeDropdown();
	    };
	    TaskComponent.prototype.removeTag = function (tag, $event) {
	        var _this = this;
	        this.task.tagIds.forEach(function (id, index) {
	            if (id === tag.id) {
	                _this.task.tagIds.splice(index, 1);
	            }
	        });
	        $event.stopPropagation();
	        this.closeDropdown();
	    };
	    TaskComponent.prototype.addAttachment = function (file) {
	        var att = new models_1.Attachment();
	        att.realFileName = file.files[0];
	        if (!this.task.attachments) {
	            this.task.attachments = [];
	        }
	        if (!this.task.fsid) {
	            this.task.fsid = '' + Date.now();
	        }
	        this.task.attachments.push(att);
	    };
	    TaskComponent.prototype.deleteAttachment = function (attachment) {
	        var _this = this;
	        this.taskService.deleteTaskAttachment(this.task, attachment).subscribe(function (r) {
	            _this.task.attachments = _this.task.attachments.filter(function (it) { return it.id != attachment.id; });
	        });
	    };
	    TaskComponent.prototype.ngOnDestroy = function () {
	        this.store.dispatch({ type: task_reducer_1.TASK_CLOSE });
	    };
	    TaskComponent = __decorate([
	        core_1.Component({
	            selector: 'task',
	            template: __webpack_require__(836),
	            directives: [
	                router_1.ROUTER_DIRECTIVES,
	                common_1.FORM_DIRECTIVES,
	                switch_button_1.SwitchButtonComponent,
	                dropdown_1.DROPDOWN_DIRECTIVES,
	                tabs_1.TAB_DIRECTIVES,
	                user_select_1.UserSelectComponent,
	                project_select_1.ProjectSelectComponent,
	                task_type_select_1.TaskTypeSelectComponent,
	                tags_select_1.TagsSelectComponent,
	                task_requests_1.TaskRequestsComponent,
	                task_request_1.TaskRequestComponent,
	                attachments_1.AttachmentsComponent,
	                comments_1.CommentsComponent,
	                markdown_1.MarkdownEditorComponent,
	                datepicker_1.DatepickerDirective
	            ],
	            providers: [common_1.FormBuilder],
	            pipes: [ng2_translate_1.TranslatePipe, pipes_1.TextTransformPipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, router_1.Router, router_1.ActivatedRoute, common_1.FormBuilder, ng2_translate_1.TranslateService, services_1.AppService, services_1.ProjectService, services_1.TaskService, services_1.ReferenceService, notification_1.NotificationService])
	    ], TaskComponent);
	    return TaskComponent;
	}());
	exports.TaskComponent = TaskComponent;


/***/ },
/* 826 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var tabs_1 = __webpack_require__(827);
	var tab_1 = __webpack_require__(828);
	exports.TAB_DIRECTIVES = [tabs_1.Tabs, tab_1.Tab];


/***/ },
/* 827 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var tab_1 = __webpack_require__(828);
	var Tabs = (function () {
	    function Tabs() {
	    }
	    Tabs.prototype.ngAfterContentInit = function () {
	        var activeTabs = this.tabs.filter(function (tab) { return tab.active; });
	        if (activeTabs.length === 0) {
	            this.selectTab(this.tabs.first);
	        }
	    };
	    Tabs.prototype.selectTab = function (tab) {
	        this.tabs.forEach(function (tab) { return tab.active = false; });
	        tab.active = true;
	    };
	    __decorate([
	        core_1.ContentChildren(tab_1.Tab), 
	        __metadata('design:type', core_1.QueryList)
	    ], Tabs.prototype, "tabs", void 0);
	    Tabs = __decorate([
	        core_1.Component({
	            selector: 'tabs',
	            template: "\n        <ul class=\"nav nav-tabs\">\n            <li *ngFor=\"let tab of tabs\" (click)=\"selectTab(tab)\" [class.active]=\"tab.active\">\n                <a href=\"#\" (click)=\"$event.preventDefault()\">{{tab.title}}</a>\n            </li>\n        </ul>\n        <ng-content></ng-content>\n    "
	        }), 
	        __metadata('design:paramtypes', [])
	    ], Tabs);
	    return Tabs;
	}());
	exports.Tabs = Tabs;


/***/ },
/* 828 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var Tab = (function () {
	    function Tab() {
	        this.active = false;
	    }
	    __decorate([
	        core_1.Input('tabTitle'), 
	        __metadata('design:type', String)
	    ], Tab.prototype, "title", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], Tab.prototype, "active", void 0);
	    Tab = __decorate([
	        core_1.Component({
	            selector: 'tab',
	            template: "\n      <div [hidden]=\"!active\">\n        <ng-content></ng-content>\n      </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [])
	    ], Tab);
	    return Tab;
	}());
	exports.Tab = Tab;


/***/ },
/* 829 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var dropdown_1 = __webpack_require__(686);
	var TaskTypeSelectComponent = (function () {
	    function TaskTypeSelectComponent(store) {
	        this.store = store;
	        this.onSelect = new core_1.EventEmitter();
	    }
	    TaskTypeSelectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('reference').subscribe(function (state) {
	            _this.taskTypes = state.taskTypes;
	            _this.taskType = state.taskTypes.filter(function (it) { return it.id == _this.taskTypeId; })[0];
	        });
	    };
	    TaskTypeSelectComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    TaskTypeSelectComponent.prototype.select = function (m) {
	        this.taskType = m;
	        this.onSelect.emit(this.taskType);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TaskTypeSelectComponent.prototype, "taskTypeId", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TaskTypeSelectComponent.prototype, "onSelect", void 0);
	    TaskTypeSelectComponent = __decorate([
	        core_1.Component({
	            selector: 'task-type-select',
	            directives: [dropdown_1.DROPDOWN_DIRECTIVES],
	            template: "\n        <div dropdown class=\"select\">\n            <div dropdown-toggle class=\"select-selection input\">\n                <span>{{taskType?.name}}</span>\n            </div>\n            <div class=\"dropdown-menu select-dropdown\">\n                <ul class=\"select-list scroll-shadow\">\n                    <li class=\"select-option\" [class.selected]=\"taskTypeId == m.id\" *ngFor=\"let m of taskTypes\" (click)=\"select(m)\">\n                        {{m.name}}\n                    </li>\n                </ul>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], TaskTypeSelectComponent);
	    return TaskTypeSelectComponent;
	}());
	exports.TaskTypeSelectComponent = TaskTypeSelectComponent;


/***/ },
/* 830 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var dropdown_1 = __webpack_require__(686);
	var TagsSelectComponent = (function () {
	    function TagsSelectComponent(store) {
	        this.store = store;
	        this.tagIds = [];
	        this.setTags = new core_1.EventEmitter();
	        this.tags = [];
	        this.selectedTags = [];
	    }
	    TagsSelectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('reference').subscribe(function (state) {
	            _this.tags = state.tags;
	            if (_this.tagIds) {
	                _this.selectedTags = state.tags.filter(function (it) { return _this.tagIds.indexOf(it.id) != -1; });
	            }
	        });
	    };
	    TagsSelectComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    TagsSelectComponent.prototype.getTags = function () {
	        var _this = this;
	        if (this.tagIds) {
	            return this.tags.filter(function (it) { return _this.tagIds.indexOf(it.id) == -1; });
	        }
	        else {
	            return this.tags;
	        }
	    };
	    TagsSelectComponent.prototype.add = function (m) {
	        this.selectedTags.push(m);
	        this.setTags.emit(this.selectedTags);
	    };
	    TagsSelectComponent.prototype.remove = function (m) {
	        this.selectedTags = this.selectedTags.filter(function (it) { return it.id != m.id; });
	        this.setTags.emit(this.selectedTags);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array)
	    ], TagsSelectComponent.prototype, "tagIds", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagsSelectComponent.prototype, "setTags", void 0);
	    TagsSelectComponent = __decorate([
	        core_1.Component({
	            selector: 'tags-select',
	            directives: [dropdown_1.DROPDOWN_DIRECTIVES],
	            template: "\n        <div dropdown class=\"select\">\n            <div dropdown-toggle class=\"select-selection input\">\n                <span class=\"tag\"\n                    *ngFor=\"let m of selectedTags\"\n                    [style.color]=\"m.color\"\n                    (click)=\"remove(m, $event)\">\n                    {{m.name}}\n                </span>\n            </div>\n            <div class=\"dropdown-menu select-dropdown\">\n                <ul class=\"select-list scroll-shadow\">\n                    <li class=\"select-option\" *ngFor=\"let m of getTags()\" (click)=\"add(m)\">\n                        {{m.name}}\n                    </li>\n                </ul>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], TagsSelectComponent);
	    return TagsSelectComponent;
	}());
	exports.TagsSelectComponent = TagsSelectComponent;


/***/ },
/* 831 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var ng2_translate_1 = __webpack_require__(350);
	var TaskRequestsComponent = (function () {
	    function TaskRequestsComponent() {
	        this.accept = new core_1.EventEmitter();
	        this.decline = new core_1.EventEmitter();
	        this.disabled = false;
	    }
	    TaskRequestsComponent.prototype.doAccept = function (request) {
	        this.disabled = true;
	        this.accept.emit(request);
	    };
	    TaskRequestsComponent.prototype.doDecline = function (request) {
	        this.disabled = true;
	        this.decline.emit(request);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array)
	    ], TaskRequestsComponent.prototype, "requests", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TaskRequestsComponent.prototype, "accept", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TaskRequestsComponent.prototype, "decline", void 0);
	    TaskRequestsComponent = __decorate([
	        core_1.Component({
	            selector: 'task-requests',
	            template: "\n        <ul>\n            <li *ngFor=\"let r of requests\">\n                <span>{{ r.comment }}</span>\n                <span>{{ r.requestType.name }}</span>\n                <span *ngIf=\"r.resolution != 'UNKNOWN'\">\n                    {{ r.resolution }}\n                    {{ r.resolutionTime }}\n                </span>\n                <span *ngIf=\"r.resolution == 'UNKNOWN'\">\n                    <button class=\"btn btn-accept\" (click)=\"doAccept(r)\" [disabled]=\"disabled\" type=\"button\">Accept</button>\n                    <button class=\"btn btn-decline\" (click)=\"doDecline(r)\" [disabled]=\"disabled\" type=\"button\">Decline</button>\n                </span>\n            </li>\n        </ul>\n    ",
	            directives: [],
	            pipes: [ng2_translate_1.TranslatePipe]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], TaskRequestsComponent);
	    return TaskRequestsComponent;
	}());
	exports.TaskRequestsComponent = TaskRequestsComponent;


/***/ },
/* 832 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var notification_1 = __webpack_require__(376);
	var task_reducer_1 = __webpack_require__(473);
	var services_1 = __webpack_require__(453);
	var models_1 = __webpack_require__(460);
	var attachments_1 = __webpack_require__(818);
	var request_type_select_1 = __webpack_require__(833);
	var TaskRequestComponent = (function () {
	    function TaskRequestComponent(store, notifyService, taskService) {
	        var _this = this;
	        this.store = store;
	        this.notifyService = notifyService;
	        this.taskService = taskService;
	        this.isOpen = false;
	        this.refSub = store.select('reference').subscribe(function (state) {
	            _this.requestTypes = state.requestTypes;
	        });
	        this.taskSub = store.select('task').subscribe(function (state) {
	            if (state) {
	                _this.request = state.request || new models_1.Request();
	                _this.isOpen = state.showRequest;
	                if (state.task) {
	                    _this.request.taskId = state.task.id;
	                    if (!_this.request.fsid) {
	                        _this.request.fsid = '' + Date.now();
	                    }
	                }
	            }
	        });
	    }
	    TaskRequestComponent.prototype.ngOnInit = function () { };
	    TaskRequestComponent.prototype.ngOnDestroy = function () {
	        this.taskSub.unsubscribe();
	    };
	    TaskRequestComponent.prototype.selectRequestType = function (requestType) {
	        this.requestType = requestType;
	        document.body.click();
	    };
	    TaskRequestComponent.prototype.cancel = function () {
	        this.store.dispatch({ type: task_reducer_1.TASK_REQUEST_CANCEL });
	    };
	    TaskRequestComponent.prototype.sendRequest = function ($event) {
	        var _this = this;
	        $event.preventDefault();
	        this.request.comment = this.comment;
	        this.request.requestTypeId = this.requestType.id;
	        this.taskService.sendTaskRequest(this.request).subscribe(function (response) {
	            _this.notifyService.info('request send: success').show().remove(3000);
	            _this.cancel();
	        });
	    };
	    TaskRequestComponent.prototype.addAttachment = function (file) {
	        var att = new models_1.Attachment();
	        att.realFileName = file.files[0];
	        if (!this.request.attachments) {
	            this.request.attachments = [];
	        }
	        this.request.attachments.push(att);
	    };
	    TaskRequestComponent.prototype.deleteAttachment = function (attachment) {
	        var _this = this;
	        this.taskService.deleteRequestAttachment(this.request, attachment).subscribe(function (r) {
	            _this.request.attachments = _this.request.attachments.filter(function (it) { return it.id != attachment.id; });
	        });
	    };
	    TaskRequestComponent = __decorate([
	        core_1.Component({
	            selector: 'task-request',
	            template: "\n        <form class=\"task-request-form\" (submit)=\"sendRequest($event)\">\n            <header>{{ 'task_request' | translate }}</header>\n            <section>\n                <request-type-select [requestTypeId]=\"request.requestTypeId\" (onSelect)=\"selectRequestType($event)\"></request-type-select>\n                <textarea class=\"request-comment\" [(ngModel)]=\"comment\"></textarea>\n                <attachments [entity]=\"request\" (upload)=\"addAttachment($event)\" (delete)=\"addAttachment($event)\"></attachments>\n            </section>\n            <footer>\n                <button class=\"btn\" type=\"button\" (click)=\"cancel()\">{{ 'cancel' | translate }}</button>\n                <button class=\"btn btn-primary\" type=\"submit\" [disabled]=\"!requestType\">{{ 'send_request' | translate }}</button>\n            </footer>\n        </form>\n    ",
	            directives: [attachments_1.AttachmentsComponent, request_type_select_1.RequestTypeSelectComponent],
	            host: {
	                '[class.task-request]': 'true',
	                '[class.task-request-open]': 'isOpen',
	                '(keyup.escape)': 'cancel()'
	            },
	            pipes: [ng2_translate_1.TranslatePipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, notification_1.NotificationService, services_1.TaskService])
	    ], TaskRequestComponent);
	    return TaskRequestComponent;
	}());
	exports.TaskRequestComponent = TaskRequestComponent;


/***/ },
/* 833 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var store_1 = __webpack_require__(437);
	var dropdown_1 = __webpack_require__(686);
	var RequestTypeSelectComponent = (function () {
	    function RequestTypeSelectComponent(store) {
	        this.store = store;
	        this.onSelect = new core_1.EventEmitter();
	    }
	    RequestTypeSelectComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.sub = this.store.select('reference').subscribe(function (state) {
	            _this.requestTypes = state.requestTypes;
	            _this.requestType = state.requestTypes.filter(function (it) { return it.id == _this.requestTypeId; })[0];
	        });
	    };
	    RequestTypeSelectComponent.prototype.ngOnDestroy = function () {
	        this.sub.unsubscribe();
	    };
	    RequestTypeSelectComponent.prototype.select = function (m) {
	        this.requestType = m;
	        this.onSelect.emit(this.requestType);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], RequestTypeSelectComponent.prototype, "requestTypeId", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], RequestTypeSelectComponent.prototype, "onSelect", void 0);
	    RequestTypeSelectComponent = __decorate([
	        core_1.Component({
	            selector: 'request-type-select',
	            directives: [dropdown_1.DROPDOWN_DIRECTIVES],
	            template: "\n        <div dropdown class=\"select\">\n            <div dropdown-toggle class=\"select-selection input\">\n                <span>{{requestType?.name}}</span>\n            </div>\n            <div class=\"dropdown-menu select-dropdown\">\n                <ul class=\"select-list scroll-shadow\">\n                    <li class=\"select-option\" [class.selected]=\"requestType?.id == m.id\" *ngFor=\"let m of requestTypes\" (click)=\"select(m)\">\n                        {{m.name}}\n                    </li>\n                </ul>\n            </div>\n        </div>\n    "
	        }), 
	        __metadata('design:paramtypes', [store_1.Store])
	    ], RequestTypeSelectComponent);
	    return RequestTypeSelectComponent;
	}());
	exports.RequestTypeSelectComponent = RequestTypeSelectComponent;


/***/ },
/* 834 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var ng2_translate_1 = __webpack_require__(350);
	var markdown_editor_1 = __webpack_require__(391);
	var pagination_1 = __webpack_require__(804);
	var models_1 = __webpack_require__(460);
	var comment_1 = __webpack_require__(835);
	var CommentsComponent = (function () {
	    function CommentsComponent() {
	        this.add = new core_1.EventEmitter();
	        this.update = new core_1.EventEmitter();
	        this.delete = new core_1.EventEmitter();
	        this.commentText = '';
	    }
	    CommentsComponent.prototype.onEditorFocus = function () {
	        this.isEdit = true;
	    };
	    CommentsComponent.prototype.onEditorBlur = function () {
	        this.isEdit = this.commentText.length > 0;
	    };
	    CommentsComponent.prototype.setCommentText = function (text) {
	        this.commentText = text;
	    };
	    CommentsComponent.prototype.addComment = function () {
	        var comment = new models_1.Comment();
	        comment.comment = this.commentText;
	        this.add.emit(comment);
	        this.commentText = '';
	    };
	    CommentsComponent.prototype.updateComment = function (comment) {
	        this.update.emit(comment);
	    };
	    CommentsComponent.prototype.deleteComment = function (comment) {
	        this.delete.emit(comment);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array)
	    ], CommentsComponent.prototype, "comments", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], CommentsComponent.prototype, "add", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], CommentsComponent.prototype, "update", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], CommentsComponent.prototype, "delete", void 0);
	    CommentsComponent = __decorate([
	        core_1.Component({
	            selector: 'comments',
	            template: "\n        <div class=\"comments-wrap\">\n            <section class=\"comments\">\n                <comment *ngFor=\"let comment of comments\"\n                    [comment]=\"comment\"\n                    [editable]=\"true\"\n                    (save)=\"updateComment($event)\"\n                    (delete)=\"deleteComment($event)\">\n                </comment>\n            </section>\n            <section class=\"comment-composer\" [class.edit]=\"isEdit\">\n                <div class=\"comment-composer__editor\">\n                    <markdown-editor\n                        markdown=\"\"\n                        editable=\"true\"\n                        placeHolder=\"{{'add_comment' | translate}}\"\n                        (update)=\"setCommentText($event)\"\n                        (focus)=\"onEditorFocus($event)\"\n                        (blur)=\"onEditorBlur($event)\">\n                    </markdown-editor>\n                </div>\n                <button class=\"btn btn-add-comment\"\n                    (click)=\"addComment()\"\n                    [disabled]=\"!commentText\">\n                    {{ 'add_comment' | translate }}\n                </button>\n            </section>\n        </div>\n    ",
	            directives: [pagination_1.PaginationComponent, comment_1.CommentComponent, markdown_editor_1.MarkdownEditorComponent],
	            pipes: [ng2_translate_1.TranslatePipe]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], CommentsComponent);
	    return CommentsComponent;
	}());
	exports.CommentsComponent = CommentsComponent;


/***/ },
/* 835 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var ng2_translate_1 = __webpack_require__(350);
	var markdown_1 = __webpack_require__(380);
	var attachments_1 = __webpack_require__(818);
	var pipes_1 = __webpack_require__(696);
	var models_1 = __webpack_require__(460);
	var CommentComponent = (function () {
	    function CommentComponent() {
	        this.editable = false;
	        this.save = new core_1.EventEmitter();
	        this.delete = new core_1.EventEmitter();
	        this.saving = false;
	        this.edit = false;
	    }
	    CommentComponent.prototype.toggleEdit = function () {
	        this.edit = this.editable && !this.edit;
	        if (this.edit) {
	            this.commentText = this.comment.comment;
	        }
	        else {
	            this.commentText = '';
	        }
	    };
	    CommentComponent.prototype.setCommentText = function (text) {
	        this.commentText = text;
	    };
	    CommentComponent.prototype.saveComment = function () {
	        this.comment.comment = this.commentText;
	        this.saving = true;
	        this.save.emit(this.comment);
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', models_1.Comment)
	    ], CommentComponent.prototype, "comment", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], CommentComponent.prototype, "editable", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], CommentComponent.prototype, "save", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], CommentComponent.prototype, "delete", void 0);
	    CommentComponent = __decorate([
	        core_1.Component({
	            selector: 'comment',
	            template: "\n        <div class=\"comment\" [class.edit]=\"edit\" [class.saving]=\"saving\">\n            <div class=\"comment__avatar\"></div>\n            <div class=\"comment__details\">\n                <span class=\"comment__author\">{{comment.authorId}}</span>\n                <span class=\"comment__time\">{{comment.regDate}}</span>\n                <p class=\"comment__text\" *ngIf=\"!edit\" innerHTML=\"{{comment.comment | marked}}\"></p>\n                <div class=\"comment__editor\" *ngIf=\"edit\">\n                    <markdown-editor\n                        markdown=\"{{comment.comment}}\"\n                        editable=\"true\"\n                        placeHolder=\"{{'add_comment' | translate}}\"\n                        (update)=\"setCommentText($event)\">\n                    </markdown-editor>\n                    <button type=\"button\" class=\"btn btn-cancel\" [disabled]=\"saving\" (click)=\"toggleEdit()\">{{'cancel' | translate}}</button>\n                    <button type=\"button\" class=\"btn btn-primary btn-save\" [disabled]=\"saving\" (click)=\"saveComment()\">{{'save' | translate}}</button>\n                </div>\n                <!-- <attachments\n                    [entity]=\"comment\"\n                    (upload)=\"addAttachment($event)\"\n                    (delete)=\"deleteAttachment($event)\">\n                </attachments> -->\n            </div>\n            <div class=\"comment__buttons\" *ngIf=\"editable\">\n                <button type=\"button\" class=\"btn btn-sm\" *ngIf=\"!edit\" (click)=\"toggleEdit()\">\n                    <i class=\"fa fa-pencil\"></i>{{'edit' | translate}}\n                </button>\n                <button type=\"button\" class=\"btn btn-sm\" title=\"{{'delete' | translate}}\" (click)=\"delete.emit(comment)\">\n                    <i class=\"fa fa-remove\"></i>\n                </button>\n            </div>\n        </div>\n    ",
	            directives: [attachments_1.AttachmentsComponent, markdown_1.MarkdownEditorComponent],
	            pipes: [pipes_1.DateFormatPipe, ng2_translate_1.TranslatePipe, markdown_1.MarkedPipe]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], CommentComponent);
	    return CommentComponent;
	}());
	exports.CommentComponent = CommentComponent;


/***/ },
/* 836 */
/***/ function(module, exports) {

	module.exports = "<form class=\"form\" [ngFormModel]=\"form\" *ngIf=\"isReady\">\r\n    <header class=\"content-header\">\r\n        <button class=\"btn-back\" type=\"button\" (click)=\"close($event)\">\r\n            <i class=\"fa fa-chevron-left\"></i>\r\n        </button>\r\n        <h1 class=\"header-title\">\r\n            <a *ngIf=\"parentTask\" [routerLink]=\"['/task', parentTask.id]\" class=\"parent-task-link\">\r\n                {{parentTask.title}}\r\n            </a>\r\n            <div>\r\n                {{getTitle() | translate}}\r\n                <small>{{ getTaskStatusType() }}</small>\r\n            </div>\r\n        </h1>\r\n        <div class=\"content-actions\">\r\n            <button class=\"btn btn-primary\" type=\"button\" [disabled]=\"!form.valid\" (click)=\"saveTask()\">\r\n                {{'save_close' | translate}}\r\n            </button>\r\n            <button class=\"btn\" type=\"button\" (click)=\"close($event)\">\r\n                {{'close' | translate}}\r\n            </button>\r\n            <button class=\"btn\" type=\"button\" *ngIf=\"canRequestAction()\" (click)=\"newRequest($event)\">\r\n                {{'new_request' | translate}}\r\n            </button>\r\n            <button *ngIf=\"!isNew\" class=\"btn\" type=\"button\" (click)=\"addSubtask($event)\">\r\n                {{'add_subtask' | translate}}\r\n            </button>\r\n            <div *ngIf=\"!isNew\" dropdown class=\"buttons\">\r\n                <div dropdown-toggle>\r\n                    <span class=\"btn\">...</span>\r\n                </div>\r\n                <div class=\"dropdown-menu\">\r\n                    <button class=\"btn\" type=\"button\" (click)=\"deleteTask()\">\r\n                        {{'delete' | translate}}\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </header>\r\n    <section class=\"content-body\">\r\n        <tabs>\r\n            <tab class=\"tab-pane\" tabTitle=\"{{'properties' | translate}}\">\r\n                <fieldset class=\"fieldset\">\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'task_title' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.title.valid\">\r\n                            <input class=\"span8\" [(ngModel)]=\"task.title\" ngControl=\"title\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\" *ngIf=\"!isSubtask\">\r\n                        <div class=\"control-label\">\r\n                            {{'project' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.projectId.valid\">\r\n                            <div class=\"span8\">\r\n                                <project-select [projectId]=\"task.projectId\" (onSelect)=\"selectProject($event)\"></project-select>\r\n                            </div>\r\n                        </div>\r\n                        <div [hidden]=\"form.controls.projectId.valid || form.controls.projectId.pristine\" class=\"error-message\">\r\n                            {{'required' | translate}}\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\" *ngIf=\"!isSubtask\">\r\n                        <div class=\"control-label\">\r\n                            {{'task_type' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.taskTypeId.valid\">\r\n                            <div class=\"span8\">\r\n                                <task-type-select [taskTypeId]=\"task.taskTypeId\" (onSelect)=\"selectTaskType($event)\"></task-type-select>\r\n                            </div>\r\n                            <div [hidden]=\"form.controls.taskTypeId.valid || form.controls.taskTypeId.pristine\" class=\"error-message\">\r\n                                {{'required' | translate}}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'priority' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.priority.valid\">\r\n                            <switch-button [model]=\"task\" value=\"priority\" [items]=\"taskPriorityTypes\"></switch-button>\r\n                            <div [hidden]=\"form.controls.priority.valid || form.controls.priority.pristine\" class=\"error-message\">\r\n                                {{'required' | translate}}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'assignee_user' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.assigneeUserId.valid\">\r\n                            <div class=\"span8\">\r\n                                <user-select [userId]=\"task.assigneeUserId\" (onSelect)=\"selectAssigneeUser($event)\"></user-select>\r\n                            </div>\r\n                            <div [hidden]=\"form.controls.assigneeUserId.valid || form.controls.assigneeUserId.pristine\" class=\"error-message\">\r\n                                {{'required' | translate}}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'start_date' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <input datepicker class=\"span2\" (select)=\"setStartDate($event)\" [(ngModel)]=\"task.startDate\" ngControl=\"startDate\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'due_date' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <input datepicker class=\"span2\" (select)=\"setDueDate($event)\" [(ngModel)]=\"task.dueDate\" ngControl=\"dueDate\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'tags' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.tagIds.valid\">\r\n                            <div class=\"span8\">\r\n                                <tags-select [tagIds]=\"task.tagIds\" (setTags)=\"setTags($event)\"></tags-select>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'body' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\" [class.has-error]=\"!form.controls.body.valid\">\r\n                            <div class=\"span8\">\r\n                                <markdown-editor [markdown]=\"task.body || ''\" editable=\"true\" updateTimeout=\"300\" (update)=\"updateTaskBody($event)\"></markdown-editor>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                </fieldset>\r\n                <attachments [entity]=\"task\" (upload)=\"addAttachment($event)\" (delete)=\"deleteAttachment($event)\"></attachments>\r\n            </tab>\r\n            <tab *ngIf=\"!isNew\" class=\"tab-pane\" tabTitle=\"{{'comments' | translate}}\">\r\n                <comments [comments]=\"comments\" (add)=\"saveComment($event)\" (update)=\"saveComment($event)\" (delete)=\"deleteComment($event)\"></comments>\r\n            </tab>\r\n            <tab *ngIf=\"!isNew\" class=\"tab-pane\" tabTitle=\"{{'requests' | translate}} {{hasUnResolvedRequest ? '1' : '0'}}\">\r\n                <task-requests [requests]=\"requests\" (accept)=\"acceptRequest($event)\" (decline)=\"declineRequest($event)\"></task-requests>\r\n            </tab>\r\n        </tabs>\r\n    </section>\r\n</form>\r\n<task-request></task-request>\r\n"

/***/ },
/* 837 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var http_1 = __webpack_require__(329);
	var router_1 = __webpack_require__(394);
	var common_1 = __webpack_require__(2);
	var store_1 = __webpack_require__(437);
	var ng2_translate_1 = __webpack_require__(350);
	var tabs_1 = __webpack_require__(826);
	var keys_pipe_1 = __webpack_require__(803);
	var app_service_1 = __webpack_require__(454);
	var translate_service_1 = __webpack_require__(457);
	var user_1 = __webpack_require__(461);
	var utils_1 = __webpack_require__(456);
	var HEADERS = new http_1.Headers({
	    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
	    'Accept': 'application/json'
	});
	var UserProfileComponent = (function () {
	    function UserProfileComponent(store, http, router, formBuilder, ng2TranslateService, appService, translateService) {
	        var _this = this;
	        this.store = store;
	        this.http = http;
	        this.router = router;
	        this.formBuilder = formBuilder;
	        this.ng2TranslateService = ng2TranslateService;
	        this.appService = appService;
	        this.translateService = translateService;
	        this.user = new user_1.User();
	        this.changePassword = false;
	        this.language = 'RUS';
	        this.pageSizes = [10, 20, 30, 40, 50];
	        var ck = document.cookie.match('(lang)=(.*?)($|;|,(?! ))');
	        if (ck) {
	            this.language = ck[2];
	        }
	        this.store.select('authed').subscribe(function (data) {
	            _this.user = data.userProfile;
	            _this.pageSize = data.pageSize;
	            _this.languages = data.languages;
	        });
	        this.form = formBuilder.group({
	            login: [],
	            pwd: [],
	            pwd_confirm: [],
	            email: []
	        });
	    }
	    UserProfileComponent.prototype.toggleChangePassword = function () {
	        this.changePassword = !this.changePassword;
	    };
	    UserProfileComponent.prototype.updateUserProfile = function () {
	        this.appService.updateUserProfile(this.user);
	    };
	    UserProfileComponent.prototype.changeLang = function ($event) {
	        var _this = this;
	        var langCode = $event.target.value;
	        var url = '/Staff/p?id=change-session-val-action&lang=' + langCode;
	        return this.http.post(url, {}, { headers: HEADERS })
	            .map(function (response) { return response.json(); })
	            .subscribe(function (data) {
	            _this.ng2TranslateService.reloadLang(langCode).subscribe(function (r) {
	                _this.ng2TranslateService.use(langCode);
	            });
	            utils_1.createCookie('lang', langCode, 365);
	            window.location.reload();
	        });
	    };
	    UserProfileComponent.prototype.close = function (event) {
	        event.preventDefault();
	        window.history.back();
	    };
	    UserProfileComponent = __decorate([
	        core_1.Component({
	            selector: '[user-profile]',
	            template: __webpack_require__(838),
	            directives: [common_1.FORM_DIRECTIVES, tabs_1.TAB_DIRECTIVES],
	            providers: [common_1.FormBuilder],
	            pipes: [ng2_translate_1.TranslatePipe, keys_pipe_1.KeysPipe]
	        }), 
	        __metadata('design:paramtypes', [store_1.Store, http_1.Http, router_1.Router, common_1.FormBuilder, ng2_translate_1.TranslateService, app_service_1.AppService, translate_service_1.TranslateService])
	    ], UserProfileComponent);
	    return UserProfileComponent;
	}());
	exports.UserProfileComponent = UserProfileComponent;


/***/ },
/* 838 */
/***/ function(module, exports) {

	module.exports = "<form class=\"form form-userprofile\" autocomplete=\"off\" [ngFormModel]=\"form\">\r\n    <header class=\"content-header\">\r\n        <button class=\"btn-back\" type=\"button\" (click)=\"close($event)\">\r\n            <i class=\"fa fa-chevron-left\"></i>\r\n        </button>\r\n        <h1 class=\"header-title\">\r\n            {{'employee' | translate}} {{user.name}}\r\n        </h1>\r\n        <div class=\"content-actions\">\r\n            <button class=\"btn btn-primary\" type=\"button\" [disabled]=\"!form.valid\" (click)=\"updateUserProfile()\">\r\n                {{'save_close' | translate}}\r\n            </button>\r\n            <button class=\"btn\" type=\"button\" (click)=\"close($event)\">\r\n                {{'close' | translate}}\r\n            </button>\r\n        </div>\r\n    </header>\r\n    <section class=\"content-body\">\r\n        <tabs>\r\n            <tab class=\"tab-pane\" tabTitle=\"{{'properties' | translate}}\">\r\n                <!--<fieldset class=\"fieldset fieldset-user-avatar\">\r\n                            <img class=\"user-avatar\" src=\"img/avatar.png\"/>\r\n                </fieldset>-->\r\n                <fieldset class=\"fieldset fieldset-user-fields\">\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'user_name' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <span class=\"input-placeholder\">\r\n                                {{user.name}}\r\n                            </span>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'login_name' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <input type=\"text\" class=\"span4\" [(ngModel)]=\"user.login\" ngControl=\"login\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\" *ngIf=\"!changePassword\">\r\n                        <div class=\"control-label\"></div>\r\n                        <div class=\"controls\">\r\n                            <span class=\"btn btn-xs\" (click)=\"toggleChangePassword()\">{{'change_password' | translate}}</span>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\" *ngIf=\"changePassword\">\r\n                        <div class=\"control-label\">\r\n                            {{'password' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <input type=\"password\" class=\"span4\" [(ngModel)]=\"user.pwd\" ngControl=\"pwd\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\" *ngIf=\"changePassword\">\r\n                        <div class=\"control-label\">\r\n                            {{'password_confirm' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <input type=\"password\" class=\"span4\" [(ngModel)]=\"user.pwd_confirm\" ngControl=\"pwd_confirm\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'email' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <input type=\"email\" class=\"span4\" [(ngModel)]=\"user.email\" ngControl=\"email\" />\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'org_name' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <span class=\"input-placeholder\">\r\n                                {{user.organization}}\r\n                            </span>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'department' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <span class=\"input-placeholder\">\r\n                                {{user.department}}\r\n                            </span>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'position' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <span class=\"input-placeholder\">\r\n                                {{user.position}}\r\n                            </span>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'roles' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <ul class=\"input-placeholder list-style-none\">\r\n                                <xsl:for-each select=\"fields/roles/entry\">\r\n                                    <li>\r\n                                        <xsl:value-of select=\".\" />\r\n                                    </li>\r\n                                </xsl:for-each>\r\n                            </ul>\r\n                        </div>\r\n                    </div>\r\n                </fieldset>\r\n            </tab>\r\n            <tab class=\"tab-pane\" tabTitle=\"{{'interface' | translate}}\">\r\n                <fieldset class=\"fieldset\">\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'limit_view' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <select name=\"pagesize\" class=\"span2\" (change)=\"changePageSize($event)\">\r\n                                <option value=\"{{ps}}\" [selected]=\"ps == pageSize\" *ngFor=\"let ps of pageSizes\">{{ps}}</option>\r\n                            </select>\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"form-group\">\r\n                        <div class=\"control-label\">\r\n                            {{'interface_lang' | translate}}\r\n                        </div>\r\n                        <div class=\"controls\">\r\n                            <select name=\"lang\" class=\"span2\" (change)=\"changeLang($event)\">\r\n                                <option value=\"{{langCode}}\" [selected]=\"langCode == language\" *ngFor=\"let langCode of languages | keys\">\r\n                                    {{languages[langCode]}}\r\n                                </option>\r\n                            </select>\r\n                        </div>\r\n                    </div>\r\n                    <!-- <div class=\"form-group\">\r\n                        <div class=\"control-label\"></div>\r\n                        <div class=\"controls\">\r\n                            <a href=\"javascript:void(0)\" data-toggle-theme=\"theme1\" class=\"input-placeholder\">\r\n                                {{'change_skin' | translate}}\r\n                            </a>\r\n                        </div>\r\n                    </div> -->\r\n                </fieldset>\r\n            </tab>\r\n        </tabs>\r\n    </section>\r\n</form>\r\n"

/***/ },
/* 839 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(5);
	var LoginComponent = (function () {
	    function LoginComponent() {
	    }
	    LoginComponent = __decorate([
	        core_1.Component({
	            selector: '[login]',
	            template: ''
	        }), 
	        __metadata('design:paramtypes', [])
	    ], LoginComponent);
	    return LoginComponent;
	}());
	exports.LoginComponent = LoginComponent;


/***/ },
/* 840 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(841));


/***/ },
/* 841 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var compose_1 = __webpack_require__(842);
	var store_1 = __webpack_require__(437);
	var ngrx_store_logger_1 = __webpack_require__(843);
	var authed_reducer_1 = __webpack_require__(455);
	var projects_reducer_1 = __webpack_require__(459);
	var tasks_reducer_1 = __webpack_require__(472);
	var task_reducer_1 = __webpack_require__(473);
	var staff_reducer_1 = __webpack_require__(477);
	var reference_reducer_1 = __webpack_require__(475);
	var logger = ngrx_store_logger_1.storeLogger({
	    level: 'log',
	    collapsed: false,
	    duration: true,
	    timestamp: true
	});
	exports.APP_STORE = store_1.provideStore(compose_1.compose(logger, store_1.combineReducers)({
	    authed: authed_reducer_1.authedReducer,
	    projects: projects_reducer_1.projectsReducer,
	    tasks: tasks_reducer_1.tasksReducer,
	    task: task_reducer_1.taskReducer,
	    staff: staff_reducer_1.staffReducer,
	    reference: reference_reducer_1.referenceReducer
	}));


/***/ },
/* 842 */
/***/ function(module, exports) {

	"use strict";
	exports.compose = function () {
	    var functions = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        functions[_i - 0] = arguments[_i];
	    }
	    return function (arg) {
	        if (functions.length === 0) {
	            return arg;
	        }
	        var last = functions[functions.length - 1];
	        var rest = functions.slice(0, -1);
	        return rest.reduceRight(function (composed, fn) { return fn(composed); }, last(arg));
	    };
	};
	//# sourceMappingURL=compose.js.map

/***/ },
/* 843 */
/***/ function(module, exports) {

	"use strict";
	var logger = console;
	var INIT_ACTION = "@ngrx/store/init";
	var repeat = function (str, times) { return (new Array(times + 1)).join(str); };
	var pad = function (num, maxLength) { return repeat("0", maxLength - num.toString().length) + num; };
	var formatTime = function (time) { return ("@ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3)); };
	var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
	var getLogLevel = function (level, action, payload, type) {
	    switch (typeof level) {
	        case "object":
	            return typeof level[type] === "function" ? level[type].apply(level, payload) : level[type];
	        case "function":
	            return level(action);
	        default:
	            return level;
	    }
	};
	var printBuffer = function (options) { return function (logBuffer) {
	    var actionTransformer = options.actionTransformer, collapsed = options.collapsed, colors = options.colors, timestamp = options.timestamp, duration = options.duration, level = options.level;
	    logBuffer.forEach(function (logEntry, key) {
	        var started = logEntry.started, startedTime = logEntry.startedTime, action = logEntry.action, error = logEntry.error;
	        var prevState = logEntry.prevState.nextState ? logEntry.prevState.nextState : '(Empty)';
	        var took = logEntry.took, nextState = logEntry.nextState;
	        var nextEntry = logBuffer[key + 1];
	        if (nextEntry) {
	            nextState = nextEntry.prevState;
	            took = nextEntry.started - started;
	        }
	        var formattedAction = actionTransformer(action);
	        var isCollapsed = (typeof collapsed === "function") ? collapsed(function () { return nextState; }, action) : collapsed;
	        var formattedTime = formatTime(startedTime);
	        var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
	        var title = "action " + (timestamp ? formattedTime : "") + " " + formattedAction.type + " " + (duration ? "(in " + took.toFixed(2) + " ms)" : "");
	        try {
	            if (isCollapsed) {
	                if (colors.title)
	                    logger.groupCollapsed("%c " + title, titleCSS);
	                else
	                    logger.groupCollapsed(title);
	            }
	            else {
	                if (colors.title)
	                    logger.group("%c " + title, titleCSS);
	                else
	                    logger.group(title);
	            }
	        }
	        catch (e) {
	            logger.log(title);
	        }
	        var prevStateLevel = getLogLevel(level, formattedAction, [prevState], "prevState");
	        var actionLevel = getLogLevel(level, formattedAction, [formattedAction], "action");
	        var errorLevel = getLogLevel(level, formattedAction, [error, prevState], "error");
	        var nextStateLevel = getLogLevel(level, formattedAction, [nextState], "nextState");
	        if (prevStateLevel) {
	            if (colors.prevState)
	                logger[prevStateLevel]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);
	            else
	                logger[prevStateLevel]("prev state", prevState);
	        }
	        if (actionLevel) {
	            if (colors.action)
	                logger[actionLevel]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);
	            else
	                logger[actionLevel]("action", formattedAction);
	        }
	        if (error && errorLevel) {
	            if (colors.error)
	                logger[errorLevel]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);
	            else
	                logger[errorLevel]("error", error);
	        }
	        if (nextStateLevel) {
	            if (colors.nextState)
	                logger[nextStateLevel]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);
	            else
	                logger[nextStateLevel]("next state", nextState);
	        }
	        try {
	            logger.groupEnd();
	        }
	        catch (e) {
	            logger.log("\u2014\u2014 log end \u2014\u2014");
	        }
	    });
	    logBuffer.length = 0;
	}; };
	exports.storeLogger = function (opts) {
	    if (opts === void 0) { opts = {}; }
	    return function (reducer) {
	        var log = {};
	        var ua = window && window.navigator.userAgent ? window.navigator.userAgent : '';
	        var ms_ie = false;
	        //fix for action display in IE
	        var old_ie = ua.indexOf('MSIE ');
	        var new_ie = ua.indexOf('Trident/');
	        if ((old_ie > -1) || (new_ie > -1)) {
	            ms_ie = true;
	        }
	        var defaults = {
	            level: "log",
	            collapsed: false,
	            duration: true,
	            timestamp: true,
	            stateTransformer: function (state) { return state; },
	            actionTransformer: function (actn) { return actn; },
	            colors: ms_ie ? {} : {
	                title: function () { return "#000000"; },
	                prevState: function () { return "#9E9E9E"; },
	                action: function () { return "#03A9F4"; },
	                nextState: function () { return "#4CAF50"; },
	                error: function () { return "#F20404"; },
	            }
	        };
	        var options = Object.assign({}, defaults, opts);
	        var stateTransformer = options.stateTransformer;
	        var buffer = printBuffer(options);
	        return function (state, action) {
	            var preLog = {
	                started: timer.now(),
	                startedTime: new Date(),
	                prevState: stateTransformer(log),
	                action: action
	            };
	            var nextState = reducer(state, action);
	            var postLog = {
	                took: timer.now() - preLog.started,
	                nextState: stateTransformer(nextState)
	            };
	            log = Object.assign({}, preLog, postLog);
	            //ignore init action fired by store and devtools
	            if (action.type !== INIT_ACTION) {
	                buffer([log]);
	            }
	            return nextState;
	        };
	    };
	};


/***/ }
]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5icm93c2VyLnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvbm90aWZpY2F0aW9uL2luZGV4LnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc2hhcmVkL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvbWFya2Rvd24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NoYXJlZC9tYXJrZG93bi9tYXJrZG93bi1jb252ZXJ0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NoYXJlZC9tYXJrZG93bi9tYXJrZG93bi1lZGl0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NoYXJlZC9tYXJrZG93bi9tYXJrZWQucGlwZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3JvdXRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3JvdXRlci9kaXJlY3RpdmVzL3JvdXRlcl9saW5rLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3NjYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvY29uY2F0TWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2V2ZXJ5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Gcm9tT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9JdGVyYXRvck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvQXJyYXlMaWtlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3JvdXRlci9hcHBseV9yZWRpcmVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL3VybF90cmVlLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL3VybF9zZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL3V0aWxzL2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL2NyZWF0ZV9yb3V0ZXJfc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL0JlaGF2aW9yU3ViamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3JvdXRlci9yb3V0ZXJfc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvdXRpbHMvdHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3JvdXRlci9jcmVhdGVfdXJsX3RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvcmVjb2duaXplLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90b1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvcm91dGVyX291dGxldF9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvZGlyZWN0aXZlcy9yb3V0ZXJfbGlua19hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvZGlyZWN0aXZlcy9yb3V0ZXJfb3V0bGV0LmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvcm91dGVyL3JvdXRlcl9wcm92aWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9yb3V0ZXIvY29tbW9uX3JvdXRlcl9wcm92aWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NlcnZpY2VzL2luZGV4LnRzIiwid2VicGFjazovLy8uL2FwcC9zZXJ2aWNlcy9hcHAuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvcmVkdWNlcnMvYXV0aGVkLnJlZHVjZXIudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3V0aWxzL3V0aWxzLnRzIiwid2VicGFjazovLy8uL2FwcC9zZXJ2aWNlcy90cmFuc2xhdGUuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc2VydmljZXMvcHJvamVjdC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL2FwcC9yZWR1Y2Vycy9wcm9qZWN0cy5yZWR1Y2VyLnRzIiwid2VicGFjazovLy8uL2FwcC9tb2RlbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL21vZGVscy91c2VyLnRzIiwid2VicGFjazovLy8uL2FwcC9tb2RlbHMvb3JnYW5pemF0aW9uLnRzIiwid2VicGFjazovLy8uL2FwcC9tb2RlbHMvYXR0YWNobWVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvbW9kZWxzL3Byb2plY3QudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL21vZGVscy90YXNrLnRzIiwid2VicGFjazovLy8uL2FwcC9tb2RlbHMvdGFnLnRzIiwid2VicGFjazovLy8uL2FwcC9tb2RlbHMvdGFzay10eXBlLnRzIiwid2VicGFjazovLy8uL2FwcC9tb2RlbHMvY29tbWVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvbW9kZWxzL3JlcXVlc3QudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL21vZGVscy9yZXF1ZXN0LXR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NlcnZpY2VzL3Rhc2suc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvcmVkdWNlcnMvdGFza3MucmVkdWNlci50cyIsIndlYnBhY2s6Ly8vLi9hcHAvcmVkdWNlcnMvdGFzay5yZWR1Y2VyLnRzIiwid2VicGFjazovLy8uL2FwcC9zZXJ2aWNlcy9yZWZlcmVuY2Uuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvcmVkdWNlcnMvcmVmZXJlbmNlLnJlZHVjZXIudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NlcnZpY2VzL3N0YWZmLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3JlZHVjZXJzL3N0YWZmLnJlZHVjZXIudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NlcnZpY2VzL3VwbG9hZC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9SeC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvYmluZENhbGxiYWNrLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvQXN5bmNTdWJqZWN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvY29uY2F0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9kZWZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9EZWZlck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2VtcHR5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL2VtcHR5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZnJvbUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL0Zyb21FdmVudE9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb2JzZXJ2YWJsZS9Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2dlbmVyYXRlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL0dlbmVyYXRlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvSW50ZXJ2YWxPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL2lzTnVtZXJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvcmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvbmV2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvbmV2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvTmV2ZXJPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL25vb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL3JhbmdlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL3JhbmdlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL1JhbmdlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29ic2VydmFibGUvdGltZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvdGltZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvVGltZXJPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS96aXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29ic2VydmFibGUvemlwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci96aXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlckNvdW50LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9idWZmZXJDb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlclRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlclRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJUb2dnbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlclRvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlcldoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlcldoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3B1Ymxpc2hSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL1JlcGxheVN1YmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb21iaW5lQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jb21iaW5lQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0QWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9jb25jYXRBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb25jYXRNYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvY29uY2F0TWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL21lcmdlTWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvY291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZW1hdGVyaWFsaXplLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9kZW1hdGVyaWFsaXplLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2RlYm91bmNlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9kZWJvdW5jZVRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWxheVdoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2RlbGF5V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2RvLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZXhwYW5kLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9leHBhbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL0VtcHR5RXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9ncm91cEJ5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9ncm91cEJ5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy91dGlsL01hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9NYXBQb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9GYXN0TWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2lnbm9yZUVsZW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvYXVkaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL2F1ZGl0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvYXVkaXRUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9hdWRpdFRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9sYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9sYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbGV0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9sZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvbWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvbWF0ZXJpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcFRvLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvbXVsdGljYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivb2JzZXJ2ZU9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcGFydGl0aW9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9wYXJ0aXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3V0aWwvbm90LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaFJlcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2hMYXN0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9wdWJsaXNoTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3JlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvcmVwZWF0LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvcmV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3JldHJ5LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2FtcGxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9zYW1wbGVUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zYW1wbGVUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2luZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zaW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9za2lwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9za2lwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcFVudGlsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9za2lwVW50aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9za2lwV2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3NraXBXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3Vic2NyaWJlT24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3N1YnNjcmliZU9uLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vYnNlcnZhYmxlL1N1YnNjcmliZU9uT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc2NoZWR1bGVyL2FzYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NjaGVkdWxlci9Bc2FwU2NoZWR1bGVyLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9zY2hlZHVsZXIvQXNhcEFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9JbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90YWtlTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGFrZUxhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL2FkZC9vcGVyYXRvci90YWtlV2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3Rha2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGhyb3R0bGVUaW1lLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3IvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3RpbWVvdXRXaXRoLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9vcGVyYXRvci90aW1lb3V0V2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93Q291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL29wZXJhdG9yL3dpbmRvd0NvdW50LmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93VGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93VGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvd1RvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93VG9nZ2xlLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3ppcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvYWRkL29wZXJhdG9yL3ppcEFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvb3BlcmF0b3IvemlwQWxsLmpzIiwid2VicGFjazovLy8uL34vcnhqcy9PcGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc2hhcmVkL2Ryb3Bkb3duL2luZGV4LnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvZHJvcGRvd24vZHJvcGRvd24tdG9nZ2xlLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9uYXYudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3RlbXBsYXRlcy9hcHAuaHRtbCIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLnJvdXRlcy50cyIsIndlYnBhY2s6Ly8vLi9hcHAvYXV0aC5ndWFyZC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9kYXNoYm9hcmQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvc2hhcmVkL3Byb2plY3Qtc2VsZWN0LnRzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3Byb2plY3QvcHJvamVjdHMudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3BpcGVzL2luZGV4LnRzIiwid2VicGFjazovLy8uL2FwcC9waXBlcy9kYXRlLWZvcm1hdC5waXBlLnRzIiwid2VicGFjazovLy8uL2FwcC9waXBlcy90ZXh0LXRyYW5zZm9ybS5waXBlLnRzIiwid2VicGFjazovLy8uL2FwcC9waXBlcy92YWx1ZXMucGlwZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvcGlwZXMva2V5cy5waXBlLnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvcGFnaW5hdGlvbi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc2hhcmVkL3BhZ2luYXRpb24vcGFnaW5hdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9wcm9qZWN0L3Byb2plY3Qtcm93LnRzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3NoYXJlZC9jdXN0b21lci1jZWxsLnRzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3NoYXJlZC91c2VyLWNlbGwudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvcHJvamVjdC90ZW1wbGF0ZXMvcHJvamVjdC1yb3cuaHRtbCIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9wcm9qZWN0L3RlbXBsYXRlcy9wcm9qZWN0cy5odG1sIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3Byb2plY3QvcHJvamVjdC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc2hhcmVkL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc2hhcmVkL3N3aXRjaC1idXR0b24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NoYXJlZC9zd2l0Y2gtYnV0dG9uL3N3aXRjaC1idXR0b24udHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvc2hhcmVkL2N1c3RvbWVyLXNlbGVjdC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvdXNlci1zZWxlY3QudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvYXR0YWNobWVudHMudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvcHJvamVjdC90ZW1wbGF0ZXMvcHJvamVjdC5odG1sIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3Rhc2svdGFza3MudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvdGFzay90YXNrLXJvdy50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvdGFncy1jZWxsLnRzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3Rhc2svdGVtcGxhdGVzL3Rhc2stcm93Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvdGFzay90ZW1wbGF0ZXMvdGFza3MuaHRtbCIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy90YXNrL3Rhc2sudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NoYXJlZC90YWJzL2luZGV4LnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvdGFicy90YWJzLnRzIiwid2VicGFjazovLy8uL2FwcC9zaGFyZWQvdGFicy90YWIudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvc2hhcmVkL3Rhc2stdHlwZS1zZWxlY3QudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvc2hhcmVkL3RhZ3Mtc2VsZWN0LnRzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3Rhc2svdGFzay1yZXF1ZXN0cy50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy90YXNrL3Rhc2stcmVxdWVzdC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvcmVxdWVzdC10eXBlLXNlbGVjdC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9jb21tZW50L2NvbW1lbnRzLnRzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL2NvbW1lbnQvY29tbWVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy90YXNrL3RlbXBsYXRlcy90YXNrLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvdXNlci1wcm9maWxlLnRzIiwid2VicGFjazovLy8uL2FwcC90ZW1wbGF0ZXMvdXNlci1wcm9maWxlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvbG9naW4udHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3N0b3JlL2luZGV4LnRzIiwid2VicGFjazovLy8uL2FwcC9zdG9yZS9zdG9yZS50cyIsIndlYnBhY2s6Ly8vLi9+L0BuZ3J4L2NvcmUvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9+L25ncngtc3RvcmUtbG9nZ2VyL2Rpc3QvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzREFBMEIsQ0FBbUMsQ0FBQztBQUM5RCxrQ0FBd0MsQ0FBZSxDQUFDO0FBQ3hELGtDQUErQixHQUFlLENBQUM7QUFDL0Msb0NBQXVELENBQWlCLENBQUM7QUFFekUsMkNBQXVFLEdBQTZCLENBQUM7QUFHckcsMENBQW9DLEdBQXVCLENBQUM7QUFDNUQsc0NBQWtDLEdBQW1CLENBQUM7QUFDdEQsMkNBQTZCLEdBQWlCLENBQUM7QUFDL0Msd0NBQXFDLEdBQWMsQ0FBQztBQUNwRCwrQ0FBcUQsR0FBOEIsQ0FBQztBQUNwRixzQ0FBNkIsR0FBWSxDQUFDO0FBQzFDLG1DQUEwQixHQUFTLENBQUM7QUFFcEMscUNBQVMsQ0FBQyw0QkFBWSxFQUFFO0tBQ3BCLHFCQUFjO0tBQ2QsaUNBQW9CO0tBQ3BCLGNBQU8sQ0FBQyx5QkFBZ0IsRUFBRSxFQUFFLFFBQVEsRUFBRSw2QkFBb0IsRUFBRSxDQUFDO0tBQzdELGdDQUFnQjtLQUNoQixtQ0FBbUI7S0FDbkIsY0FBTyxDQUFDLCtCQUFlLEVBQUU7U0FDckIsVUFBVSxFQUFFLFVBQUMsR0FBcUIsSUFBSyxXQUFJLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxFQUE5QixDQUE4QjtTQUNyRSxJQUFJLEVBQUUsQ0FBQyxvQ0FBZ0IsQ0FBQztNQUMzQixDQUFDO0tBQ0Ysa0NBQW1CO0tBQ25CLDRCQUFpQjtLQUNqQix1QkFBWTtLQUNaLGlCQUFTO0VBQ1osQ0FBQyxDQUFDLEtBQUssQ0FBQyxhQUFHLElBQUksY0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQyxDQUFDO0FBR3BDO0tBQ0ksK0JBQW9CLGdCQUFrQztTQUFsQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0tBQUksQ0FBQztLQUVwRCw4Q0FBYyxHQUFyQixVQUFzQixJQUFZO1NBQzlCLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztLQUNyRCxDQUFDO0tBQ0wsNEJBQUM7QUFBRCxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDRCw4QkFBYyxHQUF3QixDQUFDO0FBQ3ZDLDhCQUFjLEdBQTBCLENBQUM7QUFDekMsOEJBQWMsR0FBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGL0Isa0NBQWlELENBQWUsQ0FBQztBQUVqRSwwQ0FBNkIsR0FBZ0IsQ0FBQztBQUc5QztLQUFBO1NBQ1ksWUFBTyxHQUFzQixJQUFJLG1CQUFZLEVBQUUsQ0FBQztLQStCNUQsQ0FBQztLQTdCVSx3Q0FBVSxHQUFqQjtTQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0tBQ3hCLENBQUM7S0FFRCxrQ0FBSSxHQUFKLFVBQUssT0FBTztTQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN4RCxDQUFDO0tBRUQscUNBQU8sR0FBUCxVQUFRLE9BQU87U0FDWCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDM0QsQ0FBQztLQUVELG1DQUFLLEdBQUwsVUFBTSxPQUFPO1NBQ1QsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQ3pELENBQUM7S0FFRCxxQ0FBTyxHQUFQLFVBQVEsT0FBTztTQUNYLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUMzRCxDQUFDO0tBRUQsaUNBQUcsR0FBSCxVQUFJLE9BQU87U0FDUCxJQUFJLElBQUksR0FBRyxJQUFJLDJCQUFZLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDM0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQ3BELE1BQU0sQ0FBQyxJQUFJLENBQUM7S0FDaEIsQ0FBQztLQUVELHVDQUFTLEdBQVQ7U0FDSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0tBQy9DLENBQUM7S0FoQ0w7U0FBQyxpQkFBVSxFQUFFOzs0QkFBQTtLQWlDYiwwQkFBQztBQUFELEVBQUM7QUFoQ1ksNEJBQW1CLHNCQWdDL0I7Ozs7Ozs7O0FDckNELGtDQUE2QixDQUFlLENBQUM7QUFFN0M7S0FTSSxzQkFBWSxJQUFZLEVBQUUsT0FBZTtTQVJqQyxZQUFPLEdBQXNCLElBQUksbUJBQVksRUFBRSxDQUFDO1NBSWhELFlBQU8sR0FBRyxLQUFLLENBQUM7U0FLcEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7U0FDakIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7S0FDM0IsQ0FBQztLQUVNLGlDQUFVLEdBQWpCO1NBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7S0FDeEIsQ0FBQztLQUVELDJCQUFJLEdBQUo7U0FDSSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztTQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDO0tBQ2hCLENBQUM7S0FFRCwyQkFBSSxHQUFKO1NBQ0ksSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDckIsTUFBTSxDQUFDLElBQUksQ0FBQztLQUNoQixDQUFDO0tBRUQsMEJBQUcsR0FBSCxVQUFJLE9BQU87U0FDUCxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDO2FBQ3RCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO2lCQUNwQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNoQyxDQUFDO2FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDO2lCQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUM3QixDQUFDO1NBQ0wsQ0FBQztTQUNELE1BQU0sQ0FBQyxJQUFJLENBQUM7S0FDaEIsQ0FBQztLQUVPLDhCQUFPLEdBQWY7U0FDSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7YUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQzlFLENBQUM7S0FDTCxDQUFDO0tBRUQsNkJBQU0sR0FBTixVQUFPLEtBQVU7U0FBakIsaUJBY0M7U0FiRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztTQUVuQixFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztTQUV4QixDQUFDO1NBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ25CLFVBQVUsQ0FBQztpQkFDUCxLQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUksRUFBRSxPQUFPLEVBQUUsS0FBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDOUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2QsQ0FBQztTQUFDLElBQUksQ0FBQyxDQUFDO2FBQ0osSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQzlFLENBQUM7U0FFRCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztLQUN4QixDQUFDO0tBQ0wsbUJBQUM7QUFBRCxFQUFDO0FBNURZLHFCQUFZLGVBNER4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5REQsa0NBQTBELENBQWUsQ0FBQztBQUUxRSxrREFBb0MsR0FBd0IsQ0FBQztBQWdCN0Q7S0FPSSwrQkFBb0IsYUFBa0M7U0FBbEMsa0JBQWEsR0FBYixhQUFhLENBQXFCO1NBSC9DLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztLQUdnQixDQUFDO0tBTDlCLHNCQUFJLDJDQUFRO2NBQVosY0FBaUIsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7OztRQUFBOztLQU90Rix3Q0FBUSxHQUFSO1NBQUEsaUJBYUM7U0FaRyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxFQUFFLENBQUMsU0FBUyxDQUFDLGNBQUk7YUFDMUQsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7aUJBQ25CLEtBQUssVUFBVTtxQkFDWCxLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztxQkFDeEIsS0FBSyxDQUFDO2lCQUNWLEtBQUssS0FBSztxQkFDTixLQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDNUIsS0FBSyxDQUFDO2lCQUNWO3FCQUNJLEtBQUssQ0FBQzthQUNkLENBQUM7U0FDTCxDQUFDLENBQUMsQ0FBQztLQUNQLENBQUM7S0FFRCwyQ0FBVyxHQUFYO1NBQ0ksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDaEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsWUFBRSxJQUFJLFNBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBN0IsQ0FBNkIsQ0FBQyxDQUFDO2FBQzVELElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDaEMsQ0FBQztLQUNMLENBQUM7S0FFRCx5Q0FBUyxHQUFULFVBQVUsTUFBb0I7U0FBOUIsaUJBR0M7U0FGRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsU0FBUyxDQUFDLGNBQUksSUFBSSxZQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUF4QixDQUF3QixDQUFDLENBQUM7S0FDcEUsQ0FBQztLQUVELDZDQUFhLEdBQWIsVUFBYyxJQUFJO1NBQ2QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7YUFDZixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDcEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDM0MsQ0FBQztLQUNMLENBQUM7S0F6Q0Q7U0FBQyxrQkFBVyxDQUFDLGlCQUFpQixDQUFDOzt3REFBQTtLQUMvQjtTQUFDLGtCQUFXLENBQUMsY0FBYyxDQUFDOzswREFBQTtLQWZoQztTQUFDLGdCQUFTLENBQUM7YUFDUCxRQUFRLEVBQUUsY0FBYzthQUN4QixRQUFRLEVBQUUsZ1ZBUVQ7VUFDSixDQUFDOzs4QkFBQTtLQTZDRiw0QkFBQztBQUFELEVBQUM7QUEzQ1ksOEJBQXFCLHdCQTJDakM7Ozs7Ozs7O0FDN0RELGdEQUFrQyxHQUFzQixDQUFDO0FBQWhELG9FQUFnRDtBQUN6RCw2Q0FBd0MsR0FBbUIsQ0FBQztBQUFuRCw2RUFBbUQ7QUFDNUQseUNBQTJCLEdBQWUsQ0FBQztBQUFsQywrQ0FBa0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRjNDLGtDQUEyQixDQUFlLENBQUM7QUFFM0MsS0FBTSxNQUFNLEdBQUcsbUJBQU8sQ0FBQyxHQUFRLENBQUMsQ0FBQztBQUNqQyxLQUFNLFVBQVUsR0FBRyxtQkFBTyxDQUFDLEdBQWEsQ0FBQyxDQUFDO0FBRzFDO0tBQUE7S0FTQSxDQUFDO0tBUEcsc0NBQVUsR0FBVixVQUFXLElBQUk7U0FDWCxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0tBQzNDLENBQUM7S0FFRCxrQ0FBTSxHQUFOLFVBQU8sUUFBUTtTQUNYLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDNUIsQ0FBQztLQVRMO1NBQUMsaUJBQVUsRUFBRTs7MEJBQUE7S0FVYix3QkFBQztBQUFELEVBQUM7QUFUWSwwQkFBaUIsb0JBUzdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZELGtDQUErRCxDQUFlLENBQUM7QUFDL0UsZ0RBQWtDLEdBQXNCLENBQUM7QUFrQnpEO0tBY0ksaUNBQW9CLEdBQXNCO1NBQXRCLFFBQUcsR0FBSCxHQUFHLENBQW1CO1NBYmpDLGFBQVEsR0FBWSxJQUFJLENBQUM7U0FDekIsYUFBUSxHQUFXLEVBQUUsQ0FBQztTQUN0QixVQUFLLEdBQVcsRUFBRSxDQUFDO1NBRW5CLGtCQUFhLEdBQVcsR0FBRyxDQUFDO1NBRTNCLFdBQU0sR0FBRyxJQUFJLG1CQUFZLEVBQU8sQ0FBQztTQUNqQyxVQUFLLEdBQUcsSUFBSSxtQkFBWSxFQUFPLENBQUM7U0FDaEMsU0FBSSxHQUFHLElBQUksbUJBQVksRUFBTyxDQUFDO0tBS0ssQ0FBQztLQUUvQywwQ0FBUSxHQUFSO1NBQ0ksSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDL0MsQ0FBQztLQUVELDZDQUFXLEdBQVgsVUFBWSxHQUFHO1NBQWYsaUJBS0M7U0FKRyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3RCLElBQUksQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFDO2FBQ2pCLEtBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3pELENBQUMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDM0IsQ0FBQztLQXhCRDtTQUFDLFlBQUssRUFBRTs7OERBQUE7S0FDUjtTQUFDLFlBQUssRUFBRTs7OERBQUE7S0FDUjtTQUFDLFlBQUssRUFBRTs7MkRBQUE7S0FDUjtTQUFDLFlBQUssRUFBRTs7aUVBQUE7S0FDUjtTQUFDLFlBQUssRUFBRTs7bUVBQUE7S0FFUjtTQUFDLGFBQU0sRUFBRTs7NERBQUE7S0FDVDtTQUFDLGFBQU0sRUFBRTs7MkRBQUE7S0FDVDtTQUFDLGFBQU0sRUFBRTs7MERBQUE7S0F6QmI7U0FBQyxnQkFBUyxDQUFDO2FBQ1AsUUFBUSxFQUFFLGlCQUFpQjthQUMzQixRQUFRLEVBQUUsd2RBVVQ7YUFDRCxTQUFTLEVBQUUsQ0FBQyxzQ0FBaUIsQ0FBQztVQUNqQyxDQUFDOztnQ0FBQTtLQTRCRiw4QkFBQztBQUFELEVBQUM7QUExQlksZ0NBQXVCLDBCQTBCbkM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NELGtDQUFxQixDQUFlLENBQUM7QUFDckMsZ0RBQWtDLEdBQXNCLENBQUM7QUFHekQ7S0FDSSxvQkFBb0IsR0FBc0I7U0FBdEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7S0FBSSxDQUFDO0tBRS9DLDhCQUFTLEdBQVQsVUFBVSxJQUFZO1NBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNqQyxDQUFDO0tBTkw7U0FBQyxXQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7O21CQUFBO0tBT3pCLGlCQUFDO0FBQUQsRUFBQztBQU5ZLG1CQUFVLGFBTXRCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZELGtDQUF3RSxDQUFlLENBQUM7QUFDeEYsb0NBQW1DLEdBQWlCLENBQUM7QUFDckQsbUNBQXNCLEdBQWEsQ0FBQztBQUNwQywyQ0FBZ0QsR0FBNkIsQ0FBQztBQUU5RSxzQ0FBd0YsR0FBWSxDQUFDO0FBRXJHLDBDQUEyRCxHQUF1QixDQUFDO0FBQ25GLHNDQUFvQyxHQUFtQixDQUFDO0FBQ3hELGlDQUE2QixHQUFrQixDQUFDO0FBQ2hELGtDQUFxQixHQUFlLENBQUM7QUFVckM7S0FnQkksc0JBQ1ksS0FBaUIsRUFDakIsVUFBc0IsRUFDdEIsZ0JBQWtDLEVBQ2xDLFlBQTBCLEVBQzNCLFNBQTJCO1NBckIxQyxpQkFzR0M7U0FyRmUsVUFBSyxHQUFMLEtBQUssQ0FBWTtTQUNqQixlQUFVLEdBQVYsVUFBVSxDQUFZO1NBQ3RCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7U0FDbEMsaUJBQVksR0FBWixZQUFZLENBQWM7U0FDM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7U0FuQnRDLFlBQU8sR0FBWSxLQUFLLENBQUM7U0FHekIsaUJBQVksR0FBVyxVQUFVLENBQUM7U0FJbEMsaUJBQVksR0FBVywyQkFBMkIsQ0FBQztTQWMvQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBQyxJQUFrQjthQUNyRCxLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7U0FDdkMsQ0FBQyxDQUFDLENBQUM7U0FFSCxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBRTFDLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxFQUFFLENBQUMsU0FBUyxDQUFDLGdCQUFNO2FBQzdDLEtBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzVCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2FBQ3BCLEtBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztTQUNwQyxDQUFDLENBQUMsQ0FBQztLQUNQLENBQUM7S0F2QmlELDZCQUFNLEdBQU4sVUFBTyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7O0tBQy9ELHNCQUFJLGdDQUFNO2NBQVYsY0FBZSxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7OztRQUFBOztLQUNsQyxzQkFBSSwwQ0FBZ0I7Y0FBcEIsY0FBeUIsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDOzs7UUFBQTs7S0FDMUQsc0JBQUksc0NBQVk7Y0FBaEIsY0FBcUIsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDOzs7UUFBQTs7S0FzQmxGLCtCQUFRLEdBQVI7U0FBQSxpQkF5QkM7U0F4QkcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxDQUFDO1NBRXRDLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxTQUFTLENBQUMsZ0JBQU07YUFDbkQsS0FBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDaEMsQ0FBQyxDQUFDLENBQUM7U0FFSCxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxnQkFBTTthQUMzQyxLQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoQyxDQUFDLENBQUMsQ0FBQztTQUVILElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1NBQzFCLElBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDO1NBQzVCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxXQUFJLEVBQUUsQ0FBQztTQUM3QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUd0QyxJQUFJLFFBQVEsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoRCxRQUFRLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBRXhELElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBRXBDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBRXpCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxlQUFLLElBQUksWUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLEVBQXpCLENBQXlCLENBQUMsQ0FBQztLQUM5RSxDQUFDO0tBRUQsa0NBQVcsR0FBWDtTQUNJLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUN2QyxDQUFDO0tBRUQsZ0NBQVMsR0FBVDtTQUNJLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO0tBQy9DLENBQUM7S0FFRCw4QkFBTyxHQUFQLFVBQVEsS0FBSztTQUNULEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUN2QixJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztTQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztLQUM5QixDQUFDO0tBRUQsbUNBQVksR0FBWjtTQUNJLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO0tBQzNDLENBQUM7S0FFRCw2QkFBTSxHQUFOLFVBQU8sS0FBSztTQUNSLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUV2QixNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUM7S0FDcEMsQ0FBQztLQUVELDZCQUFNLEdBQU47U0FDSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0tBQzFCLENBQUM7S0FFRCxxQ0FBYyxHQUFkLFVBQWUsS0FBSztTQUNoQixLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7S0FDM0IsQ0FBQztLQUVELCtCQUFRLEdBQVI7U0FDSSxNQUFNLENBQUMsZ0VBQWdFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUN0RyxDQUFDO0tBRUQsK0JBQVEsR0FBUixVQUFTLE1BQU07U0FDWCxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxVQUFVLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUN2RSxDQUFDO0tBMUZEO1NBQUMsbUJBQVksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQzs7OzsrQ0FBQTtLQUNqRDtTQUFDLGtCQUFXLENBQUMsYUFBYSxDQUFDOzsrQ0FBQTtLQUMzQjtTQUFDLGtCQUFXLENBQUMsdUJBQXVCLENBQUM7O3lEQUFBO0tBQ3JDO1NBQUMsa0JBQVcsQ0FBQyxtQkFBbUIsQ0FBQzs7cURBQUE7S0F0QnJDO1NBQUMsZ0JBQVMsQ0FBQzthQUNQLFFBQVEsRUFBRSxLQUFLO2FBQ2YsUUFBUSxFQUFFLG1CQUFPLENBQUMsR0FBc0IsQ0FBQzthQUN6QyxVQUFVLEVBQUUsQ0FBQywwQkFBaUIsRUFBRSxrQkFBWSxFQUFFLG9DQUFxQixFQUFFLDhCQUFtQixDQUFDO2FBQ3pGLFNBQVMsRUFBRSxDQUFDLGtDQUFtQixDQUFDO2FBQ2hDLEtBQUssRUFBRSxDQUFDLDZCQUFhLENBQUM7VUFDekIsQ0FBQzs7cUJBQUE7S0F3R0YsbUJBQUM7QUFBRCxFQUFDO0FBdEdZLHFCQUFZLGVBc0d4Qjs7Ozs7OztBQzFIRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLDJrRTs7Ozs7O0FDN0IzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMLDREQUEyRCwrQkFBK0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRSxpRkFBaUY7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsNENBQTJDLHVoTTs7Ozs7O0FDcEYzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNELHdFQUF3RTtBQUM5SDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCx5RUFBeUU7QUFDaEk7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixnQ0FBZ0MsRUFBRTtBQUM1RDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsMkJBQTBCLCtDQUErQyxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSwyQkFBMEIsMEJBQTBCLEVBQUU7QUFDdEQ7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0Qyx5Q0FBeUM7QUFDckY7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0EscURBQW9ELDBDQUEwQztBQUM5RixpREFBZ0Qsc0NBQXNDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9ELHFEQUFxRCxFQUFFO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsdUNBQXNDLHdCQUF3QixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDZEQUE0RCxzRUFBc0UsRUFBRTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLHVDQUFzQyx3QkFBd0IsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSx1Q0FBc0Msd0JBQXdCLEVBQUU7QUFDaEU7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCw2REFBNEQsbUVBQW1FLEVBQUU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSwyREFBMkQ7QUFDeEUsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLCtDQUErQyxFQUFFO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsK3c2Qzs7Ozs7O0FDNVozQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxVQUFTO0FBQ1QsVUFBUztBQUNUO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxVQUFTO0FBQ1QsVUFBUztBQUNUO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLFlBQVcsV0FBVztBQUN0QjtBQUNBLFlBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxVQUFTO0FBQ1QsVUFBUztBQUNULFVBQVM7QUFDVCxVQUFTO0FBQ1QsVUFBUztBQUNUO0FBQ0EsWUFBVywrQ0FBK0M7QUFDMUQ7QUFDQTtBQUNBLFlBQVcsb0ZBQW9GO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLElBQUk7QUFDZixhQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxrQzs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsMENBQTBDLEVBQUU7QUFDN0U7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLGNBQWE7QUFDYixjQUFhO0FBQ2IsY0FBYTtBQUNiO0FBQ0EsZ0JBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBLGdCQUFlLElBQUk7QUFDbkI7QUFDQSxnQkFBZSxVQUFVO0FBQ3pCO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsMkM7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsU0FBUztBQUN0Qyw4QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW1FLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsOEJBQTZCLFNBQVM7QUFDdEMsOEJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRSxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDOzs7Ozs7QUNoTUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTJCLDBDQUEwQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLGdEOzs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWdGLHFFQUFxRTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsZ0VBQStELHFCQUFxQixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsa0RBQWtELEVBQUU7QUFDOUg7QUFDQTtBQUNBLHdDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLDZEQUE2RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DLHVDQUFzQyxFQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRCx3QkFBd0IsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLDRDQUEyQyx1dXBCOzs7Ozs7QUM5TDNDO0FBQ0E7QUFDQSw0Q0FBMkMsdWU7Ozs7OztBQ0YzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsb0VBQW9FO0FBQ2xIO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdELHlCQUF5QixFQUFFO0FBQ25GO0FBQ0Esa0RBQWlELDhDQUE4QztBQUMvRjtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0QsNkNBQTZDO0FBQ3JHO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLG1pYjs7Ozs7O0FDaEozQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0Esc0RBQXFELHlCQUF5QixFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxXQUFXLDhCQUE4QixFQUFFO0FBQ3RGO0FBQ0E7QUFDQSxnREFBK0MsbUNBQW1DLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlELHVDQUF1QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFO0FBQ2xFLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QsNENBQTJDLHV6d0I7Ozs7OztBQ3RRM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakMsd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsZUFBZSxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLG04Sjs7Ozs7O0FDOUQzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQywyaEY7Ozs7OztBQ25CM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxzQkFBc0IsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQStELDJEQUEyRCxFQUFFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQywreEs7Ozs7OztBQ3pDM0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLDRDOzs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsaUNBQWlDO0FBQ25GO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtHQUFpRztBQUNqRywrREFBOEQ7QUFDOUQsb0VBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxxQkFBcUIsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsa0NBQWtDO0FBQzVGO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSwyQ0FBMEMsc0RBQXNEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLG11WTs7Ozs7O0FDcEczQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIseUJBQXlCLEVBQUU7QUFDckQ7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsZ0JBQWdCLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJELGdCQUFnQixFQUFFO0FBQzdFLHdDQUF1QyxpQkFBaUIsRUFBRTtBQUMxRDtBQUNBLGlEQUFnRCxzREFBc0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUMxSCxnREFBK0MseUNBQXlDO0FBQ3hGO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsMENBQTBDLEVBQUU7QUFDbkc7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQSw0Q0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsdUNBQXVDO0FBQ3RGO0FBQ0EsRUFBQztBQUNEO0FBQ0EsNENBQTJDLG03Tjs7Ozs7O0FDcEYzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxtREFBa0Qsd0JBQXdCLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxtK3VCOzs7Ozs7QUMxTjNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esb0VBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxnRUFBK0QscUJBQXFCLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBMkYsbURBQW1ELEVBQUU7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixnREFBZ0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFLHFCQUFxQixFQUFFO0FBQ3pGLG1EQUFrRCxxQkFBcUIsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSw0Q0FBMkMsdTNoQjs7Ozs7O0FDOUkzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZ0UsY0FBYyxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxpREFBZ0QsNkNBQTZDLEVBQUU7QUFDL0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxVQUFTLEVBQUUsRUFBRTtBQUNiO0FBQ0E7QUFDQSw0Q0FBMkMsbXJHOzs7Ozs7QUN4QjNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBd0UsOEJBQThCO0FBQ3RHO0FBQ0EsRUFBQztBQUNEO0FBQ0EsNENBQTJDLCswQjs7Ozs7O0FDVDNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELHVCQUF1QixFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsa0VBQWlFLGVBQWU7QUFDaEYsMkRBQTBELGlDQUFpQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCw0Q0FBMkMsaUZBQWlGLEVBQUU7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSw0Q0FBMkMsMnFLOzs7Ozs7QUM3RTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQix5QkFBeUIsRUFBRTtBQUNyRDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsNENBQTJDLCtuSTs7Ozs7O0FDaEUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLFdBQVc7QUFDckM7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLG1wRDs7Ozs7O0FDWDNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxvQkFBb0IsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRCxtREFBbUQsRUFBRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCx5QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsb0RBQW9ELEdBQUcsbURBQW1EO0FBQ25ILDZCQUE0Qiw4RUFBOEU7QUFDMUcsVUFBUywyRkFBMkY7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTLG1FQUFtRSwyQkFBMkIsRUFBRSwyQkFBMkI7QUFDcEksVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyx1NU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0QzQyx5Q0FBMkIsR0FBZSxDQUFDO0FBUWxDLG1CQUFVO0FBUG5CLCtDQUFpQyxHQUFxQixDQUFDO0FBUTlDLHlCQUFnQjtBQVB6Qiw2Q0FBK0IsR0FBbUIsQ0FBQztBQVExQyx1QkFBYztBQVB2QiwwQ0FBNEIsR0FBZ0IsQ0FBQztBQVFwQyxvQkFBVztBQVBwQiwrQ0FBaUMsR0FBcUIsQ0FBQztBQVE5Qyx5QkFBZ0I7QUFQekIsMkNBQTZCLEdBQWlCLENBQUM7QUFRdEMscUJBQVk7QUFQckIsNENBQThCLEdBQWtCLENBQUM7QUFReEMsc0JBQWE7QUFFVCxxQkFBWSxHQUFHO0tBQ3hCLHdCQUFVO0tBQ1Ysb0NBQWdCO0tBQ2hCLGdDQUFjO0tBQ2QsMEJBQVc7S0FDWCxvQ0FBZ0I7S0FDaEIsNEJBQVk7S0FDWiw4QkFBYTtFQUNoQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCRixrQ0FBMkIsQ0FBZSxDQUFDO0FBQzNDLGtDQUE4QixHQUFlLENBQUM7QUFHOUMsNENBQW1DLEdBQTRCLENBQUM7QUFFaEUsbUNBQXFDLEdBQWdCLENBQUM7QUFFdEQsS0FBTSxPQUFPLEdBQUcsSUFBSSxjQUFPLENBQUM7S0FDeEIsY0FBYyxFQUFFLGtEQUFrRDtLQUNsRSxRQUFRLEVBQUUsa0JBQWtCO0VBQy9CLENBQUMsQ0FBQztBQUdIO0tBSUksb0JBQ1ksSUFBVTtTQUFWLFNBQUksR0FBSixJQUFJLENBQU07U0FIdEIsYUFBUSxHQUFZLEtBQUssQ0FBQztLQUl0QixDQUFDO0tBRUwsbUNBQWMsR0FBZDtTQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxrQkFBUTthQUN2RSxJQUFJLEdBQUcsR0FBRyw0QkFBb0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDeEQsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO2FBQ2xCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2lCQUNsQixRQUFRLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVE7YUFDOUIsQ0FBQzthQUNELE1BQU0sQ0FBQztpQkFDSCxJQUFJLEVBQUUsbUNBQWtCO2lCQUN4QixPQUFPLEVBQUU7cUJBQ0wsV0FBVyxFQUFFLEdBQUcsQ0FBQyxRQUFRO3FCQUN6QixTQUFTLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYTtxQkFDN0MsUUFBUSxFQUFFLFFBQVE7a0JBQ3JCO2NBQ0o7U0FDTCxDQUFDLENBQUMsQ0FBQztLQUNQLENBQUM7S0FFRCxzQ0FBaUIsR0FBakIsVUFBa0IsSUFBVTtLQUU1QixDQUFDO0tBRUQsMkJBQU0sR0FBTjtTQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqQyxDQUFDO0tBakNMO1NBQUMsaUJBQVUsRUFBRTs7bUJBQUE7S0FrQ2IsaUJBQUM7QUFBRCxFQUFDO0FBakNZLG1CQUFVLGFBaUN0Qjs7Ozs7Ozs7QUM3Q1ksMkJBQWtCLEdBQUcsb0JBQW9CLENBQUM7QUFNdEQsRUFBQztBQUVGLEtBQU0sWUFBWSxHQUFpQjtLQUMvQixXQUFXLEVBQUUsSUFBSTtLQUNqQixTQUFTLEVBQUUsRUFBRTtLQUNiLFFBQVEsRUFBRSxFQUFFO0VBQ2YsQ0FBQztBQUVXLHNCQUFhLEdBQUcsVUFBQyxLQUFvQixFQUFFLEVBQWU7S0FBckMscUJBQW9CLEdBQXBCLG9CQUFvQjtTQUFHLGNBQUksRUFBRSxvQkFBTztLQUM5RCxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ1gsS0FBSywwQkFBa0I7YUFDbkIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRTtpQkFDNUIsV0FBVyxFQUFFLE9BQU8sQ0FBQyxXQUFXO2lCQUNoQyxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7aUJBQzVCLFFBQVEsRUFBRSxPQUFPLENBQUMsUUFBUTtjQUM3QixDQUFDLENBQUM7U0FDUDthQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUM7S0FDckIsQ0FBQztBQUNMLEVBQUMsQ0FBQzs7Ozs7Ozs7QUMzQkYsa0NBQTBDLEdBQWUsQ0FBQztBQUUxRCxnQ0FBc0MsT0FBTztLQUN6QyxJQUFJLE1BQU0sR0FBb0IsSUFBSSxzQkFBZSxFQUFFLENBQUM7S0FDcEQsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztTQUNwQixNQUFNLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxFQUFFLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEUsQ0FBQztLQUNELE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDbEIsRUFBQztBQU5lLDhCQUFxQix3QkFNcEM7QUFFRCx1QkFBNkIsR0FBRztLQUM1QixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7S0FDaEIsR0FBRyxDQUFDLENBQUMsSUFBSSxRQUFRLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztTQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hGLENBQUM7S0FDRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1QixFQUFDO0FBTmUscUJBQVksZUFNM0I7QUFFRCwrQkFBcUMsT0FBWTtLQUM3QyxJQUFJLE1BQU0sR0FBUSxFQUFFLENBQUM7S0FFckIsR0FBRyxDQUFDLENBQVksVUFBTyxFQUFQLG1CQUFPLEVBQVAscUJBQU8sRUFBUCxJQUFPLENBQUM7U0FBbkIsSUFBSSxHQUFHO1NBQ1IsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDWCxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUMzQixDQUFDO1NBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUMxQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUMzQixDQUFDO1NBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDL0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDO1NBQ2pDLENBQUM7U0FBQyxJQUFJLENBQUMsQ0FBQzthQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDckIsQ0FBQztNQUNKO0tBRUQsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNsQixFQUFDO0FBaEJlLDZCQUFvQix1QkFnQm5DO0FBRUQscUNBQTJDLElBQVM7S0FDaEQsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0tBQ2hCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDUCxHQUFHLENBQUMsQ0FBVyxVQUFJLEVBQUosYUFBSSxFQUFKLGtCQUFJLEVBQUosSUFBSSxDQUFDO2FBQWYsSUFBSSxFQUFFO2FBQ1AsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7VUFDdEI7S0FDTCxDQUFDO0tBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNsQixFQUFDO0FBUmUsbUNBQTBCLDZCQVF6QztBQUVELGdDQUFzQyxRQUFrQjtLQUNwRCxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDM0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFO1NBQ3ZCLEVBQUUsRUFBRSxJQUFJLENBQUMsSUFBSSxLQUFLLGdCQUFnQjtTQUNsQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTztNQUM3RCxDQUFDLENBQUM7QUFDUCxFQUFDO0FBTmUsOEJBQXFCLHdCQU1wQztBQUVELHVCQUE2QixJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUk7S0FDMUMsSUFBSSxPQUFPLENBQUM7S0FFWixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ1AsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztTQUN0QixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQzVELE9BQU8sR0FBRyxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ2hELENBQUM7S0FBQyxJQUFJLENBQUMsQ0FBQztTQUNKLE9BQU8sR0FBRyxFQUFFLENBQUM7S0FDakIsQ0FBQztLQUNELFFBQVEsQ0FBQyxNQUFNLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxHQUFHLE9BQU8sR0FBRyxVQUFVLENBQUM7QUFDeEcsRUFBQztBQVhlLHFCQUFZLGVBVzNCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFRCxrQ0FBMkIsQ0FBZSxDQUFDO0FBQzNDLGtDQUE4QixHQUFlLENBQUM7QUFHOUM7S0FJSSwwQkFDWSxJQUFVO1NBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtTQUhkLGlCQUFZLEdBQVEsSUFBSSxDQUFDO0tBSTdCLENBQUM7S0FFTCw0Q0FBaUIsR0FBakI7U0FBQSxpQkFVQztTQVRHLElBQUksT0FBTyxHQUFHLElBQUksY0FBTyxDQUFDO2FBQ3RCLGNBQWMsRUFBRSxrREFBa0Q7YUFDbEUsUUFBUSxFQUFFLGtCQUFrQjtVQUMvQixDQUFDLENBQUM7U0FFSCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsa0JBQVE7YUFDM0UsS0FBSSxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDO2FBQzdDLE1BQU0sQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDO1NBQzdCLENBQUMsQ0FBQyxDQUFDO0tBQ1AsQ0FBQztLQUVELDBDQUFlLEdBQWY7U0FDSSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztLQUM3QixDQUFDO0tBdkJMO1NBQUMsaUJBQVUsRUFBRTs7eUJBQUE7S0F3QmIsdUJBQUM7QUFBRCxFQUFDO0FBdkJZLHlCQUFnQixtQkF1QjVCOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNCRCxrQ0FBMkIsQ0FBZSxDQUFDO0FBQzNDLGtDQUF3QyxHQUFlLENBQUM7QUFDeEQsd0NBQTJCLEVBQWlCLENBQUM7QUFDN0MsMkNBQWlDLEdBQTZCLENBQUM7QUFFL0QsOENBSU8sR0FBOEIsQ0FBQztBQUN0QyxvQ0FBNkUsR0FBVyxDQUFDO0FBQ3pGLG1DQUFpRyxHQUFnQixDQUFDO0FBRWxILEtBQU0sT0FBTyxHQUFHLElBQUksY0FBTyxDQUFDO0tBQ3hCLGNBQWMsRUFBRSxrREFBa0Q7S0FDbEUsUUFBUSxFQUFFLGtCQUFrQjtFQUMvQixDQUFDLENBQUM7QUFHSDtLQUVJLHdCQUNZLElBQVUsRUFDVixTQUEyQjtTQUQzQixTQUFJLEdBQUosSUFBSSxDQUFNO1NBQ1YsY0FBUyxHQUFULFNBQVMsQ0FBa0I7S0FDbkMsQ0FBQztLQUVMLDhDQUFxQixHQUFyQjtTQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBQyxJQUFJO2FBQ25FLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFO2FBQ2hELEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRTthQUN6QyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUU7VUFDMUMsRUFKc0UsQ0FJdEUsQ0FBQyxDQUFDO0tBQ1AsQ0FBQztLQUVELHNDQUFhLEdBQWIsVUFBYyxXQUFnQjtTQUFoQiwyQkFBZ0IsR0FBaEIsZ0JBQWdCO1NBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRTthQUN0QyxPQUFPLEVBQUUsT0FBTzthQUNoQixNQUFNLEVBQUUsNkJBQXFCLENBQUMsV0FBVyxDQUFDO1VBQzdDLENBQUM7Y0FDRyxHQUFHLENBQUMsa0JBQVEsSUFBSSxlQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUExQixDQUEwQixDQUFDO2NBQzNDLEdBQUcsQ0FBQyxjQUFJO2FBQ0wsTUFBTSxDQUFDO2lCQUNILElBQUksRUFBRSxpQ0FBYztpQkFDcEIsT0FBTyxFQUFFO3FCQUNMLFFBQVEsRUFBYSxJQUFJLENBQUMsSUFBSTtxQkFDOUIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO3FCQUNmLE9BQU8sRUFBRSxJQUFJO2tCQUNoQjtjQUNKLENBQUM7U0FDTixDQUFDLENBQUMsQ0FBQztLQUNYLENBQUM7S0FFRCx5Q0FBZ0IsR0FBaEIsVUFBaUIsU0FBaUI7U0FDOUIsRUFBRSxDQUFDLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDdEIsTUFBTSxDQUFDLHVCQUFVLENBQUMsRUFBRSxDQUFDO2lCQUNqQixJQUFJLEVBQUUsZ0NBQWE7aUJBQ25CLE9BQU8sRUFBRTtxQkFDTCxPQUFPLEVBQUUsSUFBSSxnQkFBTyxFQUFFO2tCQUN6QjtjQUNKLENBQUMsQ0FBQztTQUNQLENBQUM7U0FFRCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsOEJBQThCLEdBQUcsU0FBUyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQ2pGLEdBQUcsQ0FBQyxrQkFBUTthQUNULElBQUksSUFBSSxHQUFHLDRCQUFvQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUN6RCxJQUFJLE9BQU8sR0FBWSxJQUFJLENBQUMsT0FBTyxDQUFDO2FBQ3BDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2lCQUNaLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQzthQUM3QixDQUFDO2FBQ0QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7aUJBQ2xCLE9BQU8sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7YUFDL0MsQ0FBQzthQUNELE1BQU0sQ0FBQztpQkFDSCxJQUFJLEVBQUUsZ0NBQWE7aUJBQ25CLE9BQU8sRUFBRTtxQkFDTCxPQUFPLEVBQVcsT0FBTztrQkFDNUI7Y0FDSixDQUFDO1NBQ04sQ0FBQyxDQUFDLENBQUM7S0FDWCxDQUFDO0tBRUQsb0NBQVcsR0FBWCxVQUFZLE9BQWdCO1NBQ3hCLElBQUksR0FBRyxHQUFHLDhCQUE4QixHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7U0FDdEQsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxvQkFBWSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQ2xFLEdBQUcsQ0FBQyxrQkFBUSxJQUFJLG9DQUFxQixDQUFDLFFBQVEsQ0FBQyxFQUEvQixDQUErQixDQUFDO2NBQ2hELEtBQUssQ0FBQyxlQUFLLElBQUksOEJBQVUsQ0FBQyxLQUFLLENBQUMsNkJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBOUMsQ0FBOEMsQ0FBQyxDQUFDO0tBQ3hFLENBQUM7S0FFRCxzQ0FBYSxHQUFiLFVBQWMsUUFBbUI7U0FDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLCtCQUErQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsWUFBRSxJQUFJLFNBQUUsQ0FBQyxFQUFFLEVBQUwsQ0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDbkcsQ0FBQztLQUVELGdEQUF1QixHQUF2QixVQUF3QixPQUFnQixFQUFFLFVBQXNCO1NBQzVELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyw4QkFBOEIsR0FBRyxPQUFPLENBQUMsRUFBRSxHQUFHLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUM1RyxDQUFDO0tBNUVMO1NBQUMsaUJBQVUsRUFBRTs7dUJBQUE7S0E2RWIscUJBQUM7QUFBRCxFQUFDO0FBNUVZLHVCQUFjLGlCQTRFMUI7Ozs7Ozs7O0FDN0ZZLHVCQUFjLEdBQUcsZ0JBQWdCLENBQUM7QUFDbEMsc0JBQWEsR0FBRyxlQUFlLENBQUM7QUFDaEMsb0JBQVcsR0FBRyxhQUFhLENBQUM7QUFDNUIsdUJBQWMsR0FBRyxnQkFBZ0IsQ0FBQztBQUNsQyx1QkFBYyxHQUFHLGdCQUFnQixDQUFDO0FBTzlDLEVBQUM7QUFFRixLQUFNLFlBQVksR0FBbUI7S0FDakMsSUFBSSxFQUFFLEVBQUU7S0FDUixRQUFRLEVBQUUsRUFBRTtLQUNaLE9BQU8sRUFBRSxTQUFTO0tBQ2xCLE9BQU8sRUFBRSxLQUFLO0VBQ2pCLENBQUM7QUFFVyx3QkFBZSxHQUFHLFVBQUMsS0FBb0IsRUFBRSxFQUFlO0tBQXJDLHFCQUFvQixHQUFwQixvQkFBb0I7U0FBRyxjQUFJLEVBQUUsb0JBQU87S0FDaEUsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNYLEtBQUssc0JBQWM7YUFDZixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFO2lCQUM1QixRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVE7aUJBQzFCLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSTtjQUNyQixDQUFDLENBQUM7U0FDUCxLQUFLLHFCQUFhO2FBQ2QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRTtpQkFDNUIsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO2NBQzNCLENBQUMsQ0FBQztTQUNQLEtBQUssbUJBQVc7YUFDWixNQUFNLENBQUMsS0FBSyxDQUFDO1NBQ2pCLEtBQUssc0JBQWM7YUFDZixNQUFNLENBQUMsS0FBSyxDQUFDO1NBQ2pCLEtBQUssc0JBQWM7YUFDZixNQUFNLENBQUMsS0FBSyxDQUFDO1NBQ2pCO2FBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQztLQUNyQixDQUFDO0FBQ0wsRUFBQyxDQUFDOzs7Ozs7OztBQzFDRixrQ0FBcUIsR0FBUSxDQUFDO0FBQXJCLDRCQUFxQjtBQUM5QiwwQ0FBNkIsR0FBZ0IsQ0FBQztBQUFyQyxvREFBcUM7QUFDOUMsd0NBQTJCLEdBQWMsQ0FBQztBQUFqQyw4Q0FBaUM7QUFDMUMscUNBQXdCLEdBQVcsQ0FBQztBQUEzQixxQ0FBMkI7QUFDcEMsa0NBQXFCLEdBQVEsQ0FBQztBQUFyQiw0QkFBcUI7QUFDOUIsaUNBQW9CLEdBQU8sQ0FBQztBQUFuQix5QkFBbUI7QUFDNUIsdUNBQXlCLEdBQWEsQ0FBQztBQUE5Qix5Q0FBOEI7QUFDdkMscUNBQXdCLEdBQVcsQ0FBQztBQUEzQixxQ0FBMkI7QUFDcEMscUNBQXdCLEdBQVcsQ0FBQztBQUEzQixxQ0FBMkI7QUFDcEMsMENBQTRCLEdBQWdCLENBQUM7QUFBcEMsa0RBQW9DOzs7Ozs7OztBQ1Q3QztLQUFBO1NBQ0ksT0FBRSxHQUFXLEVBQUUsQ0FBQztTQUdoQixhQUFRLEdBQVcsWUFBWSxDQUFDO0tBS3BDLENBQUM7S0FBRCxXQUFDO0FBQUQsRUFBQztBQVRZLGFBQUksT0FTaEI7Ozs7Ozs7O0FDVEQ7S0FBQTtTQUNJLE9BQUUsR0FBVyxFQUFFLENBQUM7S0FJcEIsQ0FBQztLQUFELG1CQUFDO0FBQUQsRUFBQztBQUxZLHFCQUFZLGVBS3hCOzs7Ozs7OztBQ0xEO0tBQUE7U0FDSSxPQUFFLEdBQVcsRUFBRSxDQUFDO0tBTXBCLENBQUM7S0FBRCxpQkFBQztBQUFELEVBQUM7QUFQWSxtQkFBVSxhQU90Qjs7Ozs7Ozs7QUNMRDtLQUFBO1NBQ0ksT0FBRSxHQUFXLEVBQUUsQ0FBQztTQUloQixTQUFJLEdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUcvQixXQUFNLEdBQVcsT0FBTyxDQUFDO0tBWTdCLENBQUM7S0FBRCxjQUFDO0FBQUQsRUFBQztBQXBCWSxnQkFBTyxVQW9CbkI7Ozs7Ozs7O0FDbkJEO0tBQUE7U0FDSSxPQUFFLEdBQVcsRUFBRSxDQUFDO1NBSWhCLFNBQUksR0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBTS9CLFdBQU0sR0FBVyxPQUFPLENBQUM7U0FDekIsYUFBUSxHQUFXLFFBQVEsQ0FBQztLQVloQyxDQUFDO0tBQUQsV0FBQztBQUFELEVBQUM7QUF4QlksYUFBSSxPQXdCaEI7Ozs7Ozs7O0FDM0JEO0tBQUE7U0FDSSxPQUFFLEdBQVcsRUFBRSxDQUFDO0tBSXBCLENBQUM7S0FBRCxVQUFDO0FBQUQsRUFBQztBQUxZLFlBQUcsTUFLZjs7Ozs7Ozs7QUNMRDtLQUFBO1NBQ0ksT0FBRSxHQUFXLEVBQUUsQ0FBQztLQUdwQixDQUFDO0tBQUQsZUFBQztBQUFELEVBQUM7QUFKWSxpQkFBUSxXQUlwQjs7Ozs7Ozs7QUNGRDtLQUFBO1NBQ0ksT0FBRSxHQUFXLEVBQUUsQ0FBQztTQUNoQixTQUFJLEdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUtuQyxDQUFDO0tBQUQsY0FBQztBQUFELEVBQUM7QUFQWSxnQkFBTyxVQU9uQjs7Ozs7Ozs7QUNQRDtLQUFBO1NBQ0ksT0FBRSxHQUFXLEVBQUUsQ0FBQztTQUNoQixTQUFJLEdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQVNuQyxDQUFDO0tBQUQsY0FBQztBQUFELEVBQUM7QUFYWSxnQkFBTyxVQVduQjs7Ozs7Ozs7QUNiRDtLQUFBO1NBQ0ksT0FBRSxHQUFXLEVBQUUsQ0FBQztLQUdwQixDQUFDO0tBQUQsa0JBQUM7QUFBRCxFQUFDO0FBSlksb0JBQVcsY0FJdkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkQsa0NBQTJCLENBQWUsQ0FBQztBQUMzQyxrQ0FBd0MsR0FBZSxDQUFDO0FBQ3hELHdDQUEyQixFQUFpQixDQUFDO0FBQzdDLDJDQUFpQyxHQUE2QixDQUFDO0FBRS9ELDJDQUlPLEdBQTJCLENBQUM7QUFDbkMsMENBR08sR0FBMEIsQ0FBQztBQUNsQyxvQ0FBbUQsR0FBVyxDQUFDO0FBQy9ELG1DQUFpRyxHQUFnQixDQUFDO0FBRWxILEtBQU0sT0FBTyxHQUFHLElBQUksY0FBTyxDQUFDO0tBQ3hCLGNBQWMsRUFBRSxrREFBa0Q7S0FDbEUsUUFBUSxFQUFFLGtCQUFrQjtFQUMvQixDQUFDLENBQUM7QUFHSDtLQUVJLHFCQUNZLElBQVUsRUFDVixTQUEyQjtTQUQzQixTQUFJLEdBQUosSUFBSSxDQUFNO1NBQ1YsY0FBUyxHQUFULFNBQVMsQ0FBa0I7S0FDbkMsQ0FBQztLQUVMLDBDQUFvQixHQUFwQjtTQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQUMsSUFBSTthQUN2RSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRTthQUNsRCxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUU7YUFDbkMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFO2FBQy9CLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRTtVQUN0QyxFQUwwRSxDQUsxRSxDQUFDLENBQUM7S0FDUCxDQUFDO0tBRUQsd0NBQWtCLEdBQWxCO1NBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBQyxJQUFJO2FBQzlFLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFO2FBQ2hELEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRTthQUNyQyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxTQUFTLEVBQUU7YUFDekMsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFO1VBQzFDLEVBTGlGLENBS2pGLENBQUMsQ0FBQztLQUNQLENBQUM7S0FFRCxnQ0FBVSxHQUFWLFVBQVcsV0FBZ0I7U0FBaEIsMkJBQWdCLEdBQWhCLGdCQUFnQjtTQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUU7YUFDbkMsT0FBTyxFQUFFLE9BQU87YUFDaEIsTUFBTSxFQUFFLDZCQUFxQixDQUFDLFdBQVcsQ0FBQztVQUM3QyxDQUFDO2NBQ0csR0FBRyxDQUFDLGtCQUFRLElBQUksZUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBMUIsQ0FBMEIsQ0FBQztjQUMzQyxHQUFHLENBQUMsY0FBSTthQUNMLE1BQU0sQ0FBQztpQkFDSCxJQUFJLEVBQUUsMkJBQVc7aUJBQ2pCLE9BQU8sRUFBRTtxQkFDTCxLQUFLLEVBQVUsSUFBSSxDQUFDLElBQUk7cUJBQ3hCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtrQkFDbEI7Y0FDSjtTQUNMLENBQUMsQ0FBQyxDQUFDO0tBQ1gsQ0FBQztLQUVELG1DQUFhLEdBQWIsVUFBYyxNQUFjO1NBQ3hCLEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQ25CLE1BQU0sQ0FBQyx1QkFBVSxDQUFDLEVBQUUsQ0FBQztpQkFDakIsSUFBSSxFQUFFLDBCQUFVO2lCQUNoQixPQUFPLEVBQUU7cUJBQ0wsSUFBSSxFQUFFLElBQUksYUFBSSxFQUFFO2tCQUNuQjtjQUNKLENBQUMsQ0FBQztTQUNQLENBQUM7U0FFRCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEdBQUcsTUFBTSxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQ3hFLEdBQUcsQ0FBQyxrQkFBUTthQUNULElBQUksSUFBSSxHQUFHLDRCQUFvQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUN6RCxJQUFJLElBQUksR0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQzNCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2lCQUNaLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQzthQUMxQixDQUFDO2FBQ0QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7aUJBQ2xCLElBQUksQ0FBQyxXQUFXLEdBQWlCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO2FBQzFELENBQUM7YUFDRCxNQUFNLENBQUM7aUJBQ0gsSUFBSSxFQUFFLDBCQUFVO2lCQUNoQixPQUFPLEVBQUU7cUJBQ0wsSUFBSSxFQUFRLElBQUk7a0JBQ25CO2NBQ0o7U0FDTCxDQUFDLENBQUMsQ0FBQztLQUNYLENBQUM7S0FFRCw4QkFBUSxHQUFSLFVBQVMsSUFBVTtTQUNmLElBQUksR0FBRyxHQUFHLGdCQUFnQixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztTQUNuRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLG9CQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUM7Y0FDL0QsR0FBRyxDQUFDLGtCQUFRLElBQUksb0NBQXFCLENBQUMsUUFBUSxDQUFDLEVBQS9CLENBQStCLENBQUM7Y0FDaEQsS0FBSyxDQUFDLGVBQUssSUFBSSw4QkFBVSxDQUFDLEtBQUssQ0FBQyw2QkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUE5QyxDQUE4QyxDQUFDLENBQUM7S0FDeEUsQ0FBQztLQUVELGdDQUFVLEdBQVYsVUFBVyxLQUFhO1NBQ3BCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyx5QkFBeUIsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQUUsSUFBSSxTQUFFLENBQUMsRUFBRSxFQUFMLENBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQzFGLENBQUM7S0FFRCwwQ0FBb0IsR0FBcEIsVUFBcUIsSUFBVSxFQUFFLFVBQXNCO1NBQ25ELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNuRyxDQUFDO0tBRUQsdUNBQWlCLEdBQWpCLFVBQWtCLElBQVUsRUFBRSxJQUFRO1NBQVIsb0JBQVEsR0FBUixRQUFRO1NBQ2xDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQzdFLEdBQUcsQ0FBQyxrQkFBUSxJQUFJLG1DQUFvQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxFQUEzRCxDQUEyRCxDQUFDO2NBQzVFLEdBQUcsQ0FBQyxjQUFJO2FBQ0wsTUFBTSxDQUFDO2lCQUNILElBQUksRUFBRSw2QkFBYztpQkFDcEIsT0FBTyxFQUFFO3FCQUNMLFFBQVEsRUFBYSxJQUFJLENBQUMsSUFBSTtxQkFDOUIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2tCQUNsQjtjQUNKO1NBQ0wsQ0FBQyxDQUFDLENBQUM7S0FDWCxDQUFDO0tBRUQscUNBQWUsR0FBZixVQUFnQixPQUFnQjtTQUM1QixJQUFJLEdBQUcsR0FBRyw0QkFBNEIsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1NBQ3hELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsb0JBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQztjQUNsRSxHQUFHLENBQUMsa0JBQVEsSUFBSSxvQ0FBcUIsQ0FBQyxRQUFRLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQztjQUNoRCxLQUFLLENBQUMsZUFBSyxJQUFJLDhCQUFVLENBQUMsS0FBSyxDQUFDLDZCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQTlDLENBQThDLENBQUMsQ0FBQztLQUN4RSxDQUFDO0tBRUQseUNBQW1CLEdBQW5CLFVBQW9CLE9BQWdCLEVBQUUsVUFBa0I7U0FDcEQsSUFBSSxHQUFHLEdBQUcsK0JBQStCLEdBQUcsT0FBTyxDQUFDLEVBQUUsR0FBRyxjQUFjLEdBQUcsVUFBVSxDQUFDO1NBQ3JGLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQzlDLEdBQUcsQ0FBQyxrQkFBUSxJQUFJLG9DQUFxQixDQUFDLFFBQVEsQ0FBQyxFQUEvQixDQUErQixDQUFDO2NBQ2hELEtBQUssQ0FBQyxlQUFLLElBQUksOEJBQVUsQ0FBQyxLQUFLLENBQUMsNkJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBOUMsQ0FBOEMsQ0FBQyxDQUFDO0tBQ3hFLENBQUM7S0FFRCxtQ0FBYSxHQUFiLFVBQWMsT0FBZ0I7U0FDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLCtCQUErQixHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMxRSxDQUFDO0tBRUQsNkNBQXVCLEdBQXZCLFVBQXdCLE9BQWdCLEVBQUUsVUFBc0I7U0FDNUQsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLCtCQUErQixHQUFHLE9BQU8sQ0FBQyxFQUFFLEdBQUcsZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzdHLENBQUM7S0FFRCxtQ0FBYSxHQUFiLFVBQWMsSUFBVSxFQUFFLElBQVE7U0FBUixvQkFBUSxHQUFSLFFBQVE7U0FDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUF1QixHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUM7Y0FDeEUsR0FBRyxDQUFDLGtCQUFRLElBQUksbUNBQW9CLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQTNELENBQTJELENBQUM7Y0FDNUUsR0FBRyxDQUFDLGNBQUk7YUFDTCxNQUFNLENBQUM7aUJBQ0gsSUFBSSxFQUFFLDZCQUFjO2lCQUNwQixPQUFPLEVBQUU7cUJBQ0wsUUFBUSxFQUFhLElBQUksQ0FBQyxJQUFJO3FCQUM5QixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7a0JBQ2xCO2NBQ0o7U0FDTCxDQUFDLENBQUMsQ0FBQztLQUNYLENBQUM7S0FFRCxpQ0FBVyxHQUFYLFVBQVksSUFBVSxFQUFFLE9BQWdCO1NBQ3BDLElBQUksR0FBRyxHQUFHLHVCQUF1QixHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLGFBQWEsR0FBRyxPQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQzdGLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsb0JBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQztjQUNsRSxHQUFHLENBQUMsa0JBQVEsSUFBSSxvQ0FBcUIsQ0FBQyxRQUFRLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQztjQUNoRCxLQUFLLENBQUMsZUFBSyxJQUFJLDhCQUFVLENBQUMsS0FBSyxDQUFDLDZCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQTlDLENBQThDLENBQUMsQ0FBQztLQUN4RSxDQUFDO0tBRUQsbUNBQWEsR0FBYixVQUFjLE9BQWdCO1NBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQywwQkFBMEIsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDckUsQ0FBQztLQUVELDZDQUF1QixHQUF2QixVQUF3QixPQUFnQixFQUFFLFVBQXNCO1NBQzVELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQywwQkFBMEIsR0FBRyxPQUFPLENBQUMsRUFBRSxHQUFHLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN4RyxDQUFDO0tBdEpMO1NBQUMsaUJBQVUsRUFBRTs7b0JBQUE7S0F1SmIsa0JBQUM7QUFBRCxFQUFDO0FBdEpZLG9CQUFXLGNBc0p2Qjs7Ozs7Ozs7QUMzS1ksb0JBQVcsR0FBRyxhQUFhLENBQUM7QUFDNUIsbUJBQVUsR0FBRyxZQUFZLENBQUM7QUFDMUIsaUJBQVEsR0FBRyxVQUFVLENBQUM7QUFDdEIsb0JBQVcsR0FBRyxhQUFhLENBQUM7QUFDNUIsb0JBQVcsR0FBRyxhQUFhLENBQUM7QUFNeEMsRUFBQztBQUVGLEtBQU0sWUFBWSxHQUFnQjtLQUM5QixJQUFJLEVBQUUsRUFBRTtLQUNSLEtBQUssRUFBRSxFQUFFO0tBQ1QsT0FBTyxFQUFFLEtBQUs7RUFDakIsQ0FBQztBQUVXLHFCQUFZLEdBQUcsVUFBQyxLQUFvQixFQUFFLEVBQWU7S0FBckMscUJBQW9CLEdBQXBCLG9CQUFvQjtTQUFHLGNBQUksRUFBRSxvQkFBTztLQUM3RCxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ1gsS0FBSyxtQkFBVzthQUNaLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUU7aUJBQzVCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztpQkFDcEIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO2NBQ3JCLENBQUMsQ0FBQztTQUNQLEtBQUssa0JBQVU7YUFDWCxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFO2lCQUM1QixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7Y0FDckIsQ0FBQyxDQUFDO1NBQ1AsS0FBSyxnQkFBUTthQUNULE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDakIsS0FBSyxtQkFBVzthQUNaLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDakIsS0FBSyxtQkFBVzthQUNaLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDakI7YUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDO0tBQ3JCLENBQUM7QUFDTCxFQUFDLENBQUM7Ozs7Ozs7O0FDdENXLHlCQUFnQixHQUFHLGtCQUFrQixDQUFDO0FBQ3RDLDRCQUFtQixHQUFHLHFCQUFxQixDQUFDO0FBQzVDLHVCQUFjLEdBQUcsZ0JBQWdCLENBQUM7QUFDbEMsdUJBQWMsR0FBRyxnQkFBZ0IsQ0FBQztBQUNsQyxtQkFBVSxHQUFHLFlBQVksQ0FBQztBQVF0QyxFQUFDO0FBRUYsS0FBTSxZQUFZLEdBQWU7S0FDN0IsSUFBSSxFQUFFLElBQUk7S0FDVixPQUFPLEVBQUUsSUFBSTtLQUNiLFFBQVEsRUFBRSxFQUFFO0tBQ1osV0FBVyxFQUFFLEtBQUs7S0FDbEIsUUFBUSxFQUFFLEVBQUU7RUFDZixDQUFDO0FBRVcsb0JBQVcsR0FBRyxVQUFDLEtBQW9CLEVBQUUsRUFBZTtLQUFyQyxxQkFBb0IsR0FBcEIsb0JBQW9CO1NBQUcsY0FBSSxFQUFFLG9CQUFPO0tBQzVELE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDWCxLQUFLLHNCQUFjO2FBQ2YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRTtpQkFDNUIsUUFBUSxFQUFFLE9BQU8sQ0FBQyxRQUFRO2NBQzdCLENBQUMsQ0FBQztTQUNQLEtBQUssd0JBQWdCO2FBQ2pCLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUU7aUJBQzVCLElBQUksRUFBRSxPQUFPO2lCQUNiLFdBQVcsRUFBRSxJQUFJO2NBQ3BCLENBQUMsQ0FBQztTQUNQLEtBQUssMkJBQW1CO2FBQ3BCLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUU7aUJBQzVCLFdBQVcsRUFBRSxLQUFLO2NBQ3JCLENBQUMsQ0FBQztTQUNQLEtBQUssc0JBQWM7YUFDZixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFO2lCQUM1QixRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVE7Y0FDN0IsQ0FBQyxDQUFDO1NBQ1AsS0FBSyxrQkFBVTthQUNYLE1BQU0sQ0FBQztpQkFDSCxJQUFJLEVBQUUsSUFBSTtpQkFDVixPQUFPLEVBQUUsSUFBSTtpQkFDYixRQUFRLEVBQUUsRUFBRTtpQkFDWixXQUFXLEVBQUUsS0FBSztpQkFDbEIsUUFBUSxFQUFFLEVBQUU7Y0FDZixDQUFDO1NBQ047YUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDO0tBQ3JCLENBQUM7QUFDTCxFQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdERGLGtDQUEyQixDQUFlLENBQUM7QUFDM0Msa0NBQThCLEdBQWUsQ0FBQztBQUM5QyxtQ0FBc0IsR0FBYSxDQUFDO0FBRXBDLCtDQUlPLEdBQStCLENBQUM7QUFHdkMsS0FBTSxPQUFPLEdBQUcsSUFBSSxjQUFPLENBQUM7S0FDeEIsY0FBYyxFQUFFLGtEQUFrRDtLQUNsRSxRQUFRLEVBQUUsa0JBQWtCO0VBQy9CLENBQUMsQ0FBQztBQUdIO0tBRUksMEJBQ1ksSUFBVSxFQUNWLEtBQWlCO1NBRGpCLFNBQUksR0FBSixJQUFJLENBQU07U0FDVixVQUFLLEdBQUwsS0FBSyxDQUFZO0tBQ3pCLENBQUM7S0FFTCx3Q0FBYSxHQUFiO1NBQUEsaUJBVUM7U0FURyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLGdCQUFNO2FBQzdCLEtBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2hDLENBQUMsQ0FBQyxDQUFDO1NBQ0gsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxnQkFBTTthQUNsQyxLQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoQyxDQUFDLENBQUMsQ0FBQztTQUNILElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLFNBQVMsQ0FBQyxnQkFBTTthQUNyQyxLQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoQyxDQUFDLENBQUMsQ0FBQztLQUNQLENBQUM7S0FFRCxvQ0FBUyxHQUFUO1NBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHNCQUFzQixFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQzdELEdBQUcsQ0FBQyxrQkFBUSxJQUFJLGVBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQTFCLENBQTBCLENBQUM7Y0FDM0MsR0FBRyxDQUFDLGNBQUk7YUFDTCxNQUFNLENBQUM7aUJBQ0gsSUFBSSxFQUFFLDhCQUFVO2lCQUNoQixPQUFPLEVBQUU7cUJBQ0wsSUFBSSxFQUFTLElBQUksQ0FBQyxJQUFJO3FCQUN0QixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7a0JBQ2xCO2NBQ0o7U0FDTCxDQUFDLENBQUMsQ0FBQztLQUNYLENBQUM7S0FFRCx5Q0FBYyxHQUFkO1NBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLDJCQUEyQixFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQ2xFLEdBQUcsQ0FBQyxrQkFBUSxJQUFJLGVBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQTFCLENBQTBCLENBQUM7Y0FDM0MsR0FBRyxDQUFDLGNBQUk7YUFDTCxNQUFNLENBQUM7aUJBQ0gsSUFBSSxFQUFFLG9DQUFnQjtpQkFDdEIsT0FBTyxFQUFFO3FCQUNMLFNBQVMsRUFBYyxJQUFJLENBQUMsSUFBSTtxQkFDaEMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2tCQUNsQjtjQUNKO1NBQ0wsQ0FBQyxDQUFDLENBQUM7S0FDWCxDQUFDO0tBRUQsNENBQWlCLEdBQWpCO1NBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLCtCQUErQixFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQ3RFLEdBQUcsQ0FBQyxrQkFBUSxJQUFJLGVBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQTFCLENBQTBCLENBQUM7Y0FDM0MsR0FBRyxDQUFDLGNBQUk7YUFDTCxNQUFNLENBQUM7aUJBQ0gsSUFBSSxFQUFFLHVDQUFtQjtpQkFDekIsT0FBTyxFQUFFO3FCQUNMLFlBQVksRUFBaUIsSUFBSSxDQUFDLElBQUk7cUJBQ3RDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtrQkFDbEI7Y0FDSjtTQUNMLENBQUMsQ0FBQyxDQUFDO0tBQ1gsQ0FBQztLQTVETDtTQUFDLGlCQUFVLEVBQUU7O3lCQUFBO0tBNkRiLHVCQUFDO0FBQUQsRUFBQztBQTVEWSx5QkFBZ0IsbUJBNEQ1Qjs7Ozs7Ozs7QUMzRVksbUJBQVUsR0FBRyxZQUFZLENBQUM7QUFDMUIseUJBQWdCLEdBQUcsa0JBQWtCLENBQUM7QUFDdEMsNEJBQW1CLEdBQUcscUJBQXFCLENBQUM7QUFNeEQsRUFBQztBQUVGLEtBQU0sWUFBWSxHQUFHO0tBQ2pCLElBQUksRUFBRSxFQUFFO0tBQ1IsU0FBUyxFQUFFLEVBQUU7S0FDYixZQUFZLEVBQUUsRUFBRTtFQUNuQixDQUFDO0FBRVcseUJBQWdCLEdBQUcsVUFBQyxLQUFvQixFQUFFLEVBQWU7S0FBckMscUJBQW9CLEdBQXBCLG9CQUFvQjtTQUFHLGNBQUksRUFBRSxvQkFBTztLQUNqRSxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ1gsS0FBSyxrQkFBVTthQUNYLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUU7aUJBQzVCLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSTtjQUNyQixDQUFDLENBQUM7U0FDUCxLQUFLLHdCQUFnQjthQUNqQixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFO2lCQUM1QixTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7Y0FDL0IsQ0FBQyxDQUFDO1NBQ1AsS0FBSywyQkFBbUI7YUFDcEIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRTtpQkFDNUIsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZO2NBQ3JDLENBQUMsQ0FBQztTQUNQO2FBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQztLQUNyQixDQUFDO0FBQ0wsRUFBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25DRixrQ0FBMkIsQ0FBZSxDQUFDO0FBQzNDLGtDQUE4QixHQUFlLENBQUM7QUFFOUMsMkNBR08sR0FBMkIsQ0FBQztBQUVuQyxtQ0FBc0MsR0FBZ0IsQ0FBQztBQUV2RCxLQUFNLE9BQU8sR0FBRyxJQUFJLGNBQU8sQ0FBQztLQUN4QixjQUFjLEVBQUUsa0RBQWtEO0tBQ2xFLFFBQVEsRUFBRSxrQkFBa0I7RUFDL0IsQ0FBQyxDQUFDO0FBR0g7S0FFSSxzQkFDWSxJQUFVO1NBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtLQUNsQixDQUFDO0tBRUwseUNBQWtCLEdBQWxCLFVBQW1CLFdBQWdCO1NBQWhCLDJCQUFnQixHQUFoQixnQkFBZ0I7U0FDL0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLCtCQUErQixFQUFFO2FBQ2xELE9BQU8sRUFBRSxPQUFPO2FBQ2hCLE1BQU0sRUFBRSw2QkFBcUIsQ0FBQyxXQUFXLENBQUM7VUFDN0MsQ0FBQztjQUNHLEdBQUcsQ0FBQyxrQkFBUSxJQUFJLGVBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQTFCLENBQTBCLENBQUM7Y0FDM0MsR0FBRyxDQUFDLGNBQUk7YUFDTCxNQUFNLENBQUM7aUJBQ0gsSUFBSSxFQUFFLG1DQUFtQjtpQkFDekIsT0FBTyxFQUFFO3FCQUNMLGFBQWEsRUFBa0IsSUFBSSxDQUFDLElBQUk7cUJBQ3hDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtrQkFDbEI7Y0FDSjtTQUNMLENBQUMsQ0FBQyxDQUFDO0tBQ1gsQ0FBQztLQUVELGlDQUFVLEdBQVY7U0FDSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDO2NBQ25ELEdBQUcsQ0FBQyxrQkFBUTthQUNULE1BQU0sQ0FBQztpQkFDSCxJQUFJLEVBQUUsMkJBQVc7aUJBQ2pCLE9BQU8sRUFBRTtxQkFDTCxLQUFLLEVBQVUsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO2tCQUNqRDtjQUNKO1NBQ0wsQ0FBQyxDQUFDLENBQUM7S0FDWCxDQUFDO0tBbENMO1NBQUMsaUJBQVUsRUFBRTs7cUJBQUE7S0FtQ2IsbUJBQUM7QUFBRCxFQUFDO0FBbENZLHFCQUFZLGVBa0N4Qjs7Ozs7Ozs7QUNoRFksNEJBQW1CLEdBQUcscUJBQXFCLENBQUM7QUFDNUMsb0JBQVcsR0FBRyxhQUFhLENBQUM7QUFLeEMsRUFBQztBQUVGLEtBQU0sWUFBWSxHQUFnQjtLQUM5QixhQUFhLEVBQUUsRUFBRTtLQUNqQixLQUFLLEVBQUUsRUFBRTtFQUNaLENBQUM7QUFFVyxxQkFBWSxHQUFHLFVBQUMsS0FBb0IsRUFBRSxFQUFlO0tBQXJDLHFCQUFvQixHQUFwQixvQkFBb0I7U0FBRyxjQUFJLEVBQUUsb0JBQU87S0FDN0QsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNYLEtBQUssMkJBQW1CO2FBQ3BCLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUU7aUJBQzVCLGFBQWEsRUFBRSxPQUFPLENBQUMsYUFBYTtjQUN2QyxDQUFDLENBQUM7U0FDUCxLQUFLLG1CQUFXO2FBQ1osTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRTtpQkFDNUIsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLO2NBQ3ZCLENBQUMsQ0FBQztTQUNQO2FBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQztLQUNyQixDQUFDO0FBQ0wsRUFBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzVCRixrQ0FBMkIsQ0FBZSxDQUFDO0FBQzNDLGdDQUEyQixHQUFTLENBQUM7QUFHckM7S0FJSTtTQUpKLGlCQTZDQztTQXhDTyxJQUFJLENBQUMsU0FBUyxHQUFHLGVBQVUsQ0FBQyxNQUFNLENBQUMsa0JBQVE7YUFDdkMsS0FBSSxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQztTQUNyQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNmLENBQUM7S0FFRCx1Q0FBZSxHQUFmLFVBQWdCLEdBQVcsRUFBRSxNQUFXLEVBQUUsS0FBYTtTQUF2RCxpQkFrQ0M7U0FqQ0csTUFBTSxDQUFDLGVBQVUsQ0FBQyxNQUFNLENBQUMsa0JBQVE7YUFDN0IsSUFBSSxRQUFRLEdBQWEsSUFBSSxRQUFRLEVBQUUsRUFDbkMsR0FBRyxHQUFtQixJQUFJLGNBQWMsRUFBRSxDQUFDO2FBRS9DLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2lCQUNwQyxRQUFRLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzFELENBQUM7YUFFRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2lCQUNULEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUM7cUJBQ25CLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNsQyxDQUFDO2FBQ0wsQ0FBQzthQUVELEdBQUcsQ0FBQyxrQkFBa0IsR0FBRztpQkFDckIsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2QixFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7eUJBQ3JCLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzt5QkFDeEMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO3FCQUN4QixDQUFDO3FCQUFDLElBQUksQ0FBQyxDQUFDO3lCQUNKLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUNqQyxDQUFDO2lCQUNMLENBQUM7YUFDTCxDQUFDLENBQUM7YUFFRixHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxVQUFDLEtBQUs7aUJBQzFCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2lCQUM1RCxLQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3pDLENBQUMsQ0FBQzthQUVGLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUM1QixHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3ZCLENBQUMsQ0FBQyxDQUFDO0tBQ1AsQ0FBQztLQTdDTDtTQUFDLGlCQUFVLEVBQUU7O3NCQUFBO0tBOENiLG9CQUFDO0FBQUQsRUFBQztBQTdDWSxzQkFBYSxnQkE2Q3pCOzs7Ozs7O0FDakREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsVUFBVTtBQUN4QjtBQUNBLGVBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Qsc0M7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxvQzs7Ozs7O0FDelBBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxrQ0FBa0MsRUFBRTtBQUNuRixnQzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSx3Qzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLHVDOzs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QscUM7Ozs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsVUFBUztBQUNULFVBQVM7QUFDVCxVQUFTO0FBQ1Q7QUFDQSxZQUFXLDJDQUEyQztBQUN0RDtBQUNBO0FBQ0EsYUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxzQzs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsMkJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELGNBQWMsRUFBRTtBQUNoRSxpREFBZ0QsYUFBYSxFQUFFO0FBQy9ELCtCQUE4QjtBQUM5QixxQ0FBb0Msa0JBQWtCLEVBQUU7QUFDeEQseUNBQXdDLGtCQUFrQixFQUFFO0FBQzVELHNDQUFxQyxrQkFBa0IsRUFBRTtBQUN6RCx5Q0FBd0Msa0JBQWtCLEVBQUU7QUFDNUQscUNBQW9DLGtCQUFrQixFQUFFO0FBQ3hEO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJvb3RzdHJhcCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XHJcbmltcG9ydCB7IHByb3ZpZGUsIGVuYWJsZVByb2RNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEhUVFBfUFJPVklERVJTIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XHJcbmltcG9ydCB7IExvY2F0aW9uU3RyYXRlZ3ksIEhhc2hMb2NhdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7IFRSQU5TTEFURV9QUk9WSURFUlMsIFRyYW5zbGF0ZVNlcnZpY2UsIFRyYW5zbGF0ZUxvYWRlciB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnXHJcblxyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9zaGFyZWQvbm90aWZpY2F0aW9uJztcclxuaW1wb3J0IHsgTWFya2Rvd25Db252ZXJ0ZXIgfSBmcm9tICcuL3NoYXJlZC9tYXJrZG93bic7XHJcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEFQUF9ST1VURVJfUFJPVklERVJTIH0gZnJvbSAnLi9hcHAucm91dGVzJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSBhcyB0cmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy90cmFuc2xhdGUuc2VydmljZSc7XHJcbmltcG9ydCB7IEFQUF9TRVJWSUNFUyB9IGZyb20gJy4vc2VydmljZXMnO1xyXG5pbXBvcnQgeyBBUFBfU1RPUkUgfSBmcm9tICcuL3N0b3JlJztcclxuXHJcbmJvb3RzdHJhcChBcHBDb21wb25lbnQsIFtcclxuICAgIEhUVFBfUFJPVklERVJTLFxyXG4gICAgQVBQX1JPVVRFUl9QUk9WSURFUlMsXHJcbiAgICBwcm92aWRlKExvY2F0aW9uU3RyYXRlZ3ksIHsgdXNlQ2xhc3M6IEhhc2hMb2NhdGlvblN0cmF0ZWd5IH0pLFxyXG4gICAgVHJhbnNsYXRlU2VydmljZSxcclxuICAgIFRSQU5TTEFURV9QUk9WSURFUlMsXHJcbiAgICBwcm92aWRlKFRyYW5zbGF0ZUxvYWRlciwge1xyXG4gICAgICAgIHVzZUZhY3Rvcnk6ICh0cnM6IHRyYW5zbGF0ZVNlcnZpY2UpID0+IG5ldyBDdXN0b21UcmFuc2xhdGVMb2FkZXIodHJzKSxcclxuICAgICAgICBkZXBzOiBbdHJhbnNsYXRlU2VydmljZV1cclxuICAgIH0pLFxyXG4gICAgTm90aWZpY2F0aW9uU2VydmljZSxcclxuICAgIE1hcmtkb3duQ29udmVydGVyLFxyXG4gICAgQVBQX1NFUlZJQ0VTLFxyXG4gICAgQVBQX1NUT1JFXHJcbl0pLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xyXG5cclxuLy9cclxuY2xhc3MgQ3VzdG9tVHJhbnNsYXRlTG9hZGVyIGltcGxlbWVudHMgVHJhbnNsYXRlTG9hZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJhbnNsYXRlU2VydmljZTogdHJhbnNsYXRlU2VydmljZSkgeyB9XHJcblxyXG4gICAgcHVibGljIGdldFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlU2VydmljZS5mZXRjaFRyYW5zbGF0aW9ucygpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL21haW4uYnJvd3Nlci50c1xuICoqLyIsImV4cG9ydCAqIGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xyXG5leHBvcnQgKiBmcm9tICcuL25vdGlmaWNhdGlvbi5jb21wb25lbnQnO1xyXG5leHBvcnQgKiBmcm9tICcuL25vdGlmaWNhdGlvbic7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC9ub3RpZmljYXRpb24vaW5kZXgudHNcbiAqKi8iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi9ub3RpZmljYXRpb24nO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uU2VydmljZSB7XHJcbiAgICBwcml2YXRlIGVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgIHB1YmxpYyBnZXRFbWl0dGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXR0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaW5mbyhtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHsgdHlwZTogJ2luZm8nLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN1Y2Nlc3MobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh7IHR5cGU6ICdzdWNjZXNzJywgbWVzc2FnZTogbWVzc2FnZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBlcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZTogbWVzc2FnZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoeyB0eXBlOiAncHJvY2VzcycsIG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKG9wdGlvbnMpOiBOb3RpZmljYXRpb24ge1xyXG4gICAgICAgIGxldCBub3R5ID0gbmV3IE5vdGlmaWNhdGlvbihvcHRpb25zLnR5cGUsIG9wdGlvbnMubWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoeyBjb21tYW5kOiAnYWRkJywgbm90aWZ5OiBub3R5IH0pO1xyXG4gICAgICAgIHJldHVybiBub3R5O1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUFsbCgpIHtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdCh7IGNvbW1hbmQ6ICdjbGVhbkFsbCcgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2hhcmVkL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uc2VydmljZS50c1xuICoqLyIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvbiB7XHJcbiAgICBwcml2YXRlIGVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgIHByaXZhdGUgdHlwZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGRpc3BsYXkgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgZGVsYXk7XHJcbiAgICBwcml2YXRlIHByb21pc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlcjtcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgICB0aGlzLmRpc3BsYXkgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXQob3B0aW9ucykge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdtZXNzYWdlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3R5cGUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNtaXNzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KHsgZGlzbWlzczogdHJ1ZSwgbm90aWZ5OiB0aGlzLCBwcm9taXNlOiB0aGlzLnByb21pc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZShkZWxheTogYW55KSB7XHJcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xyXG5cclxuICAgICAgICBpZiAoZGVsYXkgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgLy8gcmVzb2x2ZSBvbiBkaXNtaXNzXHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWxheSA+IDApIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdCh7IGRpc21pc3M6IHRydWUsIG5vdGlmeTogdGhpcywgcHJvbWlzZTogdGhpcy5wcm9taXNlIH0pO1xyXG4gICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoeyBkaXNtaXNzOiB0cnVlLCBub3RpZnk6IHRoaXMsIHByb21pc2U6IHRoaXMucHJvbWlzZSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2hhcmVkL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24udHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgT25EZXN0cm95LCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBOb3RpZmljYXRpb24gfSBmcm9tICcuL25vdGlmaWNhdGlvbic7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnbm90aWZpY2F0aW9uJyxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm5iLW5vdGlmeS1lbnRyeS17e25vdGlmeS50eXBlfX1cIlxyXG4gICAgICAgICAgICBbY2xhc3MuZGlzbWlzcy1jbGlja109XCJub3RpZnkuZGVsYXkgPT0gJ2NsaWNrJ1wiXHJcbiAgICAgICAgICAgIFtzdHlsZS5kaXNwbGF5XT1cIm5vdGlmeS5kaXNwbGF5ID8gJ2Jsb2NrJzogJ25vbmUnXCJcclxuICAgICAgICAgICAgKGNsaWNrKT1cIm5vdGlmeS5kaXNtaXNzKClcIlxyXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgbm90aWZ5IG9mIG5vdGlmaWNhdGlvbnNcIj5cclxuICAgICAgICAgICAge3tub3RpZnkubWVzc2FnZX19XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIEBIb3N0QmluZGluZygnY2xhc3MubmItbm90aWZ5JykgdHJ1ZTtcclxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaGlkZGVuJykgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zLmxlbmd0aCA9PSAwOyB9O1xyXG5cclxuICAgIHB1YmxpYyBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcjogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbm90aWZ5U2VydmljZTogTm90aWZpY2F0aW9uU2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IHRoaXMubm90aWZ5U2VydmljZS5nZXRFbWl0dGVyKCkuc3Vic2NyaWJlKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uY29tbWFuZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2xlYW5BbGwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE5vdGlmeShpdGVtLm5vdGlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLm1hcChpdCA9PiBpdC5nZXRFbWl0dGVyKCkudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkTm90aWZ5KG5vdGlmeTogTm90aWZpY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLnB1c2gobm90aWZ5KTtcclxuICAgICAgICBub3RpZnkuZ2V0RW1pdHRlcigpLnN1YnNjcmliZShpdGVtID0+IHRoaXMubm90aWZ5RW1pdHRlcihpdGVtKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbm90aWZ5RW1pdHRlcihkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEuZGlzbWlzcykge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vdGlmaWNhdGlvbnMuaW5kZXhPZihkYXRhLm5vdGlmeSk7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBkYXRhLm5vdGlmeS5nZXRFbWl0dGVyKCkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2hhcmVkL25vdGlmaWNhdGlvbi9ub3RpZmljYXRpb24uY29tcG9uZW50LnRzXG4gKiovIiwiZXhwb3J0IHsgTWFya2Rvd25Db252ZXJ0ZXIgfSBmcm9tICcuL21hcmtkb3duLWNvbnZlcnRlcic7XHJcbmV4cG9ydCB7IE1hcmtkb3duRWRpdG9yQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJrZG93bi1lZGl0b3InO1xyXG5leHBvcnQgeyBNYXJrZWRQaXBlIH0gZnJvbSAnLi9tYXJrZWQucGlwZSc7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC9tYXJrZG93bi9pbmRleC50c1xuICoqLyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmNvbnN0IG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xyXG5jb25zdCB0b01hcmtkb3duID0gcmVxdWlyZSgndG8tbWFya2Rvd24nKTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE1hcmtkb3duQ29udmVydGVyIHtcclxuXHJcbiAgICB0b01hcmtkb3duKGh0bWwpIHtcclxuICAgICAgICByZXR1cm4gdG9NYXJrZG93bihodG1sLCB7IGdmbTogdHJ1ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0b0h0bWwobWFya2Rvd24pIHtcclxuICAgICAgICByZXR1cm4gbWFya2VkKG1hcmtkb3duKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zaGFyZWQvbWFya2Rvd24vbWFya2Rvd24tY29udmVydGVyLnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXJrZG93bkNvbnZlcnRlciB9IGZyb20gJy4vbWFya2Rvd24tY29udmVydGVyJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdtYXJrZG93bi1lZGl0b3InLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwicnQtZWRpdG9yXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJydC1lZGl0b3JfX2FyZWEge3trbGFzc319XCIgW2NsYXNzLmVkaXRdPVwiZWRpdGFibGVcIiBjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIGlubmVySHRtbD1cInt7aHRtbH19XCJcclxuICAgICAgICAgICAgICAgIChrZXl1cCk9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0KVwiXHJcbiAgICAgICAgICAgICAgICAoZm9jdXMpPVwiZm9jdXMuZW1pdCgxKVwiXHJcbiAgICAgICAgICAgICAgICAoYmx1cik9XCJibHVyLmVtaXQoMSlcIj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwhLS0gPHNwYW4gY2xhc3M9XCJydC1lZGl0b3JfX3BsYWNlaG9sZGVyXCIgKm5nSWY9XCIhaHRtbC5sZW5ndGhcIj57e3BsYWNlSG9sZGVyfX08L3NwYW4+IC0tPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYCxcclxuICAgIHByb3ZpZGVyczogW01hcmtkb3duQ29udmVydGVyXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIE1hcmtkb3duRWRpdG9yQ29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIGVkaXRhYmxlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIG1hcmtkb3duOiBzdHJpbmcgPSAnJztcclxuICAgIEBJbnB1dCgpIGtsYXNzOiBzdHJpbmcgPSAnJztcclxuICAgIEBJbnB1dCgpIHBsYWNlSG9sZGVyOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSB1cGRhdGVUaW1lb3V0OiBudW1iZXIgPSAxNTA7XHJcblxyXG4gICAgQE91dHB1dCgpIHVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgQE91dHB1dCgpIGZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgYmx1ciA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG5cclxuICAgIHByaXZhdGUgaHRtbDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSB0bzogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbWRjOiBNYXJrZG93bkNvbnZlcnRlcikgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5odG1sID0gdGhpcy5tZGMudG9IdG1sKHRoaXMubWFya2Rvd24pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVZhbHVlKCRlbCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcclxuICAgICAgICB0aGlzLnRvID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQodGhpcy5tZGMudG9NYXJrZG93bigkZWwuaW5uZXJIVE1MKSk7XHJcbiAgICAgICAgfSwgdGhpcy51cGRhdGVUaW1lb3V0KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zaGFyZWQvbWFya2Rvd24vbWFya2Rvd24tZWRpdG9yLnRzXG4gKiovIiwiaW1wb3J0IHsgUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXJrZG93bkNvbnZlcnRlciB9IGZyb20gJy4vbWFya2Rvd24tY29udmVydGVyJztcclxuXHJcbkBQaXBlKHsgbmFtZTogJ21hcmtlZCcgfSlcclxuZXhwb3J0IGNsYXNzIE1hcmtlZFBpcGUge1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtZGM6IE1hcmtkb3duQ29udmVydGVyKSB7IH1cclxuXHJcbiAgICB0cmFuc2Zvcm0odGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZGMudG9IdG1sKHRleHQpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC9tYXJrZG93bi9tYXJrZWQucGlwZS50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUk9VVEVSX0RJUkVDVElWRVMgfSAgZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUsIFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgQXBwU2VydmljZSwgUHJvamVjdFNlcnZpY2UsIFRhc2tTZXJ2aWNlLCBSZWZlcmVuY2VTZXJ2aWNlLCBTdGFmZlNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzJztcclxuaW1wb3J0IHsgSUF1dGhlZFN0YXRlIH0gZnJvbSAnLi9yZWR1Y2Vycy9hdXRoZWQucmVkdWNlcic7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UsIE5vdGlmaWNhdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vc2hhcmVkL25vdGlmaWNhdGlvbic7XHJcbmltcG9ydCB7IERST1BET1dOX0RJUkVDVElWRVMgfSBmcm9tICcuL3NoYXJlZC9kcm9wZG93bic7XHJcbmltcG9ydCB7IE5hdkNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9uYXYnO1xyXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi9tb2RlbHMvdXNlcic7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnYXBwJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RlbXBsYXRlcy9hcHAuaHRtbCcpLFxyXG4gICAgZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTLCBOYXZDb21wb25lbnQsIE5vdGlmaWNhdGlvbkNvbXBvbmVudCwgRFJPUERPV05fRElSRUNUSVZFU10sXHJcbiAgICBwcm92aWRlcnM6IFtOb3RpZmljYXRpb25TZXJ2aWNlXSxcclxuICAgIHBpcGVzOiBbVHJhbnNsYXRlUGlwZV1cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xyXG4gICAgcHJpdmF0ZSBzdWI6IGFueTtcclxuICAgIGlzUmVhZHk6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIGxvZ2dlZFVzZXI6IFVzZXI7XHJcbiAgICBsYW5ndWFnZTogYW55O1xyXG4gICAgSEVBREVSX1RJVExFOiBzdHJpbmcgPSAnUHJvamVjdHMnO1xyXG4gICAgaXNOYXZDb2xsYXBzZWQ6IEJvb2xlYW47XHJcbiAgICBpc1NlYXJjaE9wZW46IEJvb2xlYW47XHJcbiAgICBpc01vYmlsZURldmljZTogQm9vbGVhbjtcclxuICAgIHdvcmtzcGFjZVVybDogc3RyaW5nID0gJy9Xb3Jrc3BhY2UvcD9pZD13b3Jrc3BhY2UnO1xyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnLCBbJyRldmVudC50YXJnZXQnXSkgcmVzaXplKHdpbmRvdykgeyB0aGlzLm9uUmVzaXplKHdpbmRvdyk7IH07XHJcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLnBob25lJykgZ2V0IGRldmljZSgpIHsgcmV0dXJuIHRoaXMuaXNNb2JpbGVEZXZpY2U7IH07XHJcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLnNpZGUtbmF2LXRvZ2dsZScpIGdldCB0b2dnbGVOYXZWaXNpYmxlKCkgeyByZXR1cm4gdGhpcy5pc05hdkNvbGxhcHNlZDsgfTtcclxuICAgIEBIb3N0QmluZGluZygnY2xhc3Muc2VhcmNoLW9wZW4nKSBnZXQgdG9nZ2xlU2VhcmNoKCkgeyByZXR1cm4gdGhpcy5pc1NlYXJjaE9wZW47IH07XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogU3RvcmU8YW55PixcclxuICAgICAgICBwcml2YXRlIGFwcFNlcnZpY2U6IEFwcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByZWZlcmVuY2VTZXJ2aWNlOiBSZWZlcmVuY2VTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgc3RhZmZTZXJ2aWNlOiBTdGFmZlNlcnZpY2UsXHJcbiAgICAgICAgcHVibGljIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZVxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZS5zZWxlY3QoJ2F1dGhlZCcpLnN1YnNjcmliZSgoZGF0YTogSUF1dGhlZFN0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VkVXNlciA9IGRhdGEudXNlclByb2ZpbGU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3ViID0gdGhpcy5zdG9yZS5zZWxlY3QoJ3JlZmVyZW5jZScpO1xyXG5cclxuICAgICAgICB0aGlzLmFwcFNlcnZpY2UuZ2V0VXNlclByb2ZpbGUoKS5zdWJzY3JpYmUoYWN0aW9uID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFwcFNlcnZpY2UuaXNMb2dnZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlU2VydmljZS5sb2FkUmVmZXJlbmNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhZmZTZXJ2aWNlLmZldGNoT3JnYW5pemF0aW9ucygpLnN1YnNjcmliZShhY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhZmZTZXJ2aWNlLmZldGNoVXNlcnMoKS5zdWJzY3JpYmUoYWN0aW9uID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmlzU2VhcmNoT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNOYXZDb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvZ2dlZFVzZXIgPSBuZXcgVXNlcigpO1xyXG4gICAgICAgIHRoaXMuaXNNb2JpbGVEZXZpY2UgPSB0aGlzLmlzTW9iaWxlKCk7XHJcblxyXG4gICAgICAgIC8vIG5nMi10cmFuc2xhdGVcclxuICAgICAgICB2YXIgdXNlckxhbmcgPSBuYXZpZ2F0b3IubGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXTsgLy8gdXNlIG5hdmlnYXRvciBsYW5nIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIHVzZXJMYW5nID0gLyhydXxlbikvZ2kudGVzdCh1c2VyTGFuZykgPyB1c2VyTGFuZyA6ICdlbic7XHJcbiAgICAgICAgLy8gdGhpcyBsYW5ndWFnZSB3aWxsIGJlIHVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIGEgdHJhbnNsYXRpb24gaXNuJ3QgZm91bmQgaW4gdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZS5zZXREZWZhdWx0TGFuZygnZW4nKTtcclxuICAgICAgICAvLyB0aGUgbGFuZyB0byB1c2UsIGlmIHRoZSBsYW5nIGlzbid0IGF2YWlsYWJsZSwgaXQgd2lsbCB1c2UgdGhlIGN1cnJlbnQgbG9hZGVyIHRvIGdldCB0aGVtXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGUudXNlKCdlbicpOyAvLyB1c2VyTGFuZ1xyXG5cclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZS5nZXQoJ2JyYW5kJykuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMuSEVBREVSX1RJVExFID0gdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3ViICYmIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9nZ2xlTmF2KCkge1xyXG4gICAgICAgIHRoaXMuaXNOYXZDb2xsYXBzZWQgPSAhdGhpcy5pc05hdkNvbGxhcHNlZDtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlTmF2KGV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLmlzTmF2Q29sbGFwc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1NlYXJjaE9wZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2hUb2dnbGUoKSB7XHJcbiAgICAgICAgdGhpcy5pc1NlYXJjaE9wZW4gPSAhdGhpcy5pc1NlYXJjaE9wZW47XHJcbiAgICB9XHJcblxyXG4gICAgbG9nb3V0KGV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAvLyB0aGlzLmxvZ2dlZFVzZXIgPSBudWxsO1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJ0xvZ291dCc7XHJcbiAgICB9XHJcblxyXG4gICAgZ29CYWNrKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNb2JpbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBvblJlc2l6ZSh3aW5kb3cpIHtcclxuICAgICAgICB0aGlzLmlzTW9iaWxlRGV2aWNlID0gd2luZG93LmlubmVyV2lkdGggPD0gMTAyNCB8fCB0aGlzLmlzTW9iaWxlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvYXBwLmNvbXBvbmVudC50c1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvdXRlcl9saW5rXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvcm91dGVyX2xpbmsnKTtcbnZhciByb3V0ZXJfbGlua19hY3RpdmVfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9yb3V0ZXJfbGlua19hY3RpdmUnKTtcbnZhciByb3V0ZXJfb3V0bGV0XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvcm91dGVyX291dGxldCcpO1xudmFyIHJvdXRlcl8xID0gcmVxdWlyZSgnLi9yb3V0ZXInKTtcbmV4cG9ydHMuTmF2aWdhdGlvbkNhbmNlbCA9IHJvdXRlcl8xLk5hdmlnYXRpb25DYW5jZWw7XG5leHBvcnRzLk5hdmlnYXRpb25FbmQgPSByb3V0ZXJfMS5OYXZpZ2F0aW9uRW5kO1xuZXhwb3J0cy5OYXZpZ2F0aW9uRXJyb3IgPSByb3V0ZXJfMS5OYXZpZ2F0aW9uRXJyb3I7XG5leHBvcnRzLk5hdmlnYXRpb25TdGFydCA9IHJvdXRlcl8xLk5hdmlnYXRpb25TdGFydDtcbmV4cG9ydHMuUm91dGVyID0gcm91dGVyXzEuUm91dGVyO1xuZXhwb3J0cy5Sb3V0ZXNSZWNvZ25pemVkID0gcm91dGVyXzEuUm91dGVzUmVjb2duaXplZDtcbnZhciByb3V0ZXJfb3V0bGV0X21hcF8xID0gcmVxdWlyZSgnLi9yb3V0ZXJfb3V0bGV0X21hcCcpO1xuZXhwb3J0cy5Sb3V0ZXJPdXRsZXRNYXAgPSByb3V0ZXJfb3V0bGV0X21hcF8xLlJvdXRlck91dGxldE1hcDtcbnZhciByb3V0ZXJfcHJvdmlkZXJzXzEgPSByZXF1aXJlKCcuL3JvdXRlcl9wcm92aWRlcnMnKTtcbmV4cG9ydHMucHJvdmlkZVJvdXRlciA9IHJvdXRlcl9wcm92aWRlcnNfMS5wcm92aWRlUm91dGVyO1xudmFyIHJvdXRlcl9zdGF0ZV8xID0gcmVxdWlyZSgnLi9yb3V0ZXJfc3RhdGUnKTtcbmV4cG9ydHMuQWN0aXZhdGVkUm91dGUgPSByb3V0ZXJfc3RhdGVfMS5BY3RpdmF0ZWRSb3V0ZTtcbmV4cG9ydHMuQWN0aXZhdGVkUm91dGVTbmFwc2hvdCA9IHJvdXRlcl9zdGF0ZV8xLkFjdGl2YXRlZFJvdXRlU25hcHNob3Q7XG5leHBvcnRzLlJvdXRlclN0YXRlID0gcm91dGVyX3N0YXRlXzEuUm91dGVyU3RhdGU7XG5leHBvcnRzLlJvdXRlclN0YXRlU25hcHNob3QgPSByb3V0ZXJfc3RhdGVfMS5Sb3V0ZXJTdGF0ZVNuYXBzaG90O1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbmV4cG9ydHMuUFJJTUFSWV9PVVRMRVQgPSBzaGFyZWRfMS5QUklNQVJZX09VVExFVDtcbnZhciB1cmxfc2VyaWFsaXplcl8xID0gcmVxdWlyZSgnLi91cmxfc2VyaWFsaXplcicpO1xuZXhwb3J0cy5EZWZhdWx0VXJsU2VyaWFsaXplciA9IHVybF9zZXJpYWxpemVyXzEuRGVmYXVsdFVybFNlcmlhbGl6ZXI7XG5leHBvcnRzLlVybFNlcmlhbGl6ZXIgPSB1cmxfc2VyaWFsaXplcl8xLlVybFNlcmlhbGl6ZXI7XG52YXIgdXJsX3RyZWVfMSA9IHJlcXVpcmUoJy4vdXJsX3RyZWUnKTtcbmV4cG9ydHMuVXJsUGF0aFdpdGhQYXJhbXMgPSB1cmxfdHJlZV8xLlVybFBhdGhXaXRoUGFyYW1zO1xuZXhwb3J0cy5VcmxUcmVlID0gdXJsX3RyZWVfMS5VcmxUcmVlO1xuZXhwb3J0cy5ST1VURVJfRElSRUNUSVZFUyA9IFtyb3V0ZXJfb3V0bGV0XzEuUm91dGVyT3V0bGV0LCByb3V0ZXJfbGlua18xLlJvdXRlckxpbmssIHJvdXRlcl9saW5rX2FjdGl2ZV8xLlJvdXRlckxpbmtBY3RpdmVdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOXpjbU12YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxEUkNRVUY1UWl3d1FrRkJNRUlzUTBGQlF5eERRVUZCTzBGQlEzQkVMRzFEUVVFclFpeHBRMEZCYVVNc1EwRkJReXhEUVVGQk8wRkJRMnBGTERoQ1FVRXlRaXcwUWtGQk5FSXNRMEZCUXl4RFFVRkJPMEZCUzNoRUxIVkNRVUZwU0N4VlFVRlZMRU5CUVVNN1FVRkJOMGNzY1VSQlFXZENPMEZCUVVVc0swTkJRV0U3UVVGQlJTeHRSRUZCWlR0QlFVRkZMRzFFUVVGbE8wRkJRVVVzYVVOQlFVMDdRVUZCUlN4eFJFRkJhME03UVVGRE5VZ3NhME5CUVRoQ0xIRkNRVUZ4UWl4RFFVRkRPMEZCUVRWRExEaEVRVUUwUXp0QlFVTndSQ3hwUTBGQk5FSXNiMEpCUVc5Q0xFTkJRVU03UVVGQmVrTXNlVVJCUVhsRE8wRkJRMnBFTERaQ1FVRjFSaXhuUWtGQlowSXNRMEZCUXp0QlFVRm9SeXgxUkVGQll6dEJRVUZGTEhWRlFVRnpRanRCUVVGRkxHbEVRVUZYTzBGQlFVVXNhVVZCUVRKRE8wRkJRM2hITEhWQ1FVRnhReXhWUVVGVkxFTkJRVU03UVVGQmVFTXNhVVJCUVhkRE8wRkJRMmhFTEN0Q1FVRnJSQ3hyUWtGQmEwSXNRMEZCUXp0QlFVRTNSQ3h4UlVGQmIwSTdRVUZCUlN4MVJFRkJkVU03UVVGRGNrVXNlVUpCUVhsRExGbEJRVmtzUTBGQlF6dEJRVUU1UXl4NVJFRkJhVUk3UVVGQlJTeHhRMEZCTWtJN1FVRkZla01zZVVKQlFXbENMRWRCUVVjc1EwRkJReXcwUWtGQldTeEZRVUZGTEhkQ1FVRlZMRVZCUVVVc2NVTkJRV2RDTEVOQlFVTXNRMEZCUXlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltbHRjRzl5ZENCN1VtOTFkR1Z5VEdsdWEzMGdabkp2YlNBbkxpOWthWEpsWTNScGRtVnpMM0p2ZFhSbGNsOXNhVzVySnp0Y2JtbHRjRzl5ZENCN1VtOTFkR1Z5VEdsdWEwRmpkR2wyWlgwZ1puSnZiU0FuTGk5a2FYSmxZM1JwZG1WekwzSnZkWFJsY2w5c2FXNXJYMkZqZEdsMlpTYzdYRzVwYlhCdmNuUWdlMUp2ZFhSbGNrOTFkR3hsZEgwZ1puSnZiU0FuTGk5a2FYSmxZM1JwZG1WekwzSnZkWFJsY2w5dmRYUnNaWFFuTzF4dVhHNWxlSEJ2Y25RZ2UwVjRkSEpoVDNCMGFXOXVjMzBnWm5KdmJTQW5MaTlqYjIxdGIyNWZjbTkxZEdWeVgzQnliM1pwWkdWeWN5YzdYRzVsZUhCdmNuUWdlMUp2ZFhSbExDQlNiM1YwWlhKRGIyNW1hV2Q5SUdaeWIyMGdKeTR2WTI5dVptbG5KenRjYm1WNGNHOXlkQ0I3UTJGdVFXTjBhWFpoZEdVc0lFTmhia1JsWVdOMGFYWmhkR1Y5SUdaeWIyMGdKeTR2YVc1MFpYSm1ZV05sY3ljN1hHNWxlSEJ2Y25RZ2UwVjJaVzUwTENCT1lYWnBaMkYwYVc5dVEyRnVZMlZzTENCT1lYWnBaMkYwYVc5dVJXNWtMQ0JPWVhacFoyRjBhVzl1UlhKeWIzSXNJRTVoZG1sbllYUnBiMjVUZEdGeWRDd2dVbTkxZEdWeUxDQlNiM1YwWlhOU1pXTnZaMjVwZW1Wa2ZTQm1jbTl0SUNjdUwzSnZkWFJsY2ljN1hHNWxlSEJ2Y25RZ2UxSnZkWFJsY2s5MWRHeGxkRTFoY0gwZ1puSnZiU0FuTGk5eWIzVjBaWEpmYjNWMGJHVjBYMjFoY0NjN1hHNWxlSEJ2Y25RZ2UzQnliM1pwWkdWU2IzVjBaWEo5SUdaeWIyMGdKeTR2Y205MWRHVnlYM0J5YjNacFpHVnljeWM3WEc1bGVIQnZjblFnZTBGamRHbDJZWFJsWkZKdmRYUmxMQ0JCWTNScGRtRjBaV1JTYjNWMFpWTnVZWEJ6YUc5MExDQlNiM1YwWlhKVGRHRjBaU3dnVW05MWRHVnlVM1JoZEdWVGJtRndjMmh2ZEgwZ1puSnZiU0FuTGk5eWIzVjBaWEpmYzNSaGRHVW5PMXh1Wlhod2IzSjBJSHRRVWtsTlFWSlpYMDlWVkV4RlZDd2dVR0Z5WVcxemZTQm1jbTl0SUNjdUwzTm9ZWEpsWkNjN1hHNWxlSEJ2Y25RZ2UwUmxabUYxYkhSVmNteFRaWEpwWVd4cGVtVnlMQ0JWY214VFpYSnBZV3hwZW1WeWZTQm1jbTl0SUNjdUwzVnliRjl6WlhKcFlXeHBlbVZ5Snp0Y2JtVjRjRzl5ZENCN1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhNc0lGVnliRlJ5WldWOUlHWnliMjBnSnk0dmRYSnNYM1J5WldVbk8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1VrOVZWRVZTWDBSSlVrVkRWRWxXUlZNZ1BTQmJVbTkxZEdWeVQzVjBiR1YwTENCU2IzVjBaWEpNYVc1ckxDQlNiM1YwWlhKTWFXNXJRV04wYVhabFhUc2lYWDA9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQGFuZ3VsYXIvcm91dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKCcuLi9yb3V0ZXInKTtcbnZhciByb3V0ZXJfc3RhdGVfMSA9IHJlcXVpcmUoJy4uL3JvdXRlcl9zdGF0ZScpO1xudmFyIFJvdXRlckxpbmsgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlckxpbmsocm91dGVyLCByb3V0ZSwgbG9jYXRpb25TdHJhdGVneSkge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uU3RyYXRlZ3kgPSBsb2NhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJvdXRlckxpbmsucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHsgdGhpcy51cGRhdGVUYXJnZXRVcmxBbmRIcmVmKCk7IH07XG4gICAgUm91dGVyTGluay5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChidXR0b24sIGN0cmxLZXksIG1ldGFLZXkpIHtcbiAgICAgICAgaWYgKGJ1dHRvbiAhPT0gMCB8fCBjdHJsS2V5IHx8IG1ldGFLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICdzdHJpbmcnICYmIHRoaXMudGFyZ2V0ICE9ICdfc2VsZicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodGhpcy51cmxUcmVlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUm91dGVyTGluay5wcm90b3R5cGUudXBkYXRlVGFyZ2V0VXJsQW5kSHJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cmxUcmVlID0gdGhpcy5yb3V0ZXIuY3JlYXRlVXJsVHJlZSh0aGlzLmNvbW1hbmRzLCB7IHJlbGF0aXZlVG86IHRoaXMucm91dGUsIHF1ZXJ5UGFyYW1zOiB0aGlzLnF1ZXJ5UGFyYW1zLCBmcmFnbWVudDogdGhpcy5mcmFnbWVudCB9KTtcbiAgICAgICAgaWYgKHRoaXMudXJsVHJlZSkge1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5sb2NhdGlvblN0cmF0ZWd5LnByZXBhcmVFeHRlcm5hbFVybCh0aGlzLnJvdXRlci5zZXJpYWxpemVVcmwodGhpcy51cmxUcmVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwiZnJhZ21lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkhvc3RCaW5kaW5nKCksIFxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJocmVmXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LmJ1dHRvbicsICckZXZlbnQuY3RybEtleScsICckZXZlbnQubWV0YUtleSddKSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgRnVuY3Rpb24pLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbTnVtYmVyLCBCb29sZWFuLCBCb29sZWFuXSksIFxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cmV0dXJudHlwZScsIEJvb2xlYW4pXG4gICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbiAgICBSb3V0ZXJMaW5rID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tyb3V0ZXJMaW5rXScgfSksIFxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtyb3V0ZXJfMS5Sb3V0ZXIsIHJvdXRlcl9zdGF0ZV8xLkFjdGl2YXRlZFJvdXRlLCBjb21tb25fMS5Mb2NhdGlvblN0cmF0ZWd5XSlcbiAgICBdLCBSb3V0ZXJMaW5rKTtcbiAgICByZXR1cm4gUm91dGVyTGluaztcbn0oKSk7XG5leHBvcnRzLlJvdXRlckxpbmsgPSBSb3V0ZXJMaW5rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY205MWRHVnlYMnhwYm1zdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdseVpXTjBhWFpsY3k5eWIzVjBaWEpmYkdsdWF5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUVVFc2RVSkJRU3RDTEdsQ1FVRnBRaXhEUVVGRExFTkJRVUU3UVVGRGFrUXNjVUpCUVhGRkxHVkJRV1VzUTBGQlF5eERRVUZCTzBGQlJYSkdMSFZDUVVGeFFpeFhRVUZYTEVOQlFVTXNRMEZCUVR0QlFVTnFReXcyUWtGQk5rSXNhVUpCUVdsQ0xFTkJRVU1zUTBGQlFUdEJRU3RDTDBNN1NVRmpSU3h2UWtGRFdTeE5RVUZqTEVWQlFWVXNTMEZCY1VJc1JVRkROME1zWjBKQlFXdERPMUZCUkd4RExGZEJRVTBzUjBGQlRpeE5RVUZOTEVOQlFWRTdVVUZCVlN4VlFVRkxMRWRCUVV3c1MwRkJTeXhEUVVGblFqdFJRVU0zUXl4eFFrRkJaMElzUjBGQmFFSXNaMEpCUVdkQ0xFTkJRV3RDTzFGQlpIUkRMR0ZCUVZFc1IwRkJWU3hGUVVGRkxFTkJRVU03U1VGamIwSXNRMEZCUXp0SlFVZHNSQ3h6UWtGQlNTeHJRMEZCVlR0aFFVRmtMRlZCUVdVc1NVRkJhMEk3V1VGREwwSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM2hDTEVsQlFVa3NRMEZCUXl4UlFVRlJMRWRCUVZFc1NVRkJTU3hEUVVGRE8xbEJRelZDTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeEpRVUZKTEVOQlFVTXNVVUZCVVN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRGVrSXNRMEZCUXp0UlFVTklMRU5CUVVNN096dFBRVUZCTzBsQlJVUXNaME5CUVZjc1IwRkJXQ3hWUVVGWkxFOUJRVmNzU1VGQlV5eEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZIYUVVc05FSkJRVThzUjBGQlVDeFZRVUZSTEUxQlFXTXNSVUZCUlN4UFFVRm5RaXhGUVVGRkxFOUJRV2RDTzFGQlEzaEVMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVsQlFVa3NUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRSUVVOa0xFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRWxCUVVrc1EwRkJReXhOUVVGTkxFdEJRVXNzVVVGQlVTeEpRVUZKTEVsQlFVa3NRMEZCUXl4TlFVRk5MRWxCUVVrc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU01UkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dFJRVVZFTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTjRReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBsQlEyWXNRMEZCUXp0SlFVVlBMREpEUVVGelFpeEhRVUU1UWp0UlFVTkZMRWxCUVVrc1EwRkJReXhQUVVGUExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUTNCRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlEySXNSVUZCUXl4VlFVRlZMRVZCUVVVc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZYTEVWQlFVVXNTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSU3hSUVVGUkxFVkJRVVVzU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUXl4RFFVRkRMRU5CUVVNN1VVRkRkRVlzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrSXNTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMMFlzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZxUkVRN1VVRkJReXhaUVVGTExFVkJRVVU3T3poRFFVRkJPMGxCUlZJN1VVRkJReXhaUVVGTExFVkJRVVU3TzIxRVFVRkJPMGxCUTFJN1VVRkJReXhaUVVGTExFVkJRVVU3TzJkRVFVRkJPMGxCUjFJN1VVRkJReXhyUWtGQlZ5eEZRVUZGT3pzMFEwRkJRVHRKUVZka08xRkJRVU1zV1VGQlN5eEZRVUZGT3pzN1owUkJRVUU3U1VGWFVqdFJRVUZETEcxQ1FVRlpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zWlVGQlpTeEZRVUZGTEdkQ1FVRm5RaXhGUVVGRkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNN096czdOa05CUVVFN1NVRTVRaTlGTzFGQlFVTXNaMEpCUVZNc1EwRkJReXhGUVVGRExGRkJRVkVzUlVGQlJTeGpRVUZqTEVWQlFVTXNRMEZCUXpzN2EwSkJRVUU3U1VGdlJIUkRMR2xDUVVGRE8wRkJRVVFzUTBGQlF5eEJRVzVFUkN4SlFXMUVRenRCUVc1RVdTeHJRa0ZCVlN4aFFXMUVkRUlzUTBGQlFTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdURzlqWVhScGIyNVRkSEpoZEdWbmVYMGdabkp2YlNBblFHRnVaM1ZzWVhJdlkyOXRiVzl1Snp0Y2JtbHRjRzl5ZENCN1JHbHlaV04wYVhabExDQkliM04wUW1sdVpHbHVaeXdnU0c5emRFeHBjM1JsYm1WeUxDQkpibkIxZEN3Z1QyNURhR0Z1WjJWemZTQm1jbTl0SUNkQVlXNW5kV3hoY2k5amIzSmxKenRjYmx4dWFXMXdiM0owSUh0U2IzVjBaWEo5SUdaeWIyMGdKeTR1TDNKdmRYUmxjaWM3WEc1cGJYQnZjblFnZTBGamRHbDJZWFJsWkZKdmRYUmxmU0JtY205dElDY3VMaTl5YjNWMFpYSmZjM1JoZEdVbk8xeHVhVzF3YjNKMElIdFZjbXhVY21WbGZTQm1jbTl0SUNjdUxpOTFjbXhmZEhKbFpTYzdYRzVjYmx4dVhHNHZLaXBjYmlBcUlGUm9aU0JTYjNWMFpYSk1hVzVySUdScGNtVmpkR2wyWlNCc1pYUnpJSGx2ZFNCc2FXNXJJSFJ2SUhOd1pXTnBabWxqSUhCaGNuUnpJRzltSUhsdmRYSWdZWEJ3TGx4dUlDcGNiaUFxSUVOdmJuTnBaR1Z5SUhSb1pTQm1iMnhzYjNkcGJtY2djbTkxZEdVZ1kyOXVabWxuZFhKaGRHbHZianBjYmx4dUlDb2dZR0JnWEc0Z0tpQmJleUJ3WVhSb09pQW5MM1Z6WlhJbkxDQmpiMjF3YjI1bGJuUTZJRlZ6WlhKRGJYQWdmVjFjYmlBcUlHQmdZRnh1SUNwY2JpQXFJRmRvWlc0Z2JHbHVhMmx1WnlCMGJ5QjBhR2x6SUdCVmMyVnlZQ0J5YjNWMFpTd2dlVzkxSUdOaGJpQjNjbWwwWlRwY2JpQXFYRzRnS2lCZ1lHQmNiaUFxSUR4aElGdHliM1YwWlhKTWFXNXJYVDFjSWxzbkwzVnpaWEluWFZ3aVBteHBibXNnZEc4Z2RYTmxjaUJqYjIxd2IyNWxiblE4TDJFK1hHNGdLaUJnWUdCY2JpQXFYRzRnS2lCU2IzVjBaWEpNYVc1cklHVjRjR1ZqZEhNZ2RHaGxJSFpoYkhWbElIUnZJR0psSUdGdUlHRnljbUY1SUc5bUlIQmhkR2dnYzJWbmJXVnVkSE1zSUdadmJHeHZkMlZrSUdKNUlIUm9aU0J3WVhKaGJYTmNiaUFxSUdadmNpQjBhR0YwSUd4bGRtVnNJRzltSUhKdmRYUnBibWN1SUVadmNpQnBibk4wWVc1alpTQmdXeWN2ZEdWaGJTY3NJSHQwWldGdFNXUTZJREY5TENBbmRYTmxjaWNzSUh0MWMyVnlTV1E2SURKOVhXQmNiaUFxSUcxbFlXNXpJSFJvWVhRZ2QyVWdkMkZ1ZENCMGJ5Qm5aVzVsY21GMFpTQmhJR3hwYm1zZ2RHOGdZQzkwWldGdE8zUmxZVzFKWkQweEwzVnpaWEk3ZFhObGNrbGtQVEpnTGx4dUlDcGNiaUFxSUZSb1pTQm1hWEp6ZENCelpXZHRaVzUwSUc1aGJXVWdZMkZ1SUdKbElIQnlaWEJsYm1SbFpDQjNhWFJvSUdBdllDd2dZQzR2WUN3Z2IzSWdZQzR1TDJBdVhHNGdLaUJKWmlCMGFHVWdjMlZuYldWdWRDQmlaV2RwYm5NZ2QybDBhQ0JnTDJBc0lIUm9aU0J5YjNWMFpYSWdkMmxzYkNCc2IyOXJJSFZ3SUhSb1pTQnliM1YwWlNCbWNtOXRJSFJvWlNCeWIyOTBJRzltSUhSb1pTQmhjSEF1WEc0Z0tpQkpaaUIwYUdVZ2MyVm5iV1Z1ZENCaVpXZHBibk1nZDJsMGFDQmdMaTlnTENCdmNpQmtiMlZ6YmlkMElHSmxaMmx1SUhkcGRHZ2dZU0J6YkdGemFDd2dkR2hsSUhKdmRYUmxjaUIzYVd4c1hHNGdLaUJwYm5OMFpXRmtJR3h2YjJzZ2FXNGdkR2hsSUdOMWNuSmxiblFnWTI5dGNHOXVaVzUwSjNNZ1kyaHBiR1J5Wlc0Z1ptOXlJSFJvWlNCeWIzVjBaUzVjYmlBcUlFRnVaQ0JwWmlCMGFHVWdjMlZuYldWdWRDQmlaV2RwYm5NZ2QybDBhQ0JnTGk0dllDd2dkR2hsSUhKdmRYUmxjaUIzYVd4c0lHZHZJSFZ3SUc5dVpTQnNaWFpsYkM1Y2JpQXFMMXh1UUVScGNtVmpkR2wyWlNoN2MyVnNaV04wYjNJNklDZGJjbTkxZEdWeVRHbHVhMTBuZlNsY2JtVjRjRzl5ZENCamJHRnpjeUJTYjNWMFpYSk1hVzVySUdsdGNHeGxiV1Z1ZEhNZ1QyNURhR0Z1WjJWeklIdGNiaUFnUUVsdWNIVjBLQ2tnZEdGeVoyVjBPaUJ6ZEhKcGJtYzdYRzRnSUhCeWFYWmhkR1VnWTI5dGJXRnVaSE02SUdGdWVWdGRJRDBnVzEwN1hHNGdJRUJKYm5CMWRDZ3BJSEYxWlhKNVVHRnlZVzF6T2lCN1cyczZJSE4wY21sdVoxMDZJR0Z1ZVgwN1hHNGdJRUJKYm5CMWRDZ3BJR1p5WVdkdFpXNTBPaUJ6ZEhKcGJtYzdYRzVjYmlBZ0x5OGdkR2hsSUhWeWJDQmthWE53YkdGNVpXUWdiMjRnZEdobElHRnVZMmh2Y2lCbGJHVnRaVzUwTGx4dUlDQkFTRzl6ZEVKcGJtUnBibWNvS1NCb2NtVm1PaUJ6ZEhKcGJtYzdYRzVjYmlBZ2RYSnNWSEpsWlRvZ1ZYSnNWSEpsWlR0Y2JseHVJQ0F2S2lwY2JpQWdJQ29nUUdsdWRHVnlibUZzWEc0Z0lDQXFMMXh1SUNCamIyNXpkSEoxWTNSdmNpaGNiaUFnSUNBZ0lIQnlhWFpoZEdVZ2NtOTFkR1Z5T2lCU2IzVjBaWElzSUhCeWFYWmhkR1VnY205MWRHVTZJRUZqZEdsMllYUmxaRkp2ZFhSbExGeHVJQ0FnSUNBZ2NISnBkbUYwWlNCc2IyTmhkR2x2YmxOMGNtRjBaV2Q1T2lCTWIyTmhkR2x2YmxOMGNtRjBaV2Q1S1NCN2ZWeHVYRzRnSUVCSmJuQjFkQ2dwWEc0Z0lITmxkQ0J5YjNWMFpYSk1hVzVyS0dSaGRHRTZJR0Z1ZVZ0ZGZITjBjbWx1WnlrZ2UxeHVJQ0FnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0dSaGRHRXBLU0I3WEc0Z0lDQWdJQ0IwYUdsekxtTnZiVzFoYm1SeklEMGdQR0Z1ZVQ1a1lYUmhPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCMGFHbHpMbU52YlcxaGJtUnpJRDBnVzJSaGRHRmRPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJRzVuVDI1RGFHRnVaMlZ6S0dOb1lXNW5aWE02SUh0OUtUb2dZVzU1SUhzZ2RHaHBjeTUxY0dSaGRHVlVZWEpuWlhSVmNteEJibVJJY21WbUtDazdJSDFjYmx4dUlDQkFTRzl6ZEV4cGMzUmxibVZ5S0NkamJHbGpheWNzSUZzbkpHVjJaVzUwTG1KMWRIUnZiaWNzSUNja1pYWmxiblF1WTNSeWJFdGxlU2NzSUNja1pYWmxiblF1YldWMFlVdGxlU2RkS1Z4dUlDQnZia05zYVdOcktHSjFkSFJ2YmpvZ2JuVnRZbVZ5TENCamRISnNTMlY1T2lCaWIyOXNaV0Z1TENCdFpYUmhTMlY1T2lCaWIyOXNaV0Z1S1RvZ1ltOXZiR1ZoYmlCN1hHNGdJQ0FnYVdZZ0tHSjFkSFJ2YmlBaFBUMGdNQ0I4ZkNCamRISnNTMlY1SUh4OElHMWxkR0ZMWlhrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGNuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdkR2hwY3k1MFlYSm5aWFFnUFQwOUlDZHpkSEpwYm1jbklDWW1JSFJvYVhNdWRHRnlaMlYwSUNFOUlDZGZjMlZzWmljcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGNuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIUm9hWE11Y205MWRHVnlMbTVoZG1sbllYUmxRbmxWY213b2RHaHBjeTUxY214VWNtVmxLVHRjYmlBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lIMWNibHh1SUNCd2NtbDJZWFJsSUhWd1pHRjBaVlJoY21kbGRGVnliRUZ1WkVoeVpXWW9LVG9nZG05cFpDQjdYRzRnSUNBZ2RHaHBjeTUxY214VWNtVmxJRDBnZEdocGN5NXliM1YwWlhJdVkzSmxZWFJsVlhKc1ZISmxaU2hjYmlBZ0lDQWdJQ0FnZEdocGN5NWpiMjF0WVc1a2N5eGNiaUFnSUNBZ0lDQWdlM0psYkdGMGFYWmxWRzg2SUhSb2FYTXVjbTkxZEdVc0lIRjFaWEo1VUdGeVlXMXpPaUIwYUdsekxuRjFaWEo1VUdGeVlXMXpMQ0JtY21GbmJXVnVkRG9nZEdocGN5NW1jbUZuYldWdWRIMHBPMXh1SUNBZ0lHbG1JQ2gwYUdsekxuVnliRlJ5WldVcElIdGNiaUFnSUNBZ0lIUm9hWE11YUhKbFppQTlJSFJvYVhNdWJHOWpZWFJwYjI1VGRISmhkR1ZuZVM1d2NtVndZWEpsUlhoMFpYSnVZV3hWY213b2RHaHBjeTV5YjNWMFpYSXVjMlZ5YVdGc2FYcGxWWEpzS0hSb2FYTXVkWEpzVkhKbFpTa3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dWZWeHVJbDE5XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQGFuZ3VsYXIvcm91dGVyL2RpcmVjdGl2ZXMvcm91dGVyX2xpbmsuanNcbiAqKiBtb2R1bGUgaWQgPSAzOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvbWFwJyk7XG5yZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9zY2FuJyk7XG5yZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcCcpO1xucmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0Jyk7XG5yZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9jb25jYXRNYXAnKTtcbnJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL2V2ZXJ5Jyk7XG5yZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZUFsbCcpO1xucmVxdWlyZSgncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tJyk7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJ3J4anMvU3ViamVjdCcpO1xudmFyIG9mXzEgPSByZXF1aXJlKCdyeGpzL29ic2VydmFibGUvb2YnKTtcbnZhciBhcHBseV9yZWRpcmVjdHNfMSA9IHJlcXVpcmUoJy4vYXBwbHlfcmVkaXJlY3RzJyk7XG52YXIgY29uZmlnXzEgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIGNyZWF0ZV9yb3V0ZXJfc3RhdGVfMSA9IHJlcXVpcmUoJy4vY3JlYXRlX3JvdXRlcl9zdGF0ZScpO1xudmFyIGNyZWF0ZV91cmxfdHJlZV8xID0gcmVxdWlyZSgnLi9jcmVhdGVfdXJsX3RyZWUnKTtcbnZhciByZWNvZ25pemVfMSA9IHJlcXVpcmUoJy4vcmVjb2duaXplJyk7XG52YXIgcmVzb2x2ZV8xID0gcmVxdWlyZSgnLi9yZXNvbHZlJyk7XG52YXIgcm91dGVyX291dGxldF9tYXBfMSA9IHJlcXVpcmUoJy4vcm91dGVyX291dGxldF9tYXAnKTtcbnZhciByb3V0ZXJfc3RhdGVfMSA9IHJlcXVpcmUoJy4vcm91dGVyX3N0YXRlJyk7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xudmFyIHVybF90cmVlXzEgPSByZXF1aXJlKCcuL3VybF90cmVlJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi91dGlscy9jb2xsZWN0aW9uJyk7XG52YXIgTmF2aWdhdGlvblN0YXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uU3RhcnQoaWQsIHVybCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbiAgICBOYXZpZ2F0aW9uU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJOYXZpZ2F0aW9uU3RhcnQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInKVwiOyB9O1xuICAgIHJldHVybiBOYXZpZ2F0aW9uU3RhcnQ7XG59KCkpO1xuZXhwb3J0cy5OYXZpZ2F0aW9uU3RhcnQgPSBOYXZpZ2F0aW9uU3RhcnQ7XG52YXIgTmF2aWdhdGlvbkVuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbkVuZChpZCwgdXJsLCB1cmxBZnRlclJlZGlyZWN0cykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgfVxuICAgIE5hdmlnYXRpb25FbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJOYXZpZ2F0aW9uRW5kKGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTmF2aWdhdGlvbkVuZDtcbn0oKSk7XG5leHBvcnRzLk5hdmlnYXRpb25FbmQgPSBOYXZpZ2F0aW9uRW5kO1xudmFyIE5hdmlnYXRpb25DYW5jZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdmlnYXRpb25DYW5jZWwoaWQsIHVybCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbiAgICBOYXZpZ2F0aW9uQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiTmF2aWdhdGlvbkNhbmNlbChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicpXCI7IH07XG4gICAgcmV0dXJuIE5hdmlnYXRpb25DYW5jZWw7XG59KCkpO1xuZXhwb3J0cy5OYXZpZ2F0aW9uQ2FuY2VsID0gTmF2aWdhdGlvbkNhbmNlbDtcbnZhciBOYXZpZ2F0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdmlnYXRpb25FcnJvcihpZCwgdXJsLCBlcnJvcikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIE5hdmlnYXRpb25FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk5hdmlnYXRpb25FcnJvcihpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIGVycm9yOiBcIiArIHRoaXMuZXJyb3IgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBOYXZpZ2F0aW9uRXJyb3I7XG59KCkpO1xuZXhwb3J0cy5OYXZpZ2F0aW9uRXJyb3IgPSBOYXZpZ2F0aW9uRXJyb3I7XG52YXIgUm91dGVzUmVjb2duaXplZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVzUmVjb2duaXplZChpZCwgdXJsLCB1cmxBZnRlclJlZGlyZWN0cywgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIFJvdXRlc1JlY29nbml6ZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSb3V0ZXNSZWNvZ25pemVkKGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicsIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBSb3V0ZXNSZWNvZ25pemVkO1xufSgpKTtcbmV4cG9ydHMuUm91dGVzUmVjb2duaXplZCA9IFJvdXRlc1JlY29nbml6ZWQ7XG52YXIgUm91dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXIocm9vdENvbXBvbmVudFR5cGUsIHJlc29sdmVyLCB1cmxTZXJpYWxpemVyLCBvdXRsZXRNYXAsIGxvY2F0aW9uLCBpbmplY3RvciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMucm9vdENvbXBvbmVudFR5cGUgPSByb290Q29tcG9uZW50VHlwZTtcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgICB0aGlzLnVybFNlcmlhbGl6ZXIgPSB1cmxTZXJpYWxpemVyO1xuICAgICAgICB0aGlzLm91dGxldE1hcCA9IG91dGxldE1hcDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbklkID0gMDtcbiAgICAgICAgdGhpcy5yZXNldENvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLnJvdXRlckV2ZW50cyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRVcmxUcmVlID0gdXJsX3RyZWVfMS5jcmVhdGVFbXB0eVVybFRyZWUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Um91dGVyU3RhdGUgPSByb3V0ZXJfc3RhdGVfMS5jcmVhdGVFbXB0eVN0YXRlKHRoaXMuY3VycmVudFVybFRyZWUsIHRoaXMucm9vdENvbXBvbmVudFR5cGUpO1xuICAgIH1cbiAgICBSb3V0ZXIucHJvdG90eXBlLmluaXRpYWxOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5sb2NhdGlvbi5wYXRoKCkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlci5wcm90b3R5cGUsIFwicm91dGVyU3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY3VycmVudFJvdXRlclN0YXRlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplVXJsKHRoaXMuY3VycmVudFVybFRyZWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyLnByb3RvdHlwZSwgXCJldmVudHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyRXZlbnRzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWdfMS52YWxpZGF0ZUNvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5sb2NhdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUuY3JlYXRlVXJsVHJlZSA9IGZ1bmN0aW9uIChjb21tYW5kcywgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJlbGF0aXZlVG8gPSBfYi5yZWxhdGl2ZVRvLCBxdWVyeVBhcmFtcyA9IF9iLnF1ZXJ5UGFyYW1zLCBmcmFnbWVudCA9IF9iLmZyYWdtZW50O1xuICAgICAgICB2YXIgYSA9IHJlbGF0aXZlVG8gPyByZWxhdGl2ZVRvIDogdGhpcy5yb3V0ZXJTdGF0ZS5yb290O1xuICAgICAgICByZXR1cm4gY3JlYXRlX3VybF90cmVlXzEuY3JlYXRlVXJsVHJlZShhLCB0aGlzLmN1cnJlbnRVcmxUcmVlLCBjb21tYW5kcywgcXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbiAgICB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGVCeVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIHVybF90cmVlXzEuVXJsVHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKHVybCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVybFRyZWUgPSB0aGlzLnVybFNlcmlhbGl6ZXIucGFyc2UodXJsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlTmF2aWdhdGlvbih1cmxUcmVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAoY29tbWFuZHMsIGV4dHJhcykge1xuICAgICAgICBpZiAoZXh0cmFzID09PSB2b2lkIDApIHsgZXh0cmFzID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKHRoaXMuY3JlYXRlVXJsVHJlZShjb21tYW5kcywgZXh0cmFzKSwgZmFsc2UpO1xuICAgIH07XG4gICAgUm91dGVyLnByb3RvdHlwZS5zZXJpYWxpemVVcmwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiB0aGlzLnVybFNlcmlhbGl6ZXIuc2VyaWFsaXplKHVybCk7IH07XG4gICAgUm91dGVyLnByb3RvdHlwZS5wYXJzZVVybCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIHRoaXMudXJsU2VyaWFsaXplci5wYXJzZSh1cmwpOyB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUuc2NoZWR1bGVOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKHVybCwgcHJldmVudFB1c2hTdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSArK3RoaXMubmF2aWdhdGlvbklkO1xuICAgICAgICB0aGlzLnJvdXRlckV2ZW50cy5uZXh0KG5ldyBOYXZpZ2F0aW9uU3RhcnQoaWQsIHRoaXMuc2VyaWFsaXplVXJsKHVybCkpKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnJ1bk5hdmlnYXRlKHVybCwgcHJldmVudFB1c2hTdGF0ZSwgaWQpOyB9KTtcbiAgICB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUuc2V0VXBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNjaGVkdWxlTmF2aWdhdGlvbihfdGhpcy51cmxTZXJpYWxpemVyLnBhcnNlKGNoYW5nZVsndXJsJ10pLCBjaGFuZ2VbJ3BvcCddKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJ1bk5hdmlnYXRlID0gZnVuY3Rpb24gKHVybCwgcHJldmVudFB1c2hTdGF0ZSwgaWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGlkICE9PSB0aGlzLm5hdmlnYXRpb25JZCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5nbyh0aGlzLnVybFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMuY3VycmVudFVybFRyZWUpKTtcbiAgICAgICAgICAgIHRoaXMucm91dGVyRXZlbnRzLm5leHQobmV3IE5hdmlnYXRpb25DYW5jZWwoaWQsIHRoaXMuc2VyaWFsaXplVXJsKHVybCkpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkVXJsO1xuICAgICAgICAgICAgdmFyIHN0YXRlO1xuICAgICAgICAgICAgYXBwbHlfcmVkaXJlY3RzXzEuYXBwbHlSZWRpcmVjdHModXJsLCBfdGhpcy5jb25maWcpXG4gICAgICAgICAgICAgICAgLm1lcmdlTWFwKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFVybCA9IHU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZV8xLnJlY29nbml6ZShfdGhpcy5yb290Q29tcG9uZW50VHlwZSwgX3RoaXMuY29uZmlnLCB1cGRhdGVkVXJsLCBfdGhpcy5zZXJpYWxpemVVcmwodXBkYXRlZFVybCkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWVyZ2VNYXAoZnVuY3Rpb24gKG5ld1JvdXRlclN0YXRlU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yb3V0ZXJFdmVudHMubmV4dChuZXcgUm91dGVzUmVjb2duaXplZChpZCwgX3RoaXMuc2VyaWFsaXplVXJsKHVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh1cGRhdGVkVXJsKSwgbmV3Um91dGVyU3RhdGVTbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlXzEucmVzb2x2ZShfdGhpcy5yZXNvbHZlciwgbmV3Um91dGVyU3RhdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJvdXRlclN0YXRlU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlX3JvdXRlcl9zdGF0ZV8xLmNyZWF0ZVJvdXRlclN0YXRlKHJvdXRlclN0YXRlU25hcHNob3QsIF90aGlzLmN1cnJlbnRSb3V0ZXJTdGF0ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1lcmdlTWFwKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHdWFyZENoZWNrcyhzdGF0ZS5zbmFwc2hvdCwgX3RoaXMuY3VycmVudFJvdXRlclN0YXRlLnNuYXBzaG90LCBfdGhpcy5pbmplY3RvcilcbiAgICAgICAgICAgICAgICAgICAgLmNoZWNrKF90aGlzLm91dGxldE1hcCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzaG91bGRBY3RpdmF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkQWN0aXZhdGUgfHwgaWQgIT09IF90aGlzLm5hdmlnYXRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb3V0ZXJFdmVudHMubmV4dChuZXcgTmF2aWdhdGlvbkNhbmNlbChpZCwgX3RoaXMuc2VyaWFsaXplVXJsKHVybCkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmF0ZVJvdXRlcyhzdGF0ZSwgX3RoaXMuY3VycmVudFJvdXRlclN0YXRlKS5hY3RpdmF0ZShfdGhpcy5vdXRsZXRNYXApO1xuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRVcmxUcmVlID0gdXBkYXRlZFVybDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50Um91dGVyU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBfdGhpcy51cmxTZXJpYWxpemVyLnNlcmlhbGl6ZSh1cGRhdGVkVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmxvY2F0aW9uLmlzQ3VycmVudFBhdGhFcXVhbFRvKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2NhdGlvbi5yZXBsYWNlU3RhdGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2NhdGlvbi5nbyhwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucm91dGVyRXZlbnRzLm5leHQobmV3IE5hdmlnYXRpb25FbmQoaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh1cmwpLCBfdGhpcy5zZXJpYWxpemVVcmwodXBkYXRlZFVybCkpKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSh0cnVlKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucm91dGVyRXZlbnRzLm5leHQobmV3IE5hdmlnYXRpb25FcnJvcihpZCwgX3RoaXMuc2VyaWFsaXplVXJsKHVybCksIGUpKTtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJvdXRlcjtcbn0oKSk7XG5leHBvcnRzLlJvdXRlciA9IFJvdXRlcjtcbnZhciBDYW5BY3RpdmF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FuQWN0aXZhdGUocm91dGUpIHtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgIH1cbiAgICByZXR1cm4gQ2FuQWN0aXZhdGU7XG59KCkpO1xudmFyIENhbkRlYWN0aXZhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbkRlYWN0aXZhdGUoY29tcG9uZW50LCByb3V0ZSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgIH1cbiAgICByZXR1cm4gQ2FuRGVhY3RpdmF0ZTtcbn0oKSk7XG52YXIgR3VhcmRDaGVja3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd1YXJkQ2hlY2tzKGZ1dHVyZSwgY3VyciwgaW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5mdXR1cmUgPSBmdXR1cmU7XG4gICAgICAgIHRoaXMuY3VyciA9IGN1cnI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5jaGVja3MgPSBbXTtcbiAgICB9XG4gICAgR3VhcmRDaGVja3MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKHBhcmVudE91dGxldE1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnV0dXJlUm9vdCA9IHRoaXMuZnV0dXJlLl9yb290O1xuICAgICAgICB2YXIgY3VyclJvb3QgPSB0aGlzLmN1cnIgPyB0aGlzLmN1cnIuX3Jvb3QgOiBudWxsO1xuICAgICAgICB0aGlzLnRyYXZlcnNlQ2hpbGRSb3V0ZXMoZnV0dXJlUm9vdCwgY3VyclJvb3QsIHBhcmVudE91dGxldE1hcCk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gb2ZfMS5vZih0cnVlKTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb20odGhpcy5jaGVja3MpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBpZiAocyBpbnN0YW5jZW9mIENhbkFjdGl2YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJ1bkNhbkFjdGl2YXRlKHMucm91dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocyBpbnN0YW5jZW9mIENhbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucnVuQ2FuRGVhY3RpdmF0ZShzLmNvbXBvbmVudCwgcy5yb3V0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiZSByZWFjaGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWVyZ2VBbGwoKVxuICAgICAgICAgICAgLmV2ZXJ5KGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICBHdWFyZENoZWNrcy5wcm90b3R5cGUudHJhdmVyc2VDaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIChmdXR1cmVOb2RlLCBjdXJyTm9kZSwgb3V0bGV0TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChjdXJyTm9kZSk7XG4gICAgICAgIGZ1dHVyZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgX3RoaXMudHJhdmVyc2VSb3V0ZXMoYywgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XSwgb3V0bGV0TWFwKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcmV2Q2hpbGRyZW5bYy52YWx1ZS5vdXRsZXRdO1xuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvbl8xLmZvckVhY2gocHJldkNoaWxkcmVuLCBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gX3RoaXMuZGVhY3RpdmF0ZU91dGxldEFuZEl0Q2hpbGRyZW4odiwgb3V0bGV0TWFwLl9vdXRsZXRzW2tdKTsgfSk7XG4gICAgfTtcbiAgICBHdWFyZENoZWNrcy5wcm90b3R5cGUudHJhdmVyc2VSb3V0ZXMgPSBmdW5jdGlvbiAoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIHBhcmVudE91dGxldE1hcCkge1xuICAgICAgICB2YXIgZnV0dXJlID0gZnV0dXJlTm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcbiAgICAgICAgdmFyIG91dGxldCA9IHBhcmVudE91dGxldE1hcCA/IHBhcmVudE91dGxldE1hcC5fb3V0bGV0c1tmdXR1cmVOb2RlLnZhbHVlLm91dGxldF0gOiBudWxsO1xuICAgICAgICBpZiAoY3VyciAmJiBmdXR1cmUuX3JvdXRlQ29uZmlnID09PSBjdXJyLl9yb3V0ZUNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuc2hhbGxvd0VxdWFsKGZ1dHVyZS5wYXJhbXMsIGN1cnIucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tzLnB1c2gobmV3IENhbkRlYWN0aXZhdGUob3V0bGV0LmNvbXBvbmVudCwgY3VyciksIG5ldyBDYW5BY3RpdmF0ZShmdXR1cmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhdmVyc2VDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgb3V0bGV0ID8gb3V0bGV0Lm91dGxldE1hcCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlT3V0bGV0QW5kSXRDaGlsZHJlbihjdXJyLCBvdXRsZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja3MucHVzaChuZXcgQ2FuQWN0aXZhdGUoZnV0dXJlKSk7XG4gICAgICAgICAgICB0aGlzLnRyYXZlcnNlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgbnVsbCwgb3V0bGV0ID8gb3V0bGV0Lm91dGxldE1hcCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHdWFyZENoZWNrcy5wcm90b3R5cGUuZGVhY3RpdmF0ZU91dGxldEFuZEl0Q2hpbGRyZW4gPSBmdW5jdGlvbiAocm91dGUsIG91dGxldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3V0bGV0ICYmIG91dGxldC5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLmZvckVhY2gob3V0bGV0Lm91dGxldE1hcC5fb3V0bGV0cywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodi5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWFjdGl2YXRlT3V0bGV0QW5kSXRDaGlsZHJlbih2LmFjdGl2YXRlZFJvdXRlLnNuYXBzaG90LCB2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzLnB1c2gobmV3IENhbkRlYWN0aXZhdGUob3V0bGV0LmNvbXBvbmVudCwgcm91dGUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3VhcmRDaGVja3MucHJvdG90eXBlLnJ1bkNhbkFjdGl2YXRlID0gZnVuY3Rpb24gKGZ1dHVyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FuQWN0aXZhdGUgPSBmdXR1cmUuX3JvdXRlQ29uZmlnID8gZnV0dXJlLl9yb3V0ZUNvbmZpZy5jYW5BY3RpdmF0ZSA6IG51bGw7XG4gICAgICAgIGlmICghY2FuQWN0aXZhdGUgfHwgY2FuQWN0aXZhdGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG9mXzEub2YodHJ1ZSk7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mcm9tKGNhbkFjdGl2YXRlKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIGd1YXJkID0gX3RoaXMuaW5qZWN0b3IuZ2V0KGMpO1xuICAgICAgICAgICAgaWYgKGd1YXJkLmNhbkFjdGl2YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZC5jYW5BY3RpdmF0ZShmdXR1cmUsIF90aGlzLmZ1dHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZChmdXR1cmUsIF90aGlzLmZ1dHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm1lcmdlQWxsKClcbiAgICAgICAgICAgIC5ldmVyeShmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgPT09IHRydWU7IH0pO1xuICAgIH07XG4gICAgR3VhcmRDaGVja3MucHJvdG90eXBlLnJ1bkNhbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjdXJyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYW5EZWFjdGl2YXRlID0gY3Vyci5fcm91dGVDb25maWcgPyBjdXJyLl9yb3V0ZUNvbmZpZy5jYW5EZWFjdGl2YXRlIDogbnVsbDtcbiAgICAgICAgaWYgKCFjYW5EZWFjdGl2YXRlIHx8IGNhbkRlYWN0aXZhdGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG9mXzEub2YodHJ1ZSk7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mcm9tKGNhbkRlYWN0aXZhdGUpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgZ3VhcmQgPSBfdGhpcy5pbmplY3Rvci5nZXQoYyk7XG4gICAgICAgICAgICBpZiAoZ3VhcmQuY2FuRGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQuY2FuRGVhY3RpdmF0ZShjb21wb25lbnQsIGN1cnIsIF90aGlzLmN1cnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQoY29tcG9uZW50LCBjdXJyLCBfdGhpcy5jdXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWVyZ2VBbGwoKVxuICAgICAgICAgICAgLmV2ZXJ5KGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3VhcmRDaGVja3M7XG59KCkpO1xuZnVuY3Rpb24gd3JhcEludG9PYnNlcnZhYmxlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mXzEub2YodmFsdWUpO1xuICAgIH1cbn1cbnZhciBBY3RpdmF0ZVJvdXRlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWN0aXZhdGVSb3V0ZXMoZnV0dXJlU3RhdGUsIGN1cnJTdGF0ZSkge1xuICAgICAgICB0aGlzLmZ1dHVyZVN0YXRlID0gZnV0dXJlU3RhdGU7XG4gICAgICAgIHRoaXMuY3VyclN0YXRlID0gY3VyclN0YXRlO1xuICAgIH1cbiAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAocGFyZW50T3V0bGV0TWFwKSB7XG4gICAgICAgIHZhciBmdXR1cmVSb290ID0gdGhpcy5mdXR1cmVTdGF0ZS5fcm9vdDtcbiAgICAgICAgdmFyIGN1cnJSb290ID0gdGhpcy5jdXJyU3RhdGUgPyB0aGlzLmN1cnJTdGF0ZS5fcm9vdCA6IG51bGw7XG4gICAgICAgIHB1c2hRdWVyeVBhcmFtc0FuZEZyYWdtZW50KHRoaXMuZnV0dXJlU3RhdGUpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlUm9vdCwgY3VyclJvb3QsIHBhcmVudE91dGxldE1hcCk7XG4gICAgfTtcbiAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuYWN0aXZhdGVDaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIChmdXR1cmVOb2RlLCBjdXJyTm9kZSwgb3V0bGV0TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChjdXJyTm9kZSk7XG4gICAgICAgIGZ1dHVyZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGVSb3V0ZXMoYywgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XSwgb3V0bGV0TWFwKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcmV2Q2hpbGRyZW5bYy52YWx1ZS5vdXRsZXRdO1xuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvbl8xLmZvckVhY2gocHJldkNoaWxkcmVuLCBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gX3RoaXMuZGVhY3RpdmF0ZU91dGxldEFuZEl0Q2hpbGRyZW4ob3V0bGV0TWFwLl9vdXRsZXRzW2tdKTsgfSk7XG4gICAgfTtcbiAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuYWN0aXZhdGVSb3V0ZXMgPSBmdW5jdGlvbiAoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIHBhcmVudE91dGxldE1hcCkge1xuICAgICAgICB2YXIgZnV0dXJlID0gZnV0dXJlTm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcbiAgICAgICAgdmFyIG91dGxldCA9IGdldE91dGxldChwYXJlbnRPdXRsZXRNYXAsIGZ1dHVyZU5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoZnV0dXJlID09PSBjdXJyKSB7XG4gICAgICAgICAgICByb3V0ZXJfc3RhdGVfMS5hZHZhbmNlQWN0aXZhdGVkUm91dGUoZnV0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgb3V0bGV0Lm91dGxldE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKG91dGxldCk7XG4gICAgICAgICAgICB2YXIgb3V0bGV0TWFwID0gbmV3IHJvdXRlcl9vdXRsZXRfbWFwXzEuUm91dGVyT3V0bGV0TWFwKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlTmV3Um91dGVzKG91dGxldE1hcCwgZnV0dXJlLCBvdXRsZXQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIG51bGwsIG91dGxldE1hcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5hY3RpdmF0ZU5ld1JvdXRlcyA9IGZ1bmN0aW9uIChvdXRsZXRNYXAsIGZ1dHVyZSwgb3V0bGV0KSB7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IGNvcmVfMS5SZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbXG4gICAgICAgICAgICB7IHByb3ZpZGU6IHJvdXRlcl9zdGF0ZV8xLkFjdGl2YXRlZFJvdXRlLCB1c2VWYWx1ZTogZnV0dXJlIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IHJvdXRlcl9vdXRsZXRfbWFwXzEuUm91dGVyT3V0bGV0TWFwLCB1c2VWYWx1ZTogb3V0bGV0TWFwIH1cbiAgICAgICAgXSk7XG4gICAgICAgIHJvdXRlcl9zdGF0ZV8xLmFkdmFuY2VBY3RpdmF0ZWRSb3V0ZShmdXR1cmUpO1xuICAgICAgICBvdXRsZXQuYWN0aXZhdGUoZnV0dXJlLl9mdXR1cmVTbmFwc2hvdC5fcmVzb2x2ZWRDb21wb25lbnRGYWN0b3J5LCBmdXR1cmUsIHJlc29sdmVkLCBvdXRsZXRNYXApO1xuICAgIH07XG4gICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuID0gZnVuY3Rpb24gKG91dGxldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3V0bGV0ICYmIG91dGxldC5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLmZvckVhY2gob3V0bGV0Lm91dGxldE1hcC5fb3V0bGV0cywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLmRlYWN0aXZhdGVPdXRsZXRBbmRJdENoaWxkcmVuKHYpOyB9KTtcbiAgICAgICAgICAgIG91dGxldC5kZWFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmF0ZVJvdXRlcztcbn0oKSk7XG5mdW5jdGlvbiBwdXNoUXVlcnlQYXJhbXNBbmRGcmFnbWVudChzdGF0ZSkge1xuICAgIGlmICghY29sbGVjdGlvbl8xLnNoYWxsb3dFcXVhbChzdGF0ZS5zbmFwc2hvdC5xdWVyeVBhcmFtcywgc3RhdGUucXVlcnlQYXJhbXMudmFsdWUpKSB7XG4gICAgICAgIHN0YXRlLnF1ZXJ5UGFyYW1zLm5leHQoc3RhdGUuc25hcHNob3QucXVlcnlQYXJhbXMpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc25hcHNob3QuZnJhZ21lbnQgIT09IHN0YXRlLmZyYWdtZW50LnZhbHVlKSB7XG4gICAgICAgIHN0YXRlLmZyYWdtZW50Lm5leHQoc3RhdGUuc25hcHNob3QuZnJhZ21lbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVDaGlsZHJlbkFzTWFwKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IG5vZGUuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChtLCBjKSB7XG4gICAgICAgIG1bYy52YWx1ZS5vdXRsZXRdID0gYztcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSwge30pIDoge307XG59XG5mdW5jdGlvbiBnZXRPdXRsZXQob3V0bGV0TWFwLCByb3V0ZSkge1xuICAgIHZhciBvdXRsZXQgPSBvdXRsZXRNYXAuX291dGxldHNbcm91dGUub3V0bGV0XTtcbiAgICBpZiAoIW91dGxldCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IHJvdXRlLmNvbXBvbmVudC5uYW1lO1xuICAgICAgICBpZiAocm91dGUub3V0bGV0ID09PSBzaGFyZWRfMS5QUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgcHJpbWFyeSBvdXRsZXQgdG8gbG9hZCAnXCIgKyBjb21wb25lbnROYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgdGhlIG91dGxldCBcIiArIHJvdXRlLm91dGxldCArIFwiIHRvIGxvYWQgJ1wiICsgY29tcG9uZW50TmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0bGV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY205MWRHVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDNKdmRYUmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNVVUZCVHl4MVFrRkJkVUlzUTBGQlF5eERRVUZCTzBGQlF5OUNMRkZCUVU4c2QwSkJRWGRDTEVOQlFVTXNRMEZCUVR0QlFVTm9ReXhSUVVGUExEUkNRVUUwUWl4RFFVRkRMRU5CUVVFN1FVRkRjRU1zVVVGQlR5d3dRa0ZCTUVJc1EwRkJReXhEUVVGQk8wRkJRMnhETEZGQlFVOHNOa0pCUVRaQ0xFTkJRVU1zUTBGQlFUdEJRVU55UXl4UlFVRlBMSGxDUVVGNVFpeERRVUZETEVOQlFVRTdRVUZEYWtNc1VVRkJUeXcwUWtGQk5FSXNRMEZCUXl4RFFVRkJPMEZCUTNCRExGRkJRVThzTUVKQlFUQkNMRU5CUVVNc1EwRkJRVHRCUVVkc1F5eHhRa0ZCYjBVc1pVRkJaU3hEUVVGRExFTkJRVUU3UVVGRGNFWXNNa0pCUVhsQ0xHbENRVUZwUWl4RFFVRkRMRU5CUVVFN1FVRkRNME1zZDBKQlFYTkNMR05CUVdNc1EwRkJReXhEUVVGQk8wRkJSWEpETEcxQ1FVRnJRaXh2UWtGQmIwSXNRMEZCUXl4RFFVRkJPMEZCUlhaRExHZERRVUUyUWl4dFFrRkJiVUlzUTBGQlF5eERRVUZCTzBGQlEycEVMSFZDUVVFeVF5eFZRVUZWTEVOQlFVTXNRMEZCUVR0QlFVTjBSQ3h2UTBGQlowTXNkVUpCUVhWQ0xFTkJRVU1zUTBGQlFUdEJRVU40UkN4blEwRkJORUlzYlVKQlFXMUNMRU5CUVVNc1EwRkJRVHRCUVVWb1JDd3dRa0ZCZDBJc1lVRkJZU3hEUVVGRExFTkJRVUU3UVVGRGRFTXNkMEpCUVhOQ0xGZEJRVmNzUTBGQlF5eERRVUZCTzBGQlEyeERMR3REUVVFNFFpeHhRa0ZCY1VJc1EwRkJReXhEUVVGQk8wRkJRM0JFTERaQ1FVRm5TU3huUWtGQlowSXNRMEZCUXl4RFFVRkJPMEZCUTJwS0xIVkNRVUZ4UXl4VlFVRlZMRU5CUVVNc1EwRkJRVHRCUVVWb1JDeDVRa0ZCTUVNc1dVRkJXU3hEUVVGRExFTkJRVUU3UVVGRGRrUXNNa0pCUVc5RExHOUNRVUZ2UWl4RFFVRkRMRU5CUVVFN1FVRlpla1E3U1VGRFJTeDVRa0ZCYlVJc1JVRkJWU3hGUVVGVExFZEJRVmM3VVVGQk9VSXNUMEZCUlN4SFFVRkdMRVZCUVVVc1EwRkJVVHRSUVVGVExGRkJRVWNzUjBGQlNDeEhRVUZITEVOQlFWRTdTVUZCUnl4RFFVRkRPMGxCUlhKRUxHdERRVUZSTEVkQlFWSXNZMEZCY1VJc1RVRkJUU3hEUVVGRExIbENRVUYxUWl4SlFVRkpMRU5CUVVNc1JVRkJSU3huUWtGQlZ5eEpRVUZKTEVOQlFVTXNSMEZCUnl4UFFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM1JHTEhOQ1FVRkRPMEZCUVVRc1EwRkJReXhCUVVwRUxFbEJTVU03UVVGS1dTeDFRa0ZCWlN4clFrRkpNMElzUTBGQlFUdEJRVXRFTzBsQlEwVXNkVUpCUVcxQ0xFVkJRVlVzUlVGQlV5eEhRVUZYTEVWQlFWTXNhVUpCUVhsQ08xRkJRV2hGTEU5QlFVVXNSMEZCUml4RlFVRkZMRU5CUVZFN1VVRkJVeXhSUVVGSExFZEJRVWdzUjBGQlJ5eERRVUZSTzFGQlFWTXNjMEpCUVdsQ0xFZEJRV3BDTEdsQ1FVRnBRaXhEUVVGUk8wbEJRVWNzUTBGQlF6dEpRVVYyUml4blEwRkJVU3hIUVVGU08xRkJRMFVzVFVGQlRTeERRVUZETEhWQ1FVRnhRaXhKUVVGSkxFTkJRVU1zUlVGQlJTeG5Ra0ZCVnl4SlFVRkpMRU5CUVVNc1IwRkJSeXdyUWtGQk1FSXNTVUZCU1N4RFFVRkRMR2xDUVVGcFFpeFBRVUZKTEVOQlFVTTdTVUZETjBjc1EwRkJRenRKUVVOSUxHOUNRVUZETzBGQlFVUXNRMEZCUXl4QlFVNUVMRWxCVFVNN1FVRk9XU3h4UWtGQllTeG5Ra0ZOZWtJc1EwRkJRVHRCUVV0RU8wbEJRMFVzTUVKQlFXMUNMRVZCUVZVc1JVRkJVeXhIUVVGWE8xRkJRVGxDTEU5QlFVVXNSMEZCUml4RlFVRkZMRU5CUVZFN1VVRkJVeXhSUVVGSExFZEJRVWdzUjBGQlJ5eERRVUZSTzBsQlFVY3NRMEZCUXp0SlFVVnlSQ3h0UTBGQlVTeEhRVUZTTEdOQlFYRkNMRTFCUVUwc1EwRkJReXd3UWtGQmQwSXNTVUZCU1N4RFFVRkRMRVZCUVVVc1owSkJRVmNzU1VGQlNTeERRVUZETEVkQlFVY3NUMEZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOMlJpeDFRa0ZCUXp0QlFVRkVMRU5CUVVNc1FVRktSQ3hKUVVsRE8wRkJTbGtzZDBKQlFXZENMRzFDUVVrMVFpeERRVUZCTzBGQlMwUTdTVUZEUlN4NVFrRkJiVUlzUlVGQlZTeEZRVUZUTEVkQlFWY3NSVUZCVXl4TFFVRlZPMUZCUVdwRUxFOUJRVVVzUjBGQlJpeEZRVUZGTEVOQlFWRTdVVUZCVXl4UlFVRkhMRWRCUVVnc1IwRkJSeXhEUVVGUk8xRkJRVk1zVlVGQlN5eEhRVUZNTEV0QlFVc3NRMEZCU3p0SlFVRkhMRU5CUVVNN1NVRkZlRVVzYTBOQlFWRXNSMEZCVWp0UlFVTkZMRTFCUVUwc1EwRkJReXg1UWtGQmRVSXNTVUZCU1N4RFFVRkRMRVZCUVVVc1owSkJRVmNzU1VGQlNTeERRVUZETEVkQlFVY3NhMEpCUVdFc1NVRkJTU3hEUVVGRExFdEJRVXNzVFVGQlJ5eERRVUZETzBsQlEzSkdMRU5CUVVNN1NVRkRTQ3h6UWtGQlF6dEJRVUZFTEVOQlFVTXNRVUZPUkN4SlFVMURPMEZCVGxrc2RVSkJRV1VzYTBKQlRUTkNMRU5CUVVFN1FVRkxSRHRKUVVORkxEQkNRVU5YTEVWQlFWVXNSVUZCVXl4SFFVRlhMRVZCUVZNc2FVSkJRWGxDTEVWQlEyaEZMRXRCUVRCQ08xRkJSREZDTEU5QlFVVXNSMEZCUml4RlFVRkZMRU5CUVZFN1VVRkJVeXhSUVVGSExFZEJRVWdzUjBGQlJ5eERRVUZSTzFGQlFWTXNjMEpCUVdsQ0xFZEJRV3BDTEdsQ1FVRnBRaXhEUVVGUk8xRkJRMmhGTEZWQlFVc3NSMEZCVEN4TFFVRkxMRU5CUVhGQ08wbEJRVWNzUTBGQlF6dEpRVVY2UXl4dFEwRkJVU3hIUVVGU08xRkJRMFVzVFVGQlRTeERRVUZETERCQ1FVRjNRaXhKUVVGSkxFTkJRVU1zUlVGQlJTeG5Ra0ZCVnl4SlFVRkpMRU5CUVVNc1IwRkJSeXdyUWtGQk1FSXNTVUZCU1N4RFFVRkRMR2xDUVVGcFFpeHJRa0ZCWVN4SlFVRkpMRU5CUVVNc1MwRkJTeXhOUVVGSExFTkJRVU03U1VGRGRFa3NRMEZCUXp0SlFVTklMSFZDUVVGRE8wRkJRVVFzUTBGQlF5eEJRVkpFTEVsQlVVTTdRVUZTV1N4M1FrRkJaMElzYlVKQlVUVkNMRU5CUVVFN1FVRlBSRHRKUVZkRkxHZENRVU5aTEdsQ1FVRjFRaXhGUVVGVkxGRkJRVEpDTEVWQlF6VkVMR0ZCUVRSQ0xFVkJRVlVzVTBGQk1FSXNSVUZEYUVVc1VVRkJhMElzUlVGQlZTeFJRVUZyUWl4RlFVRkZMRTFCUVc5Q08xRkJSbkJGTEhOQ1FVRnBRaXhIUVVGcVFpeHBRa0ZCYVVJc1EwRkJUVHRSUVVGVkxHRkJRVkVzUjBGQlVpeFJRVUZSTEVOQlFXMUNPMUZCUXpWRUxHdENRVUZoTEVkQlFXSXNZVUZCWVN4RFFVRmxPMUZCUVZVc1kwRkJVeXhIUVVGVUxGTkJRVk1zUTBGQmFVSTdVVUZEYUVVc1lVRkJVU3hIUVVGU0xGRkJRVkVzUTBGQlZUdFJRVUZWTEdGQlFWRXNSMEZCVWl4UlFVRlJMRU5CUVZVN1VVRlViRVFzYVVKQlFWa3NSMEZCVnl4RFFVRkRMRU5CUVVNN1VVRlZMMElzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVONlFpeEpRVUZKTEVOQlFVTXNXVUZCV1N4SFFVRkhMRWxCUVVrc2FVSkJRVThzUlVGQlV5eERRVUZETzFGQlEzcERMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzTmtKQlFXdENMRVZCUVVVc1EwRkJRenRSUVVNelF5eEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFZEJRVWNzSzBKQlFXZENMRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUlVGQlJTeEpRVUZKTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU1zUTBGQlF6dEpRVU14Uml4RFFVRkRPMGxCUzBRc2EwTkJRV2xDTEVkQlFXcENPMUZCUTBVc1NVRkJTU3hEUVVGRExESkNRVUV5UWl4RlFVRkZMRU5CUVVNN1VVRkRia01zU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVV0RUxITkNRVUZKTEN0Q1FVRlhPMkZCUVdZc1kwRkJhVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4clFrRkJhMElzUTBGQlF5eERRVUZETEVOQlFVTTdPenRQUVVGQk8wbEJTMnhGTEhOQ1FVRkpMSFZDUVVGSE8yRkJRVkFzWTBGQmIwSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenM3TzA5QlFVRTdTVUZMY0VVc2MwSkJRVWtzTUVKQlFVMDdZVUZCVml4alFVRnJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNN096dFBRVUZCTzBsQlowSTNSQ3cwUWtGQlZ5eEhRVUZZTEZWQlFWa3NUVUZCYjBJN1VVRkRPVUlzZFVKQlFXTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOMlFpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJRenRKUVVOMlFpeERRVUZETzBsQlMwUXNkMEpCUVU4c1IwRkJVQ3hqUVVGclFpeEpRVUZKTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCYVVNMVJDdzRRa0ZCWVN4SFFVRmlMRlZCUVdNc1VVRkJaU3hGUVVGRkxFVkJRVEJFTzFsQlFURkVMRFJDUVVFd1JDeEZRVUY2UkN3d1FrRkJWU3hGUVVGRkxEUkNRVUZYTEVWQlFVVXNjMEpCUVZFN1VVRkZMMFFzU1VGQlRTeERRVUZETEVkQlFVY3NWVUZCVlN4SFFVRkhMRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXp0UlFVTXhSQ3hOUVVGTkxFTkJRVU1zSzBKQlFXRXNRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExHTkJRV01zUlVGQlJTeFJRVUZSTEVWQlFVVXNWMEZCVnl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8wbEJRMmhHTEVOQlFVTTdTVUZuUWtRc09FSkJRV0VzUjBGQllpeFZRVUZqTEVkQlFXMUNPMUZCUXk5Q0xFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NXVUZCV1N4clFrRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU16UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU0zUXl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeEpRVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTTVReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFOUJRVThzUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUXp0UlFVTnFSQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRV2xDUkN4NVFrRkJVU3hIUVVGU0xGVkJRVk1zVVVGQlpTeEZRVUZGTEUxQlFUWkNPMUZCUVRkQ0xITkNRVUUyUWl4SFFVRTNRaXhYUVVFMlFqdFJRVU55UkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRemxGTEVOQlFVTTdTVUZMUkN3MlFrRkJXU3hIUVVGYUxGVkJRV0VzUjBGQldTeEpRVUZaTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkxhRVlzZVVKQlFWRXNSMEZCVWl4VlFVRlRMRWRCUVZjc1NVRkJZU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlJXaEZMRzFEUVVGclFpeEhRVUV4UWl4VlFVRXlRaXhIUVVGWkxFVkJRVVVzWjBKQlFYbENPMUZCUVd4RkxHbENRVWxETzFGQlNFTXNTVUZCVFN4RlFVRkZMRWRCUVVjc1JVRkJSU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETzFGQlF5OUNMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NaVUZCWlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFJTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZETEVOQlFVTXNTVUZCU3l4UFFVRkJMRXRCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zUjBGQlJ5eEZRVUZGTEdkQ1FVRm5RaXhGUVVGRkxFVkJRVVVzUTBGQlF5eEZRVUV6UXl4RFFVRXlReXhEUVVGRExFTkJRVU03U1VGRGNFWXNRMEZCUXp0SlFVVlBMRFJEUVVFeVFpeEhRVUZ1UXp0UlFVRkJMR2xDUVVsRE8xRkJTRU1zU1VGQlNTeERRVUZETEc5Q1FVRnZRaXhIUVVGUkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4RFFVRkRMRlZCUVVNc1RVRkJUVHRaUVVNNVJDeE5RVUZOTEVOQlFVTXNTMEZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETEV0QlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzcEdMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZQTERSQ1FVRlhMRWRCUVc1Q0xGVkJRVzlDTEVkQlFWa3NSVUZCUlN4blFrRkJlVUlzUlVGQlJTeEZRVUZWTzFGQlFYWkZMR2xDUVc5RlF6dFJRVzVGUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFdEJRVXNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMElzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFVXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeG5Ra0ZCWjBJc1EwRkJReXhGUVVGRkxFVkJRVVVzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVrVXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdVVUZEYUVNc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEU5QlFVOHNRMEZCUXl4VlFVRkRMR05CUVdNc1JVRkJSU3hoUVVGaE8xbEJReTlETEVsQlFVa3NWVUZCYlVJc1EwRkJRenRaUVVONFFpeEpRVUZKTEV0QlFXdENMRU5CUVVNN1dVRkRka0lzWjBOQlFXTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dHBRa0ZETTBJc1VVRkJVU3hEUVVGRExGVkJRVUVzUTBGQlF6dG5Ra0ZEVkN4VlFVRlZMRWRCUVVjc1EwRkJReXhEUVVGRE8yZENRVU5tTEUxQlFVMHNRMEZCUXl4eFFrRkJVeXhEUVVOYUxFdEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hMUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEZWQlFWVXNSVUZCUlN4TFFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVZc1EwRkJReXhEUVVGRE8ybENRVVZFTEZGQlFWRXNRMEZCUXl4VlFVRkRMSE5DUVVGelFqdG5Ra0ZETDBJc1MwRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4blFrRkJaMElzUTBGRGRrTXNSVUZCUlN4RlFVRkZMRXRCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNTMEZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJTeHpRa0ZCYzBJc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzaEdMRTFCUVUwc1EwRkJReXhwUWtGQlR5eERRVUZETEV0QlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc2MwSkJRWE5DTEVOQlFVTXNRMEZCUXp0WlFVVjRSQ3hEUVVGRExFTkJRVU03YVVKQlEwUXNSMEZCUnl4RFFVRkRMRlZCUVVNc2JVSkJRVzFDTzJkQ1FVTjJRaXhOUVVGTkxFTkJRVU1zZFVOQlFXbENMRU5CUVVNc2JVSkJRVzFDTEVWQlFVVXNTMEZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETEVOQlFVTTdXVUZGZWtVc1EwRkJReXhEUVVGRE8ybENRVU5FTEVkQlFVY3NRMEZCUXl4VlFVRkRMRkZCUVhGQ08yZENRVU42UWl4TFFVRkxMRWRCUVVjc1VVRkJVU3hEUVVGRE8xbEJSVzVDTEVOQlFVTXNRMEZCUXp0cFFrRkRSQ3hSUVVGUkxFTkJRVU1zVlVGQlFTeERRVUZETzJkQ1FVTlVMRTFCUVUwc1EwRkJReXhKUVVGSkxGZEJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVrc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1MwRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF6dHhRa0ZEYkVZc1MwRkJTeXhEUVVGRExFdEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXp0WlFVVTNRaXhEUVVGRExFTkJRVU03YVVKQlEwUXNUMEZCVHl4RFFVRkRMRlZCUVVNc1kwRkJkVUk3WjBKQlF5OUNMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWTBGQll5eEpRVUZKTEVWQlFVVXNTMEZCU3l4TFFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEYUVRc1MwRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4blFrRkJaMElzUTBGQlF5eEZRVUZGTEVWQlFVVXNTMEZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNwRkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8yZENRVU5vUXl4RFFVRkRPMmRDUVVWRUxFbEJRVWtzWTBGQll5eERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkpMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzJkQ1FVVTFSU3hMUVVGSkxFTkJRVU1zWTBGQll5eEhRVUZITEZWQlFWVXNRMEZCUXp0blFrRkRha01zUzBGQlNTeERRVUZETEd0Q1FVRnJRaXhIUVVGSExFdEJRVXNzUTBGQlF6dG5Ra0ZEYUVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEzUkNMRWxCUVVrc1NVRkJTU3hIUVVGSExFdEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNVMEZCVXl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8yOUNRVU53UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEc5Q1FVRnZRaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkROME1zUzBGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlEyNURMRU5CUVVNN2IwSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdkMEpCUTA0c1MwRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN2IwSkJRM3BDTEVOQlFVTTdaMEpCUTBnc1EwRkJRenRuUWtGRFJDeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU12UWl4RFFVRkRMRU5CUVVNN2FVSkJRMFFzU1VGQlNTeERRVU5FTzJkQ1FVTkZMRXRCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVU5zUWl4SlFVRkpMR0ZCUVdFc1EwRkJReXhGUVVGRkxFVkJRVVVzUzBGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hMUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGJFWXNZMEZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJSWFpDTEVOQlFVTXNSVUZEUkN4VlFVRkJMRU5CUVVNN1owSkJRME1zUzBGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hsUVVGbExFTkJRVU1zUlVGQlJTeEZRVUZGTEV0QlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRNMFVzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1Q0xFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEySXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJRMGdzWVVGQlF6dEJRVUZFTEVOQlFVTXNRVUU1VDBRc1NVRTRUME03UVVFNVQxa3NZMEZCVFN4VFFUaFBiRUlzUTBGQlFUdEJRVVZFTzBsQlEwVXNjVUpCUVcxQ0xFdEJRVFpDTzFGQlFUZENMRlZCUVVzc1IwRkJUQ3hMUVVGTExFTkJRWGRDTzBsQlFVY3NRMEZCUXp0SlFVTjBSQ3hyUWtGQlF6dEJRVUZFTEVOQlFVTXNRVUZHUkN4SlFVVkRPMEZCUTBRN1NVRkRSU3gxUWtGQmJVSXNVMEZCYVVJc1JVRkJVeXhMUVVFMlFqdFJRVUYyUkN4alFVRlRMRWRCUVZRc1UwRkJVeXhEUVVGUk8xRkJRVk1zVlVGQlN5eEhRVUZNTEV0QlFVc3NRMEZCZDBJN1NVRkJSeXhEUVVGRE8wbEJRMmhHTEc5Q1FVRkRPMEZCUVVRc1EwRkJReXhCUVVaRUxFbEJSVU03UVVGRlJEdEpRVVZGTEhGQ1FVTlpMRTFCUVRKQ0xFVkJRVlVzU1VGQmVVSXNSVUZET1VRc1VVRkJhMEk3VVVGRWJFSXNWMEZCVFN4SFFVRk9MRTFCUVUwc1EwRkJjVUk3VVVGQlZTeFRRVUZKTEVkQlFVb3NTVUZCU1N4RFFVRnhRanRSUVVNNVJDeGhRVUZSTEVkQlFWSXNVVUZCVVN4RFFVRlZPMUZCU0hSQ0xGZEJRVTBzUjBGQmNVTXNSVUZCUlN4RFFVRkRPMGxCUjNKQ0xFTkJRVU03U1VGRmJFTXNNa0pCUVVzc1IwRkJUQ3hWUVVGTkxHVkJRV2RETzFGQlFYUkRMR2xDUVd0Q1F6dFJRV3BDUXl4SlFVRk5MRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTnlReXhKUVVGTkxGRkJRVkVzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVTndSQ3hKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1ZVRkJWU3hGUVVGRkxGRkJRVkVzUlVGQlJTeGxRVUZsTEVOQlFVTXNRMEZCUXp0UlFVTm9SU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFTkJRVU03V1VGQlF5eE5RVUZOTEVOQlFVTXNUMEZCUlN4RFFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJSUzlETEUxQlFVMHNRMEZCUXl4MVFrRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRPMkZCUXpsQ0xFZEJRVWNzUTBGQlF5eFZRVUZCTEVOQlFVTTdXVUZEU2l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExGbEJRVmtzVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkROMElzVFVGQlRTeERRVUZETEV0QlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFsQlEzUkRMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4WlFVRlpMR0ZCUVdFc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzUkRMRTFCUVUwc1EwRkJReXhMUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkRja1FzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zUTBGQlF6dFpRVU4yUXl4RFFVRkRPMUZCUTBnc1EwRkJReXhEUVVGRE8yRkJRMFFzVVVGQlVTeEZRVUZGTzJGQlExWXNTMEZCU3l4RFFVRkRMRlZCUVVFc1RVRkJUU3hKUVVGSkxFOUJRVUVzVFVGQlRTeExRVUZMTEVsQlFVa3NSVUZCWml4RFFVRmxMRU5CUVVNc1EwRkJRenRKUVVONFF5eERRVUZETzBsQlJVOHNlVU5CUVcxQ0xFZEJRVE5DTEZWQlEwa3NWVUZCTkVNc1JVRkJSU3hSUVVFd1F5eEZRVU40Uml4VFFVRXdRanRSUVVZNVFpeHBRa0ZYUXp0UlFWSkRMRWxCUVUwc1dVRkJXU3hIUVVGNVFpeHBRa0ZCYVVJc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU4yUlN4VlFVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEVOQlFVTTdXVUZETTBJc1MwRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkRhRVVzVDBGQlR5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU4wUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOSUxHOUNRVUZQTEVOQlEwZ3NXVUZCV1N4RlFVTmFMRlZCUVVNc1EwRkJUU3hGUVVGRkxFTkJRVk1zU1VGQlN5eFBRVUZCTEV0QlFVa3NRMEZCUXl3MlFrRkJOa0lzUTBGQlF5eERRVUZETEVWQlFVVXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUUxUkN4RFFVRTBSQ3hEUVVGRExFTkJRVU03U1VGRE0wWXNRMEZCUXp0SlFVVkVMRzlEUVVGakxFZEJRV1FzVlVGRFNTeFZRVUUwUXl4RlFVRkZMRkZCUVRCRExFVkJRM2hHTEdWQlFXZERPMUZCUTJ4RExFbEJRVTBzVFVGQlRTeEhRVUZITEZWQlFWVXNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRhRU1zU1VGQlRTeEpRVUZKTEVkQlFVY3NVVUZCVVN4SFFVRkhMRkZCUVZFc1EwRkJReXhMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETzFGQlF6bERMRWxCUVUwc1RVRkJUU3hIUVVGSExHVkJRV1VzUjBGQlJ5eGxRVUZsTEVOQlFVTXNVVUZCVVN4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUlRGR0xFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4TlFVRk5MRU5CUVVNc1dVRkJXU3hMUVVGTExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNlVUpCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6bERMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhUUVVGVExFVkJRVVVzU1VGQlNTeERRVUZETEVWQlFVVXNTVUZCU1N4WFFVRlhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4yUml4RFFVRkRPMWxCUTBRc1NVRkJTU3hEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRlZCUVZVc1JVRkJSU3hSUVVGUkxFVkJRVVVzVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXl4VFFVRlRMRWRCUVVjc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGJrWXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzU1VGQlNTeERRVUZETERaQ1FVRTJRaXhEUVVGRExFbEJRVWtzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0WlFVTnFSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRmRCUVZjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6RkRMRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4VlFVRlZMRVZCUVVVc1NVRkJTU3hGUVVGRkxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJReTlGTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUlU4c2JVUkJRVFpDTEVkQlFYSkRMRlZCUVhORExFdEJRVFpDTEVWQlFVVXNUVUZCYjBJN1VVRkJla1lzYVVKQlUwTTdVVUZTUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFbEJRVWtzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha01zYjBKQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUlVGQlJTeFZRVUZETEVOQlFXVTdaMEpCUTJwRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU5zUWl4TFFVRkpMRU5CUVVNc05rSkJRVFpDTEVOQlFVTXNRMEZCUXl4RFFVRkRMR05CUVdNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTI1RkxFTkJRVU03V1VGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTklMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhUUVVGVExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXZSQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZQTEc5RFFVRmpMRWRCUVhSQ0xGVkJRWFZDTEUxQlFUaENPMUZCUVhKRUxHbENRV05ETzFGQllrTXNTVUZCVFN4WFFVRlhMRWRCUVVjc1RVRkJUU3hEUVVGRExGbEJRVmtzUjBGQlJ5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRmRCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRGFrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFbEJRVWtzVjBGQlZ5eERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkJReXhOUVVGTkxFTkJRVU1zVDBGQlJTeERRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUXk5RUxFMUJRVTBzUTBGQlF5eDFRa0ZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU03WVVGRE9VSXNSMEZCUnl4RFFVRkRMRlZCUVVFc1EwRkJRenRaUVVOS0xFbEJRVTBzUzBGQlN5eEhRVUZITEV0QlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOMFFpeE5RVUZOTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUzBGQlN5eERRVUZETEZkQlFWY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VVc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNoRUxFTkJRVU03VVVGRFNDeERRVUZETEVOQlFVTTdZVUZEUkN4UlFVRlJMRVZCUVVVN1lVRkRWaXhMUVVGTExFTkJRVU1zVlVGQlFTeE5RVUZOTEVsQlFVa3NUMEZCUVN4TlFVRk5MRXRCUVVzc1NVRkJTU3hGUVVGbUxFTkJRV1VzUTBGQlF5eERRVUZETzBsQlEzaERMRU5CUVVNN1NVRkZUeXh6UTBGQlowSXNSMEZCZUVJc1ZVRkJlVUlzVTBGQmFVSXNSVUZCUlN4SlFVRTBRanRSUVVGNFJTeHBRa0ZqUXp0UlFXSkRMRWxCUVUwc1lVRkJZU3hIUVVGSExFbEJRVWtzUTBGQlF5eFpRVUZaTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhoUVVGaExFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEycEdMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWVVGQllTeEpRVUZKTEdGQlFXRXNRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRVU1zVFVGQlRTeERRVUZETEU5QlFVVXNRMEZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOdVJTeE5RVUZOTEVOQlFVTXNkVUpCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETzJGQlEyaERMRWRCUVVjc1EwRkJReXhWUVVGQkxFTkJRVU03V1VGRFNpeEpRVUZOTEV0QlFVc3NSMEZCUnl4TFFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGVFSXNUVUZCVFN4RFFVRkRMR3RDUVVGclFpeERRVUZETEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc1UwRkJVeXhGUVVGRkxFbEJRVWtzUlVGQlJTeExRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNM1JTeERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRMDRzVFVGQlRTeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVWQlFVVXNTVUZCU1N4RlFVRkZMRXRCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF5OUVMRU5CUVVNN1VVRkRTQ3hEUVVGRExFTkJRVU03WVVGRFJDeFJRVUZSTEVWQlFVVTdZVUZEVml4TFFVRkxMRU5CUVVNc1ZVRkJRU3hOUVVGTkxFbEJRVWtzVDBGQlFTeE5RVUZOTEV0QlFVc3NTVUZCU1N4RlFVRm1MRU5CUVdVc1EwRkJReXhEUVVGRE8wbEJRM2hETEVOQlFVTTdTVUZEU0N4clFrRkJRenRCUVVGRUxFTkJRVU1zUVVGd1IwUXNTVUZ2UjBNN1FVRkZSQ3cwUWtGQkswSXNTMEZCZDBJN1NVRkRja1FzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4WlFVRlpMSFZDUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaERMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRFppeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFTkJRVU1zVDBGQlJTeERRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUTNCQ0xFTkJRVU03UVVGRFNDeERRVUZETzBGQlJVUTdTVUZEUlN4M1FrRkJiMElzVjBGQmQwSXNSVUZCVlN4VFFVRnpRanRSUVVGNFJDeG5Ra0ZCVnl4SFFVRllMRmRCUVZjc1EwRkJZVHRSUVVGVkxHTkJRVk1zUjBGQlZDeFRRVUZUTEVOQlFXRTdTVUZCUnl4RFFVRkRPMGxCUldoR0xHbERRVUZSTEVkQlFWSXNWVUZCVXl4bFFVRm5RenRSUVVOMlF5eEpRVUZOTEZWQlFWVXNSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU14UXl4SlFVRk5MRkZCUVZFc1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF6dFJRVVU1UkN3d1FrRkJNRUlzUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1VVRkROME1zU1VGQlNTeERRVUZETEcxQ1FVRnRRaXhEUVVGRExGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RFFVRkRMRU5CUVVNN1NVRkRiRVVzUTBGQlF6dEpRVVZQTERSRFFVRnRRaXhIUVVFelFpeFZRVU5KTEZWQlFXOURMRVZCUVVVc1VVRkJhME1zUlVGRGVFVXNVMEZCTUVJN1VVRkdPVUlzYVVKQlYwTTdVVUZTUXl4SlFVRk5MRmxCUVZrc1IwRkJlVUlzYVVKQlFXbENMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRGRrVXNWVUZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlFTeERRVUZETzFsQlF6TkNMRXRCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zUTBGQlF5eEZRVUZGTEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMWxCUTJoRkxFOUJRVThzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRGRFTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRTQ3h2UWtGQlR5eERRVU5JTEZsQlFWa3NSVUZEV2l4VlFVRkRMRU5CUVUwc1JVRkJSU3hEUVVGVExFbEJRVXNzVDBGQlFTeExRVUZKTEVOQlFVTXNOa0pCUVRaQ0xFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGNlJDeERRVUY1UkN4RFFVRkRMRU5CUVVNN1NVRkRlRVlzUTBGQlF6dEpRVVZFTEhWRFFVRmpMRWRCUVdRc1ZVRkRTU3hWUVVGdlF5eEZRVUZGTEZGQlFXdERMRVZCUTNoRkxHVkJRV2RETzFGQlEyeERMRWxCUVUwc1RVRkJUU3hIUVVGSExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZEYUVNc1NVRkJUU3hKUVVGSkxFZEJRVWNzVVVGQlVTeEhRVUZITEZGQlFWRXNRMEZCUXl4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJSVGxETEVsQlFVMHNUVUZCVFN4SFFVRkhMRk5CUVZNc1EwRkJReXhsUVVGbExFVkJRVVVzVlVGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUlRWRUxFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNTMEZCU3l4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JDTEc5RFFVRnhRaXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlF6bENMRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4VlFVRlZMRVZCUVVVc1VVRkJVU3hGUVVGRkxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVTnVSU3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4SlFVRkpMRU5CUVVNc05rSkJRVFpDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkRNME1zU1VGQlRTeFRRVUZUTEVkQlFVY3NTVUZCU1N4dFEwRkJaU3hGUVVGRkxFTkJRVU03V1VGRGVFTXNTVUZCU1N4RFFVRkRMR2xDUVVGcFFpeERRVUZETEZOQlFWTXNSVUZCUlN4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03V1VGRGJFUXNTVUZCU1N4RFFVRkRMRzFDUVVGdFFpeERRVUZETEZWQlFWVXNSVUZCUlN4SlFVRkpMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03VVVGRGVFUXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZUeXd3UTBGQmFVSXNSMEZCZWtJc1ZVRkRTU3hUUVVFd1FpeEZRVUZGTEUxQlFYTkNMRVZCUVVVc1RVRkJiMEk3VVVGRE1VVXNTVUZCVFN4UlFVRlJMRWRCUVVjc2VVSkJRV3RDTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUXpGRExFVkJRVU1zVDBGQlR5eEZRVUZGTERaQ1FVRmpMRVZCUVVVc1VVRkJVU3hGUVVGRkxFMUJRVTBzUlVGQlF6dFpRVU16UXl4RlFVRkRMRTlCUVU4c1JVRkJSU3h0UTBGQlpTeEZRVUZGTEZGQlFWRXNSVUZCUlN4VFFVRlRMRVZCUVVNN1UwRkRhRVFzUTBGQlF5eERRVUZETzFGQlEwZ3NiME5CUVhGQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZET1VJc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMSGxDUVVGNVFpeEZRVUZGTEUxQlFVMHNSVUZCUlN4UlFVRlJMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03U1VGRGFrY3NRMEZCUXp0SlFVVlBMSE5FUVVFMlFpeEhRVUZ5UXl4VlFVRnpReXhOUVVGdlFqdFJRVUV4UkN4cFFrRk5RenRSUVV4RExFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNTVUZCU1N4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUXl4dlFrRkJUeXhEUVVOSUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RlFVRkZMRlZCUVVNc1EwRkJaU3hKUVVGTExFOUJRVUVzUzBGQlNTeERRVUZETERaQ1FVRTJRaXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZ5UXl4RFFVRnhReXhEUVVGRExFTkJRVU03V1VGRE0wWXNUVUZCVFN4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRM1JDTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBnc2NVSkJRVU03UVVGQlJDeERRVUZETEVGQk5VUkVMRWxCTkVSRE8wRkJSVVFzYjBOQlFXOURMRXRCUVd0Q08wbEJRM0JFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2VVSkJRVmtzUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRmRCUVZjc1JVRkJVU3hMUVVGTExFTkJRVU1zVjBGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFJTeExRVUZMTEVOQlFVTXNWMEZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMGxCUXpWRUxFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExGRkJRVkVzUzBGQlZ5eExRVUZMTEVOQlFVTXNVVUZCVXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFUXNTMEZCU3l4RFFVRkRMRkZCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVOMFJDeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVVkVMREpDUVVFeVFpeEpRVUZ0UWp0SlFVTTFReXhOUVVGTkxFTkJRVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlRTeEZRVUZGTEVOQlFXZENPMUZCUXpGRUxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU4wUWl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMWdzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkJRenRCUVVOa0xFTkJRVU03UVVGRlJDeHRRa0ZCYlVJc1UwRkJNRUlzUlVGQlJTeExRVUZ4UWp0SlFVTnNSU3hKUVVGSkxFMUJRVTBzUjBGQlJ5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU01UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEV2l4SlFVRk5MR0ZCUVdFc1IwRkJVeXhMUVVGTExFTkJRVU1zVTBGQlZTeERRVUZETEVsQlFVa3NRMEZCUXp0UlFVTnNSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4TFFVRkxMSFZDUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkRMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZVVOQlFYVkRMR0ZCUVdFc1RVRkJSeXhEUVVGRExFTkJRVU03VVVGRE0wVXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl3MFFrRkJNRUlzUzBGQlN5eERRVUZETEUxQlFVMHNhMEpCUVdFc1lVRkJZU3hOUVVGSExFTkJRVU1zUTBGQlF6dFJRVU4yUml4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdRVUZEYUVJc1EwRkJReUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0FuY25ocWN5OWhaR1F2YjNCbGNtRjBiM0l2YldGd0p6dGNibWx0Y0c5eWRDQW5jbmhxY3k5aFpHUXZiM0JsY21GMGIzSXZjMk5oYmljN1hHNXBiWEJ2Y25RZ0ozSjRhbk12WVdSa0wyOXdaWEpoZEc5eUwyMWxjbWRsVFdGd0p6dGNibWx0Y0c5eWRDQW5jbmhxY3k5aFpHUXZiM0JsY21GMGIzSXZZMjl1WTJGMEp6dGNibWx0Y0c5eWRDQW5jbmhxY3k5aFpHUXZiM0JsY21GMGIzSXZZMjl1WTJGMFRXRndKenRjYm1sdGNHOXlkQ0FuY25ocWN5OWhaR1F2YjNCbGNtRjBiM0l2WlhabGNua25PMXh1YVcxd2IzSjBJQ2R5ZUdwekwyRmtaQzl2Y0dWeVlYUnZjaTl0WlhKblpVRnNiQ2M3WEc1cGJYQnZjblFnSjNKNGFuTXZZV1JrTDI5aWMyVnlkbUZpYkdVdlpuSnZiU2M3WEc1Y2JtbHRjRzl5ZENCN1RHOWpZWFJwYjI1OUlHWnliMjBnSjBCaGJtZDFiR0Z5TDJOdmJXMXZiaWM3WEc1cGJYQnZjblFnZTBOdmJYQnZibVZ1ZEZKbGMyOXNkbVZ5TENCSmJtcGxZM1J2Y2l3Z1VtVm1iR1ZqZEdsMlpVbHVhbVZqZEc5eUxDQlVlWEJsZlNCbWNtOXRJQ2RBWVc1bmRXeGhjaTlqYjNKbEp6dGNibWx0Y0c5eWRDQjdUMkp6WlhKMllXSnNaWDBnWm5KdmJTQW5jbmhxY3k5UFluTmxjblpoWW14bEp6dGNibWx0Y0c5eWRDQjdVM1ZpYW1WamRIMGdabkp2YlNBbmNuaHFjeTlUZFdKcVpXTjBKenRjYm1sdGNHOXlkQ0I3VTNWaWMyTnlhWEIwYVc5dWZTQm1jbTl0SUNkeWVHcHpMMU4xWW5OamNtbHdkR2x2YmljN1hHNXBiWEJ2Y25RZ2UyOW1JSDBnWm5KdmJTQW5jbmhxY3k5dlluTmxjblpoWW14bEwyOW1KenRjYmx4dWFXMXdiM0owSUh0aGNIQnNlVkpsWkdseVpXTjBjMzBnWm5KdmJTQW5MaTloY0hCc2VWOXlaV1JwY21WamRITW5PMXh1YVcxd2IzSjBJSHRTYjNWMFpYSkRiMjVtYVdjc0lIWmhiR2xrWVhSbFEyOXVabWxuZlNCbWNtOXRJQ2N1TDJOdmJtWnBaeWM3WEc1cGJYQnZjblFnZTJOeVpXRjBaVkp2ZFhSbGNsTjBZWFJsZlNCbWNtOXRJQ2N1TDJOeVpXRjBaVjl5YjNWMFpYSmZjM1JoZEdVbk8xeHVhVzF3YjNKMElIdGpjbVZoZEdWVmNteFVjbVZsZlNCbWNtOXRJQ2N1TDJOeVpXRjBaVjkxY214ZmRISmxaU2M3WEc1cGJYQnZjblFnZTFKdmRYUmxjazkxZEd4bGRIMGdabkp2YlNBbkxpOWthWEpsWTNScGRtVnpMM0p2ZFhSbGNsOXZkWFJzWlhRbk8xeHVhVzF3YjNKMElIdHlaV052WjI1cGVtVjlJR1p5YjIwZ0p5NHZjbVZqYjJkdWFYcGxKenRjYm1sdGNHOXlkQ0I3Y21WemIyeDJaWDBnWm5KdmJTQW5MaTl5WlhOdmJIWmxKenRjYm1sdGNHOXlkQ0I3VW05MWRHVnlUM1YwYkdWMFRXRndmU0JtY205dElDY3VMM0p2ZFhSbGNsOXZkWFJzWlhSZmJXRndKenRjYm1sdGNHOXlkQ0I3UVdOMGFYWmhkR1ZrVW05MWRHVXNJRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRc0lGSnZkWFJsY2xOMFlYUmxMQ0JTYjNWMFpYSlRkR0YwWlZOdVlYQnphRzkwTENCaFpIWmhibU5sUVdOMGFYWmhkR1ZrVW05MWRHVXNJR055WldGMFpVVnRjSFI1VTNSaGRHVjlJR1p5YjIwZ0p5NHZjbTkxZEdWeVgzTjBZWFJsSnp0Y2JtbHRjRzl5ZENCN1VGSkpUVUZTV1Y5UFZWUk1SVlFzSUZCaGNtRnRjMzBnWm5KdmJTQW5MaTl6YUdGeVpXUW5PMXh1YVcxd2IzSjBJSHRWY214VFpYSnBZV3hwZW1WeWZTQm1jbTl0SUNjdUwzVnliRjl6WlhKcFlXeHBlbVZ5Snp0Y2JtbHRjRzl5ZENCN1ZYSnNWSEpsWlN3Z1kzSmxZWFJsUlcxd2RIbFZjbXhVY21WbGZTQm1jbTl0SUNjdUwzVnliRjkwY21WbEp6dGNibWx0Y0c5eWRDQjdabTl5UldGamFDd2djMmhoYkd4dmQwVnhkV0ZzZlNCbWNtOXRJQ2N1TDNWMGFXeHpMMk52Ykd4bFkzUnBiMjRuTzF4dWFXMXdiM0owSUh0VWNtVmxUbTlrWlgwZ1puSnZiU0FuTGk5MWRHbHNjeTkwY21WbEp6dGNibHh1Wlhod2IzSjBJR2x1ZEdWeVptRmpaU0JPWVhacFoyRjBhVzl1UlhoMGNtRnpJSHRjYmlBZ2NtVnNZWFJwZG1WVWJ6ODZJRUZqZEdsMllYUmxaRkp2ZFhSbE8xeHVJQ0J4ZFdWeWVWQmhjbUZ0Y3o4NklGQmhjbUZ0Y3p0Y2JpQWdabkpoWjIxbGJuUS9PaUJ6ZEhKcGJtYzdYRzU5WEc1Y2JpOHFLbHh1SUNvZ1FXNGdaWFpsYm5RZ2RISnBaMmRsY21Wa0lIZG9aVzRnWVNCdVlYWnBaMkYwYVc5dUlITjBZWEowYzF4dUlDb3ZYRzVsZUhCdmNuUWdZMnhoYzNNZ1RtRjJhV2RoZEdsdmJsTjBZWEowSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY0hWaWJHbGpJR2xrT2lCdWRXMWlaWElzSUhCMVlteHBZeUIxY213NklITjBjbWx1WnlrZ2UzMWNibHh1SUNCMGIxTjBjbWx1WnlncE9pQnpkSEpwYm1jZ2V5QnlaWFIxY200Z1lFNWhkbWxuWVhScGIyNVRkR0Z5ZENocFpEb2dKSHQwYUdsekxtbGtmU3dnZFhKc09pQW5KSHQwYUdsekxuVnliSDBuS1dBN0lIMWNibjFjYmx4dUx5b3FYRzRnS2lCQmJpQmxkbVZ1ZENCMGNtbG5aMlZ5WldRZ2QyaGxiaUJoSUc1aGRtbG5ZWFJwYjI0Z1pXNWtjeUJ6ZFdOalpYTnpablZzYkhsY2JpQXFMMXh1Wlhod2IzSjBJR05zWVhOeklFNWhkbWxuWVhScGIyNUZibVFnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWh3ZFdKc2FXTWdhV1E2SUc1MWJXSmxjaXdnY0hWaWJHbGpJSFZ5YkRvZ2MzUnlhVzVuTENCd2RXSnNhV01nZFhKc1FXWjBaWEpTWldScGNtVmpkSE02SUhOMGNtbHVaeWtnZTMxY2JseHVJQ0IwYjFOMGNtbHVaeWdwT2lCemRISnBibWNnZTF4dUlDQWdJSEpsZEhWeWJpQmdUbUYyYVdkaGRHbHZia1Z1WkNocFpEb2dKSHQwYUdsekxtbGtmU3dnZFhKc09pQW5KSHQwYUdsekxuVnliSDBuTENCMWNteEJablJsY2xKbFpHbHlaV04wY3pvZ0p5UjdkR2hwY3k1MWNteEJablJsY2xKbFpHbHlaV04wYzMwbktXQTdYRzRnSUgxY2JuMWNibHh1THlvcVhHNGdLaUJCYmlCbGRtVnVkQ0IwY21sbloyVnlaV1FnZDJobGJpQmhJRzVoZG1sbllYUnBiMjRnYVhNZ1kyRnVZMlZzWldSY2JpQXFMMXh1Wlhod2IzSjBJR05zWVhOeklFNWhkbWxuWVhScGIyNURZVzVqWld3Z2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lod2RXSnNhV01nYVdRNklHNTFiV0psY2l3Z2NIVmliR2xqSUhWeWJEb2djM1J5YVc1bktTQjdmVnh1WEc0Z0lIUnZVM1J5YVc1bktDazZJSE4wY21sdVp5QjdJSEpsZEhWeWJpQmdUbUYyYVdkaGRHbHZia05oYm1ObGJDaHBaRG9nSkh0MGFHbHpMbWxrZlN3Z2RYSnNPaUFuSkh0MGFHbHpMblZ5YkgwbktXQTdJSDFjYm4xY2JseHVMeW9xWEc0Z0tpQkJiaUJsZG1WdWRDQjBjbWxuWjJWeVpXUWdkMmhsYmlCaElHNWhkbWxuWVhScGIyNGdabUZwYkhNZ1pIVmxJSFJ2SUhWdVpYaHdaV04wWldRZ1pYSnliM0pjYmlBcUwxeHVaWGh3YjNKMElHTnNZWE56SUU1aGRtbG5ZWFJwYjI1RmNuSnZjaUI3WEc0Z0lHTnZibk4wY25WamRHOXlLSEIxWW14cFl5QnBaRG9nYm5WdFltVnlMQ0J3ZFdKc2FXTWdkWEpzT2lCemRISnBibWNzSUhCMVlteHBZeUJsY25KdmNqb2dZVzU1S1NCN2ZWeHVYRzRnSUhSdlUzUnlhVzVuS0NrNklITjBjbWx1WnlCN1hHNGdJQ0FnY21WMGRYSnVJR0JPWVhacFoyRjBhVzl1UlhKeWIzSW9hV1E2SUNSN2RHaHBjeTVwWkgwc0lIVnliRG9nSnlSN2RHaHBjeTUxY214OUp5d2daWEp5YjNJNklDUjdkR2hwY3k1bGNuSnZjbjBwWUR0Y2JpQWdmVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFRnVJR1YyWlc1MElIUnlhV2RuWlhKbFpDQjNhR1Z1SUhKdmRYUmxjeUJoY21VZ2NtVmpiMmR1YVhwbFpGeHVJQ292WEc1bGVIQnZjblFnWTJ4aGMzTWdVbTkxZEdWelVtVmpiMmR1YVhwbFpDQjdYRzRnSUdOdmJuTjBjblZqZEc5eUtGeHVJQ0FnSUNBZ2NIVmliR2xqSUdsa09pQnVkVzFpWlhJc0lIQjFZbXhwWXlCMWNtdzZJSE4wY21sdVp5d2djSFZpYkdsaklIVnliRUZtZEdWeVVtVmthWEpsWTNSek9pQnpkSEpwYm1jc1hHNGdJQ0FnSUNCd2RXSnNhV01nYzNSaGRHVTZJRkp2ZFhSbGNsTjBZWFJsVTI1aGNITm9iM1FwSUh0OVhHNWNiaUFnZEc5VGRISnBibWNvS1RvZ2MzUnlhVzVuSUh0Y2JpQWdJQ0J5WlhSMWNtNGdZRkp2ZFhSbGMxSmxZMjluYm1sNlpXUW9hV1E2SUNSN2RHaHBjeTVwWkgwc0lIVnliRG9nSnlSN2RHaHBjeTUxY214OUp5d2dkWEpzUVdaMFpYSlNaV1JwY21WamRITTZJQ2NrZTNSb2FYTXVkWEpzUVdaMFpYSlNaV1JwY21WamRITjlKeXdnYzNSaGRHVTZJQ1I3ZEdocGN5NXpkR0YwWlgwcFlEdGNiaUFnZlZ4dWZWeHVYRzVsZUhCdmNuUWdkSGx3WlNCRmRtVnVkQ0E5SUU1aGRtbG5ZWFJwYjI1VGRHRnlkQ0I4SUU1aGRtbG5ZWFJwYjI1RmJtUWdmQ0JPWVhacFoyRjBhVzl1UTJGdVkyVnNJSHdnVG1GMmFXZGhkR2x2YmtWeWNtOXlPMXh1WEc0dktpcGNiaUFxSUZSb1pTQmdVbTkxZEdWeVlDQnBjeUJ5WlhOd2IyNXphV0pzWlNCbWIzSWdiV0Z3Y0dsdVp5QlZVa3h6SUhSdklHTnZiWEJ2Ym1WdWRITXVYRzRnS2k5Y2JtVjRjRzl5ZENCamJHRnpjeUJTYjNWMFpYSWdlMXh1SUNCd2NtbDJZWFJsSUdOMWNuSmxiblJWY214VWNtVmxPaUJWY214VWNtVmxPMXh1SUNCd2NtbDJZWFJsSUdOMWNuSmxiblJTYjNWMFpYSlRkR0YwWlRvZ1VtOTFkR1Z5VTNSaGRHVTdYRzRnSUhCeWFYWmhkR1VnYkc5allYUnBiMjVUZFdKelkzSnBjSFJwYjI0NklGTjFZbk5qY21sd2RHbHZianRjYmlBZ2NISnBkbUYwWlNCeWIzVjBaWEpGZG1WdWRITTZJRk4xWW1wbFkzUThSWFpsYm5RK08xeHVJQ0J3Y21sMllYUmxJRzVoZG1sbllYUnBiMjVKWkRvZ2JuVnRZbVZ5SUQwZ01EdGNiaUFnY0hKcGRtRjBaU0JqYjI1bWFXYzZJRkp2ZFhSbGNrTnZibVpwWnp0Y2JseHVJQ0F2S2lwY2JpQWdJQ29nUUdsdWRHVnlibUZzWEc0Z0lDQXFMMXh1SUNCamIyNXpkSEoxWTNSdmNpaGNiaUFnSUNBZ0lIQnlhWFpoZEdVZ2NtOXZkRU52YlhCdmJtVnVkRlI1Y0dVNklGUjVjR1VzSUhCeWFYWmhkR1VnY21WemIyeDJaWEk2SUVOdmJYQnZibVZ1ZEZKbGMyOXNkbVZ5TEZ4dUlDQWdJQ0FnY0hKcGRtRjBaU0IxY214VFpYSnBZV3hwZW1WeU9pQlZjbXhUWlhKcFlXeHBlbVZ5TENCd2NtbDJZWFJsSUc5MWRHeGxkRTFoY0RvZ1VtOTFkR1Z5VDNWMGJHVjBUV0Z3TEZ4dUlDQWdJQ0FnY0hKcGRtRjBaU0JzYjJOaGRHbHZiam9nVEc5allYUnBiMjRzSUhCeWFYWmhkR1VnYVc1cVpXTjBiM0k2SUVsdWFtVmpkRzl5TENCamIyNW1hV2M2SUZKdmRYUmxja052Ym1acFp5a2dlMXh1SUNBZ0lIUm9hWE11Y21WelpYUkRiMjVtYVdjb1kyOXVabWxuS1R0Y2JpQWdJQ0IwYUdsekxuSnZkWFJsY2tWMlpXNTBjeUE5SUc1bGR5QlRkV0pxWldOMFBFVjJaVzUwUGlncE8xeHVJQ0FnSUhSb2FYTXVZM1Z5Y21WdWRGVnliRlJ5WldVZ1BTQmpjbVZoZEdWRmJYQjBlVlZ5YkZSeVpXVW9LVHRjYmlBZ0lDQjBhR2x6TG1OMWNuSmxiblJTYjNWMFpYSlRkR0YwWlNBOUlHTnlaV0YwWlVWdGNIUjVVM1JoZEdVb2RHaHBjeTVqZFhKeVpXNTBWWEpzVkhKbFpTd2dkR2hwY3k1eWIyOTBRMjl0Y0c5dVpXNTBWSGx3WlNrN1hHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dRR2x1ZEdWeWJtRnNYRzRnSUNBcUwxeHVJQ0JwYm1sMGFXRnNUbUYyYVdkaGRHbHZiaWdwT2lCMmIybGtJSHRjYmlBZ0lDQjBhR2x6TG5ObGRGVndURzlqWVhScGIyNURhR0Z1WjJWTWFYTjBaVzVsY2lncE8xeHVJQ0FnSUhSb2FYTXVibUYyYVdkaGRHVkNlVlZ5YkNoMGFHbHpMbXh2WTJGMGFXOXVMbkJoZEdnb0tTazdYRzRnSUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nVW1WMGRYSnVjeUIwYUdVZ1kzVnljbVZ1ZENCeWIzVjBaU0J6ZEdGMFpTNWNiaUFnSUNvdlhHNGdJR2RsZENCeWIzVjBaWEpUZEdGMFpTZ3BPaUJTYjNWMFpYSlRkR0YwWlNCN0lISmxkSFZ5YmlCMGFHbHpMbU4xY25KbGJuUlNiM1YwWlhKVGRHRjBaVHNnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJTWlhSMWNtNXpJSFJvWlNCamRYSnlaVzUwSUhWeWJDNWNiaUFnSUNvdlhHNGdJR2RsZENCMWNtd29LVG9nYzNSeWFXNW5JSHNnY21WMGRYSnVJSFJvYVhNdWMyVnlhV0ZzYVhwbFZYSnNLSFJvYVhNdVkzVnljbVZ1ZEZWeWJGUnlaV1VwT3lCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUZKbGRIVnlibk1nWVc0Z2IySnpaWEoyWVdKc1pTQnZaaUJ5YjNWMFpTQmxkbVZ1ZEhOY2JpQWdJQ292WEc0Z0lHZGxkQ0JsZG1WdWRITW9LVG9nVDJKelpYSjJZV0pzWlR4RmRtVnVkRDRnZXlCeVpYUjFjbTRnZEdocGN5NXliM1YwWlhKRmRtVnVkSE03SUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nVW1WelpYUnpJSFJvWlNCamIyNW1hV2QxY21GMGFXOXVJSFZ6WldRZ1ptOXlJRzVoZG1sbllYUnBiMjRnWVc1a0lHZGxibVZ5WVhScGJtY2diR2x1YTNNdVhHNGdJQ0FxWEc0Z0lDQXFJQ01qSXlCVmMyRm5aVnh1SUNBZ0tseHVJQ0FnS2lCZ1lHQmNiaUFnSUNvZ2NtOTFkR1Z5TG5KbGMyVjBRMjl1Wm1sbktGdGNiaUFnSUNvZ0lIc2djR0YwYURvZ0ozUmxZVzB2T21sa0p5d2dZMjl0Y0c5dVpXNTBPaUJVWldGdFEyMXdMQ0JqYUdsc1pISmxiam9nVzF4dUlDQWdLaUFnSUNCN0lIQmhkR2c2SUNkemFXMXdiR1VuTENCamIyMXdiMjVsYm5RNklGTnBiWEJzWlVOdGNDQjlMRnh1SUNBZ0tpQWdJQ0I3SUhCaGRHZzZJQ2QxYzJWeUx6cHVZVzFsSnl3Z1kyOXRjRzl1Wlc1ME9pQlZjMlZ5UTIxd0lIMWNiaUFnSUNvZ0lGMGdmVnh1SUNBZ0tpQmRLVHRjYmlBZ0lDb2dZR0JnWEc0Z0lDQXFMMXh1SUNCeVpYTmxkRU52Ym1acFp5aGpiMjVtYVdjNklGSnZkWFJsY2tOdmJtWnBaeWs2SUhadmFXUWdlMXh1SUNBZ0lIWmhiR2xrWVhSbFEyOXVabWxuS0dOdmJtWnBaeWs3WEc0Z0lDQWdkR2hwY3k1amIyNW1hV2NnUFNCamIyNW1hV2M3WEc0Z0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1FHbHVkR1Z5Ym1Gc1hHNGdJQ0FxTDF4dUlDQmthWE53YjNObEtDazZJSFp2YVdRZ2V5QjBhR2x6TG14dlkyRjBhVzl1VTNWaWMyTnlhWEIwYVc5dUxuVnVjM1ZpYzJOeWFXSmxLQ2s3SUgxY2JseHVJQ0F2S2lwY2JpQWdJQ29nUVhCd2JHbGxjeUJoYmlCaGNuSmhlU0J2WmlCamIyMXRZVzVrY3lCMGJ5QjBhR1VnWTNWeWNtVnVkQ0IxY213Z2RISmxaU0JoYm1RZ1kzSmxZWFJsYzF4dUlDQWdLaUJoSUc1bGR5QjFjbXdnZEhKbFpTNWNiaUFnSUNwY2JpQWdJQ29nVjJobGJpQm5hWFpsYmlCaGJpQmhZM1JwZG1GMFpTQnliM1YwWlN3Z1lYQndiR2xsY3lCMGFHVWdaMmwyWlc0Z1kyOXRiV0Z1WkhNZ2MzUmhjblJwYm1jZ1puSnZiU0IwYUdVZ2NtOTFkR1V1WEc0Z0lDQXFJRmRvWlc0Z2JtOTBJR2RwZG1WdUlHRWdjbTkxZEdVc0lHRndjR3hwWlhNZ2RHaGxJR2RwZG1WdUlHTnZiVzFoYm1RZ2MzUmhjblJwYm1jZ1puSnZiU0IwYUdVZ2NtOXZkQzVjYmlBZ0lDcGNiaUFnSUNvZ0l5TWpJRlZ6WVdkbFhHNGdJQ0FxWEc0Z0lDQXFJR0JnWUZ4dUlDQWdLaUF2THlCamNtVmhkR1VnTDNSbFlXMHZNek12ZFhObGNpOHhNVnh1SUNBZ0tpQnliM1YwWlhJdVkzSmxZWFJsVlhKc1ZISmxaU2hiSnk5MFpXRnRKeXdnTXpNc0lDZDFjMlZ5Snl3Z01URmRLVHRjYmlBZ0lDcGNiaUFnSUNvZ0x5OGdZM0psWVhSbElDOTBaV0Z0THpNek8yVjRjR0Z1WkQxMGNuVmxMM1Z6WlhJdk1URmNiaUFnSUNvZ2NtOTFkR1Z5TG1OeVpXRjBaVlZ5YkZSeVpXVW9XeWN2ZEdWaGJTY3NJRE16TENCN1pYaHdZVzVrT2lCMGNuVmxmU3dnSjNWelpYSW5MQ0F4TVYwcE8xeHVJQ0FnS2x4dUlDQWdLaUF2THlCNWIzVWdZMkZ1SUdOdmJHeGhjSE5sSUhOMFlYUnBZeUJtY21GbmJXVnVkSE1nYkdsclpTQjBhR2x6WEc0Z0lDQXFJSEp2ZFhSbGNpNWpjbVZoZEdWVmNteFVjbVZsS0ZzbkwzUmxZVzB2TXpNdmRYTmxjaWNzSUhWelpYSkpaRjBwTzF4dUlDQWdLbHh1SUNBZ0tpQXZMeUJoYzNOMWJXbHVaeUIwYUdVZ1kzVnljbVZ1ZENCMWNtd2dhWE1nWUM5MFpXRnRMek16TDNWelpYSXZNVEZnSUdGdVpDQjBhR1VnY205MWRHVWdjRzlwYm5SeklIUnZJR0IxYzJWeUx6RXhZRnh1SUNBZ0tseHVJQ0FnS2lBdkx5QnVZWFpwWjJGMFpTQjBieUF2ZEdWaGJTOHpNeTkxYzJWeUx6RXhMMlJsZEdGcGJITmNiaUFnSUNvZ2NtOTFkR1Z5TG1OeVpXRjBaVlZ5YkZSeVpXVW9XeWRrWlhSaGFXeHpKMTBzSUh0eVpXeGhkR2wyWlZSdk9pQnliM1YwWlgwcE8xeHVJQ0FnS2x4dUlDQWdLaUF2THlCdVlYWnBaMkYwWlNCMGJ5QXZkR1ZoYlM4ek15OTFjMlZ5THpJeVhHNGdJQ0FxSUhKdmRYUmxjaTVqY21WaGRHVlZjbXhVY21WbEtGc25MaTR2TWpJblhTd2dlM0psYkdGMGFYWmxWRzg2SUhKdmRYUmxmU2s3WEc0Z0lDQXFYRzRnSUNBcUlDOHZJRzVoZG1sbllYUmxJSFJ2SUM5MFpXRnRMelEwTDNWelpYSXZNakpjYmlBZ0lDb2djbTkxZEdWeUxtTnlaV0YwWlZWeWJGUnlaV1VvV3ljdUxpOHVMaTkwWldGdEx6UTBMM1Z6WlhJdk1qSW5YU3dnZTNKbGJHRjBhWFpsVkc4NklISnZkWFJsZlNrN1hHNGdJQ0FxSUdCZ1lGeHVJQ0FnS2k5Y2JpQWdZM0psWVhSbFZYSnNWSEpsWlNoamIyMXRZVzVrY3pvZ1lXNTVXMTBzSUh0eVpXeGhkR2wyWlZSdkxDQnhkV1Z5ZVZCaGNtRnRjeXdnWm5KaFoyMWxiblI5T2lCT1lYWnBaMkYwYVc5dVJYaDBjbUZ6SUQwZ2UzMHBPbHh1SUNBZ0lDQWdWWEpzVkhKbFpTQjdYRzRnSUNBZ1kyOXVjM1FnWVNBOUlISmxiR0YwYVhabFZHOGdQeUJ5Wld4aGRHbDJaVlJ2SURvZ2RHaHBjeTV5YjNWMFpYSlRkR0YwWlM1eWIyOTBPMXh1SUNBZ0lISmxkSFZ5YmlCamNtVmhkR1ZWY214VWNtVmxLR0VzSUhSb2FYTXVZM1Z5Y21WdWRGVnliRlJ5WldVc0lHTnZiVzFoYm1SekxDQnhkV1Z5ZVZCaGNtRnRjeXdnWm5KaFoyMWxiblFwTzF4dUlDQjlYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFNWhkbWxuWVhSbElHSmhjMlZrSUc5dUlIUm9aU0J3Y205MmFXUmxaQ0IxY213dUlGUm9hWE1nYm1GMmFXZGhkR2x2YmlCcGN5QmhiSGRoZVhNZ1lXSnpiMngxZEdVdVhHNGdJQ0FxWEc0Z0lDQXFJRkpsZEhWeWJuTWdZU0J3Y205dGFYTmxJSFJvWVhRNlhHNGdJQ0FxSUMwZ2FYTWdjbVZ6YjJ4MlpXUWdkMmwwYUNBbmRISjFaU2NnZDJobGJpQnVZWFpwWjJGMGFXOXVJSE4xWTJObFpXUnpYRzRnSUNBcUlDMGdhWE1nY21WemIyeDJaV1FnZDJsMGFDQW5abUZzYzJVbklIZG9aVzRnYm1GMmFXZGhkR2x2YmlCbVlXbHNjMXh1SUNBZ0tpQXRJR2x6SUhKbGFtVmpkR1ZrSUhkb1pXNGdZVzRnWlhKeWIzSWdhR0Z3Y0dWdWMxeHVJQ0FnS2x4dUlDQWdLaUFqSXlNZ1ZYTmhaMlZjYmlBZ0lDcGNiaUFnSUNvZ1lHQmdYRzRnSUNBcUlISnZkWFJsY2k1dVlYWnBaMkYwWlVKNVZYSnNLRndpTDNSbFlXMHZNek12ZFhObGNpOHhNVndpS1R0Y2JpQWdJQ29nWUdCZ1hHNGdJQ0FxTDF4dUlDQnVZWFpwWjJGMFpVSjVWWEpzS0hWeWJEb2djM1J5YVc1bmZGVnliRlJ5WldVcE9pQlFjbTl0YVhObFBHSnZiMnhsWVc0K0lIdGNiaUFnSUNCcFppQW9kWEpzSUdsdWMzUmhibU5sYjJZZ1ZYSnNWSEpsWlNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjMk5vWldSMWJHVk9ZWFpwWjJGMGFXOXVLSFZ5YkN3Z1ptRnNjMlVwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmpiMjV6ZENCMWNteFVjbVZsSUQwZ2RHaHBjeTUxY214VFpYSnBZV3hwZW1WeUxuQmhjbk5sS0hWeWJDazdYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV6WTJobFpIVnNaVTVoZG1sbllYUnBiMjRvZFhKc1ZISmxaU3dnWm1Gc2MyVXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJPWVhacFoyRjBaU0JpWVhObFpDQnZiaUIwYUdVZ2NISnZkbWxrWldRZ1lYSnlZWGtnYjJZZ1kyOXRiV0Z1WkhNZ1lXNWtJR0VnYzNSaGNuUnBibWNnY0c5cGJuUXVYRzRnSUNBcUlFbG1JRzV2SUhOMFlYSjBhVzVuSUhKdmRYUmxJR2x6SUhCeWIzWnBaR1ZrTENCMGFHVWdibUYyYVdkaGRHbHZiaUJwY3lCaFluTnZiSFYwWlM1Y2JpQWdJQ3BjYmlBZ0lDb2dVbVYwZFhKdWN5QmhJSEJ5YjIxcGMyVWdkR2hoZERwY2JpQWdJQ29nTFNCcGN5QnlaWE52YkhabFpDQjNhWFJvSUNkMGNuVmxKeUIzYUdWdUlHNWhkbWxuWVhScGIyNGdjM1ZqWTJWbFpITmNiaUFnSUNvZ0xTQnBjeUJ5WlhOdmJIWmxaQ0IzYVhSb0lDZG1ZV3h6WlNjZ2QyaGxiaUJ1WVhacFoyRjBhVzl1SUdaaGFXeHpYRzRnSUNBcUlDMGdhWE1nY21WcVpXTjBaV1FnZDJobGJpQmhiaUJsY25KdmNpQm9ZWEJ3Wlc1elhHNGdJQ0FxWEc0Z0lDQXFJQ01qSXlCVmMyRm5aVnh1SUNBZ0tseHVJQ0FnS2lCZ1lHQmNiaUFnSUNvZ2NtOTFkR1Z5TG01aGRtbG5ZWFJsS0ZzbmRHVmhiU2NzSURNekxDQW5kR1ZoYlNjc0lDY3hNVjBzSUh0eVpXeGhkR2wyWlZSdk9pQnliM1YwWlgwcE8xeHVJQ0FnS2lCZ1lHQmNiaUFnSUNvdlhHNGdJRzVoZG1sbllYUmxLR052YlcxaGJtUnpPaUJoYm5sYlhTd2daWGgwY21Gek9pQk9ZWFpwWjJGMGFXOXVSWGgwY21GeklEMGdlMzBwT2lCUWNtOXRhWE5sUEdKdmIyeGxZVzQrSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1elkyaGxaSFZzWlU1aGRtbG5ZWFJwYjI0b2RHaHBjeTVqY21WaGRHVlZjbXhVY21WbEtHTnZiVzFoYm1SekxDQmxlSFJ5WVhNcExDQm1ZV3h6WlNrN1hHNGdJSDFjYmx4dUlDQXZLaXBjYmlBZ0lDb2dVMlZ5YVdGc2FYcGxjeUJoSUh0QWJHbHVheUJWY214VWNtVmxmU0JwYm5SdklHRWdjM1J5YVc1bkxseHVJQ0FnS2k5Y2JpQWdjMlZ5YVdGc2FYcGxWWEpzS0hWeWJEb2dWWEpzVkhKbFpTazZJSE4wY21sdVp5QjdJSEpsZEhWeWJpQjBhR2x6TG5WeWJGTmxjbWxoYkdsNlpYSXVjMlZ5YVdGc2FYcGxLSFZ5YkNrN0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1VHRnljMlVnWVNCemRISnBibWNnYVc1MGJ5QmhJSHRBYkdsdWF5QlZjbXhVY21WbGZTNWNiaUFnSUNvdlhHNGdJSEJoY25ObFZYSnNLSFZ5YkRvZ2MzUnlhVzVuS1RvZ1ZYSnNWSEpsWlNCN0lISmxkSFZ5YmlCMGFHbHpMblZ5YkZObGNtbGhiR2w2WlhJdWNHRnljMlVvZFhKc0tUc2dmVnh1WEc0Z0lIQnlhWFpoZEdVZ2MyTm9aV1IxYkdWT1lYWnBaMkYwYVc5dUtIVnliRG9nVlhKc1ZISmxaU3dnY0hKbGRtVnVkRkIxYzJoVGRHRjBaVG9nWW05dmJHVmhiaWs2SUZCeWIyMXBjMlU4WW05dmJHVmhiajRnZTF4dUlDQWdJR052Ym5OMElHbGtJRDBnS3l0MGFHbHpMbTVoZG1sbllYUnBiMjVKWkR0Y2JpQWdJQ0IwYUdsekxuSnZkWFJsY2tWMlpXNTBjeTV1WlhoMEtHNWxkeUJPWVhacFoyRjBhVzl1VTNSaGNuUW9hV1FzSUhSb2FYTXVjMlZ5YVdGc2FYcGxWWEpzS0hWeWJDa3BLVHRjYmlBZ0lDQnlaWFIxY200Z1VISnZiV2x6WlM1eVpYTnZiSFpsS0NrdWRHaGxiaWdvWHlrZ1BUNGdkR2hwY3k1eWRXNU9ZWFpwWjJGMFpTaDFjbXdzSUhCeVpYWmxiblJRZFhOb1UzUmhkR1VzSUdsa0tTazdYRzRnSUgxY2JseHVJQ0J3Y21sMllYUmxJSE5sZEZWd1RHOWpZWFJwYjI1RGFHRnVaMlZNYVhOMFpXNWxjaWdwT2lCMmIybGtJSHRjYmlBZ0lDQjBhR2x6TG14dlkyRjBhVzl1VTNWaWMyTnlhWEIwYVc5dUlEMGdQR0Z1ZVQ1MGFHbHpMbXh2WTJGMGFXOXVMbk4xWW5OamNtbGlaU2dvWTJoaGJtZGxLU0E5UGlCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXpZMmhsWkhWc1pVNWhkbWxuWVhScGIyNG9kR2hwY3k1MWNteFRaWEpwWVd4cGVtVnlMbkJoY25ObEtHTm9ZVzVuWlZzbmRYSnNKMTBwTENCamFHRnVaMlZiSjNCdmNDZGRLVHRjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUhCeWFYWmhkR1VnY25WdVRtRjJhV2RoZEdVb2RYSnNPaUJWY214VWNtVmxMQ0J3Y21WMlpXNTBVSFZ6YUZOMFlYUmxPaUJpYjI5c1pXRnVMQ0JwWkRvZ2JuVnRZbVZ5S1RvZ1VISnZiV2x6WlR4aWIyOXNaV0Z1UGlCN1hHNGdJQ0FnYVdZZ0tHbGtJQ0U5UFNCMGFHbHpMbTVoZG1sbllYUnBiMjVKWkNrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTVzYjJOaGRHbHZiaTVuYnloMGFHbHpMblZ5YkZObGNtbGhiR2w2WlhJdWMyVnlhV0ZzYVhwbEtIUm9hWE11WTNWeWNtVnVkRlZ5YkZSeVpXVXBLVHRjYmlBZ0lDQWdJSFJvYVhNdWNtOTFkR1Z5UlhabGJuUnpMbTVsZUhRb2JtVjNJRTVoZG1sbllYUnBiMjVEWVc1alpXd29hV1FzSUhSb2FYTXVjMlZ5YVdGc2FYcGxWWEpzS0hWeWJDa3BLVHRjYmlBZ0lDQWdJSEpsZEhWeWJpQlFjbTl0YVhObExuSmxjMjlzZG1Vb1ptRnNjMlVwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQnVaWGNnVUhKdmJXbHpaU2dvY21WemIyeDJaVkJ5YjIxcGMyVXNJSEpsYW1WamRGQnliMjFwYzJVcElEMCtJSHRjYmlBZ0lDQWdJR3hsZENCMWNHUmhkR1ZrVlhKc09pQlZjbXhVY21WbE8xeHVJQ0FnSUNBZ2JHVjBJSE4wWVhSbE9pQlNiM1YwWlhKVGRHRjBaVHRjYmlBZ0lDQWdJR0Z3Y0d4NVVtVmthWEpsWTNSektIVnliQ3dnZEdocGN5NWpiMjVtYVdjcFhHNGdJQ0FnSUNBZ0lDQWdMbTFsY21kbFRXRndLSFVnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZFhCa1lYUmxaRlZ5YkNBOUlIVTdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnY21WamIyZHVhWHBsS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVjbTl2ZEVOdmJYQnZibVZ1ZEZSNWNHVXNJSFJvYVhNdVkyOXVabWxuTENCMWNHUmhkR1ZrVlhKc0xDQjBhR2x6TG5ObGNtbGhiR2w2WlZWeWJDaDFjR1JoZEdWa1ZYSnNLU2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZTbGNibHh1SUNBZ0lDQWdJQ0FnSUM1dFpYSm5aVTFoY0Nnb2JtVjNVbTkxZEdWeVUzUmhkR1ZUYm1Gd2MyaHZkQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXliM1YwWlhKRmRtVnVkSE11Ym1WNGRDaHVaWGNnVW05MWRHVnpVbVZqYjJkdWFYcGxaQ2hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JwWkN3Z2RHaHBjeTV6WlhKcFlXeHBlbVZWY213b2RYSnNLU3dnZEdocGN5NXpaWEpwWVd4cGVtVlZjbXdvZFhCa1lYUmxaRlZ5YkNrc0lHNWxkMUp2ZFhSbGNsTjBZWFJsVTI1aGNITm9iM1FwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnlaWE52YkhabEtIUm9hWE11Y21WemIyeDJaWElzSUc1bGQxSnZkWFJsY2xOMFlYUmxVMjVoY0hOb2IzUXBPMXh1WEc0Z0lDQWdJQ0FnSUNBZ2ZTbGNiaUFnSUNBZ0lDQWdJQ0F1YldGd0tDaHliM1YwWlhKVGRHRjBaVk51WVhCemFHOTBLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZM0psWVhSbFVtOTFkR1Z5VTNSaGRHVW9jbTkxZEdWeVUzUmhkR1ZUYm1Gd2MyaHZkQ3dnZEdocGN5NWpkWEp5Wlc1MFVtOTFkR1Z5VTNSaGRHVXBPMXh1WEc0Z0lDQWdJQ0FnSUNBZ2ZTbGNiaUFnSUNBZ0lDQWdJQ0F1YldGd0tDaHVaWGRUZEdGMFpUb2dVbTkxZEdWeVUzUmhkR1VwSUQwK0lIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhOMFlYUmxJRDBnYm1WM1UzUmhkR1U3WEc1Y2JpQWdJQ0FnSUNBZ0lDQjlLVnh1SUNBZ0lDQWdJQ0FnSUM1dFpYSm5aVTFoY0NoZklEMCtJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCdVpYY2dSM1ZoY21SRGFHVmphM01vYzNSaGRHVXVjMjVoY0hOb2IzUXNJSFJvYVhNdVkzVnljbVZ1ZEZKdmRYUmxjbE4wWVhSbExuTnVZWEJ6YUc5MExDQjBhR2x6TG1sdWFtVmpkRzl5S1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM1amFHVmpheWgwYUdsekxtOTFkR3hsZEUxaGNDazdYRzVjYmlBZ0lDQWdJQ0FnSUNCOUtWeHVJQ0FnSUNBZ0lDQWdJQzVtYjNKRllXTm9LQ2h6YUc5MWJHUkJZM1JwZG1GMFpUb2dZbTl2YkdWaGJpa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0NGemFHOTFiR1JCWTNScGRtRjBaU0I4ZkNCcFpDQWhQVDBnZEdocGN5NXVZWFpwWjJGMGFXOXVTV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXliM1YwWlhKRmRtVnVkSE11Ym1WNGRDaHVaWGNnVG1GMmFXZGhkR2x2YmtOaGJtTmxiQ2hwWkN3Z2RHaHBjeTV6WlhKcFlXeHBlbVZWY213b2RYSnNLU2twTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdVSEp2YldselpTNXlaWE52YkhabEtHWmhiSE5sS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdibVYzSUVGamRHbDJZWFJsVW05MWRHVnpLSE4wWVhSbExDQjBhR2x6TG1OMWNuSmxiblJTYjNWMFpYSlRkR0YwWlNrdVlXTjBhWFpoZEdVb2RHaHBjeTV2ZFhSc1pYUk5ZWEFwTzF4dVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtTjFjbkpsYm5SVmNteFVjbVZsSUQwZ2RYQmtZWFJsWkZWeWJEdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVZM1Z5Y21WdWRGSnZkWFJsY2xOMFlYUmxJRDBnYzNSaGRHVTdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9JWEJ5WlhabGJuUlFkWE5vVTNSaGRHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdiR1YwSUhCaGRHZ2dQU0IwYUdsekxuVnliRk5sY21saGJHbDZaWEl1YzJWeWFXRnNhWHBsS0hWd1pHRjBaV1JWY213cE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1c2IyTmhkR2x2Ymk1cGMwTjFjbkpsYm5SUVlYUm9SWEYxWVd4VWJ5aHdZWFJvS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11Ykc5allYUnBiMjR1Y21Wd2JHRmpaVk4wWVhSbEtIQmhkR2dwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWJHOWpZWFJwYjI0dVoyOG9jR0YwYUNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCUWNtOXRhWE5sTG5KbGMyOXNkbVVvZEhKMVpTazdYRzRnSUNBZ0lDQWdJQ0FnZlNsY2JpQWdJQ0FnSUNBZ0lDQXVkR2hsYmloY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnS0NrZ1BUNGdlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWNtOTFkR1Z5UlhabGJuUnpMbTVsZUhRb1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzVsZHlCT1lYWnBaMkYwYVc5dVJXNWtLR2xrTENCMGFHbHpMbk5sY21saGJHbDZaVlZ5YkNoMWNtd3BMQ0IwYUdsekxuTmxjbWxoYkdsNlpWVnliQ2gxY0dSaGRHVmtWWEpzS1NrcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjMjlzZG1WUWNtOXRhWE5sS0hSeWRXVXBPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJR1VnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11Y205MWRHVnlSWFpsYm5SekxtNWxlSFFvYm1WM0lFNWhkbWxuWVhScGIyNUZjbkp2Y2locFpDd2dkR2hwY3k1elpYSnBZV3hwZW1WVmNtd29kWEpzS1N3Z1pTa3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYW1WamRGQnliMjFwYzJVb1pTazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHBPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlYRzVjYm1Oc1lYTnpJRU5oYmtGamRHbDJZWFJsSUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY0hWaWJHbGpJSEp2ZFhSbE9pQkJZM1JwZG1GMFpXUlNiM1YwWlZOdVlYQnphRzkwS1NCN2ZWeHVmVnh1WTJ4aGMzTWdRMkZ1UkdWaFkzUnBkbUYwWlNCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0hCMVlteHBZeUJqYjIxd2IyNWxiblE2SUU5aWFtVmpkQ3dnY0hWaWJHbGpJSEp2ZFhSbE9pQkJZM1JwZG1GMFpXUlNiM1YwWlZOdVlYQnphRzkwS1NCN2ZWeHVmVnh1WEc1amJHRnpjeUJIZFdGeVpFTm9aV05yY3lCN1hHNGdJSEJ5YVhaaGRHVWdZMmhsWTJ0ek9pQkJjbkpoZVR4RFlXNUJZM1JwZG1GMFpYeERZVzVFWldGamRHbDJZWFJsUGlBOUlGdGRPMXh1SUNCamIyNXpkSEoxWTNSdmNpaGNiaUFnSUNBZ0lIQnlhWFpoZEdVZ1puVjBkWEpsT2lCU2IzVjBaWEpUZEdGMFpWTnVZWEJ6YUc5MExDQndjbWwyWVhSbElHTjFjbkk2SUZKdmRYUmxjbE4wWVhSbFUyNWhjSE5vYjNRc1hHNGdJQ0FnSUNCd2NtbDJZWFJsSUdsdWFtVmpkRzl5T2lCSmJtcGxZM1J2Y2lrZ2UzMWNibHh1SUNCamFHVmpheWh3WVhKbGJuUlBkWFJzWlhSTllYQTZJRkp2ZFhSbGNrOTFkR3hsZEUxaGNDazZJRTlpYzJWeWRtRmliR1U4WW05dmJHVmhiajRnZTF4dUlDQWdJR052Ym5OMElHWjFkSFZ5WlZKdmIzUWdQU0IwYUdsekxtWjFkSFZ5WlM1ZmNtOXZkRHRjYmlBZ0lDQmpiMjV6ZENCamRYSnlVbTl2ZENBOUlIUm9hWE11WTNWeWNpQS9JSFJvYVhNdVkzVnljaTVmY205dmRDQTZJRzUxYkd3N1hHNGdJQ0FnZEdocGN5NTBjbUYyWlhKelpVTm9hV3hrVW05MWRHVnpLR1oxZEhWeVpWSnZiM1FzSUdOMWNuSlNiMjkwTENCd1lYSmxiblJQZFhSc1pYUk5ZWEFwTzF4dUlDQWdJR2xtSUNoMGFHbHpMbU5vWldOcmN5NXNaVzVuZEdnZ1BUMDlJREFwSUhKbGRIVnliaUJ2WmlBb2RISjFaU2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdUMkp6WlhKMllXSnNaUzVtY205dEtIUm9hWE11WTJobFkydHpLVnh1SUNBZ0lDQWdJQ0F1YldGd0tITWdQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h6SUdsdWMzUmhibU5sYjJZZ1EyRnVRV04wYVhaaGRHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkoxYmtOaGJrRmpkR2wyWVhSbEtITXVjbTkxZEdVcE8xeHVJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvY3lCcGJuTjBZVzVqWlc5bUlFTmhia1JsWVdOMGFYWmhkR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KMWJrTmhia1JsWVdOMGFYWmhkR1VvY3k1amIyMXdiMjVsYm5Rc0lITXVjbTkxZEdVcE8xeHVJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjBOaGJtNXZkQ0JpWlNCeVpXRmphR1ZrSnlrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5S1Z4dUlDQWdJQ0FnSUNBdWJXVnlaMlZCYkd3b0tWeHVJQ0FnSUNBZ0lDQXVaWFpsY25rb2NtVnpkV3gwSUQwK0lISmxjM1ZzZENBOVBUMGdkSEoxWlNrN1hHNGdJSDFjYmx4dUlDQndjbWwyWVhSbElIUnlZWFpsY25ObFEyaHBiR1JTYjNWMFpYTW9YRzRnSUNBZ0lDQm1kWFIxY21WT2IyUmxPaUJVY21WbFRtOWtaVHhCWTNScGRtRjBaV1JTYjNWMFpWTnVZWEJ6YUc5MFBpd2dZM1Z5Y2s1dlpHVTZJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0xGeHVJQ0FnSUNBZ2IzVjBiR1YwVFdGd09pQlNiM1YwWlhKUGRYUnNaWFJOWVhBcE9pQjJiMmxrSUh0Y2JpQWdJQ0JqYjI1emRDQndjbVYyUTJocGJHUnlaVzQ2SUh0YmEyVjVPaUJ6ZEhKcGJtZGRPaUJoYm5sOUlEMGdibTlrWlVOb2FXeGtjbVZ1UVhOTllYQW9ZM1Z5Y2s1dlpHVXBPMXh1SUNBZ0lHWjFkSFZ5WlU1dlpHVXVZMmhwYkdSeVpXNHVabTl5UldGamFDaGpJRDArSUh0Y2JpQWdJQ0FnSUhSb2FYTXVkSEpoZG1WeWMyVlNiM1YwWlhNb1l5d2djSEpsZGtOb2FXeGtjbVZ1VzJNdWRtRnNkV1V1YjNWMGJHVjBYU3dnYjNWMGJHVjBUV0Z3S1R0Y2JpQWdJQ0FnSUdSbGJHVjBaU0J3Y21WMlEyaHBiR1J5Wlc1Yll5NTJZV3gxWlM1dmRYUnNaWFJkTzF4dUlDQWdJSDBwTzF4dUlDQWdJR1p2Y2tWaFkyZ29YRzRnSUNBZ0lDQWdJSEJ5WlhaRGFHbHNaSEpsYml4Y2JpQWdJQ0FnSUNBZ0tIWTZJR0Z1ZVN3Z2F6b2djM1J5YVc1bktTQTlQaUIwYUdsekxtUmxZV04wYVhaaGRHVlBkWFJzWlhSQmJtUkpkRU5vYVd4a2NtVnVLSFlzSUc5MWRHeGxkRTFoY0M1ZmIzVjBiR1YwYzF0clhTa3BPMXh1SUNCOVhHNWNiaUFnZEhKaGRtVnljMlZTYjNWMFpYTW9YRzRnSUNBZ0lDQm1kWFIxY21WT2IyUmxPaUJVY21WbFRtOWtaVHhCWTNScGRtRjBaV1JTYjNWMFpWTnVZWEJ6YUc5MFBpd2dZM1Z5Y2s1dlpHVTZJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0xGeHVJQ0FnSUNBZ2NHRnlaVzUwVDNWMGJHVjBUV0Z3T2lCU2IzVjBaWEpQZFhSc1pYUk5ZWEFwT2lCMmIybGtJSHRjYmlBZ0lDQmpiMjV6ZENCbWRYUjFjbVVnUFNCbWRYUjFjbVZPYjJSbExuWmhiSFZsTzF4dUlDQWdJR052Ym5OMElHTjFjbklnUFNCamRYSnlUbTlrWlNBL0lHTjFjbkpPYjJSbExuWmhiSFZsSURvZ2JuVnNiRHRjYmlBZ0lDQmpiMjV6ZENCdmRYUnNaWFFnUFNCd1lYSmxiblJQZFhSc1pYUk5ZWEFnUHlCd1lYSmxiblJQZFhSc1pYUk5ZWEF1WDI5MWRHeGxkSE5iWm5WMGRYSmxUbTlrWlM1MllXeDFaUzV2ZFhSc1pYUmRJRG9nYm5Wc2JEdGNibHh1SUNBZ0lHbG1JQ2hqZFhKeUlDWW1JR1oxZEhWeVpTNWZjbTkxZEdWRGIyNW1hV2NnUFQwOUlHTjFjbkl1WDNKdmRYUmxRMjl1Wm1sbktTQjdYRzRnSUNBZ0lDQnBaaUFvSVhOb1lXeHNiM2RGY1hWaGJDaG1kWFIxY21VdWNHRnlZVzF6TENCamRYSnlMbkJoY21GdGN5a3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWphR1ZqYTNNdWNIVnphQ2h1WlhjZ1EyRnVSR1ZoWTNScGRtRjBaU2h2ZFhSc1pYUXVZMjl0Y0c5dVpXNTBMQ0JqZFhKeUtTd2dibVYzSUVOaGJrRmpkR2wyWVhSbEtHWjFkSFZ5WlNrcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2RHaHBjeTUwY21GMlpYSnpaVU5vYVd4a1VtOTFkR1Z6S0daMWRIVnlaVTV2WkdVc0lHTjFjbkpPYjJSbExDQnZkWFJzWlhRZ1B5QnZkWFJzWlhRdWIzVjBiR1YwVFdGd0lEb2diblZzYkNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSFJvYVhNdVpHVmhZM1JwZG1GMFpVOTFkR3hsZEVGdVpFbDBRMmhwYkdSeVpXNG9ZM1Z5Y2l3Z2IzVjBiR1YwS1R0Y2JpQWdJQ0FnSUhSb2FYTXVZMmhsWTJ0ekxuQjFjMmdvYm1WM0lFTmhia0ZqZEdsMllYUmxLR1oxZEhWeVpTa3BPMXh1SUNBZ0lDQWdkR2hwY3k1MGNtRjJaWEp6WlVOb2FXeGtVbTkxZEdWektHWjFkSFZ5WlU1dlpHVXNJRzUxYkd3c0lHOTFkR3hsZENBL0lHOTFkR3hsZEM1dmRYUnNaWFJOWVhBZ09pQnVkV3hzS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCd2NtbDJZWFJsSUdSbFlXTjBhWFpoZEdWUGRYUnNaWFJCYm1SSmRFTm9hV3hrY21WdUtISnZkWFJsT2lCQlkzUnBkbUYwWldSU2IzVjBaVk51WVhCemFHOTBMQ0J2ZFhSc1pYUTZJRkp2ZFhSbGNrOTFkR3hsZENrNklIWnZhV1FnZTF4dUlDQWdJR2xtSUNodmRYUnNaWFFnSmlZZ2IzVjBiR1YwTG1selFXTjBhWFpoZEdWa0tTQjdYRzRnSUNBZ0lDQm1iM0pGWVdOb0tHOTFkR3hsZEM1dmRYUnNaWFJOWVhBdVgyOTFkR3hsZEhNc0lDaDJPaUJTYjNWMFpYSlBkWFJzWlhRcElEMCtJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIWXVhWE5CWTNScGRtRjBaV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TG1SbFlXTjBhWFpoZEdWUGRYUnNaWFJCYm1SSmRFTm9hV3hrY21WdUtIWXVZV04wYVhaaGRHVmtVbTkxZEdVdWMyNWhjSE5vYjNRc0lIWXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUhSb2FYTXVZMmhsWTJ0ekxuQjFjMmdvYm1WM0lFTmhia1JsWVdOMGFYWmhkR1VvYjNWMGJHVjBMbU52YlhCdmJtVnVkQ3dnY205MWRHVXBLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J3Y21sMllYUmxJSEoxYmtOaGJrRmpkR2wyWVhSbEtHWjFkSFZ5WlRvZ1FXTjBhWFpoZEdWa1VtOTFkR1ZUYm1Gd2MyaHZkQ2s2SUU5aWMyVnlkbUZpYkdVOFltOXZiR1ZoYmo0Z2UxeHVJQ0FnSUdOdmJuTjBJR05oYmtGamRHbDJZWFJsSUQwZ1puVjBkWEpsTGw5eWIzVjBaVU52Ym1acFp5QS9JR1oxZEhWeVpTNWZjbTkxZEdWRGIyNW1hV2N1WTJGdVFXTjBhWFpoZEdVZ09pQnVkV3hzTzF4dUlDQWdJR2xtSUNnaFkyRnVRV04wYVhaaGRHVWdmSHdnWTJGdVFXTjBhWFpoZEdVdWJHVnVaM1JvSUQwOVBTQXdLU0J5WlhSMWNtNGdiMllnS0hSeWRXVXBPMXh1SUNBZ0lISmxkSFZ5YmlCUFluTmxjblpoWW14bExtWnliMjBvWTJGdVFXTjBhWFpoZEdVcFhHNGdJQ0FnSUNBZ0lDNXRZWEFvWXlBOVBpQjdYRzRnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdaM1ZoY21RZ1BTQjBhR2x6TG1sdWFtVmpkRzl5TG1kbGRDaGpLVHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9aM1ZoY21RdVkyRnVRV04wYVhaaGRHVXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCM2NtRndTVzUwYjA5aWMyVnlkbUZpYkdVb1ozVmhjbVF1WTJGdVFXTjBhWFpoZEdVb1puVjBkWEpsTENCMGFHbHpMbVoxZEhWeVpTa3BPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2QzSmhjRWx1ZEc5UFluTmxjblpoWW14bEtHZDFZWEprS0daMWRIVnlaU3dnZEdocGN5NW1kWFIxY21VcEtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgwcFhHNGdJQ0FnSUNBZ0lDNXRaWEpuWlVGc2JDZ3BYRzRnSUNBZ0lDQWdJQzVsZG1WeWVTaHlaWE4xYkhRZ1BUNGdjbVZ6ZFd4MElEMDlQU0IwY25WbEtUdGNiaUFnZlZ4dVhHNGdJSEJ5YVhaaGRHVWdjblZ1UTJGdVJHVmhZM1JwZG1GMFpTaGpiMjF3YjI1bGJuUTZJRTlpYW1WamRDd2dZM1Z5Y2pvZ1FXTjBhWFpoZEdWa1VtOTFkR1ZUYm1Gd2MyaHZkQ2s2SUU5aWMyVnlkbUZpYkdVOFltOXZiR1ZoYmo0Z2UxeHVJQ0FnSUdOdmJuTjBJR05oYmtSbFlXTjBhWFpoZEdVZ1BTQmpkWEp5TGw5eWIzVjBaVU52Ym1acFp5QS9JR04xY25JdVgzSnZkWFJsUTI5dVptbG5MbU5oYmtSbFlXTjBhWFpoZEdVZ09pQnVkV3hzTzF4dUlDQWdJR2xtSUNnaFkyRnVSR1ZoWTNScGRtRjBaU0I4ZkNCallXNUVaV0ZqZEdsMllYUmxMbXhsYm1kMGFDQTlQVDBnTUNrZ2NtVjBkWEp1SUc5bUlDaDBjblZsS1R0Y2JpQWdJQ0J5WlhSMWNtNGdUMkp6WlhKMllXSnNaUzVtY205dEtHTmhia1JsWVdOMGFYWmhkR1VwWEc0Z0lDQWdJQ0FnSUM1dFlYQW9ZeUE5UGlCN1hHNGdJQ0FnSUNBZ0lDQWdZMjl1YzNRZ1ozVmhjbVFnUFNCMGFHbHpMbWx1YW1WamRHOXlMbWRsZENoaktUdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb1ozVmhjbVF1WTJGdVJHVmhZM1JwZG1GMFpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhkeVlYQkpiblJ2VDJKelpYSjJZV0pzWlNobmRXRnlaQzVqWVc1RVpXRmpkR2wyWVhSbEtHTnZiWEJ2Ym1WdWRDd2dZM1Z5Y2l3Z2RHaHBjeTVqZFhKeUtTazdYRzRnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCM2NtRndTVzUwYjA5aWMyVnlkbUZpYkdVb1ozVmhjbVFvWTI5dGNHOXVaVzUwTENCamRYSnlMQ0IwYUdsekxtTjFjbklwS1R0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDBwWEc0Z0lDQWdJQ0FnSUM1dFpYSm5aVUZzYkNncFhHNGdJQ0FnSUNBZ0lDNWxkbVZ5ZVNoeVpYTjFiSFFnUFQ0Z2NtVnpkV3gwSUQwOVBTQjBjblZsS1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjNjbUZ3U1c1MGIwOWljMlZ5ZG1GaWJHVThWRDRvZG1Gc2RXVTZJRlFnZkNCUFluTmxjblpoWW14bFBGUStLVG9nVDJKelpYSjJZV0pzWlR4VVBpQjdYRzRnSUdsbUlDaDJZV3gxWlNCcGJuTjBZVzVqWlc5bUlFOWljMlZ5ZG1GaWJHVXBJSHRjYmlBZ0lDQnlaWFIxY200Z2RtRnNkV1U3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnY21WMGRYSnVJRzltSUNoMllXeDFaU2s3WEc0Z0lIMWNibjFjYmx4dVkyeGhjM01nUVdOMGFYWmhkR1ZTYjNWMFpYTWdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaHdjbWwyWVhSbElHWjFkSFZ5WlZOMFlYUmxPaUJTYjNWMFpYSlRkR0YwWlN3Z2NISnBkbUYwWlNCamRYSnlVM1JoZEdVNklGSnZkWFJsY2xOMFlYUmxLU0I3ZlZ4dVhHNGdJR0ZqZEdsMllYUmxLSEJoY21WdWRFOTFkR3hsZEUxaGNEb2dVbTkxZEdWeVQzVjBiR1YwVFdGd0tUb2dkbTlwWkNCN1hHNGdJQ0FnWTI5dWMzUWdablYwZFhKbFVtOXZkQ0E5SUhSb2FYTXVablYwZFhKbFUzUmhkR1V1WDNKdmIzUTdYRzRnSUNBZ1kyOXVjM1FnWTNWeWNsSnZiM1FnUFNCMGFHbHpMbU4xY25KVGRHRjBaU0EvSUhSb2FYTXVZM1Z5Y2xOMFlYUmxMbDl5YjI5MElEb2diblZzYkR0Y2JseHVJQ0FnSUhCMWMyaFJkV1Z5ZVZCaGNtRnRjMEZ1WkVaeVlXZHRaVzUwS0hSb2FYTXVablYwZFhKbFUzUmhkR1VwTzF4dUlDQWdJSFJvYVhNdVlXTjBhWFpoZEdWRGFHbHNaRkp2ZFhSbGN5aG1kWFIxY21WU2IyOTBMQ0JqZFhKeVVtOXZkQ3dnY0dGeVpXNTBUM1YwYkdWMFRXRndLVHRjYmlBZ2ZWeHVYRzRnSUhCeWFYWmhkR1VnWVdOMGFYWmhkR1ZEYUdsc1pGSnZkWFJsY3loY2JpQWdJQ0FnSUdaMWRIVnlaVTV2WkdVNklGUnlaV1ZPYjJSbFBFRmpkR2wyWVhSbFpGSnZkWFJsUGl3Z1kzVnljazV2WkdVNklGUnlaV1ZPYjJSbFBFRmpkR2wyWVhSbFpGSnZkWFJsUGl4Y2JpQWdJQ0FnSUc5MWRHeGxkRTFoY0RvZ1VtOTFkR1Z5VDNWMGJHVjBUV0Z3S1RvZ2RtOXBaQ0I3WEc0Z0lDQWdZMjl1YzNRZ2NISmxka05vYVd4a2NtVnVPaUI3VzJ0bGVUb2djM1J5YVc1blhUb2dZVzU1ZlNBOUlHNXZaR1ZEYUdsc1pISmxia0Z6VFdGd0tHTjFjbkpPYjJSbEtUdGNiaUFnSUNCbWRYUjFjbVZPYjJSbExtTm9hV3hrY21WdUxtWnZja1ZoWTJnb1l5QTlQaUI3WEc0Z0lDQWdJQ0IwYUdsekxtRmpkR2wyWVhSbFVtOTFkR1Z6S0dNc0lIQnlaWFpEYUdsc1pISmxibHRqTG5aaGJIVmxMbTkxZEd4bGRGMHNJRzkxZEd4bGRFMWhjQ2s3WEc0Z0lDQWdJQ0JrWld4bGRHVWdjSEpsZGtOb2FXeGtjbVZ1VzJNdWRtRnNkV1V1YjNWMGJHVjBYVHRjYmlBZ0lDQjlLVHRjYmlBZ0lDQm1iM0pGWVdOb0tGeHVJQ0FnSUNBZ0lDQndjbVYyUTJocGJHUnlaVzRzWEc0Z0lDQWdJQ0FnSUNoMk9pQmhibmtzSUdzNklITjBjbWx1WnlrZ1BUNGdkR2hwY3k1a1pXRmpkR2wyWVhSbFQzVjBiR1YwUVc1a1NYUkRhR2xzWkhKbGJpaHZkWFJzWlhSTllYQXVYMjkxZEd4bGRITmJhMTBwS1R0Y2JpQWdmVnh1WEc0Z0lHRmpkR2wyWVhSbFVtOTFkR1Z6S0Z4dUlDQWdJQ0FnWm5WMGRYSmxUbTlrWlRvZ1ZISmxaVTV2WkdVOFFXTjBhWFpoZEdWa1VtOTFkR1UrTENCamRYSnlUbTlrWlRvZ1ZISmxaVTV2WkdVOFFXTjBhWFpoZEdWa1VtOTFkR1UrTEZ4dUlDQWdJQ0FnY0dGeVpXNTBUM1YwYkdWMFRXRndPaUJTYjNWMFpYSlBkWFJzWlhSTllYQXBPaUIyYjJsa0lIdGNiaUFnSUNCamIyNXpkQ0JtZFhSMWNtVWdQU0JtZFhSMWNtVk9iMlJsTG5aaGJIVmxPMXh1SUNBZ0lHTnZibk4wSUdOMWNuSWdQU0JqZFhKeVRtOWtaU0EvSUdOMWNuSk9iMlJsTG5aaGJIVmxJRG9nYm5Wc2JEdGNibHh1SUNBZ0lHTnZibk4wSUc5MWRHeGxkQ0E5SUdkbGRFOTFkR3hsZENod1lYSmxiblJQZFhSc1pYUk5ZWEFzSUdaMWRIVnlaVTV2WkdVdWRtRnNkV1VwTzF4dVhHNGdJQ0FnYVdZZ0tHWjFkSFZ5WlNBOVBUMGdZM1Z5Y2lrZ2UxeHVJQ0FnSUNBZ1lXUjJZVzVqWlVGamRHbDJZWFJsWkZKdmRYUmxLR1oxZEhWeVpTazdYRzRnSUNBZ0lDQjBhR2x6TG1GamRHbDJZWFJsUTJocGJHUlNiM1YwWlhNb1puVjBkWEpsVG05a1pTd2dZM1Z5Y2s1dlpHVXNJRzkxZEd4bGRDNXZkWFJzWlhSTllYQXBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCMGFHbHpMbVJsWVdOMGFYWmhkR1ZQZFhSc1pYUkJibVJKZEVOb2FXeGtjbVZ1S0c5MWRHeGxkQ2s3WEc0Z0lDQWdJQ0JqYjI1emRDQnZkWFJzWlhSTllYQWdQU0J1WlhjZ1VtOTFkR1Z5VDNWMGJHVjBUV0Z3S0NrN1hHNGdJQ0FnSUNCMGFHbHpMbUZqZEdsMllYUmxUbVYzVW05MWRHVnpLRzkxZEd4bGRFMWhjQ3dnWm5WMGRYSmxMQ0J2ZFhSc1pYUXBPMXh1SUNBZ0lDQWdkR2hwY3k1aFkzUnBkbUYwWlVOb2FXeGtVbTkxZEdWektHWjFkSFZ5WlU1dlpHVXNJRzUxYkd3c0lHOTFkR3hsZEUxaGNDazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdjSEpwZG1GMFpTQmhZM1JwZG1GMFpVNWxkMUp2ZFhSbGN5aGNiaUFnSUNBZ0lHOTFkR3hsZEUxaGNEb2dVbTkxZEdWeVQzVjBiR1YwVFdGd0xDQm1kWFIxY21VNklFRmpkR2wyWVhSbFpGSnZkWFJsTENCdmRYUnNaWFE2SUZKdmRYUmxjazkxZEd4bGRDazZJSFp2YVdRZ2UxeHVJQ0FnSUdOdmJuTjBJSEpsYzI5c2RtVmtJRDBnVW1WbWJHVmpkR2wyWlVsdWFtVmpkRzl5TG5KbGMyOXNkbVVvVzF4dUlDQWdJQ0FnZTNCeWIzWnBaR1U2SUVGamRHbDJZWFJsWkZKdmRYUmxMQ0IxYzJWV1lXeDFaVG9nWm5WMGRYSmxmU3hjYmlBZ0lDQWdJSHR3Y205MmFXUmxPaUJTYjNWMFpYSlBkWFJzWlhSTllYQXNJSFZ6WlZaaGJIVmxPaUJ2ZFhSc1pYUk5ZWEI5WEc0Z0lDQWdYU2s3WEc0Z0lDQWdZV1IyWVc1alpVRmpkR2wyWVhSbFpGSnZkWFJsS0daMWRIVnlaU2s3WEc0Z0lDQWdiM1YwYkdWMExtRmpkR2wyWVhSbEtHWjFkSFZ5WlM1ZlpuVjBkWEpsVTI1aGNITm9iM1F1WDNKbGMyOXNkbVZrUTI5dGNHOXVaVzUwUm1GamRHOXllU3dnWm5WMGRYSmxMQ0J5WlhOdmJIWmxaQ3dnYjNWMGJHVjBUV0Z3S1R0Y2JpQWdmVnh1WEc0Z0lIQnlhWFpoZEdVZ1pHVmhZM1JwZG1GMFpVOTFkR3hsZEVGdVpFbDBRMmhwYkdSeVpXNG9iM1YwYkdWME9pQlNiM1YwWlhKUGRYUnNaWFFwT2lCMmIybGtJSHRjYmlBZ0lDQnBaaUFvYjNWMGJHVjBJQ1ltSUc5MWRHeGxkQzVwYzBGamRHbDJZWFJsWkNrZ2UxeHVJQ0FnSUNBZ1ptOXlSV0ZqYUNoY2JpQWdJQ0FnSUNBZ0lDQnZkWFJzWlhRdWIzVjBiR1YwVFdGd0xsOXZkWFJzWlhSekxDQW9kam9nVW05MWRHVnlUM1YwYkdWMEtTQTlQaUIwYUdsekxtUmxZV04wYVhaaGRHVlBkWFJzWlhSQmJtUkpkRU5vYVd4a2NtVnVLSFlwS1R0Y2JpQWdJQ0FnSUc5MWRHeGxkQzVrWldGamRHbDJZWFJsS0NrN1hHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlIQjFjMmhSZFdWeWVWQmhjbUZ0YzBGdVpFWnlZV2R0Wlc1MEtITjBZWFJsT2lCU2IzVjBaWEpUZEdGMFpTazZJSFp2YVdRZ2UxeHVJQ0JwWmlBb0lYTm9ZV3hzYjNkRmNYVmhiQ2h6ZEdGMFpTNXpibUZ3YzJodmRDNXhkV1Z5ZVZCaGNtRnRjeXdnS0R4aGJuaytjM1JoZEdVdWNYVmxjbmxRWVhKaGJYTXBMblpoYkhWbEtTa2dlMXh1SUNBZ0lDZzhZVzU1UG5OMFlYUmxMbkYxWlhKNVVHRnlZVzF6S1M1dVpYaDBLSE4wWVhSbExuTnVZWEJ6YUc5MExuRjFaWEo1VUdGeVlXMXpLVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHpkR0YwWlM1emJtRndjMmh2ZEM1bWNtRm5iV1Z1ZENBaFBUMGdLRHhoYm5rK2MzUmhkR1V1Wm5KaFoyMWxiblFwTG5aaGJIVmxLU0I3WEc0Z0lDQWdLRHhoYm5rK2MzUmhkR1V1Wm5KaFoyMWxiblFwTG01bGVIUW9jM1JoZEdVdWMyNWhjSE5vYjNRdVpuSmhaMjFsYm5RcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJRzV2WkdWRGFHbHNaSEpsYmtGelRXRndLRzV2WkdVNklGUnlaV1ZPYjJSbFBHRnVlVDRwSUh0Y2JpQWdjbVYwZFhKdUlHNXZaR1VnUHlCdWIyUmxMbU5vYVd4a2NtVnVMbkpsWkhWalpTZ29iVG9nWVc1NUxDQmpPaUJVY21WbFRtOWtaVHhoYm5rK0tTQTlQaUI3WEc0Z0lDQWdiVnRqTG5aaGJIVmxMbTkxZEd4bGRGMGdQU0JqTzF4dUlDQWdJSEpsZEhWeWJpQnRPMXh1SUNCOUxDQjdmU2tnT2lCN2ZUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1oyVjBUM1YwYkdWMEtHOTFkR3hsZEUxaGNEb2dVbTkxZEdWeVQzVjBiR1YwVFdGd0xDQnliM1YwWlRvZ1FXTjBhWFpoZEdWa1VtOTFkR1VwT2lCU2IzVjBaWEpQZFhSc1pYUWdlMXh1SUNCc1pYUWdiM1YwYkdWMElEMGdiM1YwYkdWMFRXRndMbDl2ZFhSc1pYUnpXM0p2ZFhSbExtOTFkR3hsZEYwN1hHNGdJR2xtSUNnaGIzVjBiR1YwS1NCN1hHNGdJQ0FnWTI5dWMzUWdZMjl0Y0c5dVpXNTBUbUZ0WlNBOUlDZzhZVzU1UG5KdmRYUmxMbU52YlhCdmJtVnVkQ2t1Ym1GdFpUdGNiaUFnSUNCcFppQW9jbTkxZEdVdWIzVjBiR1YwSUQwOVBTQlFVa2xOUVZKWlgwOVZWRXhGVkNrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0dCRFlXNXViM1FnWm1sdVpDQndjbWx0WVhKNUlHOTFkR3hsZENCMGJ5QnNiMkZrSUNja2UyTnZiWEJ2Ym1WdWRFNWhiV1Y5SjJBcE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9ZRU5oYm01dmRDQm1hVzVrSUhSb1pTQnZkWFJzWlhRZ0pIdHliM1YwWlM1dmRYUnNaWFI5SUhSdklHeHZZV1FnSnlSN1kyOXRjRzl1Wlc1MFRtRnRaWDBuWUNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhKbGRIVnliaUJ2ZFhSc1pYUTdYRzU5WEc0aVhYMD1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvcm91dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMzk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2Nhbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2NhbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNjYW4gPSBzY2FuXzEuc2Nhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYW4uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2Nhbi5qc1xuICoqIG1vZHVsZSBpZCA9IDM5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29uY2F0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0ID0gY29uY2F0XzEuY29uY2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4vbWVyZ2VBbGwnKTtcbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBzZXF1ZW50aWFsbHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIGFmdGVyIHRoZSBjdXJyZW50IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbmNhdGVuYXRlcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieVxuICogc2VxdWVudGlhbGx5IGVtaXR0aW5nIHRoZWlyIHZhbHVlcywgb25lIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBKb2lucyB0aGlzIE9ic2VydmFibGUgd2l0aCBtdWx0aXBsZSBvdGhlciBPYnNlcnZhYmxlcyBieSBzdWJzY3JpYmluZyB0byB0aGVtXG4gKiBvbmUgYXQgYSB0aW1lLCBzdGFydGluZyB3aXRoIHRoZSBzb3VyY2UsIGFuZCBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLiBXaWxsIHdhaXQgZm9yIGVhY2ggT2JzZXJ2YWJsZSB0byBjb21wbGV0ZSBiZWZvcmUgbW92aW5nXG4gKiBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhIHRpbWVyIGNvdW50aW5nIGZyb20gMCB0byAzIHdpdGggYSBzeW5jaHJvbm91cyBzZXF1ZW5jZSBmcm9tIDEgdG8gMTA8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCk7XG4gKiB2YXIgc2VxdWVuY2UgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lci5jb25jYXQoc2VxdWVuY2UpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSAzIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lcjEuY29uY2F0KHRpbWVyMiwgdGltZXIzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgU2NoZWR1bGVyIHRvIHNjaGVkdWxlIGVhY2hcbiAqIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQWxsIHZhbHVlcyBvZiBlYWNoIHBhc3NlZCBPYnNlcnZhYmxlIG1lcmdlZCBpbnRvIGFcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCBpbiBvcmRlciwgaW4gc2VyaWFsIGZhc2hpb24uXG4gKiBAbWV0aG9kIGNvbmNhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0U3RhdGljLmFwcGx5KHZvaWQgMCwgW3RoaXNdLmNvbmNhdChvYnNlcnZhYmxlcykpO1xufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW0gb25lIGF0IGEgdGltZSBhbmRcbiAqIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gV2lsbCB3YWl0IGZvciBlYWNoXG4gKiBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgMyBPYnNlcnZhYmxlczwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIxLCB0aW1lcjIsIHRpbWVyMyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gaW5wdXQxIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgd2l0aCBvdGhlcnMuXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IGlucHV0MiBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBTY2hlZHVsZXIgdG8gc2NoZWR1bGUgZWFjaFxuICogT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbGwgdmFsdWVzIG9mIGVhY2ggcGFzc2VkIE9ic2VydmFibGUgbWVyZ2VkIGludG8gYVxuICogc2luZ2xlIE9ic2VydmFibGUsIGluIG9yZGVyLCBpbiBzZXJpYWwgZmFzaGlvbi5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgY29uY2F0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzY2hlZHVsZXIgPSBudWxsO1xuICAgIHZhciBhcmdzID0gb2JzZXJ2YWJsZXM7XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoYXJnc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKDEpKTtcbn1cbmV4cG9ydHMuY29uY2F0U3RhdGljID0gY29uY2F0U3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvY29uY2F0LmpzXG4gKiogbW9kdWxlIGlkID0gNDAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29uY2F0TWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9jb25jYXRNYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb25jYXRNYXAgPSBjb25jYXRNYXBfMS5jb25jYXRNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRNYXAuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0TWFwLmpzXG4gKiogbW9kdWxlIGlkID0gNDAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZU1hcF8xID0gcmVxdWlyZSgnLi9tZXJnZU1hcCcpO1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLCBpbiBhIHNlcmlhbGl6ZWQgZmFzaGlvbiB3YWl0aW5nIGZvciBlYWNoIG9uZSB0byBjb21wbGV0ZSBiZWZvcmVcbiAqIG1lcmdpbmcgdGhlIG5leHQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIGNvbmNhdEFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0TWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIEVhY2ggbmV3IGlubmVyIE9ic2VydmFibGUgaXNcbiAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlLlxuICpcbiAqIF9fV2FybmluZzpfXyBpZiBzb3VyY2UgdmFsdWVzIGFycml2ZSBlbmRsZXNzbHkgYW5kIGZhc3RlciB0aGFuIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIGlubmVyIE9ic2VydmFibGVzIGNhbiBjb21wbGV0ZSwgaXQgd2lsbCByZXN1bHQgaW4gbWVtb3J5IGlzc3Vlc1xuICogYXMgaW5uZXIgT2JzZXJ2YWJsZXMgYW1hc3MgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlciB3YWl0aW5nIGZvciB0aGVpciB0dXJuIHRvXG4gKiBiZSBzdWJzY3JpYmVkIHRvLlxuICpcbiAqIE5vdGU6IGBjb25jYXRNYXBgIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlTWFwYCB3aXRoIGNvbmN1cnJlbmN5IHBhcmFtZXRlciBzZXRcbiAqIHRvIGAxYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3IgZWFjaCBjbGljayBldmVudCwgdGljayBldmVyeSBzZWNvbmQgZnJvbSAwIHRvIDMsIHdpdGggbm8gY29uY3VycmVuY3k8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5jb25jYXRNYXAoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0fVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlfSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIG9ic2VydmFibGUgb2YgdmFsdWVzIG1lcmdlZCBmcm9tIHRoZSBwcm9qZWN0ZWRcbiAqIE9ic2VydmFibGVzIGFzIHRoZXkgd2VyZSBzdWJzY3JpYmVkIHRvLCBvbmUgYXQgYSB0aW1lLiBPcHRpb25hbGx5LCB0aGVzZVxuICogdmFsdWVzIG1heSBoYXZlIGJlZW4gcHJvamVjdGVkIGZyb20gYSBwYXNzZWQgYHByb2plY3RSZXN1bHRgIGFyZ3VtZW50LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZyB2YWx1ZXMgZnJvbSBlYWNoIHByb2plY3RlZCBpbm5lclxuICogT2JzZXJ2YWJsZSBzZXF1ZW50aWFsbHkuXG4gKiBAbWV0aG9kIGNvbmNhdE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgbWVyZ2VNYXBfMS5NZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCAxKSk7XG59XG5leHBvcnRzLmNvbmNhdE1hcCA9IGNvbmNhdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2NvbmNhdE1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGV2ZXJ5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9ldmVyeScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmV2ZXJ5ID0gZXZlcnlfMS5ldmVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZXJ5LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2V2ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNDA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hldGhlciBvciBub3QgZXZlcnkgaXRlbSBvZiB0aGUgc291cmNlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSBhIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyBpZiBhbiBpdGVtIG1lZXRzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gb3B0aW9uYWwgb2JqZWN0IHRvIHVzZSBmb3IgYHRoaXNgIGluIHRoZSBjYWxsYmFja1xuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSBvZiBib29sZWFucyB0aGF0IGRldGVybWluZXMgaWYgYWxsIGl0ZW1zIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtZWV0IHRoZSBjb25kaXRpb24gc3BlY2lmaWVkLlxuICogQG1ldGhvZCBldmVyeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRXZlcnlPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcsIHRoaXMpKTtcbn1cbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbnZhciBFdmVyeU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVyeU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgRXZlcnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgRXZlcnlTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZXJ5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBFdmVyeVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVyeVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlcnlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICB9XG4gICAgRXZlcnlTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVyeVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGV2ZXJ5VmFsdWVNYXRjaCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEV2ZXJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmluZGV4KyssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVyeVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVyeS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2V2ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNDA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlQWxsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VBbGwgPSBtZXJnZUFsbF8xLm1lcmdlQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA0MDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmcm9tXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb20nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb20gPSBmcm9tXzEuZnJvbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gNDA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gcm9tT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mcm9tID0gRnJvbU9ic2VydmFibGVfMS5Gcm9tT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gNDA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1Byb21pc2UnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIFByb21pc2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1Byb21pc2VPYnNlcnZhYmxlJyk7XG52YXIgSXRlcmF0b3JPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0l0ZXJhdG9yT2JzZXJ2YWJsZScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbnZhciBBcnJheUxpa2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5TGlrZU9ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3Ivb2JzZXJ2ZU9uJyk7XG52YXIgJCRvYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcbnZhciBpc0FycmF5TGlrZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRnJvbU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm9tT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pc2ggPSBpc2g7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBhbiBBcnJheSwgYW4gYXJyYXktbGlrZSBvYmplY3QsIGEgUHJvbWlzZSwgYW5cbiAgICAgKiBpdGVyYWJsZSBvYmplY3QsIG9yIGFuIE9ic2VydmFibGUtbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29udmVydHMgYWxtb3N0IGFueXRoaW5nIHRvIGFuIE9ic2VydmFibGUuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ29udmVydCB2YXJpb3VzIG90aGVyIG9iamVjdHMgYW5kIGRhdGEgdHlwZXMgaW50byBPYnNlcnZhYmxlcy4gYGZyb21gXG4gICAgICogY29udmVydHMgYSBQcm9taXNlIG9yIGFuIGFycmF5LWxpa2Ugb3IgYW5cbiAgICAgKiBbaXRlcmFibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmFibGUpXG4gICAgICogb2JqZWN0IGludG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGF0IHByb21pc2Ugb3IgYXJyYXkgb3JcbiAgICAgKiBpdGVyYWJsZS4gQSBTdHJpbmcsIGluIHRoaXMgY29udGV4dCwgaXMgdHJlYXRlZCBhcyBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLlxuICAgICAqIE9ic2VydmFibGUtbGlrZSBvYmplY3RzIChjb250YWlucyBhIGZ1bmN0aW9uIG5hbWVkIHdpdGggdGhlIEVTMjAxNSBTeW1ib2xcbiAgICAgKiBmb3IgT2JzZXJ2YWJsZSkgY2FuIGFsc28gYmUgY29udmVydGVkIHRocm91Z2ggdGhpcyBvcGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnRzIGFuIGFycmF5IHRvIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XG4gICAgICogdmFyIGFycmF5ID0gWzEwLCAyMCwgMzBdO1xuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmZyb20oYXJyYXkpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIGluZmluaXRlIGl0ZXJhYmxlIChmcm9tIGEgZ2VuZXJhdG9yKSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uKiBnZW5lcmF0ZURvdWJsZXMoc2VlZCkge1xuICAgICAqICAgdmFyIGkgPSBzZWVkO1xuICAgICAqICAgd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgICAgeWllbGQgaTtcbiAgICAgKiAgICAgaSA9IDIgKiBpOyAvLyBkb3VibGUgaXRcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaXRlcmF0b3IgPSBnZW5lcmF0ZURvdWJsZXMoMyk7XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbShpdGVyYXRvcikudGFrZSgxMCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnR9XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tUHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0PFQ+fSBpc2ggQSBzdWJzY3JpYmFibGUgb2JqZWN0LCBhIFByb21pc2UsIGFuXG4gICAgICogT2JzZXJ2YWJsZS1saWtlLCBhbiBBcnJheSwgYW4gaXRlcmFibGUgb3IgYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYmVcbiAgICAgKiBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiBhbnksIGk6IG51bWJlcik6IFR9IFttYXBGbl0gQSBcIm1hcFwiIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICAgKiB3aGVuIGNvbnZlcnRpbmcgYXJyYXktbGlrZSBvYmplY3RzLCB3aGVyZSBgeGAgaXMgYSB2YWx1ZSBmcm9tIHRoZVxuICAgICAqIGFycmF5LWxpa2UgYW5kIGBpYCBpcyB0aGUgaW5kZXggb2YgdGhhdCB2YWx1ZSBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBUaGUgY29udGV4dCBvYmplY3QgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgYG1hcEZuYCxcbiAgICAgKiBpZiBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBlbWlzc2lvbnMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgb3JpZ2luYWxseSBmcm9tIHRoZVxuICAgICAqIGlucHV0IG9iamVjdCB0aGF0IHdhcyBjb252ZXJ0ZWQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGlzaCwgbWFwRm5PclNjaGVkdWxlciwgdGhpc0FyZywgbGFzdFNjaGVkdWxlcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgdmFyIG1hcEZuID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG1hcEZuT3JTY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBsYXN0U2NoZWR1bGVyIHx8IG51bGw7XG4gICAgICAgICAgICBtYXBGbiA9IG1hcEZuT3JTY2hlZHVsZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBtYXBGbk9yU2NoZWR1bGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc2hbJCRvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChpc2ggaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSAmJiAhc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnJvbU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheV8xLmlzQXJyYXkoaXNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShpc2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlT2JzZXJ2YWJsZV8xLlByb21pc2VPYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpc2hbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlXzEuSXRlcmF0b3JPYnNlcnZhYmxlKGlzaCwgbnVsbCwgbnVsbCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlKGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5TGlrZU9ic2VydmFibGVfMS5BcnJheUxpa2VPYnNlcnZhYmxlKGlzaCwgbWFwRm4sIHRoaXNBcmcsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigoaXNoICE9PSBudWxsICYmIHR5cGVvZiBpc2ggfHwgaXNoKSArICcgaXMgbm90IG9ic2VydmFibGUnKTtcbiAgICB9O1xuICAgIEZyb21PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGlzaCA9IHRoaXMuaXNoO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzaFskJG9ic2VydmFibGVdKCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzaFskJG9ic2VydmFibGVdKCkuc3Vic2NyaWJlKG5ldyBvYnNlcnZlT25fMS5PYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgMCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkZyb21PYnNlcnZhYmxlID0gRnJvbU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvRnJvbU9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNPYmplY3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgSXRlcmF0b3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlcmF0b3JPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yT2JzZXJ2YWJsZShpdGVyYXRvciwgcHJvamVjdCwgdGhpc0FyZywgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoaXRlcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChwcm9qZWN0KSkge1xuICAgICAgICAgICAgdGhpcy50aGlzQXJnID0gcHJvamVjdDtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyID0gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihwcm9qZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBwcm92aWRlZCwgYHByb2plY3RgIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBJdGVyYXRvck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBwcm9qZWN0LCB0aGlzQXJnLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvck9ic2VydmFibGUoaXRlcmF0b3IsIHByb2plY3QsIHRoaXNBcmcsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIGhhc0Vycm9yID0gc3RhdGUuaGFzRXJyb3IsIHRoaXNBcmcgPSBzdGF0ZS50aGlzQXJnLCBwcm9qZWN0ID0gc3RhdGUucHJvamVjdCwgaXRlcmF0b3IgPSBzdGF0ZS5pdGVyYXRvciwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihzdGF0ZS5lcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2gocHJvamVjdCkuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5lcnJvciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXIuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGl0ZXJhdG9yID0gX2EuaXRlcmF0b3IsIHByb2plY3QgPSBfYS5wcm9qZWN0LCB0aGlzQXJnID0gX2EudGhpc0FyZywgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEl0ZXJhdG9yT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCwgdGhpc0FyZzogdGhpc0FyZywgcHJvamVjdDogcHJvamVjdCwgaXRlcmF0b3I6IGl0ZXJhdG9yLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2gocHJvamVjdCkuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIGluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEl0ZXJhdG9yT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuSXRlcmF0b3JPYnNlcnZhYmxlID0gSXRlcmF0b3JPYnNlcnZhYmxlO1xudmFyIFN0cmluZ0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdJdGVyYXRvcihzdHIsIGlkeCwgbGVuKSB7XG4gICAgICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSBzdHIubGVuZ3RoOyB9XG4gICAgICAgIHRoaXMuc3RyID0gc3RyO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMpOyB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RyLmNoYXJBdCh0aGlzLmlkeCsrKVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdJdGVyYXRvcjtcbn0oKSk7XG52YXIgQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcihhcnIsIGlkeCwgbGVuKSB7XG4gICAgICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSB0b0xlbmd0aChhcnIpOyB9XG4gICAgICAgIHRoaXMuYXJyID0gYXJyO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkeCA8IHRoaXMubGVuID8ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5hcnJbdGhpcy5pZHgrK11cbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlJdGVyYXRvcjtcbn0oKSk7XG5mdW5jdGlvbiBnZXRJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgaSA9IG9ialtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdO1xuICAgIGlmICghaSAmJiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG4gICAgfVxuICAgIGlmICghaSAmJiBvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG4gICAgfVxuICAgIGlmICghaSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiBvYmpbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSgpO1xufVxudmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbmZ1bmN0aW9uIHRvTGVuZ3RoKG8pIHtcbiAgICB2YXIgbGVuID0gK28ubGVuZ3RoO1xuICAgIGlmIChpc05hTihsZW4pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIGxlbiA9IHNpZ24obGVuKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobGVuKSk7XG4gICAgaWYgKGxlbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID4gbWF4U2FmZUludGVnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1heFNhZmVJbnRlZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gbnVtYmVySXNGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByb290XzEucm9vdC5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaWduKHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlQXNOdW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKHZhbHVlQXNOdW1iZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gICAgfVxuICAgIGlmIChpc05hTih2YWx1ZUFzTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVBc051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlQXNOdW1iZXIgPCAwID8gLTEgOiAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlcmF0b3JPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9JdGVyYXRvck9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlMaWtlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5TGlrZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlMaWtlT2JzZXJ2YWJsZShhcnJheUxpa2UsIG1hcEZuLCB0aGlzQXJnLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXlMaWtlID0gYXJyYXlMaWtlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFtYXBGbiAmJiAhc2NoZWR1bGVyICYmIGFycmF5TGlrZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheUxpa2VbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcEZuKSB7XG4gICAgICAgICAgICB0aGlzLm1hcEZuID0gbWFwRm4uYmluZCh0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheUxpa2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcnJheUxpa2UsIG1hcEZuLCB0aGlzQXJnLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxICYmICFtYXBGbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheUxpa2VbMF0sIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5TGlrZU9ic2VydmFibGUoYXJyYXlMaWtlLCBtYXBGbiwgdGhpc0FyZywgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXlMaWtlID0gc3RhdGUuYXJyYXlMaWtlLCBpbmRleCA9IHN0YXRlLmluZGV4LCBsZW5ndGggPSBzdGF0ZS5sZW5ndGgsIG1hcEZuID0gc3RhdGUubWFwRm4sIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbWFwRm4gPyBtYXBGbihhcnJheUxpa2VbaW5kZXhdLCBpbmRleCkgOiBhcnJheUxpa2VbaW5kZXhdO1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGFycmF5TGlrZSA9IF9hLmFycmF5TGlrZSwgbWFwRm4gPSBfYS5tYXBGbiwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheUxpa2VPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMaWtlOiBhcnJheUxpa2UsIGluZGV4OiBpbmRleCwgbGVuZ3RoOiBsZW5ndGgsIG1hcEZuOiBtYXBGbiwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiAhc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hcEZuID8gbWFwRm4oYXJyYXlMaWtlW2ldLCBpKSA6IGFycmF5TGlrZVtpXTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFycmF5TGlrZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFycmF5TGlrZU9ic2VydmFibGUgPSBBcnJheUxpa2VPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlMaWtlT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvQXJyYXlMaWtlT2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgb2ZfMSA9IHJlcXVpcmUoJ3J4anMvb2JzZXJ2YWJsZS9vZicpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbnZhciB1cmxfdHJlZV8xID0gcmVxdWlyZSgnLi91cmxfdHJlZScpO1xudmFyIE5vTWF0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vTWF0Y2goc2VnbWVudCkge1xuICAgICAgICBpZiAoc2VnbWVudCA9PT0gdm9pZCAwKSB7IHNlZ21lbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBOb01hdGNoO1xufSgpKTtcbnZhciBHbG9iYWxSZWRpcmVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2xvYmFsUmVkaXJlY3QocGF0aHMpIHtcbiAgICAgICAgdGhpcy5wYXRocyA9IHBhdGhzO1xuICAgIH1cbiAgICByZXR1cm4gR2xvYmFsUmVkaXJlY3Q7XG59KCkpO1xuZnVuY3Rpb24gYXBwbHlSZWRpcmVjdHModXJsVHJlZSwgY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVVybFRyZWUodXJsVHJlZSwgZXhwYW5kU2VnbWVudChjb25maWcsIHVybFRyZWUucm9vdCwgc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBHbG9iYWxSZWRpcmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVVybFRyZWUodXJsVHJlZSwgbmV3IHVybF90cmVlXzEuVXJsU2VnbWVudChbXSwgKF9hID0ge30sIF9hW3NoYXJlZF8xLlBSSU1BUllfT1VUTEVUXSA9IG5ldyB1cmxfdHJlZV8xLlVybFNlZ21lbnQoZS5wYXRocywge30pLCBfYSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlIGluc3RhbmNlb2YgTm9NYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9icy5lcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgbWF0Y2ggYW55IHJvdXRlczogJ1wiICsgZS5zZWdtZW50ICsgXCInXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IoZSk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfYTtcbn1cbmV4cG9ydHMuYXBwbHlSZWRpcmVjdHMgPSBhcHBseVJlZGlyZWN0cztcbmZ1bmN0aW9uIGNyZWF0ZVVybFRyZWUodXJsVHJlZSwgcm9vdCkge1xuICAgIHJldHVybiBvZl8xLm9mKG5ldyB1cmxfdHJlZV8xLlVybFRyZWUocm9vdCwgdXJsVHJlZS5xdWVyeVBhcmFtcywgdXJsVHJlZS5mcmFnbWVudCkpO1xufVxuZnVuY3Rpb24gZXhwYW5kU2VnbWVudChyb3V0ZXMsIHNlZ21lbnQsIG91dGxldCkge1xuICAgIGlmIChzZWdtZW50LnBhdGhzV2l0aFBhcmFtcy5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc2VnbWVudC5jaGlsZHJlbikubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbmV3IHVybF90cmVlXzEuVXJsU2VnbWVudChbXSwgZXhwYW5kU2VnbWVudENoaWxkcmVuKHJvdXRlcywgc2VnbWVudCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZFBhdGhzV2l0aFBhcmFtcyhzZWdtZW50LCByb3V0ZXMsIHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLCBvdXRsZXQsIHRydWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4cGFuZFNlZ21lbnRDaGlsZHJlbihyb3V0ZXMsIHNlZ21lbnQpIHtcbiAgICByZXR1cm4gdXJsX3RyZWVfMS5tYXBDaGlsZHJlbihzZWdtZW50LCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7IHJldHVybiBleHBhbmRTZWdtZW50KHJvdXRlcywgY2hpbGQsIGNoaWxkT3V0bGV0KTsgfSk7XG59XG5mdW5jdGlvbiBleHBhbmRQYXRoc1dpdGhQYXJhbXMoc2VnbWVudCwgcm91dGVzLCBwYXRocywgb3V0bGV0LCBhbGxvd1JlZGlyZWN0cykge1xuICAgIGZvciAodmFyIF9pID0gMCwgcm91dGVzXzEgPSByb3V0ZXM7IF9pIDwgcm91dGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByID0gcm91dGVzXzFbX2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFBhdGhzV2l0aFBhcmFtc0FnYWluc3RSb3V0ZShzZWdtZW50LCByb3V0ZXMsIHIsIHBhdGhzLCBvdXRsZXQsIGFsbG93UmVkaXJlY3RzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE5vTWF0Y2gpKVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IE5vTWF0Y2goc2VnbWVudCk7XG59XG5mdW5jdGlvbiBleHBhbmRQYXRoc1dpdGhQYXJhbXNBZ2FpbnN0Um91dGUoc2VnbWVudCwgcm91dGVzLCByb3V0ZSwgcGF0aHMsIG91dGxldCwgYWxsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAoKHJvdXRlLm91dGxldCA/IHJvdXRlLm91dGxldCA6IHNoYXJlZF8xLlBSSU1BUllfT1VUTEVUKSAhPT0gb3V0bGV0KVxuICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmICFhbGxvd1JlZGlyZWN0cylcbiAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICBpZiAocm91dGUucmVkaXJlY3RUbykge1xuICAgICAgICByZXR1cm4gZXhwYW5kUGF0aHNXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChzZWdtZW50LCByb3V0ZXMsIHJvdXRlLCBwYXRocywgb3V0bGV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRjaFBhdGhzV2l0aFBhcmFtc0FnYWluc3RSb3V0ZShzZWdtZW50LCByb3V0ZSwgcGF0aHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4cGFuZFBhdGhzV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3Qoc2VnbWVudCwgcm91dGVzLCByb3V0ZSwgcGF0aHMsIG91dGxldCkge1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSAnKionKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRXaWxkQ2FyZFdpdGhQYXJhbXNBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0KHJvdXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHBhbmRSZWd1bGFyUGF0aFdpdGhQYXJhbXNBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0KHNlZ21lbnQsIHJvdXRlcywgcm91dGUsIHBhdGhzLCBvdXRsZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4cGFuZFdpbGRDYXJkV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3Qocm91dGUpIHtcbiAgICB2YXIgbmV3UGF0aHMgPSBhcHBseVJlZGlyZWN0Q29tbWFuZHMoW10sIHJvdXRlLnJlZGlyZWN0VG8sIHt9KTtcbiAgICBpZiAocm91dGUucmVkaXJlY3RUby5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdsb2JhbFJlZGlyZWN0KG5ld1BhdGhzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KG5ld1BhdGhzLCB7fSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXhwYW5kUmVndWxhclBhdGhXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChzZWdtZW50LCByb3V0ZXMsIHJvdXRlLCBwYXRocywgb3V0bGV0KSB7XG4gICAgdmFyIF9hID0gbWF0Y2goc2VnbWVudCwgcm91dGUsIHBhdGhzKSwgY29uc3VtZWRQYXRocyA9IF9hLmNvbnN1bWVkUGF0aHMsIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHMgPSBfYS5wb3NpdGlvbmFsUGFyYW1TZWdtZW50cztcbiAgICB2YXIgbmV3UGF0aHMgPSBhcHBseVJlZGlyZWN0Q29tbWFuZHMoY29uc3VtZWRQYXRocywgcm91dGUucmVkaXJlY3RUbywgcG9zaXRpb25hbFBhcmFtU2VnbWVudHMpO1xuICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgR2xvYmFsUmVkaXJlY3QobmV3UGF0aHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZFBhdGhzV2l0aFBhcmFtcyhzZWdtZW50LCByb3V0ZXMsIG5ld1BhdGhzLmNvbmNhdChwYXRocy5zbGljZShsYXN0Q2hpbGQpKSwgb3V0bGV0LCBmYWxzZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hQYXRoc1dpdGhQYXJhbXNBZ2FpbnN0Um91dGUoc2VnbWVudCwgcm91dGUsIHBhdGhzKSB7XG4gICAgaWYgKHJvdXRlLnBhdGggPT09ICcqKicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFNlZ21lbnQocGF0aHMsIHt9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBfYSA9IG1hdGNoKHNlZ21lbnQsIHJvdXRlLCBwYXRocyksIGNvbnN1bWVkUGF0aHMgPSBfYS5jb25zdW1lZFBhdGhzLCBsYXN0Q2hpbGQgPSBfYS5sYXN0Q2hpbGQ7XG4gICAgICAgIHZhciBjaGlsZENvbmZpZyA9IHJvdXRlLmNoaWxkcmVuID8gcm91dGUuY2hpbGRyZW4gOiBbXTtcbiAgICAgICAgdmFyIHNsaWNlZFBhdGggPSBwYXRocy5zbGljZShsYXN0Q2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRDb25maWcubGVuZ3RoID09PSAwICYmIHNsaWNlZFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHVybF90cmVlXzEuVXJsU2VnbWVudChjb25zdW1lZFBhdGhzLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2xpY2VkUGF0aC5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc2VnbWVudC5jaGlsZHJlbikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZXhwYW5kU2VnbWVudENoaWxkcmVuKGNoaWxkQ29uZmlnLCBzZWdtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KGNvbnN1bWVkUGF0aHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjcyA9IGV4cGFuZFBhdGhzV2l0aFBhcmFtcyhzZWdtZW50LCBjaGlsZENvbmZpZywgc2xpY2VkUGF0aCwgc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFNlZ21lbnQoY29uc3VtZWRQYXRocy5jb25jYXQoY3MucGF0aHNXaXRoUGFyYW1zKSwgY3MuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2goc2VnbWVudCwgcm91dGUsIHBhdGhzKSB7XG4gICAgaWYgKHJvdXRlLnBhdGggPT09ICcnKSB7XG4gICAgICAgIGlmIChyb3V0ZS50ZXJtaW5hbCAmJiAoT2JqZWN0LmtleXMoc2VnbWVudC5jaGlsZHJlbikubGVuZ3RoID4gMCB8fCBwYXRocy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbnN1bWVkUGF0aHM6IFtdLCBsYXN0Q2hpbGQ6IDAsIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzOiB7fSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgdmFyIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzID0ge307XG4gICAgdmFyIGNvbnN1bWVkUGF0aHMgPSBbXTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gcGF0aHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgaXNQb3NQYXJhbSA9IHAuc3RhcnRzV2l0aCgnOicpO1xuICAgICAgICBpZiAoIWlzUG9zUGFyYW0gJiYgcCAhPT0gY3VycmVudC5wYXRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICAgICAgaWYgKGlzUG9zUGFyYW0pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzW3Auc3Vic3RyaW5nKDEpXSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3VtZWRQYXRocy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50SW5kZXgrKztcbiAgICB9XG4gICAgaWYgKHJvdXRlLnRlcm1pbmFsICYmIChPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwIHx8IGN1cnJlbnRJbmRleCA8IHBhdGhzLmxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWRQYXRoczogY29uc3VtZWRQYXRocywgbGFzdENoaWxkOiBjdXJyZW50SW5kZXgsIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzOiBwb3NpdGlvbmFsUGFyYW1TZWdtZW50cyB9O1xufVxuZnVuY3Rpb24gYXBwbHlSZWRpcmVjdENvbW1hbmRzKHBhdGhzLCByZWRpcmVjdFRvLCBwb3NQYXJhbXMpIHtcbiAgICBpZiAocmVkaXJlY3RUby5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcmVkaXJlY3RUby5zdWJzdHJpbmcoMSkuc3BsaXQoJy8nKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhzKHJlZGlyZWN0VG8sIHBhcnRzLCBwYXRocywgcG9zUGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHJlZGlyZWN0VG8uc3BsaXQoJy8nKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhzKHJlZGlyZWN0VG8sIHBhcnRzLCBwYXRocywgcG9zUGFyYW1zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRocyhyZWRpcmVjdFRvLCBwYXJ0cywgc2VnbWVudHMsIHBvc1BhcmFtcykge1xuICAgIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuc3RhcnRzV2l0aCgnOicpID8gZmluZFBvc1BhcmFtKHAsIHBvc1BhcmFtcywgcmVkaXJlY3RUbykgOlxuICAgICAgICBmaW5kT3JDcmVhdGVQYXRoKHAsIHNlZ21lbnRzKTsgfSk7XG59XG5mdW5jdGlvbiBmaW5kUG9zUGFyYW0ocGFydCwgcG9zUGFyYW1zLCByZWRpcmVjdFRvKSB7XG4gICAgdmFyIHBhcmFtTmFtZSA9IHBhcnQuc3Vic3RyaW5nKDEpO1xuICAgIHZhciBwb3MgPSBwb3NQYXJhbXNbcGFyYW1OYW1lXTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlZGlyZWN0IHRvICdcIiArIHJlZGlyZWN0VG8gKyBcIicuIENhbm5vdCBmaW5kICdcIiArIHBhcnQgKyBcIicuXCIpO1xuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVQYXRoKHBhcnQsIHBhdGhzKSB7XG4gICAgdmFyIG1hdGNoaW5nSW5kZXggPSBwYXRocy5maW5kSW5kZXgoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucGF0aCA9PT0gcGFydDsgfSk7XG4gICAgaWYgKG1hdGNoaW5nSW5kZXggPiAtMSkge1xuICAgICAgICB2YXIgciA9IHBhdGhzW21hdGNoaW5nSW5kZXhdO1xuICAgICAgICBwYXRocy5zcGxpY2UobWF0Y2hpbmdJbmRleCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFBhdGhXaXRoUGFyYW1zKHBhcnQsIHt9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZWEJ3YkhsZmNtVmthWEpsWTNSekxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMMkZ3Y0d4NVgzSmxaR2x5WldOMGN5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc01rSkJRWGxDTEdsQ1FVRnBRaXhEUVVGRExFTkJRVUU3UVVGRk0wTXNiVUpCUVd0Q0xHOUNRVUZ2UWl4RFFVRkRMRU5CUVVFN1FVRkhka01zZFVKQlFUWkNMRlZCUVZVc1EwRkJReXhEUVVGQk8wRkJRM2hETEhsQ1FVRnJSU3haUVVGWkxFTkJRVU1zUTBGQlFUdEJRVVV2UlR0SlFVTkZMR2xDUVVGdFFpeFBRVUV3UWp0UlFVRnFReXgxUWtGQmFVTXNSMEZCYWtNc1kwRkJhVU03VVVGQk1VSXNXVUZCVHl4SFFVRlFMRTlCUVU4c1EwRkJiVUk3U1VGQlJ5eERRVUZETzBsQlEyNUVMR05CUVVNN1FVRkJSQ3hEUVVGRExFRkJSa1FzU1VGRlF6dEJRVU5FTzBsQlEwVXNkMEpCUVcxQ0xFdEJRVEJDTzFGQlFURkNMRlZCUVVzc1IwRkJUQ3hMUVVGTExFTkJRWEZDTzBsQlFVY3NRMEZCUXp0SlFVTnVSQ3h4UWtGQlF6dEJRVUZFTEVOQlFVTXNRVUZHUkN4SlFVVkRPMEZCUlVRc2QwSkJRU3RDTEU5QlFXZENMRVZCUVVVc1RVRkJiMEk3U1VGRGJrVXNTVUZCU1N4RFFVRkRPMUZCUTBnc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eFBRVUZQTEVWQlFVVXNZVUZCWVN4RFFVRkRMRTFCUVUwc1JVRkJSU3hQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEhWQ1FVRmpMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM0pHTEVOQlFVVTdTVUZCUVN4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlExZ3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhaUVVGWkxHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYUVNc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGRGFFSXNUMEZCVHl4RlFVRkZMRWxCUVVrc2NVSkJRVlVzUTBGQlF5eEZRVUZGTEVWQlFVVXNWVUZCUXl4SFFVRkRMSFZDUVVGakxFTkJRVU1zUjBGQlJTeEpRVUZKTEhGQ1FVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZGTEVOQlFVTXNTMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOd1JpeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zV1VGQldTeFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoRExFMUJRVTBzUTBGQlF5eEpRVUZKTEhWQ1FVRlZMRU5CUTJwQ0xGVkJRVU1zUjBGQmMwSTdaMEpCUTI1Q0xFOUJRVUVzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXdyUWtGQk5rSXNRMEZCUXl4RFFVRkRMRTlCUVU4c1RVRkJSeXhEUVVGRExFTkJRVU03V1VGQkwwUXNRMEZCSzBRc1EwRkJReXhEUVVGRE8xRkJRek5GTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFMUJRVTBzUTBGQlF5eEpRVUZKTEhWQ1FVRlZMRU5CUVZVc1ZVRkJReXhIUVVGelFpeEpRVUZMTEU5QlFVRXNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQldpeERRVUZaTEVOQlFVTXNRMEZCUXp0UlFVTXpSU3hEUVVGRE8wbEJRMGdzUTBGQlF6czdRVUZEU0N4RFFVRkRPMEZCWm1Vc2MwSkJRV01zYVVKQlpUZENMRU5CUVVFN1FVRkZSQ3gxUWtGQmRVSXNUMEZCWjBJc1JVRkJSU3hKUVVGblFqdEpRVU4yUkN4TlFVRk5MRU5CUVVNc1QwRkJSU3hEUVVGRkxFbEJRVWtzYTBKQlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExGZEJRVmNzUlVGQlJTeFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOMlJTeERRVUZETzBGQlJVUXNkVUpCUVhWQ0xFMUJRV1VzUlVGQlJTeFBRVUZ0UWl4RlFVRkZMRTFCUVdNN1NVRkRla1VzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMR1ZCUVdVc1EwRkJReXhOUVVGTkxFdEJRVXNzUTBGQlF5eEpRVUZKTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pHTEUxQlFVMHNRMEZCUXl4SlFVRkpMSEZDUVVGVkxFTkJRVU1zUlVGQlJTeEZRVUZGTEhGQ1FVRnhRaXhEUVVGRExFMUJRVTBzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNCRkxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1RVRkJUU3hGUVVGRkxFOUJRVThzUTBGQlF5eGxRVUZsTEVWQlFVVXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRM1pHTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUlVRc0swSkJRU3RDTEUxQlFXVXNSVUZCUlN4UFFVRnRRanRKUVVOcVJTeE5RVUZOTEVOQlFVTXNjMEpCUVZjc1EwRkJReXhQUVVGUExFVkJRVVVzVlVGQlF5eExRVUZMTEVWQlFVVXNWMEZCVnl4SlFVRkxMRTlCUVVFc1lVRkJZU3hEUVVGRExFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVVXNWMEZCVnl4RFFVRkRMRVZCUVhwRExFTkJRWGxETEVOQlFVTXNRMEZCUXp0QlFVTnFSeXhEUVVGRE8wRkJSVVFzSzBKQlEwa3NUMEZCYlVJc1JVRkJSU3hOUVVGbExFVkJRVVVzUzBGQk1FSXNSVUZCUlN4TlFVRmpMRVZCUTJoR0xHTkJRWFZDTzBsQlEzcENMRWRCUVVjc1EwRkJReXhEUVVGVkxGVkJRVTBzUlVGQlRpeHBRa0ZCVFN4RlFVRk9MRzlDUVVGTkxFVkJRVTRzU1VGQlRTeERRVUZETzFGQlFXaENMRWxCUVVrc1EwRkJReXhsUVVGQk8xRkJRMUlzU1VGQlNTeERRVUZETzFsQlEwZ3NUVUZCVFN4RFFVRkRMR2xEUVVGcFF5eERRVUZETEU5QlFVOHNSVUZCUlN4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFdEJRVXNzUlVGQlJTeE5RVUZOTEVWQlFVVXNZMEZCWXl4RFFVRkRMRU5CUVVNN1VVRkRPVVlzUTBGQlJUdFJRVUZCTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFdDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhaUVVGWkxFOUJRVThzUTBGQlF5eERRVUZETzJkQ1FVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRM1pETEVOQlFVTTdTMEZEUmp0SlFVTkVMRTFCUVUwc1NVRkJTU3hQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdRVUZETjBJc1EwRkJRenRCUVVWRUxESkRRVU5KTEU5QlFXMUNMRVZCUVVVc1RVRkJaU3hGUVVGRkxFdEJRVmtzUlVGQlJTeExRVUV3UWl4RlFVRkZMRTFCUVdNc1JVRkRPVVlzWTBGQmRVSTdTVUZEZWtJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFZEJRVWNzZFVKQlFXTXNRMEZCUXl4TFFVRkxMRTFCUVUwc1EwRkJRenRSUVVGRExFMUJRVTBzU1VGQlNTeFBRVUZQTEVWQlFVVXNRMEZCUXp0SlFVTnVSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNWVUZCVlN4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRE8xRkJRVU1zVFVGQlRTeEpRVUZKTEU5QlFVOHNSVUZCUlN4RFFVRkRPMGxCUlRkRUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pDTEUxQlFVMHNRMEZCUXl3NFEwRkJPRU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdTVUZETDBZc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNUVUZCVFN4RFFVRkRMR2REUVVGblF5eERRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRGFrVXNRMEZCUXp0QlFVTklMRU5CUVVNN1FVRkZSQ3gzUkVGRFNTeFBRVUZ0UWl4RlFVRkZMRTFCUVdVc1JVRkJSU3hMUVVGWkxFVkJRVVVzUzBGQk1FSXNSVUZET1VVc1RVRkJZenRKUVVOb1FpeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVJc1RVRkJUU3hEUVVGRExHbEVRVUZwUkN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRMnhGTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xFMUJRVTBzUTBGQlF5eHZSRUZCYjBRc1EwRkRka1FzVDBGQlR5eEZRVUZGTEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVVc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF6ZERMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJSVVFzTWtSQlFUSkVMRXRCUVZrN1NVRkRja1VzU1VGQlRTeFJRVUZSTEVkQlFVY3NjVUpCUVhGQ0xFTkJRVU1zUlVGQlJTeEZRVUZGTEV0QlFVc3NRMEZCUXl4VlFVRlZMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGFrVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eFZRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pETEUxQlFVMHNTVUZCU1N4alFVRmpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03U1VGRGNrTXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzVFVGQlRTeERRVUZETEVsQlFVa3NjVUpCUVZVc1EwRkJReXhSUVVGUkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEZEVNc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGRlJDdzRSRUZEU1N4UFFVRnRRaXhGUVVGRkxFMUJRV1VzUlVGQlJTeExRVUZaTEVWQlFVVXNTMEZCTUVJc1JVRkRPVVVzVFVGQll6dEpRVU5vUWl4SlFVRkJMR2xEUVVGM1JpeEZRVUZxUml4blEwRkJZU3hGUVVGRkxIZENRVUZUTEVWQlFVVXNiMFJCUVhWQ0xFTkJRV2xETzBsQlEzcEdMRWxCUVUwc1VVRkJVU3hIUVVOV0xIRkNRVUZ4UWl4RFFVRkRMR0ZCUVdFc1JVRkJSU3hMUVVGTExFTkJRVU1zVlVGQlZTeEZRVUZQTEhWQ1FVRjFRaXhEUVVGRExFTkJRVU03U1VGRGVrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eFZRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pETEUxQlFVMHNTVUZCU1N4alFVRmpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03U1VGRGNrTXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzVFVGQlRTeERRVUZETEhGQ1FVRnhRaXhEUVVONFFpeFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhGUVVGRkxFMUJRVTBzUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUXp0SlFVTXZSU3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVVZFTERCRFFVTkpMRTlCUVcxQ0xFVkJRVVVzUzBGQldTeEZRVUZGTEV0QlFUQkNPMGxCUXk5RUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3h4UWtGQlZTeERRVUZETEV0QlFVc3NSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOdVF5eERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhKUVVGQkxHbERRVUVyUkN4RlFVRjRSQ3huUTBGQllTeEZRVUZGTEhkQ1FVRlRMRU5CUVdsRE8xRkJRMmhGTEVsQlFVMHNWMEZCVnl4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRla1FzU1VGQlRTeFZRVUZWTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF6dFJRVVV4UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNTVUZCU1N4VlFVRlZMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVRc1RVRkJUU3hEUVVGRExFbEJRVWtzY1VKQlFWVXNRMEZCUXl4aFFVRmhMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGSE0wTXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4TFFVRkxMRU5CUVVNc1NVRkJTU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXZSU3hKUVVGTkxGRkJRVkVzUjBGQlJ5eHhRa0ZCY1VJc1EwRkJReXhYUVVGWExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdXVUZETjBRc1RVRkJUU3hEUVVGRExFbEJRVWtzY1VKQlFWVXNRMEZCUXl4aFFVRmhMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRmFrUXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzU1VGQlRTeEZRVUZGTEVkQlFVY3NjVUpCUVhGQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEZkQlFWY3NSVUZCUlN4VlFVRlZMRVZCUVVVc2RVSkJRV01zUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTjZSaXhOUVVGTkxFTkJRVU1zU1VGQlNTeHhRa0ZCVlN4RFFVRkRMR0ZCUVdFc1EwRkJReXhOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETEdWQlFXVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU12UlN4RFFVRkRPMGxCUTBnc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGRlJDeGxRVUZsTEU5QlFXMUNMRVZCUVVVc1MwRkJXU3hGUVVGRkxFdEJRVEJDTzBsQlN6RkZMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnlSaXhOUVVGTkxFbEJRVWtzVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEZEVJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNUVUZCVFN4RFFVRkRMRVZCUVVNc1lVRkJZU3hGUVVGRkxFVkJRVVVzUlVGQlJTeFRRVUZUTEVWQlFVVXNRMEZCUXl4RlFVRkZMSFZDUVVGMVFpeEZRVUZGTEVWQlFVVXNSVUZCUXl4RFFVRkRPMUZCUTNoRkxFTkJRVU03U1VGRFNDeERRVUZETzBsQlJVUXNTVUZCVFN4SlFVRkpMRWRCUVVjc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU40UWl4SlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFbEJRVTBzZFVKQlFYVkNMRWRCUVhGRExFVkJRVVVzUTBGQlF6dEpRVU55UlN4SlFVRk5MR0ZCUVdFc1IwRkJkMElzUlVGQlJTeERRVUZETzBsQlJUbERMRWxCUVVrc1dVRkJXU3hIUVVGSExFTkJRVU1zUTBGQlF6dEpRVVZ5UWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFVkJRVVVzUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTjBReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFpRVUZaTEVsQlFVa3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJRenRaUVVGRExFMUJRVTBzU1VGQlNTeFBRVUZQTEVWQlFVVXNRMEZCUXp0UlFVTjBSQ3hKUVVGTkxFOUJRVThzUjBGQlJ5eExRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1VVRkZjRU1zU1VGQlRTeERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMjVDTEVsQlFVMHNWVUZCVlN4SFFVRkhMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZGY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVsQlFVa3NRMEZCUXl4TFFVRkxMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU03V1VGQlF5eE5RVUZOTEVsQlFVa3NUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkRNMFFzUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVObUxIVkNRVUYxUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4UFFVRlBMRU5CUVVNN1VVRkRjRVFzUTBGQlF6dFJRVU5FTEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRE5VSXNXVUZCV1N4RlFVRkZMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4SlFVRkpMRmxCUVZrc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoSExFMUJRVTBzU1VGQlNTeFBRVUZQTEVWQlFVVXNRMEZCUXp0SlFVTjBRaXhEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEVWQlFVTXNaVUZCUVN4aFFVRmhMRVZCUVVVc1UwRkJVeXhGUVVGRkxGbEJRVmtzUlVGQlJTeDVRa0ZCUVN4MVFrRkJkVUlzUlVGQlF5eERRVUZETzBGQlF6TkZMRU5CUVVNN1FVRkZSQ3dyUWtGRFNTeExRVUV3UWl4RlFVRkZMRlZCUVd0Q0xFVkJRemxETEZOQlFUSkRPMGxCUXpkRExFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF5OUNMRWxCUVUwc1MwRkJTeXhIUVVGSExGVkJRVlVzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFGQlEycEVMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zVlVGQlZTeEZRVUZGTEV0QlFVc3NSVUZCUlN4TFFVRkxMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03U1VGRE1VUXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzU1VGQlRTeExRVUZMTEVkQlFVY3NWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU53UXl4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExGVkJRVlVzUlVGQlJTeExRVUZMTEVWQlFVVXNTMEZCU3l4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8wbEJRekZFTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUlVRc2NVSkJRMGtzVlVGQmEwSXNSVUZCUlN4TFFVRmxMRVZCUVVVc1VVRkJOa0lzUlVGRGJFVXNVMEZCTWtNN1NVRkROME1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUTFvc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExGbEJRVmtzUTBGQlF5eERRVUZETEVWQlFVVXNVMEZCVXl4RlFVRkZMRlZCUVZVc1EwRkJRenRSUVVOMFF5eG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFVkJRVVVzVVVGQlVTeERRVUZETEVWQlJHcEVMRU5CUTJsRUxFTkJRVU1zUTBGQlF6dEJRVU01UkN4RFFVRkRPMEZCUlVRc2MwSkJRMGtzU1VGQldTeEZRVUZGTEZOQlFUSkRMRVZCUTNwRUxGVkJRV3RDTzBsQlEzQkNMRWxCUVUwc1UwRkJVeXhIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRjRU1zU1VGQlRTeEhRVUZITEVkQlFVY3NVMEZCVXl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8wbEJRMnBETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRE8xRkJRVU1zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4NVFrRkJkVUlzVlVGQlZTeDNRa0ZCYlVJc1NVRkJTU3hQUVVGSkxFTkJRVU1zUTBGQlF6dEpRVU40Uml4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRE8wRkJRMklzUTBGQlF6dEJRVVZFTERCQ1FVRXdRaXhKUVVGWkxFVkJRVVVzUzBGQk1FSTdTVUZEYUVVc1NVRkJUU3hoUVVGaExFZEJRVWNzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4VlFVRkJMRU5CUVVNc1NVRkJTU3hQUVVGQkxFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NTVUZCU1N4RlFVRm1MRU5CUVdVc1EwRkJReXhEUVVGRE8wbEJRelZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR0ZCUVdFc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZGtJc1NVRkJUU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkROVUlzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTllMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEUxQlFVMHNRMEZCUXl4SlFVRkpMRFJDUVVGcFFpeERRVUZETEVsQlFVa3NSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVONlF5eERRVUZETzBGQlEwZ3NRMEZCUXlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltbHRjRzl5ZENCN1QySnpaWEoyWVdKc1pYMGdabkp2YlNBbmNuaHFjeTlQWW5ObGNuWmhZbXhsSnp0Y2JtbHRjRzl5ZENCN1QySnpaWEoyWlhKOUlHWnliMjBnSjNKNGFuTXZUMkp6WlhKMlpYSW5PMXh1YVcxd2IzSjBJSHR2WmlCOUlHWnliMjBnSjNKNGFuTXZiMkp6WlhKMllXSnNaUzl2WmljN1hHNWNibWx0Y0c5eWRDQjdVbTkxZEdVc0lGSnZkWFJsY2tOdmJtWnBaMzBnWm5KdmJTQW5MaTlqYjI1bWFXY25PMXh1YVcxd2IzSjBJSHRRVWtsTlFWSlpYMDlWVkV4RlZIMGdabkp2YlNBbkxpOXphR0Z5WldRbk8xeHVhVzF3YjNKMElIdFZjbXhRWVhSb1YybDBhRkJoY21GdGN5d2dWWEpzVTJWbmJXVnVkQ3dnVlhKc1ZISmxaU3dnYldGd1EyaHBiR1J5Wlc1OUlHWnliMjBnSnk0dmRYSnNYM1J5WldVbk8xeHVYRzVqYkdGemN5Qk9iMDFoZEdOb0lIdGNiaUFnWTI5dWMzUnlkV04wYjNJb2NIVmliR2xqSUhObFoyMWxiblE2SUZWeWJGTmxaMjFsYm5RZ1BTQnVkV3hzS1NCN2ZWeHVmVnh1WTJ4aGMzTWdSMnh2WW1Gc1VtVmthWEpsWTNRZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lod2RXSnNhV01nY0dGMGFITTZJRlZ5YkZCaGRHaFhhWFJvVUdGeVlXMXpXMTBwSUh0OVhHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJoY0hCc2VWSmxaR2x5WldOMGN5aDFjbXhVY21WbE9pQlZjbXhVY21WbExDQmpiMjVtYVdjNklGSnZkWFJsY2tOdmJtWnBaeWs2SUU5aWMyVnlkbUZpYkdVOFZYSnNWSEpsWlQ0Z2UxeHVJQ0IwY25rZ2UxeHVJQ0FnSUhKbGRIVnliaUJqY21WaGRHVlZjbXhVY21WbEtIVnliRlJ5WldVc0lHVjRjR0Z1WkZObFoyMWxiblFvWTI5dVptbG5MQ0IxY214VWNtVmxMbkp2YjNRc0lGQlNTVTFCVWxsZlQxVlVURVZVS1NrN1hHNGdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0JwWmlBb1pTQnBibk4wWVc1alpXOW1JRWRzYjJKaGJGSmxaR2x5WldOMEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1kzSmxZWFJsVlhKc1ZISmxaU2hjYmlBZ0lDQWdJQ0FnSUNCMWNteFVjbVZsTENCdVpYY2dWWEpzVTJWbmJXVnVkQ2hiWFN3Z2UxdFFVa2xOUVZKWlgwOVZWRXhGVkYwNklHNWxkeUJWY214VFpXZHRaVzUwS0dVdWNHRjBhSE1zSUh0OUtYMHBLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR1VnYVc1emRHRnVZMlZ2WmlCT2IwMWhkR05vS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lFOWljMlZ5ZG1GaWJHVThWWEpzVkhKbFpUNG9YRzRnSUNBZ0lDQWdJQ0FnS0c5aWN6b2dUMkp6WlhKMlpYSThWWEpzVkhKbFpUNHBJRDArWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRzlpY3k1bGNuSnZjaWh1WlhjZ1JYSnliM0lvWUVOaGJtNXZkQ0J0WVhSamFDQmhibmtnY205MWRHVnpPaUFuSkh0bExuTmxaMjFsYm5SOUoyQXBLU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCdVpYY2dUMkp6WlhKMllXSnNaVHhWY214VWNtVmxQaWdvYjJKek9pQlBZbk5sY25abGNqeFZjbXhVY21WbFBpa2dQVDRnYjJKekxtVnljbTl5S0dVcEtUdGNiaUFnSUNCOVhHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdZM0psWVhSbFZYSnNWSEpsWlNoMWNteFVjbVZsT2lCVmNteFVjbVZsTENCeWIyOTBPaUJWY214VFpXZHRaVzUwS1RvZ1QySnpaWEoyWVdKc1pUeFZjbXhVY21WbFBpQjdYRzRnSUhKbGRIVnliaUJ2WmlBb2JtVjNJRlZ5YkZSeVpXVW9jbTl2ZEN3Z2RYSnNWSEpsWlM1eGRXVnllVkJoY21GdGN5d2dkWEpzVkhKbFpTNW1jbUZuYldWdWRDa3BPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxlSEJoYm1SVFpXZHRaVzUwS0hKdmRYUmxjem9nVW05MWRHVmJYU3dnYzJWbmJXVnVkRG9nVlhKc1UyVm5iV1Z1ZEN3Z2IzVjBiR1YwT2lCemRISnBibWNwT2lCVmNteFRaV2R0Wlc1MElIdGNiaUFnYVdZZ0tITmxaMjFsYm5RdWNHRjBhSE5YYVhSb1VHRnlZVzF6TG14bGJtZDBhQ0E5UFQwZ01DQW1KaUJQWW1wbFkzUXVhMlY1Y3loelpXZHRaVzUwTG1Ob2FXeGtjbVZ1S1M1c1pXNW5kR2dnUGlBd0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QlZjbXhUWldkdFpXNTBLRnRkTENCbGVIQmhibVJUWldkdFpXNTBRMmhwYkdSeVpXNG9jbTkxZEdWekxDQnpaV2R0Wlc1MEtTazdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdjbVYwZFhKdUlHVjRjR0Z1WkZCaGRHaHpWMmwwYUZCaGNtRnRjeWh6WldkdFpXNTBMQ0J5YjNWMFpYTXNJSE5sWjIxbGJuUXVjR0YwYUhOWGFYUm9VR0Z5WVcxekxDQnZkWFJzWlhRc0lIUnlkV1VwTzF4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlHVjRjR0Z1WkZObFoyMWxiblJEYUdsc1pISmxiaWh5YjNWMFpYTTZJRkp2ZFhSbFcxMHNJSE5sWjIxbGJuUTZJRlZ5YkZObFoyMWxiblFwT2lCN1cyNWhiV1U2SUhOMGNtbHVaMTA2SUZWeWJGTmxaMjFsYm5SOUlIdGNiaUFnY21WMGRYSnVJRzFoY0VOb2FXeGtjbVZ1S0hObFoyMWxiblFzSUNoamFHbHNaQ3dnWTJocGJHUlBkWFJzWlhRcElEMCtJR1Y0Y0dGdVpGTmxaMjFsYm5Rb2NtOTFkR1Z6TENCamFHbHNaQ3dnWTJocGJHUlBkWFJzWlhRcEtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1pYaHdZVzVrVUdGMGFITlhhWFJvVUdGeVlXMXpLRnh1SUNBZ0lITmxaMjFsYm5RNklGVnliRk5sWjIxbGJuUXNJSEp2ZFhSbGN6b2dVbTkxZEdWYlhTd2djR0YwYUhNNklGVnliRkJoZEdoWGFYUm9VR0Z5WVcxelcxMHNJRzkxZEd4bGREb2djM1J5YVc1bkxGeHVJQ0FnSUdGc2JHOTNVbVZrYVhKbFkzUnpPaUJpYjI5c1pXRnVLVG9nVlhKc1UyVm5iV1Z1ZENCN1hHNGdJR1p2Y2lBb2JHVjBJSElnYjJZZ2NtOTFkR1Z6S1NCN1hHNGdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbGVIQmhibVJRWVhSb2MxZHBkR2hRWVhKaGJYTkJaMkZwYm5OMFVtOTFkR1VvYzJWbmJXVnVkQ3dnY205MWRHVnpMQ0J5TENCd1lYUm9jeXdnYjNWMGJHVjBMQ0JoYkd4dmQxSmxaR2x5WldOMGN5azdYRzRnSUNBZ2ZTQmpZWFJqYUNBb1pTa2dlMXh1SUNBZ0lDQWdhV1lnS0NFb1pTQnBibk4wWVc1alpXOW1JRTV2VFdGMFkyZ3BLU0IwYUhKdmR5QmxPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQjBhSEp2ZHlCdVpYY2dUbTlOWVhSamFDaHpaV2R0Wlc1MEtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1pYaHdZVzVrVUdGMGFITlhhWFJvVUdGeVlXMXpRV2RoYVc1emRGSnZkWFJsS0Z4dUlDQWdJSE5sWjIxbGJuUTZJRlZ5YkZObFoyMWxiblFzSUhKdmRYUmxjem9nVW05MWRHVmJYU3dnY205MWRHVTZJRkp2ZFhSbExDQndZWFJvY3pvZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhOYlhTd2diM1YwYkdWME9pQnpkSEpwYm1jc1hHNGdJQ0FnWVd4c2IzZFNaV1JwY21WamRITTZJR0p2YjJ4bFlXNHBPaUJWY214VFpXZHRaVzUwSUh0Y2JpQWdhV1lnS0NoeWIzVjBaUzV2ZFhSc1pYUWdQeUJ5YjNWMFpTNXZkWFJzWlhRZ09pQlFVa2xOUVZKWlgwOVZWRXhGVkNrZ0lUMDlJRzkxZEd4bGRDa2dkR2h5YjNjZ2JtVjNJRTV2VFdGMFkyZ29LVHRjYmlBZ2FXWWdLSEp2ZFhSbExuSmxaR2x5WldOMFZHOGdKaVlnSVdGc2JHOTNVbVZrYVhKbFkzUnpLU0IwYUhKdmR5QnVaWGNnVG05TllYUmphQ2dwTzF4dVhHNGdJR2xtSUNoeWIzVjBaUzV5WldScGNtVmpkRlJ2S1NCN1hHNGdJQ0FnY21WMGRYSnVJR1Y0Y0dGdVpGQmhkR2h6VjJsMGFGQmhjbUZ0YzBGbllXbHVjM1JTYjNWMFpWVnphVzVuVW1Wa2FYSmxZM1FvYzJWbmJXVnVkQ3dnY205MWRHVnpMQ0J5YjNWMFpTd2djR0YwYUhNc0lHOTFkR3hsZENrN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUcxaGRHTm9VR0YwYUhOWGFYUm9VR0Z5WVcxelFXZGhhVzV6ZEZKdmRYUmxLSE5sWjIxbGJuUXNJSEp2ZFhSbExDQndZWFJvY3lrN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdaWGh3WVc1a1VHRjBhSE5YYVhSb1VHRnlZVzF6UVdkaGFXNXpkRkp2ZFhSbFZYTnBibWRTWldScGNtVmpkQ2hjYmlBZ0lDQnpaV2R0Wlc1ME9pQlZjbXhUWldkdFpXNTBMQ0J5YjNWMFpYTTZJRkp2ZFhSbFcxMHNJSEp2ZFhSbE9pQlNiM1YwWlN3Z2NHRjBhSE02SUZWeWJGQmhkR2hYYVhSb1VHRnlZVzF6VzEwc1hHNGdJQ0FnYjNWMGJHVjBPaUJ6ZEhKcGJtY3BPaUJWY214VFpXZHRaVzUwSUh0Y2JpQWdhV1lnS0hKdmRYUmxMbkJoZEdnZ1BUMDlJQ2NxS2ljcElIdGNiaUFnSUNCeVpYUjFjbTRnWlhod1lXNWtWMmxzWkVOaGNtUlhhWFJvVUdGeVlXMXpRV2RoYVc1emRGSnZkWFJsVlhOcGJtZFNaV1JwY21WamRDaHliM1YwWlNrN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUdWNGNHRnVaRkpsWjNWc1lYSlFZWFJvVjJsMGFGQmhjbUZ0YzBGbllXbHVjM1JTYjNWMFpWVnphVzVuVW1Wa2FYSmxZM1FvWEc0Z0lDQWdJQ0FnSUhObFoyMWxiblFzSUhKdmRYUmxjeXdnY205MWRHVXNJSEJoZEdoekxDQnZkWFJzWlhRcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1Y0Y0dGdVpGZHBiR1JEWVhKa1YybDBhRkJoY21GdGMwRm5ZV2x1YzNSU2IzVjBaVlZ6YVc1blVtVmthWEpsWTNRb2NtOTFkR1U2SUZKdmRYUmxLVG9nVlhKc1UyVm5iV1Z1ZENCN1hHNGdJR052Ym5OMElHNWxkMUJoZEdoeklEMGdZWEJ3YkhsU1pXUnBjbVZqZEVOdmJXMWhibVJ6S0Z0ZExDQnliM1YwWlM1eVpXUnBjbVZqZEZSdkxDQjdmU2s3WEc0Z0lHbG1JQ2h5YjNWMFpTNXlaV1JwY21WamRGUnZMbk4wWVhKMGMxZHBkR2dvSnk4bktTa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkhiRzlpWVd4U1pXUnBjbVZqZENodVpYZFFZWFJvY3lrN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QlZjbXhUWldkdFpXNTBLRzVsZDFCaGRHaHpMQ0I3ZlNrN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdaWGh3WVc1a1VtVm5kV3hoY2xCaGRHaFhhWFJvVUdGeVlXMXpRV2RoYVc1emRGSnZkWFJsVlhOcGJtZFNaV1JwY21WamRDaGNiaUFnSUNCelpXZHRaVzUwT2lCVmNteFRaV2R0Wlc1MExDQnliM1YwWlhNNklGSnZkWFJsVzEwc0lISnZkWFJsT2lCU2IzVjBaU3dnY0dGMGFITTZJRlZ5YkZCaGRHaFhhWFJvVUdGeVlXMXpXMTBzWEc0Z0lDQWdiM1YwYkdWME9pQnpkSEpwYm1jcE9pQlZjbXhUWldkdFpXNTBJSHRjYmlBZ1kyOXVjM1FnZTJOdmJuTjFiV1ZrVUdGMGFITXNJR3hoYzNSRGFHbHNaQ3dnY0c5emFYUnBiMjVoYkZCaGNtRnRVMlZuYldWdWRITjlJRDBnYldGMFkyZ29jMlZuYldWdWRDd2djbTkxZEdVc0lIQmhkR2h6S1R0Y2JpQWdZMjl1YzNRZ2JtVjNVR0YwYUhNZ1BWeHVJQ0FnSUNBZ1lYQndiSGxTWldScGNtVmpkRU52YlcxaGJtUnpLR052Ym5OMWJXVmtVR0YwYUhNc0lISnZkWFJsTG5KbFpHbHlaV04wVkc4c0lEeGhibmsrY0c5emFYUnBiMjVoYkZCaGNtRnRVMlZuYldWdWRITXBPMXh1SUNCcFppQW9jbTkxZEdVdWNtVmthWEpsWTNSVWJ5NXpkR0Z5ZEhOWGFYUm9LQ2N2SnlrcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1IyeHZZbUZzVW1Wa2FYSmxZM1FvYm1WM1VHRjBhSE1wTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGRIVnliaUJsZUhCaGJtUlFZWFJvYzFkcGRHaFFZWEpoYlhNb1hHNGdJQ0FnSUNBZ0lITmxaMjFsYm5Rc0lISnZkWFJsY3l3Z2JtVjNVR0YwYUhNdVkyOXVZMkYwS0hCaGRHaHpMbk5zYVdObEtHeGhjM1JEYUdsc1pDa3BMQ0J2ZFhSc1pYUXNJR1poYkhObEtUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ0WVhSamFGQmhkR2h6VjJsMGFGQmhjbUZ0YzBGbllXbHVjM1JTYjNWMFpTaGNiaUFnSUNCelpXZHRaVzUwT2lCVmNteFRaV2R0Wlc1MExDQnliM1YwWlRvZ1VtOTFkR1VzSUhCaGRHaHpPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMXRkS1RvZ1ZYSnNVMlZuYldWdWRDQjdYRzRnSUdsbUlDaHliM1YwWlM1d1lYUm9JRDA5UFNBbktpb25LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHNWxkeUJWY214VFpXZHRaVzUwS0hCaGRHaHpMQ0I3ZlNrN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ1kyOXVjM1FnZTJOdmJuTjFiV1ZrVUdGMGFITXNJR3hoYzNSRGFHbHNaSDBnUFNCdFlYUmphQ2h6WldkdFpXNTBMQ0J5YjNWMFpTd2djR0YwYUhNcE8xeHVJQ0FnSUdOdmJuTjBJR05vYVd4a1EyOXVabWxuSUQwZ2NtOTFkR1V1WTJocGJHUnlaVzRnUHlCeWIzVjBaUzVqYUdsc1pISmxiaUE2SUZ0ZE8xeHVJQ0FnSUdOdmJuTjBJSE5zYVdObFpGQmhkR2dnUFNCd1lYUm9jeTV6YkdsalpTaHNZWE4wUTJocGJHUXBPMXh1WEc0Z0lDQWdhV1lnS0dOb2FXeGtRMjl1Wm1sbkxteGxibWQwYUNBOVBUMGdNQ0FtSmlCemJHbGpaV1JRWVhSb0xteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRzVsZHlCVmNteFRaV2R0Wlc1MEtHTnZibk4xYldWa1VHRjBhSE1zSUh0OUtUdGNibHh1SUNBZ0lDQWdMeThnVkU5RVR6b2dZMmhsWTJzZ2RHaGhkQ0IwYUdVZ2NtbG5hSFFnYzJWbmJXVnVkQ0JwY3lCd2NtVnpaVzUwWEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h6YkdsalpXUlFZWFJvTG14bGJtZDBhQ0E5UFQwZ01DQW1KaUJQWW1wbFkzUXVhMlY1Y3loelpXZHRaVzUwTG1Ob2FXeGtjbVZ1S1M1c1pXNW5kR2dnUGlBd0tTQjdYRzRnSUNBZ0lDQmpiMjV6ZENCamFHbHNaSEpsYmlBOUlHVjRjR0Z1WkZObFoyMWxiblJEYUdsc1pISmxiaWhqYUdsc1pFTnZibVpwWnl3Z2MyVm5iV1Z1ZENrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lGVnliRk5sWjIxbGJuUW9ZMjl1YzNWdFpXUlFZWFJvY3l3Z1kyaHBiR1J5Wlc0cE8xeHVYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJR056SUQwZ1pYaHdZVzVrVUdGMGFITlhhWFJvVUdGeVlXMXpLSE5sWjIxbGJuUXNJR05vYVd4a1EyOXVabWxuTENCemJHbGpaV1JRWVhSb0xDQlFVa2xOUVZKWlgwOVZWRXhGVkN3Z2RISjFaU2s3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdibVYzSUZWeWJGTmxaMjFsYm5Rb1kyOXVjM1Z0WldSUVlYUm9jeTVqYjI1allYUW9ZM011Y0dGMGFITlhhWFJvVUdGeVlXMXpLU3dnWTNNdVkyaHBiR1J5Wlc0cE8xeHVJQ0FnSUgxY2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnRZWFJqYUNoelpXZHRaVzUwT2lCVmNteFRaV2R0Wlc1MExDQnliM1YwWlRvZ1VtOTFkR1VzSUhCaGRHaHpPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMXRkS1RvZ2UxeHVJQ0JqYjI1emRXMWxaRkJoZEdoek9pQlZjbXhRWVhSb1YybDBhRkJoY21GdGMxdGRMRnh1SUNCc1lYTjBRMmhwYkdRNklHNTFiV0psY2l4Y2JpQWdjRzl6YVhScGIyNWhiRkJoY21GdFUyVm5iV1Z1ZEhNNklIdGJhem9nYzNSeWFXNW5YVG9nVlhKc1VHRjBhRmRwZEdoUVlYSmhiWE45WEc1OUlIdGNiaUFnYVdZZ0tISnZkWFJsTG5CaGRHZ2dQVDA5SUNjbktTQjdYRzRnSUNBZ2FXWWdLSEp2ZFhSbExuUmxjbTFwYm1Gc0lDWW1JQ2hQWW1wbFkzUXVhMlY1Y3loelpXZHRaVzUwTG1Ob2FXeGtjbVZ1S1M1c1pXNW5kR2dnUGlBd0lIeDhJSEJoZEdoekxteGxibWQwYUNBK0lEQXBLU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnVG05TllYUmphQ2dwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2UyTnZibk4xYldWa1VHRjBhSE02SUZ0ZExDQnNZWE4wUTJocGJHUTZJREFzSUhCdmMybDBhVzl1WVd4UVlYSmhiVk5sWjIxbGJuUnpPaUI3ZlgwN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ1kyOXVjM1FnY0dGMGFDQTlJSEp2ZFhSbExuQmhkR2c3WEc0Z0lHTnZibk4wSUhCaGNuUnpJRDBnY0dGMGFDNXpjR3hwZENnbkx5Y3BPMXh1SUNCamIyNXpkQ0J3YjNOcGRHbHZibUZzVUdGeVlXMVRaV2R0Wlc1MGN6b2dlMXRyT2lCemRISnBibWRkT2lCVmNteFFZWFJvVjJsMGFGQmhjbUZ0YzMwZ1BTQjdmVHRjYmlBZ1kyOXVjM1FnWTI5dWMzVnRaV1JRWVhSb2N6b2dWWEpzVUdGMGFGZHBkR2hRWVhKaGJYTmJYU0E5SUZ0ZE8xeHVYRzRnSUd4bGRDQmpkWEp5Wlc1MFNXNWtaWGdnUFNBd08xeHVYRzRnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z2NHRnlkSE11YkdWdVozUm9PeUFySzJrcElIdGNiaUFnSUNCcFppQW9ZM1Z5Y21WdWRFbHVaR1Y0SUQ0OUlIQmhkR2h6TG14bGJtZDBhQ2tnZEdoeWIzY2dibVYzSUU1dlRXRjBZMmdvS1R0Y2JpQWdJQ0JqYjI1emRDQmpkWEp5Wlc1MElEMGdjR0YwYUhOYlkzVnljbVZ1ZEVsdVpHVjRYVHRjYmx4dUlDQWdJR052Ym5OMElIQWdQU0J3WVhKMGMxdHBYVHRjYmlBZ0lDQmpiMjV6ZENCcGMxQnZjMUJoY21GdElEMGdjQzV6ZEdGeWRITlhhWFJvS0NjNkp5azdYRzVjYmlBZ0lDQnBaaUFvSVdselVHOXpVR0Z5WVcwZ0ppWWdjQ0FoUFQwZ1kzVnljbVZ1ZEM1d1lYUm9LU0IwYUhKdmR5QnVaWGNnVG05TllYUmphQ2dwTzF4dUlDQWdJR2xtSUNocGMxQnZjMUJoY21GdEtTQjdYRzRnSUNBZ0lDQndiM05wZEdsdmJtRnNVR0Z5WVcxVFpXZHRaVzUwYzF0d0xuTjFZbk4wY21sdVp5Z3hLVjBnUFNCamRYSnlaVzUwTzF4dUlDQWdJSDFjYmlBZ0lDQmpiMjV6ZFcxbFpGQmhkR2h6TG5CMWMyZ29ZM1Z5Y21WdWRDazdYRzRnSUNBZ1kzVnljbVZ1ZEVsdVpHVjRLeXM3WEc0Z0lIMWNibHh1SUNCcFppQW9jbTkxZEdVdWRHVnliV2x1WVd3Z0ppWWdLRTlpYW1WamRDNXJaWGx6S0hObFoyMWxiblF1WTJocGJHUnlaVzRwTG14bGJtZDBhQ0ErSURBZ2ZId2dZM1Z5Y21WdWRFbHVaR1Y0SUR3Z2NHRjBhSE11YkdWdVozUm9LU2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJPYjAxaGRHTm9LQ2s3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZTJOdmJuTjFiV1ZrVUdGMGFITXNJR3hoYzNSRGFHbHNaRG9nWTNWeWNtVnVkRWx1WkdWNExDQndiM05wZEdsdmJtRnNVR0Z5WVcxVFpXZHRaVzUwYzMwN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdGd2NHeDVVbVZrYVhKbFkzUkRiMjF0WVc1a2N5aGNiaUFnSUNCd1lYUm9jem9nVlhKc1VHRjBhRmRwZEdoUVlYSmhiWE5iWFN3Z2NtVmthWEpsWTNSVWJ6b2djM1J5YVc1bkxGeHVJQ0FnSUhCdmMxQmhjbUZ0Y3pvZ2UxdHJPaUJ6ZEhKcGJtZGRPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMzBwT2lCVmNteFFZWFJvVjJsMGFGQmhjbUZ0YzF0ZElIdGNiaUFnYVdZZ0tISmxaR2x5WldOMFZHOHVjM1JoY25SelYybDBhQ2duTHljcEtTQjdYRzRnSUNBZ1kyOXVjM1FnY0dGeWRITWdQU0J5WldScGNtVmpkRlJ2TG5OMVluTjBjbWx1WnlneEtTNXpjR3hwZENnbkx5Y3BPMXh1SUNBZ0lISmxkSFZ5YmlCamNtVmhkR1ZRWVhSb2N5aHlaV1JwY21WamRGUnZMQ0J3WVhKMGN5d2djR0YwYUhNc0lIQnZjMUJoY21GdGN5azdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdZMjl1YzNRZ2NHRnlkSE1nUFNCeVpXUnBjbVZqZEZSdkxuTndiR2wwS0Njdkp5azdYRzRnSUNBZ2NtVjBkWEp1SUdOeVpXRjBaVkJoZEdoektISmxaR2x5WldOMFZHOHNJSEJoY25SekxDQndZWFJvY3l3Z2NHOXpVR0Z5WVcxektUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVlFZWFJvY3loY2JpQWdJQ0J5WldScGNtVmpkRlJ2T2lCemRISnBibWNzSUhCaGNuUnpPaUJ6ZEhKcGJtZGJYU3dnYzJWbmJXVnVkSE02SUZWeWJGQmhkR2hYYVhSb1VHRnlZVzF6VzEwc1hHNGdJQ0FnY0c5elVHRnlZVzF6T2lCN1cyczZJSE4wY21sdVoxMDZJRlZ5YkZCaGRHaFhhWFJvVUdGeVlXMXpmU2s2SUZWeWJGQmhkR2hYYVhSb1VHRnlZVzF6VzEwZ2UxeHVJQ0J5WlhSMWNtNGdjR0Z5ZEhNdWJXRndLRnh1SUNBZ0lDQWdjQ0E5UGlCd0xuTjBZWEowYzFkcGRHZ29Kem9uS1NBL0lHWnBibVJRYjNOUVlYSmhiU2h3TENCd2IzTlFZWEpoYlhNc0lISmxaR2x5WldOMFZHOHBJRHBjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1hVzVrVDNKRGNtVmhkR1ZRWVhSb0tIQXNJSE5sWjIxbGJuUnpLU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJR1pwYm1SUWIzTlFZWEpoYlNoY2JpQWdJQ0J3WVhKME9pQnpkSEpwYm1jc0lIQnZjMUJoY21GdGN6b2dlMXRyT2lCemRISnBibWRkT2lCVmNteFFZWFJvVjJsMGFGQmhjbUZ0YzMwc1hHNGdJQ0FnY21Wa2FYSmxZM1JVYnpvZ2MzUnlhVzVuS1RvZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhNZ2UxeHVJQ0JqYjI1emRDQndZWEpoYlU1aGJXVWdQU0J3WVhKMExuTjFZbk4wY21sdVp5Z3hLVHRjYmlBZ1kyOXVjM1FnY0c5eklEMGdjRzl6VUdGeVlXMXpXM0JoY21GdFRtRnRaVjA3WEc0Z0lHbG1JQ2doY0c5ektTQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1lFTmhibTV2ZENCeVpXUnBjbVZqZENCMGJ5QW5KSHR5WldScGNtVmpkRlJ2ZlNjdUlFTmhibTV2ZENCbWFXNWtJQ2NrZTNCaGNuUjlKeTVnS1R0Y2JpQWdjbVYwZFhKdUlIQnZjenRjYm4xY2JseHVablZ1WTNScGIyNGdabWx1WkU5eVEzSmxZWFJsVUdGMGFDaHdZWEowT2lCemRISnBibWNzSUhCaGRHaHpPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMXRkS1RvZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhNZ2UxeHVJQ0JqYjI1emRDQnRZWFJqYUdsdVowbHVaR1Y0SUQwZ2NHRjBhSE11Wm1sdVpFbHVaR1Y0S0hNZ1BUNGdjeTV3WVhSb0lEMDlQU0J3WVhKMEtUdGNiaUFnYVdZZ0tHMWhkR05vYVc1blNXNWtaWGdnUGlBdE1Ta2dlMXh1SUNBZ0lHTnZibk4wSUhJZ1BTQndZWFJvYzF0dFlYUmphR2x1WjBsdVpHVjRYVHRjYmlBZ0lDQndZWFJvY3k1emNHeHBZMlVvYldGMFkyaHBibWRKYm1SbGVDazdYRzRnSUNBZ2NtVjBkWEp1SUhJN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QlZjbXhRWVhSb1YybDBhRkJoY21GdGN5aHdZWEowTENCN2ZTazdYRzRnSUgxY2JuMWNiaUpkZlE9PVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bhbmd1bGFyL3JvdXRlci9hcHBseV9yZWRpcmVjdHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5QUklNQVJZX09VVExFVCA9ICdQUklNQVJZX09VVExFVCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMmhoY21Wa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMM05vWVhKbFpDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCU1dFc2MwSkJRV01zUjBGQlJ5eG5Ra0ZCWjBJc1EwRkJReUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cUtseHVJQ29nVG1GdFpTQnZaaUIwYUdVZ2NISnBiV0Z5ZVNCdmRYUnNaWFF1WEc0Z0tpQkFkSGx3WlNCN2MzUnlhVzVuZlZ4dUlDb3ZYRzVsZUhCdmNuUWdZMjl1YzNRZ1VGSkpUVUZTV1Y5UFZWUk1SVlFnUFNBblVGSkpUVUZTV1Y5UFZWUk1SVlFuTzF4dVhHNHZLaXBjYmlBcUlFRWdZMjlzYkdWamRHbHZiaUJ2WmlCd1lYSmhiV1YwWlhKekxseHVJQ292WEc1bGVIQnZjblFnZEhsd1pTQlFZWEpoYlhNZ1BTQjdYRzRnSUZ0clpYazZJSE4wY21sdVoxMDZJR0Z1ZVZ4dWZUdGNiaUpkZlE9PVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bhbmd1bGFyL3JvdXRlci9zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbnZhciB1cmxfc2VyaWFsaXplcl8xID0gcmVxdWlyZSgnLi91cmxfc2VyaWFsaXplcicpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbHMvY29sbGVjdGlvbicpO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlVcmxUcmVlKCkge1xuICAgIHJldHVybiBuZXcgVXJsVHJlZShuZXcgVXJsU2VnbWVudChbXSwge30pLCB7fSwgbnVsbCk7XG59XG5leHBvcnRzLmNyZWF0ZUVtcHR5VXJsVHJlZSA9IGNyZWF0ZUVtcHR5VXJsVHJlZTtcbmZ1bmN0aW9uIGNvbnRhaW5zVHJlZShjb250YWluZXIsIGNvbnRhaW5lZSwgZXhhY3QpIHtcbiAgICBpZiAoZXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsU2VnbWVudHMoY29udGFpbmVyLnJvb3QsIGNvbnRhaW5lZS5yb290KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250YWluc1NlZ21lbnQoY29udGFpbmVyLnJvb3QsIGNvbnRhaW5lZS5yb290KTtcbiAgICB9XG59XG5leHBvcnRzLmNvbnRhaW5zVHJlZSA9IGNvbnRhaW5zVHJlZTtcbmZ1bmN0aW9uIGVxdWFsU2VnbWVudHMoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIucGF0aHNXaXRoUGFyYW1zLCBjb250YWluZWUucGF0aHNXaXRoUGFyYW1zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChPYmplY3Qua2V5cyhjb250YWluZXIuY2hpbGRyZW4pLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoY29udGFpbmVlLmNoaWxkcmVuKS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBjIGluIGNvbnRhaW5lZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5jaGlsZHJlbltjXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFlcXVhbFNlZ21lbnRzKGNvbnRhaW5lci5jaGlsZHJlbltjXSwgY29udGFpbmVlLmNoaWxkcmVuW2NdKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb250YWluc1NlZ21lbnQoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICByZXR1cm4gY29udGFpbnNTZWdtZW50SGVscGVyKGNvbnRhaW5lciwgY29udGFpbmVlLCBjb250YWluZWUucGF0aHNXaXRoUGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zU2VnbWVudEhlbHBlcihjb250YWluZXIsIGNvbnRhaW5lZSwgY29udGFpbmVlUGF0aHMpIHtcbiAgICBpZiAoY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcy5sZW5ndGggPiBjb250YWluZWVQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIucGF0aHNXaXRoUGFyYW1zLnNsaWNlKDAsIGNvbnRhaW5lZVBhdGhzLmxlbmd0aCk7XG4gICAgICAgIGlmICghZXF1YWxQYXRoKGN1cnJlbnQsIGNvbnRhaW5lZVBhdGhzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbnRhaW5lZS5jaGlsZHJlbikubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRhaW5lci5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoID09PSBjb250YWluZWVQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFlcXVhbFBhdGgoY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcywgY29udGFpbmVlUGF0aHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBjIGluIGNvbnRhaW5lZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuY2hpbGRyZW5bY10pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFjb250YWluc1NlZ21lbnQoY29udGFpbmVyLmNoaWxkcmVuW2NdLCBjb250YWluZWUuY2hpbGRyZW5bY10pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVlUGF0aHMuc2xpY2UoMCwgY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcy5sZW5ndGgpO1xuICAgICAgICB2YXIgbmV4dCA9IGNvbnRhaW5lZVBhdGhzLnNsaWNlKGNvbnRhaW5lci5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFlcXVhbFBhdGgoY29udGFpbmVyLnBhdGhzV2l0aFBhcmFtcywgY3VycmVudCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb250YWluc1NlZ21lbnRIZWxwZXIoY29udGFpbmVyLmNoaWxkcmVuW3NoYXJlZF8xLlBSSU1BUllfT1VUTEVUXSwgY29udGFpbmVlLCBuZXh0KTtcbiAgICB9XG59XG52YXIgVXJsVHJlZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsVHJlZShyb290LCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgfVxuICAgIFVybFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHVybF9zZXJpYWxpemVyXzEuRGVmYXVsdFVybFNlcmlhbGl6ZXIoKS5zZXJpYWxpemUodGhpcyk7IH07XG4gICAgcmV0dXJuIFVybFRyZWU7XG59KCkpO1xuZXhwb3J0cy5VcmxUcmVlID0gVXJsVHJlZTtcbnZhciBVcmxTZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxTZWdtZW50KHBhdGhzV2l0aFBhcmFtcywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wYXRoc1dpdGhQYXJhbXMgPSBwYXRoc1dpdGhQYXJhbXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHYucGFyZW50ID0gX3RoaXM7IH0pO1xuICAgIH1cbiAgICBVcmxTZWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF9zZXJpYWxpemVyXzEuc2VyaWFsaXplUGF0aHModGhpcyk7IH07XG4gICAgcmV0dXJuIFVybFNlZ21lbnQ7XG59KCkpO1xuZXhwb3J0cy5VcmxTZWdtZW50ID0gVXJsU2VnbWVudDtcbnZhciBVcmxQYXRoV2l0aFBhcmFtcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsUGF0aFdpdGhQYXJhbXMocGF0aCwgcGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgIH1cbiAgICBVcmxQYXRoV2l0aFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmxfc2VyaWFsaXplcl8xLnNlcmlhbGl6ZVBhdGgodGhpcyk7IH07XG4gICAgcmV0dXJuIFVybFBhdGhXaXRoUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuVXJsUGF0aFdpdGhQYXJhbXMgPSBVcmxQYXRoV2l0aFBhcmFtcztcbmZ1bmN0aW9uIGVxdWFsUGF0aHNXaXRoUGFyYW1zKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhW2ldLnBhdGggIT09IGJbaV0ucGF0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuc2hhbGxvd0VxdWFsKGFbaV0ucGFyYW1ldGVycywgYltpXS5wYXJhbWV0ZXJzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmVxdWFsUGF0aHNXaXRoUGFyYW1zID0gZXF1YWxQYXRoc1dpdGhQYXJhbXM7XG5mdW5jdGlvbiBlcXVhbFBhdGgoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0ucGF0aCAhPT0gYltpXS5wYXRoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxQYXRoID0gZXF1YWxQYXRoO1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oc2VnbWVudCwgZm4pIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSB7fTtcbiAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgIGlmIChjaGlsZE91dGxldCA9PT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW2NoaWxkT3V0bGV0XSA9IGZuKGNoaWxkLCBjaGlsZE91dGxldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgIGlmIChjaGlsZE91dGxldCAhPT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW2NoaWxkT3V0bGV0XSA9IGZuKGNoaWxkLCBjaGlsZE91dGxldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Q2hpbGRyZW47XG59XG5leHBvcnRzLm1hcENoaWxkcmVuID0gbWFwQ2hpbGRyZW47XG5mdW5jdGlvbiBtYXBDaGlsZHJlbkludG9BcnJheShzZWdtZW50LCBmbikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgIGlmIChjaGlsZE91dGxldCA9PT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZm4oY2hpbGQsIGNoaWxkT3V0bGV0KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgIGlmIChjaGlsZE91dGxldCAhPT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZm4oY2hpbGQsIGNoaWxkT3V0bGV0KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5tYXBDaGlsZHJlbkludG9BcnJheSA9IG1hcENoaWxkcmVuSW50b0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZFhKc1gzUnlaV1V1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmRYSnNYM1J5WldVdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEhWQ1FVRTJRaXhWUVVGVkxFTkJRVU1zUTBGQlFUdEJRVU40UXl3clFrRkJhMFVzYTBKQlFXdENMRU5CUVVNc1EwRkJRVHRCUVVOeVJpd3lRa0ZCYjBNc2IwSkJRVzlDTEVOQlFVTXNRMEZCUVR0QlFVVjZSRHRKUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEU5QlFVOHNRMEZCUXl4SlFVRkpMRlZCUVZVc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8wRkJRM1pFTEVOQlFVTTdRVUZHWlN3d1FrRkJhMElzY1VKQlJXcERMRU5CUVVFN1FVRkZSQ3h6UWtGQk5rSXNVMEZCYTBJc1JVRkJSU3hUUVVGclFpeEZRVUZGTEV0QlFXTTdTVUZEYWtZc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTldMRTFCUVUwc1EwRkJReXhoUVVGaExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NSVUZCUlN4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRGRrUXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTjZSQ3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVTVsTEc5Q1FVRlpMR1ZCVFROQ0xFTkJRVUU3UVVGRlJDeDFRa0ZCZFVJc1UwRkJjVUlzUlVGQlJTeFRRVUZ4UWp0SlFVTnFSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4VFFVRlRMRU5CUVVNc1pVRkJaU3hGUVVGRkxGTkJRVk1zUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0UlFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRGJrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU53Uml4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wbEJRMllzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTjZReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdGQlFXRXNRMEZCUXl4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1NVRkRha1lzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJSVVFzZVVKQlFYbENMRk5CUVhGQ0xFVkJRVVVzVTBGQmNVSTdTVUZEYmtVc1RVRkJUU3hEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRk5CUVZNc1JVRkJSU3hUUVVGVExFVkJRVVVzVTBGQlV5eERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMEZCUTJoR0xFTkJRVU03UVVGRlJDd3JRa0ZEU1N4VFFVRnhRaXhGUVVGRkxGTkJRWEZDTEVWQlFVVXNZMEZCYlVNN1NVRkRia1lzUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhOUVVGTkxFZEJRVWNzWTBGQll5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkROMFFzU1VGQlRTeFBRVUZQTEVkQlFVY3NVMEZCVXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTEdOQlFXTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVNeFJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFVkJRVVVzWTBGQll5eERRVUZETEVOQlFVTTdXVUZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRM1JFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUXpkRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZGWkN4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1RVRkJUU3hMUVVGTExHTkJRV01zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNc1EwRkJReXhsUVVGbExFVkJRVVVzWTBGQll5eERRVUZETEVOQlFVTTdXVUZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRM2hGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxGTkJRVk1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xbEJRM3BETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExGTkJRVk1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZEYmtZc1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZGWkN4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeEpRVUZOTEU5QlFVOHNSMEZCUnl4alFVRmpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJTeFRRVUZUTEVOQlFVTXNaVUZCWlN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRekZGTEVsQlFVMHNTVUZCU1N4SFFVRkhMR05CUVdNc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEdWQlFXVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOd1JTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJReXhUUVVGVExFTkJRVU1zWlVGQlpTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU5xUlN4TlFVRk5MRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXgxUWtGQll5eERRVUZETEVWQlFVVXNVMEZCVXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRM0JHTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUzBRN1NVRkpSU3hwUWtGRFZ5eEpRVUZuUWl4RlFVRlRMRmRCUVc5RExFVkJRemRFTEZGQlFXZENPMUZCUkdoQ0xGTkJRVWtzUjBGQlNpeEpRVUZKTEVOQlFWazdVVUZCVXl4blFrRkJWeXhIUVVGWUxGZEJRVmNzUTBGQmVVSTdVVUZETjBRc1lVRkJVU3hIUVVGU0xGRkJRVkVzUTBGQlVUdEpRVUZITEVOQlFVTTdTVUZGTDBJc01FSkJRVkVzUjBGQlVpeGpRVUZ4UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3h4UTBGQmIwSXNSVUZCUlN4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETTBVc1kwRkJRenRCUVVGRUxFTkJRVU1zUVVGVVJDeEpRVk5ETzBGQlZGa3NaVUZCVHl4VlFWTnVRaXhEUVVGQk8wRkJSVVE3U1VGRlJTeHZRa0ZEVnl4bFFVRnZReXhGUVVGVExGRkJRWEZETzFGQlNDOUdMR2xDUVZGRE8xRkJURmtzYjBKQlFXVXNSMEZCWml4bFFVRmxMRU5CUVhGQ08xRkJRVk1zWVVGQlVTeEhRVUZTTEZGQlFWRXNRMEZCTmtJN1VVRkdkRVlzVjBGQlRTeEhRVUZsTEVsQlFVa3NRMEZCUXp0UlFVY3ZRaXh2UWtGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4VlFVRkRMRU5CUVUwc1JVRkJSU3hEUVVGTkxFbEJRVXNzVDBGQlFTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRXRCUVVrc1JVRkJaaXhEUVVGbExFTkJRVU1zUTBGQlF6dEpRVU42UkN4RFFVRkRPMGxCUlVRc05rSkJRVkVzUjBGQlVpeGpRVUZ4UWl4TlFVRk5MRU5CUVVNc0swSkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRja1FzYVVKQlFVTTdRVUZCUkN4RFFVRkRMRUZCVWtRc1NVRlJRenRCUVZKWkxHdENRVUZWTEdGQlVYUkNMRU5CUVVFN1FVRkZSRHRKUVVORkxESkNRVUZ0UWl4SlFVRlpMRVZCUVZNc1ZVRkJiVU03VVVGQmVFUXNVMEZCU1N4SFFVRktMRWxCUVVrc1EwRkJVVHRSUVVGVExHVkJRVlVzUjBGQlZpeFZRVUZWTEVOQlFYbENPMGxCUVVjc1EwRkJRenRKUVVNdlJTeHZRMEZCVVN4SFFVRlNMR05CUVhGQ0xFMUJRVTBzUTBGQlF5dzRRa0ZCWVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU53UkN4M1FrRkJRenRCUVVGRUxFTkJRVU1zUVVGSVJDeEpRVWRETzBGQlNGa3NlVUpCUVdsQ0xHOUNRVWMzUWl4RFFVRkJPMEZCUlVRc09FSkJRWEZETEVOQlFYTkNMRVZCUVVVc1EwRkJjMEk3U1VGRGFrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU40UXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhOUVVGTkxFVkJRVVVzUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTnNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlF6RkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFpRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1NVRkRjRVVzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJVR1VzTkVKQlFXOUNMSFZDUVU5dVF5eERRVUZCTzBGQlJVUXNiVUpCUVRCQ0xFTkJRWE5DTEVWQlFVVXNRMEZCYzBJN1NVRkRkRVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETzFGQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVONFF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4TlFVRk5MRVZCUVVVc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF6dFJRVU5zUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTTdXVUZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wbEJRelZETEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wRkJRMlFzUTBGQlF6dEJRVTVsTEdsQ1FVRlRMRmxCVFhoQ0xFTkJRVUU3UVVGRlJDeHhRa0ZCTkVJc1QwRkJiVUlzUlVGQlJTeEZRVUUwUXp0SlFVVXpSaXhKUVVGTkxGZEJRVmNzUjBGQmFVTXNSVUZCUlN4RFFVRkRPMGxCUTNKRUxHOUNRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hWUVVGRExFdEJRV2xDTEVWQlFVVXNWMEZCYlVJN1VVRkRMMFFzUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4TFFVRkxMSFZDUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRmRCUVZjc1EwRkJReXhYUVVGWExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRmRCUVZjc1EwRkJReXhEUVVGRE8xRkJRM0JFTEVOQlFVTTdTVUZEU0N4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOSUxHOUNRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hWUVVGRExFdEJRV2xDTEVWQlFVVXNWMEZCYlVJN1VVRkRMMFFzUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4TFFVRkxMSFZDUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRmRCUVZjc1EwRkJReXhYUVVGWExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRmRCUVZjc1EwRkJReXhEUVVGRE8xRkJRM0JFTEVOQlFVTTdTVUZEU0N4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOSUxFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTTdRVUZEY2tJc1EwRkJRenRCUVdSbExHMUNRVUZYTEdOQll6RkNMRU5CUVVFN1FVRkZSQ3c0UWtGRFNTeFBRVUZ0UWl4RlFVRkZMRVZCUVhGRE8wbEJRelZFTEVsQlFVa3NSMEZCUnl4SFFVRlJMRVZCUVVVc1EwRkJRenRKUVVOc1FpeHZRa0ZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzVlVGQlF5eExRVUZwUWl4RlFVRkZMRmRCUVcxQ08xRkJReTlFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmRCUVZjc1MwRkJTeXgxUWtGQll5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETTBNc1EwRkJRenRKUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwZ3NiMEpCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEZWQlFVTXNTMEZCYVVJc1JVRkJSU3hYUVVGdFFqdFJRVU12UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGWExFdEJRVXNzZFVKQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpORExFTkJRVU03U1VGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTklMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03UVVGRFlpeERRVUZETzBGQlpHVXNORUpCUVc5Q0xIVkNRV051UXl4RFFVRkJJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpYVcxd2IzSjBJSHRRVWtsTlFWSlpYMDlWVkV4RlZIMGdabkp2YlNBbkxpOXphR0Z5WldRbk8xeHVhVzF3YjNKMElIdEVaV1poZFd4MFZYSnNVMlZ5YVdGc2FYcGxjaXdnYzJWeWFXRnNhWHBsVUdGMGFDd2djMlZ5YVdGc2FYcGxVR0YwYUhOOUlHWnliMjBnSnk0dmRYSnNYM05sY21saGJHbDZaWEluTzF4dWFXMXdiM0owSUh0bWIzSkZZV05vTENCemFHRnNiRzkzUlhGMVlXeDlJR1p5YjIwZ0p5NHZkWFJwYkhNdlkyOXNiR1ZqZEdsdmJpYzdYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJqY21WaGRHVkZiWEIwZVZWeWJGUnlaV1VvS1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnVlhKc1ZISmxaU2h1WlhjZ1ZYSnNVMlZuYldWdWRDaGJYU3dnZTMwcExDQjdmU3dnYm5Wc2JDazdYRzU5WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCamIyNTBZV2x1YzFSeVpXVW9ZMjl1ZEdGcGJtVnlPaUJWY214VWNtVmxMQ0JqYjI1MFlXbHVaV1U2SUZWeWJGUnlaV1VzSUdWNFlXTjBPaUJpYjI5c1pXRnVLVG9nWW05dmJHVmhiaUI3WEc0Z0lHbG1JQ2hsZUdGamRDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbGNYVmhiRk5sWjIxbGJuUnpLR052Ym5SaGFXNWxjaTV5YjI5MExDQmpiMjUwWVdsdVpXVXVjbTl2ZENrN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtVjBkWEp1SUdOdmJuUmhhVzV6VTJWbmJXVnVkQ2hqYjI1MFlXbHVaWEl1Y205dmRDd2dZMjl1ZEdGcGJtVmxMbkp2YjNRcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1Z4ZFdGc1UyVm5iV1Z1ZEhNb1kyOXVkR0ZwYm1WeU9pQlZjbXhUWldkdFpXNTBMQ0JqYjI1MFlXbHVaV1U2SUZWeWJGTmxaMjFsYm5RcE9pQmliMjlzWldGdUlIdGNiaUFnYVdZZ0tDRmxjWFZoYkZCaGRHZ29ZMjl1ZEdGcGJtVnlMbkJoZEdoelYybDBhRkJoY21GdGN5d2dZMjl1ZEdGcGJtVmxMbkJoZEdoelYybDBhRkJoY21GdGN5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdhV1lnS0U5aWFtVmpkQzVyWlhsektHTnZiblJoYVc1bGNpNWphR2xzWkhKbGJpa3ViR1Z1WjNSb0lDRTlQU0JQWW1wbFkzUXVhMlY1Y3loamIyNTBZV2x1WldVdVkyaHBiR1J5Wlc0cExteGxibWQwYUNsY2JpQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJR1p2Y2lBb2JHVjBJR01nYVc0Z1kyOXVkR0ZwYm1WbExtTm9hV3hrY21WdUtTQjdYRzRnSUNBZ2FXWWdLQ0ZqYjI1MFlXbHVaWEl1WTJocGJHUnlaVzViWTEwcElISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQnBaaUFvSVdWeGRXRnNVMlZuYldWdWRITW9ZMjl1ZEdGcGJtVnlMbU5vYVd4a2NtVnVXMk5kTENCamIyNTBZV2x1WldVdVkyaHBiR1J5Wlc1YlkxMHBLU0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUhSeWRXVTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHTnZiblJoYVc1elUyVm5iV1Z1ZENoamIyNTBZV2x1WlhJNklGVnliRk5sWjIxbGJuUXNJR052Ym5SaGFXNWxaVG9nVlhKc1UyVm5iV1Z1ZENrNklHSnZiMnhsWVc0Z2UxeHVJQ0J5WlhSMWNtNGdZMjl1ZEdGcGJuTlRaV2R0Wlc1MFNHVnNjR1Z5S0dOdmJuUmhhVzVsY2l3Z1kyOXVkR0ZwYm1WbExDQmpiMjUwWVdsdVpXVXVjR0YwYUhOWGFYUm9VR0Z5WVcxektUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1kyOXVkR0ZwYm5OVFpXZHRaVzUwU0dWc2NHVnlLRnh1SUNBZ0lHTnZiblJoYVc1bGNqb2dWWEpzVTJWbmJXVnVkQ3dnWTI5dWRHRnBibVZsT2lCVmNteFRaV2R0Wlc1MExDQmpiMjUwWVdsdVpXVlFZWFJvY3pvZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhOYlhTazZJR0p2YjJ4bFlXNGdlMXh1SUNCcFppQW9ZMjl1ZEdGcGJtVnlMbkJoZEdoelYybDBhRkJoY21GdGN5NXNaVzVuZEdnZ1BpQmpiMjUwWVdsdVpXVlFZWFJvY3k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0JqYjI1emRDQmpkWEp5Wlc1MElEMGdZMjl1ZEdGcGJtVnlMbkJoZEdoelYybDBhRkJoY21GdGN5NXpiR2xqWlNnd0xDQmpiMjUwWVdsdVpXVlFZWFJvY3k1c1pXNW5kR2dwTzF4dUlDQWdJR2xtSUNnaFpYRjFZV3hRWVhSb0tHTjFjbkpsYm5Rc0lHTnZiblJoYVc1bFpWQmhkR2h6S1NrZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lHbG1JQ2hQWW1wbFkzUXVhMlY1Y3loamIyNTBZV2x1WldVdVkyaHBiR1J5Wlc0cExteGxibWQwYUNBK0lEQXBJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JseHVJQ0I5SUdWc2MyVWdhV1lnS0dOdmJuUmhhVzVsY2k1d1lYUm9jMWRwZEdoUVlYSmhiWE11YkdWdVozUm9JRDA5UFNCamIyNTBZV2x1WldWUVlYUm9jeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQnBaaUFvSVdWeGRXRnNVR0YwYUNoamIyNTBZV2x1WlhJdWNHRjBhSE5YYVhSb1VHRnlZVzF6TENCamIyNTBZV2x1WldWUVlYUm9jeWtwSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNCbWIzSWdLR3hsZENCaklHbHVJR052Ym5SaGFXNWxaUzVqYUdsc1pISmxiaWtnZTF4dUlDQWdJQ0FnYVdZZ0tDRmpiMjUwWVdsdVpYSXVZMmhwYkdSeVpXNWJZMTBwSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNBZ0lHbG1JQ2doWTI5dWRHRnBibk5UWldkdFpXNTBLR052Ym5SaGFXNWxjaTVqYUdsc1pISmxibHRqWFN3Z1kyOXVkR0ZwYm1WbExtTm9hV3hrY21WdVcyTmRLU2tnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JseHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHTnZibk4wSUdOMWNuSmxiblFnUFNCamIyNTBZV2x1WldWUVlYUm9jeTV6YkdsalpTZ3dMQ0JqYjI1MFlXbHVaWEl1Y0dGMGFITlhhWFJvVUdGeVlXMXpMbXhsYm1kMGFDazdYRzRnSUNBZ1kyOXVjM1FnYm1WNGRDQTlJR052Ym5SaGFXNWxaVkJoZEdoekxuTnNhV05sS0dOdmJuUmhhVzVsY2k1d1lYUm9jMWRwZEdoUVlYSmhiWE11YkdWdVozUm9LVHRjYmlBZ0lDQnBaaUFvSVdWeGRXRnNVR0YwYUNoamIyNTBZV2x1WlhJdWNHRjBhSE5YYVhSb1VHRnlZVzF6TENCamRYSnlaVzUwS1NrZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lISmxkSFZ5YmlCamIyNTBZV2x1YzFObFoyMWxiblJJWld4d1pYSW9ZMjl1ZEdGcGJtVnlMbU5vYVd4a2NtVnVXMUJTU1UxQlVsbGZUMVZVVEVWVVhTd2dZMjl1ZEdGcGJtVmxMQ0J1WlhoMEtUdGNiaUFnZlZ4dWZWeHVYRzR2S2lwY2JpQXFJRUVnVlZKTUlHbHVJSFJvWlNCMGNtVmxJR1p2Y20wdVhHNGdLaTljYm1WNGNHOXlkQ0JqYkdGemN5QlZjbXhVY21WbElIdGNiaUFnTHlvcVhHNGdJQ0FxSUVCcGJuUmxjbTVoYkZ4dUlDQWdLaTljYmlBZ1kyOXVjM1J5ZFdOMGIzSW9YRzRnSUNBZ0lDQndkV0pzYVdNZ2NtOXZkRG9nVlhKc1UyVm5iV1Z1ZEN3Z2NIVmliR2xqSUhGMVpYSjVVR0Z5WVcxek9pQjdXMnRsZVRvZ2MzUnlhVzVuWFRvZ2MzUnlhVzVuZlN4Y2JpQWdJQ0FnSUhCMVlteHBZeUJtY21GbmJXVnVkRG9nYzNSeWFXNW5LU0I3ZlZ4dVhHNGdJSFJ2VTNSeWFXNW5LQ2s2SUhOMGNtbHVaeUI3SUhKbGRIVnliaUJ1WlhjZ1JHVm1ZWFZzZEZWeWJGTmxjbWxoYkdsNlpYSW9LUzV6WlhKcFlXeHBlbVVvZEdocGN5azdJSDFjYm4xY2JseHVaWGh3YjNKMElHTnNZWE56SUZWeWJGTmxaMjFsYm5RZ2UxeHVJQ0J3ZFdKc2FXTWdjR0Z5Wlc1ME9pQlZjbXhUWldkdFpXNTBJRDBnYm5Wc2JEdGNiaUFnWTI5dWMzUnlkV04wYjNJb1hHNGdJQ0FnSUNCd2RXSnNhV01nY0dGMGFITlhhWFJvVUdGeVlXMXpPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMXRkTENCd2RXSnNhV01nWTJocGJHUnlaVzQ2SUh0YmEyVjVPaUJ6ZEhKcGJtZGRPaUJWY214VFpXZHRaVzUwZlNrZ2UxeHVJQ0FnSUdadmNrVmhZMmdvWTJocGJHUnlaVzRzSUNoMk9pQmhibmtzSUdzNklHRnVlU2tnUFQ0Z2RpNXdZWEpsYm5RZ1BTQjBhR2x6S1R0Y2JpQWdmVnh1WEc0Z0lIUnZVM1J5YVc1bktDazZJSE4wY21sdVp5QjdJSEpsZEhWeWJpQnpaWEpwWVd4cGVtVlFZWFJvY3loMGFHbHpLVHNnZlZ4dWZWeHVYRzVsZUhCdmNuUWdZMnhoYzNNZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhNZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lod2RXSnNhV01nY0dGMGFEb2djM1J5YVc1bkxDQndkV0pzYVdNZ2NHRnlZVzFsZEdWeWN6b2dlMXRyWlhrNklITjBjbWx1WjEwNklITjBjbWx1WjMwcElIdDlYRzRnSUhSdlUzUnlhVzVuS0NrNklITjBjbWx1WnlCN0lISmxkSFZ5YmlCelpYSnBZV3hwZW1WUVlYUm9LSFJvYVhNcE95QjlYRzU5WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCbGNYVmhiRkJoZEdoelYybDBhRkJoY21GdGN5aGhPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMXRkTENCaU9pQlZjbXhRWVhSb1YybDBhRkJoY21GdGMxdGRLVG9nWW05dmJHVmhiaUI3WEc0Z0lHbG1JQ2hoTG14bGJtZDBhQ0FoUFQwZ1lpNXNaVzVuZEdncElISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmhMbXhsYm1kMGFEc2dLeXRwS1NCN1hHNGdJQ0FnYVdZZ0tHRmJhVjB1Y0dGMGFDQWhQVDBnWWx0cFhTNXdZWFJvS1NCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ2FXWWdLQ0Z6YUdGc2JHOTNSWEYxWVd3b1lWdHBYUzV3WVhKaGJXVjBaWEp6TENCaVcybGRMbkJoY21GdFpYUmxjbk1wS1NCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JpQWdjbVYwZFhKdUlIUnlkV1U3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmxjWFZoYkZCaGRHZ29ZVG9nVlhKc1VHRjBhRmRwZEdoUVlYSmhiWE5iWFN3Z1lqb2dWWEpzVUdGMGFGZHBkR2hRWVhKaGJYTmJYU2s2SUdKdmIyeGxZVzRnZTF4dUlDQnBaaUFvWVM1c1pXNW5kR2dnSVQwOUlHSXViR1Z1WjNSb0tTQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lHWnZjaUFvYkdWMElHa2dQU0F3T3lCcElEd2dZUzVzWlc1bmRHZzdJQ3NyYVNrZ2UxeHVJQ0FnSUdsbUlDaGhXMmxkTG5CaGRHZ2dJVDA5SUdKYmFWMHVjR0YwYUNrZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQjBjblZsTzF4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdiV0Z3UTJocGJHUnlaVzRvYzJWbmJXVnVkRG9nVlhKc1UyVm5iV1Z1ZEN3Z1ptNDZJQ2gyT2lCVmNteFRaV2R0Wlc1MExDQnJPaUJ6ZEhKcGJtY3BJRDArSUZWeWJGTmxaMjFsYm5RcE9seHVJQ0FnSUh0YmJtRnRaVG9nYzNSeWFXNW5YVG9nVlhKc1UyVm5iV1Z1ZEgwZ2UxeHVJQ0JqYjI1emRDQnVaWGREYUdsc1pISmxiam9nZTF0dVlXMWxPaUJ6ZEhKcGJtZGRPaUJWY214VFpXZHRaVzUwZlNBOUlIdDlPMXh1SUNCbWIzSkZZV05vS0hObFoyMWxiblF1WTJocGJHUnlaVzRzSUNoamFHbHNaRG9nVlhKc1UyVm5iV1Z1ZEN3Z1kyaHBiR1JQZFhSc1pYUTZJSE4wY21sdVp5a2dQVDRnZTF4dUlDQWdJR2xtSUNoamFHbHNaRTkxZEd4bGRDQTlQVDBnVUZKSlRVRlNXVjlQVlZSTVJWUXBJSHRjYmlBZ0lDQWdJRzVsZDBOb2FXeGtjbVZ1VzJOb2FXeGtUM1YwYkdWMFhTQTlJR1p1S0dOb2FXeGtMQ0JqYUdsc1pFOTFkR3hsZENrN1hHNGdJQ0FnZlZ4dUlDQjlLVHRjYmlBZ1ptOXlSV0ZqYUNoelpXZHRaVzUwTG1Ob2FXeGtjbVZ1TENBb1kyaHBiR1E2SUZWeWJGTmxaMjFsYm5Rc0lHTm9hV3hrVDNWMGJHVjBPaUJ6ZEhKcGJtY3BJRDArSUh0Y2JpQWdJQ0JwWmlBb1kyaHBiR1JQZFhSc1pYUWdJVDA5SUZCU1NVMUJVbGxmVDFWVVRFVlVLU0I3WEc0Z0lDQWdJQ0J1WlhkRGFHbHNaSEpsYmx0amFHbHNaRTkxZEd4bGRGMGdQU0JtYmloamFHbHNaQ3dnWTJocGJHUlBkWFJzWlhRcE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc0Z0lISmxkSFZ5YmlCdVpYZERhR2xzWkhKbGJqdGNibjFjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUcxaGNFTm9hV3hrY21WdVNXNTBiMEZ5Y21GNVBGUStLRnh1SUNBZ0lITmxaMjFsYm5RNklGVnliRk5sWjIxbGJuUXNJR1p1T2lBb2Rqb2dWWEpzVTJWbmJXVnVkQ3dnYXpvZ2MzUnlhVzVuS1NBOVBpQlVXMTBwT2lCVVcxMGdlMXh1SUNCc1pYUWdjbVZ6T2lCVVcxMGdQU0JiWFR0Y2JpQWdabTl5UldGamFDaHpaV2R0Wlc1MExtTm9hV3hrY21WdUxDQW9ZMmhwYkdRNklGVnliRk5sWjIxbGJuUXNJR05vYVd4a1QzVjBiR1YwT2lCemRISnBibWNwSUQwK0lIdGNiaUFnSUNCcFppQW9ZMmhwYkdSUGRYUnNaWFFnUFQwOUlGQlNTVTFCVWxsZlQxVlVURVZVS1NCN1hHNGdJQ0FnSUNCeVpYTWdQU0J5WlhNdVkyOXVZMkYwS0dadUtHTm9hV3hrTENCamFHbHNaRTkxZEd4bGRDa3BPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNGdJR1p2Y2tWaFkyZ29jMlZuYldWdWRDNWphR2xzWkhKbGJpd2dLR05vYVd4a09pQlZjbXhUWldkdFpXNTBMQ0JqYUdsc1pFOTFkR3hsZERvZ2MzUnlhVzVuS1NBOVBpQjdYRzRnSUNBZ2FXWWdLR05vYVd4a1QzVjBiR1YwSUNFOVBTQlFVa2xOUVZKWlgwOVZWRXhGVkNrZ2UxeHVJQ0FnSUNBZ2NtVnpJRDBnY21WekxtTnZibU5oZENobWJpaGphR2xzWkN3Z1kyaHBiR1JQZFhSc1pYUXBLVHRjYmlBZ0lDQjlYRzRnSUgwcE8xeHVJQ0J5WlhSMWNtNGdjbVZ6TzF4dWZWeHVJbDE5XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQGFuZ3VsYXIvcm91dGVyL3VybF90cmVlLmpzXG4gKiogbW9kdWxlIGlkID0gNDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XG52YXIgdXJsX3RyZWVfMSA9IHJlcXVpcmUoJy4vdXJsX3RyZWUnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWxzL2NvbGxlY3Rpb24nKTtcbnZhciBVcmxTZXJpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxTZXJpYWxpemVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gVXJsU2VyaWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlVybFNlcmlhbGl6ZXIgPSBVcmxTZXJpYWxpemVyO1xudmFyIERlZmF1bHRVcmxTZXJpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0VXJsU2VyaWFsaXplcigpIHtcbiAgICB9XG4gICAgRGVmYXVsdFVybFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgcCA9IG5ldyBVcmxQYXJzZXIodXJsKTtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFRyZWUocC5wYXJzZVJvb3RTZWdtZW50KCksIHAucGFyc2VRdWVyeVBhcmFtcygpLCBwLnBhcnNlRnJhZ21lbnQoKSk7XG4gICAgfTtcbiAgICBEZWZhdWx0VXJsU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBcIi9cIiArIHNlcmlhbGl6ZVNlZ21lbnQodHJlZS5yb290LCB0cnVlKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc2VyaWFsaXplUXVlcnlQYXJhbXModHJlZS5xdWVyeVBhcmFtcyk7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IHRyZWUuZnJhZ21lbnQgIT09IG51bGwgPyBcIiNcIiArIHRyZWUuZnJhZ21lbnQgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBzZWdtZW50ICsgcXVlcnkgKyBmcmFnbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0VXJsU2VyaWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLkRlZmF1bHRVcmxTZXJpYWxpemVyID0gRGVmYXVsdFVybFNlcmlhbGl6ZXI7XG5mdW5jdGlvbiBzZXJpYWxpemVQYXRocyhzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gc2VyaWFsaXplUGF0aChwKTsgfSkuam9pbignLycpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVQYXRocyA9IHNlcmlhbGl6ZVBhdGhzO1xuZnVuY3Rpb24gc2VyaWFsaXplU2VnbWVudChzZWdtZW50LCByb290KSB7XG4gICAgaWYgKHNlZ21lbnQuY2hpbGRyZW5bc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVRdICYmIHJvb3QpIHtcbiAgICAgICAgdmFyIHByaW1hcnkgPSBzZXJpYWxpemVTZWdtZW50KHNlZ21lbnQuY2hpbGRyZW5bc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVRdLCBmYWxzZSk7XG4gICAgICAgIHZhciBjaGlsZHJlbl8xID0gW107XG4gICAgICAgIGNvbGxlY3Rpb25fMS5mb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbl8xLnB1c2goayArIFwiOlwiICsgc2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoaWxkcmVuXzEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1hcnkgKyBcIihcIiArIGNoaWxkcmVuXzEuam9pbignLy8nKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcmltYXJ5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlZ21lbnQuY2hpbGRyZW5bc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVRdICYmICFyb290KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbl8yID0gW3NlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudC5jaGlsZHJlbltzaGFyZWRfMS5QUklNQVJZX09VVExFVF0sIGZhbHNlKV07XG4gICAgICAgIGNvbGxlY3Rpb25fMS5mb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbl8yLnB1c2goayArIFwiOlwiICsgc2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVBhdGhzKHNlZ21lbnQpICsgXCIvKFwiICsgY2hpbGRyZW5fMi5qb2luKCcvLycpICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplUGF0aHMoc2VnbWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplQ2hpbGRyZW4oc2VnbWVudCkge1xuICAgIGlmIChzZWdtZW50LmNoaWxkcmVuW3NoYXJlZF8xLlBSSU1BUllfT1VUTEVUXSkge1xuICAgICAgICB2YXIgcHJpbWFyeSA9IHNlcmlhbGl6ZVBhdGhzKHNlZ21lbnQuY2hpbGRyZW5bc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVRdKTtcbiAgICAgICAgdmFyIHNlY29uZGFyeV8xID0gW107XG4gICAgICAgIGNvbGxlY3Rpb25fMS5mb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlfMS5wdXNoKGsgKyBcIjpcIiArIHNlcmlhbGl6ZVBhdGhzKHYpICsgc2VyaWFsaXplQ2hpbGRyZW4odikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlY29uZGFyeVN0ciA9IHNlY29uZGFyeV8xLmxlbmd0aCA+IDAgPyBcIihcIiArIHNlY29uZGFyeV8xLmpvaW4oJy8vJykgKyBcIilcIiA6ICcnO1xuICAgICAgICB2YXIgcHJpbWFyeUNoaWxkcmVuID0gc2VyaWFsaXplQ2hpbGRyZW4oc2VnbWVudC5jaGlsZHJlbltzaGFyZWRfMS5QUklNQVJZX09VVExFVF0pO1xuICAgICAgICB2YXIgcHJpbWFyeUNoaWxkcmVuU3RyID0gcHJpbWFyeUNoaWxkcmVuID8gXCIvXCIgKyBwcmltYXJ5Q2hpbGRyZW4gOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBwcmltYXJ5ICsgc2Vjb25kYXJ5U3RyICsgcHJpbWFyeUNoaWxkcmVuU3RyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGgocGF0aCkge1xuICAgIHJldHVybiBcIlwiICsgcGF0aC5wYXRoICsgc2VyaWFsaXplUGFyYW1zKHBhdGgucGFyYW1ldGVycyk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZVBhdGggPSBzZXJpYWxpemVQYXRoO1xuZnVuY3Rpb24gc2VyaWFsaXplUGFyYW1zKHBhcmFtcykge1xuICAgIHJldHVybiBwYWlycyhwYXJhbXMpLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gKFwiO1wiICsgcC5maXJzdCArIFwiPVwiICsgcC5zZWNvbmQpOyB9KS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHBhcmFtcykge1xuICAgIHZhciBzdHJzID0gcGFpcnMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIChwLmZpcnN0ICsgXCI9XCIgKyBwLnNlY29uZCk7IH0pO1xuICAgIHJldHVybiBzdHJzLmxlbmd0aCA+IDAgPyBcIj9cIiArIHN0cnMuam9pbihcIiZcIikgOiAnJztcbn1cbnZhciBQYWlyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWlyKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgICB0aGlzLnNlY29uZCA9IHNlY29uZDtcbiAgICB9XG4gICAgcmV0dXJuIFBhaXI7XG59KCkpO1xuZnVuY3Rpb24gcGFpcnMob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKG5ldyBQYWlyKHByb3AsIG9ialtwcm9wXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG52YXIgU0VHTUVOVF9SRSA9IC9eW15cXC9cXChcXClcXD87PSYjXSsvO1xuZnVuY3Rpb24gbWF0Y2hQYXRoV2l0aFBhcmFtcyhzdHIpIHtcbiAgICBTRUdNRU5UX1JFLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoID0gU0VHTUVOVF9SRS5leGVjKHN0cik7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbn1cbnZhciBRVUVSWV9QQVJBTV9SRSA9IC9eW149XFw/JiNdKy87XG5mdW5jdGlvbiBtYXRjaFF1ZXJ5UGFyYW1zKHN0cikge1xuICAgIFFVRVJZX1BBUkFNX1JFLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoID0gU0VHTUVOVF9SRS5leGVjKHN0cik7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbn1cbnZhciBRVUVSWV9QQVJBTV9WQUxVRV9SRSA9IC9eW15cXD8mI10rLztcbmZ1bmN0aW9uIG1hdGNoVXJsUXVlcnlQYXJhbVZhbHVlKHN0cikge1xuICAgIFFVRVJZX1BBUkFNX1ZBTFVFX1JFLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoID0gUVVFUllfUEFSQU1fVkFMVUVfUkUuZXhlYyhzdHIpO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG59XG52YXIgVXJsUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxQYXJzZXIocmVtYWluaW5nKSB7XG4gICAgICAgIHRoaXMucmVtYWluaW5nID0gcmVtYWluaW5nO1xuICAgIH1cbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBlZWtTdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gdGhpcy5yZW1haW5pbmcuc3RhcnRzV2l0aChzdHIpOyB9O1xuICAgIFVybFBhcnNlci5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbWFpbmluZy5zdGFydHNXaXRoKHN0cikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHN0ciArIFwiXFxcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHJpbmcoc3RyLmxlbmd0aCk7XG4gICAgfTtcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUm9vdFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbWFpbmluZyA9PT0gJycgfHwgdGhpcy5yZW1haW5pbmcgPT09ICcvJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFNlZ21lbnQoW10sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KFtdLCB0aGlzLnBhcnNlU2VnbWVudENoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlU2VnbWVudENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aHMgPSBbdGhpcy5wYXJzZVBhdGhXaXRoUGFyYW1zKCldO1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLycpICYmICF0aGlzLnBlZWtTdGFydHNXaXRoKCcvLycpICYmICF0aGlzLnBlZWtTdGFydHNXaXRoKCcvKCcpKSB7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcbiAgICAgICAgICAgIHBhdGhzLnB1c2godGhpcy5wYXJzZVBhdGhXaXRoUGFyYW1zKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHt9O1xuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLygnKSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCcvJyk7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMucGFyc2VQYXJlbnModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlUGFyZW5zKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNbc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVRdID0gbmV3IHVybF90cmVlXzEuVXJsU2VnbWVudChwYXRocywgY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdGhXaXRoUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IG1hdGNoUGF0aFdpdGhQYXJhbXModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICB0aGlzLmNhcHR1cmUocGF0aCk7XG4gICAgICAgIHZhciBtYXRyaXhQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJzsnKSkge1xuICAgICAgICAgICAgbWF0cml4UGFyYW1zID0gdGhpcy5wYXJzZU1hdHJpeFBhcmFtcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxQYXRoV2l0aFBhcmFtcyhwYXRoLCBtYXRyaXhQYXJhbXMpO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCc/JykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnPycpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZVF1ZXJ5UGFyYW0ocGFyYW1zKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnJlbWFpbmluZy5sZW5ndGggPiAwICYmIHRoaXMucGVla1N0YXJ0c1dpdGgoJyYnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnJicpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VRdWVyeVBhcmFtKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlTWF0cml4UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgIHdoaWxlICh0aGlzLnJlbWFpbmluZy5sZW5ndGggPiAwICYmIHRoaXMucGVla1N0YXJ0c1dpdGgoJzsnKSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCc7Jyk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlUGFyYW0ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIga2V5ID0gbWF0Y2hQYXRoV2l0aFBhcmFtcyh0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYXB0dXJlKGtleSk7XG4gICAgICAgIHZhciB2YWx1ZSA9ICd0cnVlJztcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJz0nKSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKCc9Jyk7XG4gICAgICAgICAgICB2YXIgdmFsdWVNYXRjaCA9IG1hdGNoUGF0aFdpdGhQYXJhbXModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlTWF0Y2g7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVF1ZXJ5UGFyYW0gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBrZXkgPSBtYXRjaFF1ZXJ5UGFyYW1zKHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhcHR1cmUoa2V5KTtcbiAgICAgICAgdmFyIHZhbHVlID0gJ3RydWUnO1xuICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnPScpKSB7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJz0nKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZU1hdGNoID0gbWF0Y2hVcmxRdWVyeVBhcmFtVmFsdWUodGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlTWF0Y2g7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmVucyA9IGZ1bmN0aW9uIChhbGxvd1ByaW1hcnkpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0ge307XG4gICAgICAgIHRoaXMuY2FwdHVyZSgnKCcpO1xuICAgICAgICB3aGlsZSAoIXRoaXMucGVla1N0YXJ0c1dpdGgoJyknKSAmJiB0aGlzLnJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IG1hdGNoUGF0aFdpdGhQYXJhbXModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgdmFyIG91dGxldE5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgICAgIG91dGxldE5hbWUgPSBwYXRoLnN1YnN0cigwLCBwYXRoLmluZGV4T2YoJzonKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKG91dGxldE5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnOicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWxsb3dQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgb3V0bGV0TmFtZSA9IHNoYXJlZF8xLlBSSU1BUllfT1VUTEVUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wYXJzZVNlZ21lbnRDaGlsZHJlbigpO1xuICAgICAgICAgICAgc2VnbWVudHNbb3V0bGV0TmFtZV0gPSBPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVRdIDpcbiAgICAgICAgICAgICAgICBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KFtdLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnLy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhcHR1cmUoJyknKTtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFBhcnNlcjtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkWEpzWDNObGNtbGhiR2w2WlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZkWEpzWDNObGNtbGhiR2w2WlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEhWQ1FVRTJRaXhWUVVGVkxFTkJRVU1zUTBGQlFUdEJRVU40UXl4NVFrRkJjVVFzV1VGQldTeERRVUZETEVOQlFVRTdRVUZEYkVVc01rSkJRWE5DTEc5Q1FVRnZRaXhEUVVGRExFTkJRVUU3UVVGUE0wTTdTVUZCUVR0SlFWVkJMRU5CUVVNN1NVRkJSQ3h2UWtGQlF6dEJRVUZFTEVOQlFVTXNRVUZXUkN4SlFWVkRPMEZCVm5GQ0xIRkNRVUZoTEdkQ1FWVnNReXhEUVVGQk8wRkJTMFE3U1VGQlFUdEpRVmxCTEVOQlFVTTdTVUZZUXl4dlEwRkJTeXhIUVVGTUxGVkJRVTBzUjBGQlZ6dFJRVU5tTEVsQlFVMHNRMEZCUXl4SFFVRkhMRWxCUVVrc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFGQlF6ZENMRTFCUVUwc1EwRkJReXhKUVVGSkxHdENRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMR0ZCUVdFc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGNFWXNRMEZCUXp0SlFVVkVMSGREUVVGVExFZEJRVlFzVlVGQlZTeEpRVUZoTzFGQlEzSkNMRWxCUVUwc1QwRkJUeXhIUVVGSExFMUJRVWtzWjBKQlFXZENMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVY3NRMEZCUXp0UlFVTjRSQ3hKUVVGTkxFdEJRVXNzUjBGQlJ5eHZRa0ZCYjBJc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZEY2tRc1NVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNTMEZCU3l4SlFVRkpMRWRCUVVjc1RVRkJTU3hKUVVGSkxFTkJRVU1zVVVGQlZTeEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVTnVSU3hOUVVGTkxFTkJRVU1zUzBGQlJ5eFBRVUZQTEVkQlFVY3NTMEZCU3l4SFFVRkhMRkZCUVZVc1EwRkJRenRKUVVONlF5eERRVUZETzBsQlEwZ3NNa0pCUVVNN1FVRkJSQ3hEUVVGRExFRkJXa1FzU1VGWlF6dEJRVnBaTERSQ1FVRnZRaXgxUWtGWmFFTXNRMEZCUVR0QlFVVkVMSGRDUVVFclFpeFBRVUZ0UWp0SlFVTm9SQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEdWQlFXVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVdoQ0xFTkJRV2RDTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03UVVGRGRFVXNRMEZCUXp0QlFVWmxMSE5DUVVGakxHbENRVVUzUWl4RFFVRkJPMEZCUlVRc01FSkJRVEJDTEU5QlFXMUNMRVZCUVVVc1NVRkJZVHRKUVVNeFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExIVkNRVUZqTEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemRETEVsQlFVMHNUMEZCVHl4SFFVRkhMR2RDUVVGblFpeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc2RVSkJRV01zUTBGQlF5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUXpGRkxFbEJRVTBzVlVGQlVTeEhRVUZoTEVWQlFVVXNRMEZCUXp0UlFVTTVRaXh2UWtGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1ZVRkJReXhEUVVGaExFVkJRVVVzUTBGQlV6dFpRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzZFVKQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM3BDTEZWQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVrc1EwRkJReXhUUVVGSkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hMUVVGTExFTkJRVWNzUTBGQlF5eERRVUZETzFsQlEzUkVMRU5CUVVNN1VVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5JTEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZFc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjRRaXhOUVVGTkxFTkJRVWtzVDBGQlR5eFRRVUZKTEZWQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVWNzUTBGQlF6dFJRVU01UXl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNTMEZCUnl4UFFVRlRMRU5CUVVNN1VVRkRkRUlzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4MVFrRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKRUxFbEJRVTBzVlVGQlVTeEhRVUZITEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4MVFrRkJZeXhEUVVGRExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTTNSU3h2UWtGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1ZVRkJReXhEUVVGaExFVkJRVVVzUTBGQlV6dFpRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzZFVKQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM3BDTEZWQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVrc1EwRkJReXhUUVVGSkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hMUVVGTExFTkJRVWNzUTBGQlF5eERRVUZETzFsQlEzUkVMRU5CUVVNN1VVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5JTEUxQlFVMHNRMEZCU1N4alFVRmpMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVXNzVlVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJSeXhEUVVGRE8wbEJReTlFTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRha01zUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZGUkN3eVFrRkJNa0lzVDBGQmJVSTdTVUZETlVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4MVFrRkJZeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkRMRWxCUVUwc1QwRkJUeXhIUVVGSExHTkJRV01zUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMSFZDUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJXcEZMRWxCUVUwc1YwRkJVeXhIUVVGaExFVkJRVVVzUTBGQlF6dFJRVU12UWl4dlFrRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNWVUZCUXl4RFFVRmhMRVZCUVVVc1EwRkJVenRaUVVOcVJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc2RVSkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwQ0xGZEJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVa3NRMEZCUXl4VFFVRkpMR05CUVdNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eHBRa0ZCYVVJc1EwRkJReXhEUVVGRExFTkJRVWNzUTBGQlF5eERRVUZETzFsQlEzSkZMRU5CUVVNN1VVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5JTEVsQlFVMHNXVUZCV1N4SFFVRkhMRmRCUVZNc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEhRVUZITEUxQlFVa3NWMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlJ5eEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVTTNSU3hKUVVGTkxHVkJRV1VzUjBGQlJ5eHBRa0ZCYVVJc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEhWQ1FVRmpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRelZGTEVsQlFVMHNhMEpCUVd0Q0xFZEJRVmNzWlVGQlpTeEhRVUZITEUxQlFVa3NaVUZCYVVJc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRGFFWXNUVUZCVFN4RFFVRkRMRXRCUVVjc1QwRkJUeXhIUVVGSExGbEJRVmtzUjBGQlJ5eHJRa0ZCYjBJc1EwRkJRenRKUVVNeFJDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlExb3NRMEZCUXp0QlFVTklMRU5CUVVNN1FVRkZSQ3gxUWtGQk9FSXNTVUZCZFVJN1NVRkRia1FzVFVGQlRTeERRVUZETEV0QlFVY3NTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhsUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUnl4RFFVRkRPMEZCUXpORUxFTkJRVU03UVVGR1pTeHhRa0ZCWVN4blFrRkZOVUlzUTBGQlFUdEJRVVZFTEhsQ1FVRjVRaXhOUVVFclFqdEpRVU4wUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkJMRU5CUVVNc1NVRkJTU3hQUVVGQkxFOUJRVWtzUTBGQlF5eERRVUZETEV0QlFVc3NVMEZCU1N4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRkxFVkJRWHBDTEVOQlFYbENMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdRVUZEY0VVc1EwRkJRenRCUVVWRUxEaENRVUU0UWl4TlFVRXJRanRKUVVNelJDeEpRVUZOTEVsQlFVa3NSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVRXNRMEZCUXl4SlFVRkpMRTlCUVVFc1EwRkJSeXhEUVVGRExFTkJRVU1zUzBGQlN5eFRRVUZKTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVVc1JVRkJlRUlzUTBGQmQwSXNRMEZCUXl4RFFVRkRPMGxCUXpsRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1IwRkJSeXhOUVVGSkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkhMRWRCUVVjc1JVRkJSU3hEUVVGRE8wRkJRM0pFTEVOQlFVTTdRVUZGUkR0SlFVTkZMR05CUVcxQ0xFdEJRVkVzUlVGQlV5eE5RVUZUTzFGQlFURkNMRlZCUVVzc1IwRkJUQ3hMUVVGTExFTkJRVWM3VVVGQlV5eFhRVUZOTEVkQlFVNHNUVUZCVFN4RFFVRkhPMGxCUVVjc1EwRkJRenRKUVVOdVJDeFhRVUZETzBGQlFVUXNRMEZCUXl4QlFVWkVMRWxCUlVNN1FVRkRSQ3hsUVVGclFpeEhRVUYxUWp0SlFVTjJReXhKUVVGTkxFZEJRVWNzUjBGQmMwSXNSVUZCUlN4RFFVRkRPMGxCUTJ4RExFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4SlFVRkpMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExHTkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMElzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJXU3hKUVVGSkxFVkJRVVVzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOcVJDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03UVVGRFlpeERRVUZETzBGQlJVUXNTVUZCVFN4VlFVRlZMRWRCUVVjc2JVSkJRVzFDTEVOQlFVTTdRVUZEZGtNc05rSkJRVFpDTEVkQlFWYzdTVUZEZEVNc1ZVRkJWU3hEUVVGRExGTkJRVk1zUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJUU3hMUVVGTExFZEJRVWNzVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRKUVVOdVF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdRVUZETDBJc1EwRkJRenRCUVVWRUxFbEJRVTBzWTBGQll5eEhRVUZITEZsQlFWa3NRMEZCUXp0QlFVTndReXd3UWtGQk1FSXNSMEZCVnp0SlFVTnVReXhqUVVGakxFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTTNRaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8wbEJRMjVETEUxQlFVMHNRMEZCUXl4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXp0QlFVTXZRaXhEUVVGRE8wRkJSVVFzU1VGQlRTeHZRa0ZCYjBJc1IwRkJSeXhYUVVGWExFTkJRVU03UVVGRGVrTXNhVU5CUVdsRExFZEJRVmM3U1VGRE1VTXNiMEpCUVc5Q0xFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTnVReXhKUVVGTkxFdEJRVXNzUjBGQlJ5eHZRa0ZCYjBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZETjBNc1RVRkJUU3hEUVVGRExFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRE8wRkJReTlDTEVOQlFVTTdRVUZGUkR0SlFVTkZMRzFDUVVGdlFpeFRRVUZwUWp0UlFVRnFRaXhqUVVGVExFZEJRVlFzVTBGQlV5eERRVUZSTzBsQlFVY3NRMEZCUXp0SlFVVjZReXhyUTBGQll5eEhRVUZrTEZWQlFXVXNSMEZCVnl4SlFVRmhMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRkwwVXNNa0pCUVU4c1IwRkJVQ3hWUVVGUkxFZEJRVmM3VVVGRGFrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhuUWtGQllTeEhRVUZITEZGQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTNoRExFTkJRVU03VVVGRFJDeEpRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVTBGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVONFJDeERRVUZETzBsQlJVUXNiME5CUVdkQ0xFZEJRV2hDTzFGQlEwVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUzBGQlN5eEZRVUZGTEVsQlFVa3NTVUZCU1N4RFFVRkRMRk5CUVZNc1MwRkJTeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkVMRTFCUVUwc1EwRkJReXhKUVVGSkxIRkNRVUZWTEVOQlFVTXNSVUZCUlN4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRMmhETEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFMUJRVTBzUTBGQlF5eEpRVUZKTEhGQ1FVRlZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eHZRa0ZCYjBJc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGVrUXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3gzUTBGQmIwSXNSMEZCY0VJN1VVRkRSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF5OUNMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRFdpeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMElzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVOd1FpeERRVUZETzFGQlJVUXNTVUZCVFN4TFFVRkxMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJSVE5ETEU5QlFVOHNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU03V1VGRE5VWXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU5zUWl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eHRRa0ZCYlVJc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGVrTXNRMEZCUXp0UlFVVkVMRWxCUVVrc1VVRkJVU3hIUVVGblF5eEZRVUZGTEVOQlFVTTdVVUZETDBNc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE9VSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU5zUWl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTndReXhEUVVGRE8xRkJSVVFzU1VGQlNTeEhRVUZITEVkQlFXZERMRVZCUVVVc1EwRkJRenRSUVVNeFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTNRaXhIUVVGSExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVOb1F5eERRVUZETzFGQlJVUXNSMEZCUnl4RFFVRkRMSFZDUVVGakxFTkJRVU1zUjBGQlJ5eEpRVUZKTEhGQ1FVRlZMRU5CUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzFGQlEzUkVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03U1VGRFlpeERRVUZETzBsQlJVUXNkVU5CUVcxQ0xFZEJRVzVDTzFGQlEwVXNTVUZCU1N4SlFVRkpMRWRCUVVjc2JVSkJRVzFDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJReTlETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGJrSXNTVUZCU1N4WlFVRlpMRWRCUVhsQ0xFVkJRVVVzUTBGQlF6dFJRVU0xUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNM1FpeFpRVUZaTEVkQlFVY3NTVUZCU1N4RFFVRkRMR2xDUVVGcFFpeEZRVUZGTEVOQlFVTTdVVUZETVVNc1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eEpRVUZKTERSQ1FVRnBRaXhEUVVGRExFbEJRVWtzUlVGQlJTeFpRVUZaTEVOQlFVTXNRMEZCUXp0SlFVTnVSQ3hEUVVGRE8wbEJSVVFzYjBOQlFXZENMRWRCUVdoQ08xRkJRMFVzU1VGQlRTeE5RVUZOTEVkQlFYbENMRVZCUVVVc1EwRkJRenRSUVVONFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTNRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTJ4Q0xFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkROMElzVDBGQlR5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRE8yZENRVU0zUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzJkQ1FVTnNRaXhKUVVGSkxFTkJRVU1zWlVGQlpTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMWxCUXk5Q0xFTkJRVU03VVVGRFNDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVOb1FpeERRVUZETzBsQlJVUXNhVU5CUVdFc1IwRkJZanRSUVVORkxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6ZENMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVF5eERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlEyUXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3h4UTBGQmFVSXNSMEZCYWtJN1VVRkRSU3hKUVVGTkxFMUJRVTBzUjBGQmVVSXNSVUZCUlN4RFFVRkRPMUZCUTNoRExFOUJRVThzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJRenRaUVVNM1JDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRMnhDTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRE1VSXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGFFSXNRMEZCUXp0SlFVVkVMRGhDUVVGVkxFZEJRVllzVlVGQlZ5eE5RVUUwUWp0UlFVTnlReXhKUVVGTkxFZEJRVWNzUjBGQlJ5eHRRa0ZCYlVJc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdVVUZEYUVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTFRc1RVRkJUU3hEUVVGRE8xRkJRMVFzUTBGQlF6dFJRVU5FTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGJFSXNTVUZCU1N4TFFVRkxMRWRCUVZFc1RVRkJUU3hEUVVGRE8xRkJRM2hDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRiRUlzU1VGQlRTeFZRVUZWTEVkQlFVY3NiVUpCUVcxQ0xFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRPMWxCUTNaRUxFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMllzUzBGQlN5eEhRVUZITEZWQlFWVXNRMEZCUXp0blFrRkRia0lzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRaUVVOMFFpeERRVUZETzFGQlEwZ3NRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eExRVUZMTEVOQlFVTTdTVUZEZEVJc1EwRkJRenRKUVVWRUxHMURRVUZsTEVkQlFXWXNWVUZCWjBJc1RVRkJORUk3VVVGRE1VTXNTVUZCVFN4SFFVRkhMRWRCUVVjc1owSkJRV2RDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJRemRETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5VTEUxQlFVMHNRMEZCUXp0UlFVTlVMRU5CUVVNN1VVRkRSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJ4Q0xFbEJRVWtzUzBGQlN5eEhRVUZSTEUxQlFVMHNRMEZCUXp0UlFVTjRRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0zUWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlEyeENMRWxCUVVrc1ZVRkJWU3hIUVVGSExIVkNRVUYxUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF6dFpRVU42UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTm1MRXRCUVVzc1IwRkJSeXhWUVVGVkxFTkJRVU03WjBKQlEyNUNMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdXVUZEZEVJc1EwRkJRenRSUVVOSUxFTkJRVU03VVVGRFJDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRE8wbEJRM1JDTEVOQlFVTTdTVUZGUkN3clFrRkJWeXhIUVVGWUxGVkJRVmtzV1VGQmNVSTdVVUZETDBJc1NVRkJUU3hSUVVGUkxFZEJRV2RETEVWQlFVVXNRMEZCUXp0UlFVTnFSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUld4Q0xFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRE8xbEJRemxFTEVsQlFVa3NTVUZCU1N4SFFVRkhMRzFDUVVGdFFpeERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRaUVVNdlF5eEpRVUZKTEZWQlFWVXNVMEZCVVN4RFFVRkRPMWxCUTNaQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNelFpeFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU12UXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzJkQ1FVTjZRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTNCQ0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVJc1ZVRkJWU3hIUVVGSExIVkNRVUZqTEVOQlFVTTdXVUZET1VJc1EwRkJRenRaUVVWRUxFbEJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUlVGQlJTeERRVUZETzFsQlF6ZERMRkZCUVZFc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVkQlFVY3NVVUZCVVN4RFFVRkRMSFZDUVVGakxFTkJRVU03WjBKQlEzaENMRWxCUVVrc2NVSkJRVlVzUTBGQlF5eEZRVUZGTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNN1dVRkZla1lzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpsQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRja0lzUTBGQlF6dFJRVU5JTEVOQlFVTTdVVUZEUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFGQlJXeENMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0SlFVTklMR2RDUVVGRE8wRkJRVVFzUTBGQlF5eEJRVE5LUkN4SlFUSktReUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0I3VUZKSlRVRlNXVjlQVlZSTVJWUjlJR1p5YjIwZ0p5NHZjMmhoY21Wa0p6dGNibWx0Y0c5eWRDQjdWWEpzVUdGMGFGZHBkR2hRWVhKaGJYTXNJRlZ5YkZObFoyMWxiblFzSUZWeWJGUnlaV1Y5SUdaeWIyMGdKeTR2ZFhKc1gzUnlaV1VuTzF4dWFXMXdiM0owSUh0bWIzSkZZV05vZlNCbWNtOXRJQ2N1TDNWMGFXeHpMMk52Ykd4bFkzUnBiMjRuTzF4dVhHNWNibHh1THlvcVhHNGdLaUJFWldacGJtVnpJR0VnZDJGNUlIUnZJSE5sY21saGJHbDZaUzlrWlhObGNtbGhiR2w2WlNCaElIVnliQ0IwY21WbExseHVJQ292WEc1bGVIQnZjblFnWVdKemRISmhZM1FnWTJ4aGMzTWdWWEpzVTJWeWFXRnNhWHBsY2lCN1hHNGdJQzhxS2x4dUlDQWdLaUJRWVhKelpTQmhJSFZ5YkNCcGJuUnZJR0VnZTBCTWFXNXJJRlZ5YkZSeVpXVjlYRzRnSUNBcUwxeHVJQ0JoWW5OMGNtRmpkQ0J3WVhKelpTaDFjbXc2SUhOMGNtbHVaeWs2SUZWeWJGUnlaV1U3WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRU52Ym5abGNuUnpJR0VnZTBCTWFXNXJJRlZ5YkZSeVpXVjlJR2x1ZEc4Z1lTQjFjbXhjYmlBZ0lDb3ZYRzRnSUdGaWMzUnlZV04wSUhObGNtbGhiR2w2WlNoMGNtVmxPaUJWY214VWNtVmxLVG9nYzNSeWFXNW5PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFRWdaR1ZtWVhWc2RDQnBiWEJzWlcxbGJuUmhkR2x2YmlCdlppQjBhR1VnYzJWeWFXRnNhWHBoZEdsdmJpNWNiaUFxTDF4dVpYaHdiM0owSUdOc1lYTnpJRVJsWm1GMWJIUlZjbXhUWlhKcFlXeHBlbVZ5SUdsdGNHeGxiV1Z1ZEhNZ1ZYSnNVMlZ5YVdGc2FYcGxjaUI3WEc0Z0lIQmhjbk5sS0hWeWJEb2djM1J5YVc1bktUb2dWWEpzVkhKbFpTQjdYRzRnSUNBZ1kyOXVjM1FnY0NBOUlHNWxkeUJWY214UVlYSnpaWElvZFhKc0tUdGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lGVnliRlJ5WldVb2NDNXdZWEp6WlZKdmIzUlRaV2R0Wlc1MEtDa3NJSEF1Y0dGeWMyVlJkV1Z5ZVZCaGNtRnRjeWdwTENCd0xuQmhjbk5sUm5KaFoyMWxiblFvS1NrN1hHNGdJSDFjYmx4dUlDQnpaWEpwWVd4cGVtVW9kSEpsWlRvZ1ZYSnNWSEpsWlNrNklITjBjbWx1WnlCN1hHNGdJQ0FnWTI5dWMzUWdjMlZuYldWdWRDQTlJR0F2Skh0elpYSnBZV3hwZW1WVFpXZHRaVzUwS0hSeVpXVXVjbTl2ZEN3Z2RISjFaU2w5WUR0Y2JpQWdJQ0JqYjI1emRDQnhkV1Z5ZVNBOUlITmxjbWxoYkdsNlpWRjFaWEo1VUdGeVlXMXpLSFJ5WldVdWNYVmxjbmxRWVhKaGJYTXBPMXh1SUNBZ0lHTnZibk4wSUdaeVlXZHRaVzUwSUQwZ2RISmxaUzVtY21GbmJXVnVkQ0FoUFQwZ2JuVnNiQ0EvSUdBakpIdDBjbVZsTG1aeVlXZHRaVzUwZldBZ09pQW5KenRjYmlBZ0lDQnlaWFIxY200Z1lDUjdjMlZuYldWdWRIMGtlM0YxWlhKNWZTUjdabkpoWjIxbGJuUjlZRHRjYmlBZ2ZWeHVmVnh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnYzJWeWFXRnNhWHBsVUdGMGFITW9jMlZuYldWdWREb2dWWEpzVTJWbmJXVnVkQ2s2SUhOMGNtbHVaeUI3WEc0Z0lISmxkSFZ5YmlCelpXZHRaVzUwTG5CaGRHaHpWMmwwYUZCaGNtRnRjeTV0WVhBb2NDQTlQaUJ6WlhKcFlXeHBlbVZRWVhSb0tIQXBLUzVxYjJsdUtDY3ZKeWs3WEc1OVhHNWNibVoxYm1OMGFXOXVJSE5sY21saGJHbDZaVk5sWjIxbGJuUW9jMlZuYldWdWREb2dWWEpzVTJWbmJXVnVkQ3dnY205dmREb2dZbTl2YkdWaGJpazZJSE4wY21sdVp5QjdYRzRnSUdsbUlDaHpaV2R0Wlc1MExtTm9hV3hrY21WdVcxQlNTVTFCVWxsZlQxVlVURVZVWFNBbUppQnliMjkwS1NCN1hHNGdJQ0FnWTI5dWMzUWdjSEpwYldGeWVTQTlJSE5sY21saGJHbDZaVk5sWjIxbGJuUW9jMlZuYldWdWRDNWphR2xzWkhKbGJsdFFVa2xOUVZKWlgwOVZWRXhGVkYwc0lHWmhiSE5sS1R0Y2JpQWdJQ0JqYjI1emRDQmphR2xzWkhKbGJqb2djM1J5YVc1blcxMGdQU0JiWFR0Y2JpQWdJQ0JtYjNKRllXTm9LSE5sWjIxbGJuUXVZMmhwYkdSeVpXNHNJQ2gyT2lCVmNteFRaV2R0Wlc1MExDQnJPaUJ6ZEhKcGJtY3BJRDArSUh0Y2JpQWdJQ0FnSUdsbUlDaHJJQ0U5UFNCUVVrbE5RVkpaWDA5VlZFeEZWQ2tnZTF4dUlDQWdJQ0FnSUNCamFHbHNaSEpsYmk1d2RYTm9LR0FrZTJ0OU9pUjdjMlZ5YVdGc2FYcGxVMlZuYldWdWRDaDJMQ0JtWVd4elpTbDlZQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc0Z0lDQWdhV1lnS0dOb2FXeGtjbVZ1TG14bGJtZDBhQ0ErSURBcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCZ0pIdHdjbWx0WVhKNWZTZ2tlMk5vYVd4a2NtVnVMbXB2YVc0b0p5OHZKeWw5S1dBN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmdKSHR3Y21sdFlYSjVmV0E3WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnYVdZZ0tITmxaMjFsYm5RdVkyaHBiR1J5Wlc1YlVGSkpUVUZTV1Y5UFZWUk1SVlJkSUNZbUlDRnliMjkwS1NCN1hHNGdJQ0FnWTI5dWMzUWdZMmhwYkdSeVpXNGdQU0JiYzJWeWFXRnNhWHBsVTJWbmJXVnVkQ2h6WldkdFpXNTBMbU5vYVd4a2NtVnVXMUJTU1UxQlVsbGZUMVZVVEVWVVhTd2dabUZzYzJVcFhUdGNiaUFnSUNCbWIzSkZZV05vS0hObFoyMWxiblF1WTJocGJHUnlaVzRzSUNoMk9pQlZjbXhUWldkdFpXNTBMQ0JyT2lCemRISnBibWNwSUQwK0lIdGNiaUFnSUNBZ0lHbG1JQ2hySUNFOVBTQlFVa2xOUVZKWlgwOVZWRXhGVkNrZ2UxeHVJQ0FnSUNBZ0lDQmphR2xzWkhKbGJpNXdkWE5vS0dBa2UydDlPaVI3YzJWeWFXRnNhWHBsVTJWbmJXVnVkQ2gyTENCbVlXeHpaU2w5WUNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNrN1hHNGdJQ0FnY21WMGRYSnVJR0FrZTNObGNtbGhiR2w2WlZCaGRHaHpLSE5sWjIxbGJuUXBmUzhvSkh0amFHbHNaSEpsYmk1cWIybHVLQ2N2THljcGZTbGdPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQnpaWEpwWVd4cGVtVlFZWFJvY3loelpXZHRaVzUwS1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnpaWEpwWVd4cGVtVkRhR2xzWkhKbGJpaHpaV2R0Wlc1ME9pQlZjbXhUWldkdFpXNTBLU0I3WEc0Z0lHbG1JQ2h6WldkdFpXNTBMbU5vYVd4a2NtVnVXMUJTU1UxQlVsbGZUMVZVVEVWVVhTa2dlMXh1SUNBZ0lHTnZibk4wSUhCeWFXMWhjbmtnUFNCelpYSnBZV3hwZW1WUVlYUm9jeWh6WldkdFpXNTBMbU5vYVd4a2NtVnVXMUJTU1UxQlVsbGZUMVZVVEVWVVhTazdYRzVjYmlBZ0lDQmpiMjV6ZENCelpXTnZibVJoY25rNklITjBjbWx1WjF0ZElEMGdXMTA3WEc0Z0lDQWdabTl5UldGamFDaHpaV2R0Wlc1MExtTm9hV3hrY21WdUxDQW9kam9nVlhKc1UyVm5iV1Z1ZEN3Z2F6b2djM1J5YVc1bktTQTlQaUI3WEc0Z0lDQWdJQ0JwWmlBb2F5QWhQVDBnVUZKSlRVRlNXVjlQVlZSTVJWUXBJSHRjYmlBZ0lDQWdJQ0FnYzJWamIyNWtZWEo1TG5CMWMyZ29ZQ1I3YTMwNkpIdHpaWEpwWVd4cGVtVlFZWFJvY3loMktYMGtlM05sY21saGJHbDZaVU5vYVd4a2NtVnVLSFlwZldBcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwcE8xeHVJQ0FnSUdOdmJuTjBJSE5sWTI5dVpHRnllVk4wY2lBOUlITmxZMjl1WkdGeWVTNXNaVzVuZEdnZ1BpQXdJRDhnWUNna2UzTmxZMjl1WkdGeWVTNXFiMmx1S0Njdkx5Y3BmU2xnSURvZ0p5YzdYRzRnSUNBZ1kyOXVjM1FnY0hKcGJXRnllVU5vYVd4a2NtVnVJRDBnYzJWeWFXRnNhWHBsUTJocGJHUnlaVzRvYzJWbmJXVnVkQzVqYUdsc1pISmxibHRRVWtsTlFWSlpYMDlWVkV4RlZGMHBPMXh1SUNBZ0lHTnZibk4wSUhCeWFXMWhjbmxEYUdsc1pISmxibE4wY2pvZ2MzUnlhVzVuSUQwZ2NISnBiV0Z5ZVVOb2FXeGtjbVZ1SUQ4Z1lDOGtlM0J5YVcxaGNubERhR2xzWkhKbGJuMWdJRG9nSnljN1hHNGdJQ0FnY21WMGRYSnVJR0FrZTNCeWFXMWhjbmw5Skh0elpXTnZibVJoY25sVGRISjlKSHR3Y21sdFlYSjVRMmhwYkdSeVpXNVRkSEo5WUR0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCeVpYUjFjbTRnSnljN1hHNGdJSDFjYm4xY2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlITmxjbWxoYkdsNlpWQmhkR2dvY0dGMGFEb2dWWEpzVUdGMGFGZHBkR2hRWVhKaGJYTXBPaUJ6ZEhKcGJtY2dlMXh1SUNCeVpYUjFjbTRnWUNSN2NHRjBhQzV3WVhSb2ZTUjdjMlZ5YVdGc2FYcGxVR0Z5WVcxektIQmhkR2d1Y0dGeVlXMWxkR1Z5Y3lsOVlEdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2MyVnlhV0ZzYVhwbFVHRnlZVzF6S0hCaGNtRnRjem9nZTF0clpYazZJSE4wY21sdVoxMDZJSE4wY21sdVozMHBPaUJ6ZEhKcGJtY2dlMXh1SUNCeVpYUjFjbTRnY0dGcGNuTW9jR0Z5WVcxektTNXRZWEFvY0NBOVBpQmdPeVI3Y0M1bWFYSnpkSDA5Skh0d0xuTmxZMjl1WkgxZ0tTNXFiMmx1S0NjbktUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2MyVnlhV0ZzYVhwbFVYVmxjbmxRWVhKaGJYTW9jR0Z5WVcxek9pQjdXMnRsZVRvZ2MzUnlhVzVuWFRvZ2MzUnlhVzVuZlNrNklITjBjbWx1WnlCN1hHNGdJR052Ym5OMElITjBjbk1nUFNCd1lXbHljeWh3WVhKaGJYTXBMbTFoY0Nod0lEMCtJR0FrZTNBdVptbHljM1I5UFNSN2NDNXpaV052Ym1SOVlDazdYRzRnSUhKbGRIVnliaUJ6ZEhKekxteGxibWQwYUNBK0lEQWdQeUJnUHlSN2MzUnljeTVxYjJsdUtGd2lKbHdpS1gxZ0lEb2dKeWM3WEc1OVhHNWNibU5zWVhOeklGQmhhWEk4UVN3Z1FqNGdlMXh1SUNCamIyNXpkSEoxWTNSdmNpaHdkV0pzYVdNZ1ptbHljM1E2SUVFc0lIQjFZbXhwWXlCelpXTnZibVE2SUVJcElIdDlYRzU5WEc1bWRXNWpkR2x2YmlCd1lXbHljenhVUGlodlltbzZJSHRiYTJWNU9pQnpkSEpwYm1kZE9pQlVmU2s2SUZCaGFYSThjM1J5YVc1bkxDQlVQbHRkSUh0Y2JpQWdZMjl1YzNRZ2NtVnpPaUJRWVdseVBITjBjbWx1Wnl3Z1ZENWJYU0E5SUZ0ZE8xeHVJQ0JtYjNJZ0tHeGxkQ0J3Y205d0lHbHVJRzlpYWlrZ2UxeHVJQ0FnSUdsbUlDaHZZbW91YUdGelQzZHVVSEp2Y0dWeWRIa29jSEp2Y0NrcElIdGNiaUFnSUNBZ0lISmxjeTV3ZFhOb0tHNWxkeUJRWVdseVBITjBjbWx1Wnl3Z1ZENG9jSEp2Y0N3Z2IySnFXM0J5YjNCZEtTazdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYTTdYRzU5WEc1Y2JtTnZibk4wSUZORlIwMUZUbFJmVWtVZ1BTQXZYbHRlWEZ3dlhGd29YRndwWEZ3L096MG1JMTByTHp0Y2JtWjFibU4wYVc5dUlHMWhkR05vVUdGMGFGZHBkR2hRWVhKaGJYTW9jM1J5T2lCemRISnBibWNwT2lCemRISnBibWNnZTF4dUlDQlRSVWROUlU1VVgxSkZMbXhoYzNSSmJtUmxlQ0E5SURBN1hHNGdJR052Ym5OMElHMWhkR05vSUQwZ1UwVkhUVVZPVkY5U1JTNWxlR1ZqS0hOMGNpazdYRzRnSUhKbGRIVnliaUJ0WVhSamFDQS9JRzFoZEdOb1d6QmRJRG9nSnljN1hHNTlYRzVjYm1OdmJuTjBJRkZWUlZKWlgxQkJVa0ZOWDFKRklEMGdMMTViWGoxY1hEOG1JMTByTHp0Y2JtWjFibU4wYVc5dUlHMWhkR05vVVhWbGNubFFZWEpoYlhNb2MzUnlPaUJ6ZEhKcGJtY3BPaUJ6ZEhKcGJtY2dlMXh1SUNCUlZVVlNXVjlRUVZKQlRWOVNSUzVzWVhOMFNXNWtaWGdnUFNBd08xeHVJQ0JqYjI1emRDQnRZWFJqYUNBOUlGTkZSMDFGVGxSZlVrVXVaWGhsWXloemRISXBPMXh1SUNCeVpYUjFjbTRnYldGMFkyZ2dQeUJ0WVhSamFGc3dYU0E2SUNjbk8xeHVmVnh1WEc1amIyNXpkQ0JSVlVWU1dWOVFRVkpCVFY5V1FVeFZSVjlTUlNBOUlDOWVXMTVjWEQ4bUkxMHJMenRjYm1aMWJtTjBhVzl1SUcxaGRHTm9WWEpzVVhWbGNubFFZWEpoYlZaaGJIVmxLSE4wY2pvZ2MzUnlhVzVuS1RvZ2MzUnlhVzVuSUh0Y2JpQWdVVlZGVWxsZlVFRlNRVTFmVmtGTVZVVmZVa1V1YkdGemRFbHVaR1Y0SUQwZ01EdGNiaUFnWTI5dWMzUWdiV0YwWTJnZ1BTQlJWVVZTV1Y5UVFWSkJUVjlXUVV4VlJWOVNSUzVsZUdWaktITjBjaWs3WEc0Z0lISmxkSFZ5YmlCdFlYUmphQ0EvSUcxaGRHTm9XekJkSURvZ0p5YzdYRzU5WEc1Y2JtTnNZWE56SUZWeWJGQmhjbk5sY2lCN1hHNGdJR052Ym5OMGNuVmpkRzl5S0hCeWFYWmhkR1VnY21WdFlXbHVhVzVuT2lCemRISnBibWNwSUh0OVhHNWNiaUFnY0dWbGExTjBZWEowYzFkcGRHZ29jM1J5T2lCemRISnBibWNwT2lCaWIyOXNaV0Z1SUhzZ2NtVjBkWEp1SUhSb2FYTXVjbVZ0WVdsdWFXNW5Mbk4wWVhKMGMxZHBkR2dvYzNSeUtUc2dmVnh1WEc0Z0lHTmhjSFIxY21Vb2MzUnlPaUJ6ZEhKcGJtY3BPaUIyYjJsa0lIdGNiaUFnSUNCcFppQW9JWFJvYVhNdWNtVnRZV2x1YVc1bkxuTjBZWEowYzFkcGRHZ29jM1J5S1NrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0dCRmVIQmxZM1JsWkNCY0lpUjdjM1J5ZlZ3aUxtQXBPMXh1SUNBZ0lIMWNiaUFnSUNCMGFHbHpMbkpsYldGcGJtbHVaeUE5SUhSb2FYTXVjbVZ0WVdsdWFXNW5Mbk4xWW5OMGNtbHVaeWh6ZEhJdWJHVnVaM1JvS1R0Y2JpQWdmVnh1WEc0Z0lIQmhjbk5sVW05dmRGTmxaMjFsYm5Rb0tUb2dWWEpzVTJWbmJXVnVkQ0I3WEc0Z0lDQWdhV1lnS0hSb2FYTXVjbVZ0WVdsdWFXNW5JRDA5UFNBbkp5QjhmQ0IwYUdsekxuSmxiV0ZwYm1sdVp5QTlQVDBnSnk4bktTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2JtVjNJRlZ5YkZObFoyMWxiblFvVzEwc0lIdDlLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUc1bGR5QlZjbXhUWldkdFpXNTBLRnRkTENCMGFHbHpMbkJoY25ObFUyVm5iV1Z1ZEVOb2FXeGtjbVZ1S0NrcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIQmhjbk5sVTJWbmJXVnVkRU5vYVd4a2NtVnVLQ2s2SUh0YmEyVjVPaUJ6ZEhKcGJtZGRPaUJWY214VFpXZHRaVzUwZlNCN1hHNGdJQ0FnYVdZZ0tIUm9hWE11Y21WdFlXbHVhVzVuTG14bGJtZDBhQ0E5UFNBd0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2UzMDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLSFJvYVhNdWNHVmxhMU4wWVhKMGMxZHBkR2dvSnk4bktTa2dlMXh1SUNBZ0lDQWdkR2hwY3k1allYQjBkWEpsS0Njdkp5azdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1kyOXVjM1FnY0dGMGFITWdQU0JiZEdocGN5NXdZWEp6WlZCaGRHaFhhWFJvVUdGeVlXMXpLQ2xkTzF4dVhHNGdJQ0FnZDJocGJHVWdLSFJvYVhNdWNHVmxhMU4wWVhKMGMxZHBkR2dvSnk4bktTQW1KaUFoZEdocGN5NXdaV1ZyVTNSaGNuUnpWMmwwYUNnbkx5OG5LU0FtSmlBaGRHaHBjeTV3WldWclUzUmhjblJ6VjJsMGFDZ25MeWduS1NrZ2UxeHVJQ0FnSUNBZ2RHaHBjeTVqWVhCMGRYSmxLQ2N2SnlrN1hHNGdJQ0FnSUNCd1lYUm9jeTV3ZFhOb0tIUm9hWE11Y0dGeWMyVlFZWFJvVjJsMGFGQmhjbUZ0Y3lncEtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCc1pYUWdZMmhwYkdSeVpXNDZJSHRiYTJWNU9pQnpkSEpwYm1kZE9pQlZjbXhUWldkdFpXNTBmU0E5SUh0OU8xeHVJQ0FnSUdsbUlDaDBhR2x6TG5CbFpXdFRkR0Z5ZEhOWGFYUm9LQ2N2S0NjcEtTQjdYRzRnSUNBZ0lDQjBhR2x6TG1OaGNIUjFjbVVvSnk4bktUdGNiaUFnSUNBZ0lHTm9hV3hrY21WdUlEMGdkR2hwY3k1d1lYSnpaVkJoY21WdWN5aDBjblZsS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzWlhRZ2NtVnpPaUI3VzJ0bGVUb2djM1J5YVc1blhUb2dWWEpzVTJWbmJXVnVkSDBnUFNCN2ZUdGNiaUFnSUNCcFppQW9kR2hwY3k1d1pXVnJVM1JoY25SelYybDBhQ2duS0NjcEtTQjdYRzRnSUNBZ0lDQnlaWE1nUFNCMGFHbHpMbkJoY25ObFVHRnlaVzV6S0daaGJITmxLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWE5iVUZKSlRVRlNXVjlQVlZSTVJWUmRJRDBnYm1WM0lGVnliRk5sWjIxbGJuUW9jR0YwYUhNc0lHTm9hV3hrY21WdUtUdGNiaUFnSUNCeVpYUjFjbTRnY21Wek8xeHVJQ0I5WEc1Y2JpQWdjR0Z5YzJWUVlYUm9WMmwwYUZCaGNtRnRjeWdwT2lCVmNteFFZWFJvVjJsMGFGQmhjbUZ0Y3lCN1hHNGdJQ0FnYkdWMElIQmhkR2dnUFNCdFlYUmphRkJoZEdoWGFYUm9VR0Z5WVcxektIUm9hWE11Y21WdFlXbHVhVzVuS1R0Y2JpQWdJQ0IwYUdsekxtTmhjSFIxY21Vb2NHRjBhQ2s3WEc0Z0lDQWdiR1YwSUcxaGRISnBlRkJoY21GdGN6b2dlMXRyWlhrNklITjBjbWx1WjEwNklHRnVlWDBnUFNCN2ZUdGNiaUFnSUNCcFppQW9kR2hwY3k1d1pXVnJVM1JoY25SelYybDBhQ2duT3ljcEtTQjdYRzRnSUNBZ0lDQnRZWFJ5YVhoUVlYSmhiWE1nUFNCMGFHbHpMbkJoY25ObFRXRjBjbWw0VUdGeVlXMXpLQ2s3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCdVpYY2dWWEpzVUdGMGFGZHBkR2hRWVhKaGJYTW9jR0YwYUN3Z2JXRjBjbWw0VUdGeVlXMXpLVHRjYmlBZ2ZWeHVYRzRnSUhCaGNuTmxVWFZsY25sUVlYSmhiWE1vS1RvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUdGdWVYMGdlMXh1SUNBZ0lHTnZibk4wSUhCaGNtRnRjem9nZTF0clpYazZJSE4wY21sdVoxMDZJR0Z1ZVgwZ1BTQjdmVHRjYmlBZ0lDQnBaaUFvZEdocGN5NXdaV1ZyVTNSaGNuUnpWMmwwYUNnblB5Y3BLU0I3WEc0Z0lDQWdJQ0IwYUdsekxtTmhjSFIxY21Vb0p6OG5LVHRjYmlBZ0lDQWdJSFJvYVhNdWNHRnljMlZSZFdWeWVWQmhjbUZ0S0hCaGNtRnRjeWs3WEc0Z0lDQWdJQ0IzYUdsc1pTQW9kR2hwY3k1eVpXMWhhVzVwYm1jdWJHVnVaM1JvSUQ0Z01DQW1KaUIwYUdsekxuQmxaV3RUZEdGeWRITlhhWFJvS0NjbUp5a3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWpZWEIwZFhKbEtDY21KeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjR0Z5YzJWUmRXVnllVkJoY21GdEtIQmhjbUZ0Y3lrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQndZWEpoYlhNN1hHNGdJSDFjYmx4dUlDQndZWEp6WlVaeVlXZHRaVzUwS0NrNklITjBjbWx1WnlCN1hHNGdJQ0FnYVdZZ0tIUm9hWE11Y0dWbGExTjBZWEowYzFkcGRHZ29KeU1uS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ0WVdsdWFXNW5Mbk4xWW5OMGNtbHVaeWd4S1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHNTFiR3c3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY0dGeWMyVk5ZWFJ5YVhoUVlYSmhiWE1vS1RvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUdGdWVYMGdlMXh1SUNBZ0lHTnZibk4wSUhCaGNtRnRjem9nZTF0clpYazZJSE4wY21sdVoxMDZJR0Z1ZVgwZ1BTQjdmVHRjYmlBZ0lDQjNhR2xzWlNBb2RHaHBjeTV5WlcxaGFXNXBibWN1YkdWdVozUm9JRDRnTUNBbUppQjBhR2x6TG5CbFpXdFRkR0Z5ZEhOWGFYUm9LQ2M3SnlrcElIdGNiaUFnSUNBZ0lIUm9hWE11WTJGd2RIVnlaU2duT3ljcE8xeHVJQ0FnSUNBZ2RHaHBjeTV3WVhKelpWQmhjbUZ0S0hCaGNtRnRjeWs3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCd1lYSmhiWE03WEc0Z0lIMWNibHh1SUNCd1lYSnpaVkJoY21GdEtIQmhjbUZ0Y3pvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUdGdWVYMHBPaUIyYjJsa0lIdGNiaUFnSUNCamIyNXpkQ0JyWlhrZ1BTQnRZWFJqYUZCaGRHaFhhWFJvVUdGeVlXMXpLSFJvYVhNdWNtVnRZV2x1YVc1bktUdGNiaUFnSUNCcFppQW9JV3RsZVNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJSDFjYmlBZ0lDQjBhR2x6TG1OaGNIUjFjbVVvYTJWNUtUdGNiaUFnSUNCc1pYUWdkbUZzZFdVNklHRnVlU0E5SUNkMGNuVmxKenRjYmlBZ0lDQnBaaUFvZEdocGN5NXdaV1ZyVTNSaGNuUnpWMmwwYUNnblBTY3BLU0I3WEc0Z0lDQWdJQ0IwYUdsekxtTmhjSFIxY21Vb0p6MG5LVHRjYmlBZ0lDQWdJR052Ym5OMElIWmhiSFZsVFdGMFkyZ2dQU0J0WVhSamFGQmhkR2hYYVhSb1VHRnlZVzF6S0hSb2FYTXVjbVZ0WVdsdWFXNW5LVHRjYmlBZ0lDQWdJR2xtSUNoMllXeDFaVTFoZEdOb0tTQjdYRzRnSUNBZ0lDQWdJSFpoYkhWbElEMGdkbUZzZFdWTllYUmphRHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWpZWEIwZFhKbEtIWmhiSFZsS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J3WVhKaGJYTmJhMlY1WFNBOUlIWmhiSFZsTzF4dUlDQjlYRzVjYmlBZ2NHRnljMlZSZFdWeWVWQmhjbUZ0S0hCaGNtRnRjem9nZTF0clpYazZJSE4wY21sdVoxMDZJR0Z1ZVgwcE9pQjJiMmxrSUh0Y2JpQWdJQ0JqYjI1emRDQnJaWGtnUFNCdFlYUmphRkYxWlhKNVVHRnlZVzF6S0hSb2FYTXVjbVZ0WVdsdWFXNW5LVHRjYmlBZ0lDQnBaaUFvSVd0bGVTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdU8xeHVJQ0FnSUgxY2JpQWdJQ0IwYUdsekxtTmhjSFIxY21Vb2EyVjVLVHRjYmlBZ0lDQnNaWFFnZG1Gc2RXVTZJR0Z1ZVNBOUlDZDBjblZsSnp0Y2JpQWdJQ0JwWmlBb2RHaHBjeTV3WldWclUzUmhjblJ6VjJsMGFDZ25QU2NwS1NCN1hHNGdJQ0FnSUNCMGFHbHpMbU5oY0hSMWNtVW9KejBuS1R0Y2JpQWdJQ0FnSUhaaGNpQjJZV3gxWlUxaGRHTm9JRDBnYldGMFkyaFZjbXhSZFdWeWVWQmhjbUZ0Vm1Gc2RXVW9kR2hwY3k1eVpXMWhhVzVwYm1jcE8xeHVJQ0FnSUNBZ2FXWWdLSFpoYkhWbFRXRjBZMmdwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnNkV1VnUFNCMllXeDFaVTFoZEdOb08xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1OaGNIUjFjbVVvZG1Gc2RXVXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnSUNCd1lYSmhiWE5iYTJWNVhTQTlJSFpoYkhWbE8xeHVJQ0I5WEc1Y2JpQWdjR0Z5YzJWUVlYSmxibk1vWVd4c2IzZFFjbWx0WVhKNU9pQmliMjlzWldGdUtUb2dlMXRyWlhrNklITjBjbWx1WjEwNklGVnliRk5sWjIxbGJuUjlJSHRjYmlBZ0lDQmpiMjV6ZENCelpXZHRaVzUwY3pvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUZWeWJGTmxaMjFsYm5SOUlEMGdlMzA3WEc0Z0lDQWdkR2hwY3k1allYQjBkWEpsS0Njb0p5azdYRzVjYmlBZ0lDQjNhR2xzWlNBb0lYUm9hWE11Y0dWbGExTjBZWEowYzFkcGRHZ29KeWtuS1NBbUppQjBhR2x6TG5KbGJXRnBibWx1Wnk1c1pXNW5kR2dnUGlBd0tTQjdYRzRnSUNBZ0lDQnNaWFFnY0dGMGFDQTlJRzFoZEdOb1VHRjBhRmRwZEdoUVlYSmhiWE1vZEdocGN5NXlaVzFoYVc1cGJtY3BPMXh1SUNBZ0lDQWdiR1YwSUc5MWRHeGxkRTVoYldVNklITjBjbWx1Wnp0Y2JpQWdJQ0FnSUdsbUlDaHdZWFJvTG1sdVpHVjRUMllvSnpvbktTQStJQzB4S1NCN1hHNGdJQ0FnSUNBZ0lHOTFkR3hsZEU1aGJXVWdQU0J3WVhSb0xuTjFZbk4wY2lnd0xDQndZWFJvTG1sdVpHVjRUMllvSnpvbktTazdYRzRnSUNBZ0lDQWdJSFJvYVhNdVkyRndkSFZ5WlNodmRYUnNaWFJPWVcxbEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1allYQjBkWEpsS0NjNkp5azdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR0ZzYkc5M1VISnBiV0Z5ZVNrZ2UxeHVJQ0FnSUNBZ0lDQnZkWFJzWlhST1lXMWxJRDBnVUZKSlRVRlNXVjlQVlZSTVJWUTdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR052Ym5OMElHTm9hV3hrY21WdUlEMGdkR2hwY3k1d1lYSnpaVk5sWjIxbGJuUkRhR2xzWkhKbGJpZ3BPMXh1SUNBZ0lDQWdjMlZuYldWdWRITmJiM1YwYkdWMFRtRnRaVjBnUFNCUFltcGxZM1F1YTJWNWN5aGphR2xzWkhKbGJpa3ViR1Z1WjNSb0lEMDlQU0F4SUQ4Z1kyaHBiR1J5Wlc1YlVGSkpUVUZTV1Y5UFZWUk1SVlJkSURwY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJRzVsZHlCVmNteFRaV2R0Wlc1MEtGdGRMQ0JqYUdsc1pISmxiaWs3WEc1Y2JpQWdJQ0FnSUdsbUlDaDBhR2x6TG5CbFpXdFRkR0Z5ZEhOWGFYUm9LQ2N2THljcEtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVkyRndkSFZ5WlNnbkx5OG5LVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2RHaHBjeTVqWVhCMGRYSmxLQ2NwSnlrN1hHNWNiaUFnSUNCeVpYUjFjbTRnYzJWbmJXVnVkSE03WEc0Z0lIMWNibjFjYmlKZGZRPT1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvdXJsX3NlcmlhbGl6ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKGEsIGIpIHtcbiAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrMVtpXTtcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnNoYWxsb3dFcXVhbCA9IHNoYWxsb3dFcXVhbDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChhW2ldW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbmZ1bmN0aW9uIGZpcnN0KGEpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPiAwID8gYVswXSA6IG51bGw7XG59XG5leHBvcnRzLmZpcnN0ID0gZmlyc3Q7XG5mdW5jdGlvbiBsYXN0KGEpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPiAwID8gYVthLmxlbmd0aCAtIDFdIDogbnVsbDtcbn1cbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG5mdW5jdGlvbiBhbmQoYm9vbHMpIHtcbiAgICByZXR1cm4gYm9vbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYmIGI7IH0sIHRydWUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5mdW5jdGlvbiBtZXJnZShtMSwgbTIpIHtcbiAgICB2YXIgbSA9IHt9O1xuICAgIGZvciAodmFyIGF0dHIgaW4gbTEpIHtcbiAgICAgICAgaWYgKG0xLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBtW2F0dHJdID0gbTFbYXR0cl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgYXR0ciBpbiBtMikge1xuICAgICAgICBpZiAobTIuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIG1bYXR0cl0gPSBtMlthdHRyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmZ1bmN0aW9uIGZvckVhY2gobWFwLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIHByb3AgaW4gbWFwKSB7XG4gICAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG1hcFtwcm9wXSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTI5c2JHVmpkR2x2Ymk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkxZEdsc2N5OWpiMnhzWldOMGFXOXVMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFTeHpRa0ZCTmtJc1EwRkJjVUlzUlVGQlJTeERRVUZ4UWp0SlFVTjJSU3hKUVVGTkxFVkJRVVVzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZDTEVsQlFVMHNSVUZCUlN4SFFVRkhMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEUxQlFVMHNTVUZCU1N4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU16UWl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wbEJRMllzUTBGQlF6dEpRVU5FTEVsQlFVa3NSMEZCVnl4RFFVRkRPMGxCUTJoQ0xFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUlVGQlJTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xRkJRMjVETEVkQlFVY3NSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFdpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFFpeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTJZc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVdSbExHOUNRVUZaTEdWQll6TkNMRU5CUVVFN1FVRkZSQ3hwUWtGQk1rSXNRMEZCVVR0SlFVTnFReXhKUVVGTkxFMUJRVTBzUjBGQlVTeEZRVUZGTEVOQlFVTTdTVUZEZGtJc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zVFVGQlRTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNN1VVRkRiRU1zUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hGUVVGRkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4yUWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdRVUZEYUVJc1EwRkJRenRCUVZKbExHVkJRVThzVlVGUmRFSXNRMEZCUVR0QlFVVkVMR1ZCUVhsQ0xFTkJRVTA3U1VGRE4wSXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03UVVGRGNFTXNRMEZCUXp0QlFVWmxMR0ZCUVVzc1VVRkZjRUlzUTBGQlFUdEJRVVZFTEdOQlFYZENMRU5CUVUwN1NVRkROVUlzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF6dEJRVU12UXl4RFFVRkRPMEZCUm1Vc1dVRkJTU3hQUVVWdVFpeERRVUZCTzBGQlJVUXNZVUZCYjBJc1MwRkJaMEk3U1VGRGJFTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkxMRTlCUVVFc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlRpeERRVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1FVRkRPVU1zUTBGQlF6dEJRVVpsTEZkQlFVY3NUVUZGYkVJc1EwRkJRVHRCUVVWRUxHVkJRWGxDTEVWQlFYTkNMRVZCUVVVc1JVRkJjMEk3U1VGRGNrVXNTVUZCU1N4RFFVRkRMRWRCUVhWQ0xFVkJRVVVzUTBGQlF6dEpRVVV2UWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkNMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRja0lzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkNMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRja0lzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMWdzUTBGQlF6dEJRV2hDWlN4aFFVRkxMRkZCWjBKd1FpeERRVUZCTzBGQlJVUXNhVUpCUTBrc1IwRkJkVUlzUlVGQlJTeFJRVUZ4UXp0SlFVTm9SU3hIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVsQlFVa3NTVUZCU1N4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpkQ0xGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRE5VSXNRMEZCUXp0SlFVTklMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJVR1VzWlVGQlR5eFZRVTkwUWl4RFFVRkJJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWlhod2IzSjBJR1oxYm1OMGFXOXVJSE5vWVd4c2IzZEZjWFZoYkNoaE9pQjdXM2c2SUhOMGNtbHVaMTA2SUdGdWVYMHNJR0k2SUh0YmVEb2djM1J5YVc1blhUb2dZVzU1ZlNrNklHSnZiMnhsWVc0Z2UxeHVJQ0JqYjI1emRDQnJNU0E5SUU5aWFtVmpkQzVyWlhsektHRXBPMXh1SUNCamIyNXpkQ0JyTWlBOUlFOWlhbVZqZEM1clpYbHpLR0lwTzF4dUlDQnBaaUFvYXpFdWJHVnVaM1JvSUNFOUlHc3lMbXhsYm1kMGFDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2ZWeHVJQ0JzWlhRZ2EyVjVPaUJ6ZEhKcGJtYzdYRzRnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z2F6RXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0JyWlhrZ1BTQnJNVnRwWFR0Y2JpQWdJQ0JwWmlBb1lWdHJaWGxkSUNFOVBTQmlXMnRsZVYwcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjbVYwZFhKdUlIUnlkV1U3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQm1iR0YwZEdWdVBGUStLR0U2SUZSYlhWdGRLVG9nVkZ0ZElIdGNiaUFnWTI5dWMzUWdkR0Z5WjJWME9pQlVXMTBnUFNCYlhUdGNiaUFnWm05eUlDaHNaWFFnYVNBOUlEQTdJR2tnUENCaExteGxibWQwYURzZ0t5dHBLU0I3WEc0Z0lDQWdabTl5SUNoc1pYUWdhaUE5SURBN0lHb2dQQ0JoVzJsZExteGxibWQwYURzZ0t5dHFLU0I3WEc0Z0lDQWdJQ0IwWVhKblpYUXVjSFZ6YUNoaFcybGRXMnBkS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJSFJoY21kbGREdGNibjFjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdacGNuTjBQRlErS0dFNklGUmJYU2s2SUZRZ2UxeHVJQ0J5WlhSMWNtNGdZUzVzWlc1bmRHZ2dQaUF3SUQ4Z1lWc3dYU0E2SUc1MWJHdzdYRzU5WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCc1lYTjBQRlErS0dFNklGUmJYU2s2SUZRZ2UxeHVJQ0J5WlhSMWNtNGdZUzVzWlc1bmRHZ2dQaUF3SUQ4Z1lWdGhMbXhsYm1kMGFDQXRJREZkSURvZ2JuVnNiRHRjYm4xY2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHRnVaQ2hpYjI5c2N6b2dZbTl2YkdWaGJsdGRLVG9nWW05dmJHVmhiaUI3WEc0Z0lISmxkSFZ5YmlCaWIyOXNjeTV5WldSMVkyVW9LR0VzSUdJcElEMCtJR0VnSmlZZ1lpd2dkSEoxWlNrN1hHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJ0WlhKblpUeFdQaWh0TVRvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUZaOUxDQnRNam9nZTF0clpYazZJSE4wY21sdVoxMDZJRlo5S1RvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUZaOUlIdGNiaUFnZG1GeUlHMDZJSHRiYTJWNU9pQnpkSEpwYm1kZE9pQldmU0E5SUh0OU8xeHVYRzRnSUdadmNpQW9kbUZ5SUdGMGRISWdhVzRnYlRFcElIdGNiaUFnSUNCcFppQW9iVEV1YUdGelQzZHVVSEp2Y0dWeWRIa29ZWFIwY2lrcElIdGNiaUFnSUNBZ0lHMWJZWFIwY2wwZ1BTQnRNVnRoZEhSeVhUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQm1iM0lnS0haaGNpQmhkSFJ5SUdsdUlHMHlLU0I3WEc0Z0lDQWdhV1lnS0cweUxtaGhjMDkzYmxCeWIzQmxjblI1S0dGMGRISXBLU0I3WEc0Z0lDQWdJQ0J0VzJGMGRISmRJRDBnYlRKYllYUjBjbDA3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJRzA3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQm1iM0pGWVdOb1BFc3NJRlkrS0Z4dUlDQWdJRzFoY0RvZ2UxdHJaWGs2SUhOMGNtbHVaMTA2SUZaOUxDQmpZV3hzWW1GamF6b2dMeW9vVml3Z1N5a2dQVDRnZG05cFpDb3ZJRVoxYm1OMGFXOXVLVG9nZG05cFpDQjdYRzRnSUdadmNpQW9kbUZ5SUhCeWIzQWdhVzRnYldGd0tTQjdYRzRnSUNBZ2FXWWdLRzFoY0M1b1lYTlBkMjVRY205d1pYSjBlU2h3Y205d0tTa2dlMXh1SUNBZ0lDQWdZMkZzYkdKaFkyc29iV0Z3VzNCeWIzQmRMQ0J3Y205d0tUdGNiaUFnSUNCOVhHNGdJSDFjYm4waVhYMD1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvdXRpbHMvY29sbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcuZm9yRWFjaCh2YWxpZGF0ZU5vZGUpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUNvbmZpZyA9IHZhbGlkYXRlQ29uZmlnO1xuZnVuY3Rpb24gdmFsaWRhdGVOb2RlKHJvdXRlKSB7XG4gICAgaWYgKCEhcm91dGUucmVkaXJlY3RUbyAmJiAhIXJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyByb3V0ZS5wYXRoICsgXCInOiByZWRpcmVjdFRvIGFuZCBjaGlsZHJlbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKCEhcm91dGUucmVkaXJlY3RUbyAmJiAhIXJvdXRlLmNvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJ1wiICsgcm91dGUucGF0aCArIFwiJzogcmVkaXJlY3RUbyBhbmQgY29tcG9uZW50IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAocm91dGUucGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm91dGUgY29uZmlndXJhdGlvbjogcm91dGVzIG11c3QgaGF2ZSBwYXRoIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm91dGUgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyByb3V0ZS5wYXRoICsgXCInOiBwYXRoIGNhbm5vdCBzdGFydCB3aXRoIGEgc2xhc2hcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTI5dVptbG5MbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDJOdmJtWnBaeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlpVRXNkMEpCUVN0Q0xFMUJRVzlDTzBsQlEycEVMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdRVUZETDBJc1EwRkJRenRCUVVabExITkNRVUZqTEdsQ1FVVTNRaXhEUVVGQk8wRkJSVVFzYzBKQlFYTkNMRXRCUVZrN1NVRkRhRU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhWUVVGVkxFbEJRVWtzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRek5ETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUTFnc2NVTkJRVzFETEV0QlFVc3NRMEZCUXl4SlFVRkpMSFZFUVVGdlJDeERRVUZETEVOQlFVTTdTVUZEZWtjc1EwRkJRenRKUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1ZVRkJWU3hKUVVGSkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNMVF5eE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVTllMSEZEUVVGdFF5eExRVUZMTEVOQlFVTXNTVUZCU1N4M1JFRkJjVVFzUTBGQlF5eERRVUZETzBsQlF6RkhMRU5CUVVNN1NVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE4wSXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXc0UkVGQk9FUXNRMEZCUXl4RFFVRkRPMGxCUTJ4R0xFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMMElzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl3eVEwRkJlVU1zUzBGQlN5eERRVUZETEVsQlFVa3NjME5CUVcxRExFTkJRVU1zUTBGQlF6dEpRVU14Unl4RFFVRkRPMEZCUTBnc1EwRkJReUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0I3Vkhsd1pYMGdabkp2YlNBblFHRnVaM1ZzWVhJdlkyOXlaU2M3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRkp2ZFhSbGNrTnZibVpwWnlBOUlGSnZkWFJsVzEwN1hHNWNibVY0Y0c5eWRDQnBiblJsY21aaFkyVWdVbTkxZEdVZ2UxeHVJQ0J3WVhSb1B6b2djM1J5YVc1bk8xeHVJQ0IwWlhKdGFXNWhiRDg2SUdKdmIyeGxZVzQ3WEc0Z0lHTnZiWEJ2Ym1WdWREODZJRlI1Y0dWOGMzUnlhVzVuTzF4dUlDQnZkWFJzWlhRL09pQnpkSEpwYm1jN1hHNGdJR05oYmtGamRHbDJZWFJsUHpvZ1lXNTVXMTA3WEc0Z0lHTmhia1JsWVdOMGFYWmhkR1UvT2lCaGJubGJYVHRjYmlBZ2NtVmthWEpsWTNSVWJ6ODZJSE4wY21sdVp6dGNiaUFnWTJocGJHUnlaVzQvT2lCU2IzVjBaVnRkTzF4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdkbUZzYVdSaGRHVkRiMjVtYVdjb1kyOXVabWxuT2lCU2IzVjBaWEpEYjI1bWFXY3BPaUIyYjJsa0lIdGNiaUFnWTI5dVptbG5MbVp2Y2tWaFkyZ29kbUZzYVdSaGRHVk9iMlJsS1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnZG1Gc2FXUmhkR1ZPYjJSbEtISnZkWFJsT2lCU2IzVjBaU2s2SUhadmFXUWdlMXh1SUNCcFppQW9JU0Z5YjNWMFpTNXlaV1JwY21WamRGUnZJQ1ltSUNFaGNtOTFkR1V1WTJocGJHUnlaVzRwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9YRzRnSUNBZ0lDQWdJR0JKYm5aaGJHbGtJR052Ym1acFozVnlZWFJwYjI0Z2IyWWdjbTkxZEdVZ0p5UjdjbTkxZEdVdWNHRjBhSDBuT2lCeVpXUnBjbVZqZEZSdklHRnVaQ0JqYUdsc1pISmxiaUJqWVc1dWIzUWdZbVVnZFhObFpDQjBiMmRsZEdobGNtQXBPMXh1SUNCOVhHNGdJR2xtSUNnaElYSnZkWFJsTG5KbFpHbHlaV04wVkc4Z0ppWWdJU0Z5YjNWMFpTNWpiMjF3YjI1bGJuUXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1hHNGdJQ0FnSUNBZ0lHQkpiblpoYkdsa0lHTnZibVpwWjNWeVlYUnBiMjRnYjJZZ2NtOTFkR1VnSnlSN2NtOTFkR1V1Y0dGMGFIMG5PaUJ5WldScGNtVmpkRlJ2SUdGdVpDQmpiMjF3YjI1bGJuUWdZMkZ1Ym05MElHSmxJSFZ6WldRZ2RHOW5aWFJvWlhKZ0tUdGNiaUFnZlZ4dUlDQnBaaUFvY205MWRHVXVjR0YwYUNBOVBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHQkpiblpoYkdsa0lISnZkWFJsSUdOdmJtWnBaM1Z5WVhScGIyNDZJSEp2ZFhSbGN5QnRkWE4wSUdoaGRtVWdjR0YwYUNCemNHVmphV1pwWldSZ0tUdGNiaUFnZlZ4dUlDQnBaaUFvY205MWRHVXVjR0YwYUM1emRHRnlkSE5YYVhSb0tDY3ZKeWtwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9ZRWx1ZG1Gc2FXUWdjbTkxZEdVZ1kyOXVabWxuZFhKaGRHbHZiaUJ2WmlCeWIzVjBaU0FuSkh0eWIzVjBaUzV3WVhSb2ZTYzZJSEJoZEdnZ1kyRnVibTkwSUhOMFlYSjBJSGRwZEdnZ1lTQnpiR0Z6YUdBcE8xeHVJQ0I5WEc1OUlsMTlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvY29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gNDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCZWhhdmlvclN1YmplY3RfMSA9IHJlcXVpcmUoJ3J4anMvQmVoYXZpb3JTdWJqZWN0Jyk7XG52YXIgcm91dGVyX3N0YXRlXzEgPSByZXF1aXJlKCcuL3JvdXRlcl9zdGF0ZScpO1xudmFyIHRyZWVfMSA9IHJlcXVpcmUoJy4vdXRpbHMvdHJlZScpO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyU3RhdGUoY3VyciwgcHJldlN0YXRlKSB7XG4gICAgdmFyIHJvb3QgPSBjcmVhdGVOb2RlKGN1cnIuX3Jvb3QsIHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5fcm9vdCA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0gcHJldlN0YXRlID8gcHJldlN0YXRlLnF1ZXJ5UGFyYW1zIDogbmV3IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdChjdXJyLnF1ZXJ5UGFyYW1zKTtcbiAgICB2YXIgZnJhZ21lbnQgPSBwcmV2U3RhdGUgPyBwcmV2U3RhdGUuZnJhZ21lbnQgOiBuZXcgQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0KGN1cnIuZnJhZ21lbnQpO1xuICAgIHJldHVybiBuZXcgcm91dGVyX3N0YXRlXzEuUm91dGVyU3RhdGUocm9vdCwgcXVlcnlQYXJhbXMsIGZyYWdtZW50LCBjdXJyKTtcbn1cbmV4cG9ydHMuY3JlYXRlUm91dGVyU3RhdGUgPSBjcmVhdGVSb3V0ZXJTdGF0ZTtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY3VyciwgcHJldlN0YXRlKSB7XG4gICAgaWYgKHByZXZTdGF0ZSAmJiBlcXVhbFJvdXRlU25hcHNob3RzKHByZXZTdGF0ZS52YWx1ZS5zbmFwc2hvdCwgY3Vyci52YWx1ZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJldlN0YXRlLnZhbHVlO1xuICAgICAgICB2YWx1ZS5fZnV0dXJlU25hcHNob3QgPSBjdXJyLnZhbHVlO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjcmVhdGVPclJldXNlQ2hpbGRyZW4oY3VyciwgcHJldlN0YXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlXzEuVHJlZU5vZGUodmFsdWUsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNyZWF0ZUFjdGl2YXRlZFJvdXRlKGN1cnIudmFsdWUpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gY3JlYXRlTm9kZShjKTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZV8xLlRyZWVOb2RlKHZhbHVlLCBjaGlsZHJlbik7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JSZXVzZUNoaWxkcmVuKGN1cnIsIHByZXZTdGF0ZSkge1xuICAgIHJldHVybiBjdXJyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcHJldlN0YXRlLmNoaWxkcmVuLmZpbmRJbmRleChmdW5jdGlvbiAocCkgeyByZXR1cm4gZXF1YWxSb3V0ZVNuYXBzaG90cyhwLnZhbHVlLnNuYXBzaG90LCBjaGlsZC52YWx1ZSk7IH0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoY2hpbGQsIHByZXZTdGF0ZS5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3RpdmF0ZWRSb3V0ZShjKSB7XG4gICAgcmV0dXJuIG5ldyByb3V0ZXJfc3RhdGVfMS5BY3RpdmF0ZWRSb3V0ZShuZXcgQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0KGMudXJsKSwgbmV3IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdChjLnBhcmFtcyksIGMub3V0bGV0LCBjLmNvbXBvbmVudCwgYyk7XG59XG5mdW5jdGlvbiBlcXVhbFJvdXRlU25hcHNob3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYS5fcm91dGVDb25maWcgPT09IGIuX3JvdXRlQ29uZmlnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTNKbFlYUmxYM0p2ZFhSbGNsOXpkR0YwWlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OWpjbVZoZEdWZmNtOTFkR1Z5WDNOMFlYUmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFTeG5RMEZCT0VJc2MwSkJRWE5DTEVOQlFVTXNRMEZCUVR0QlFVVnlSQ3cyUWtGQmRVWXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlFUdEJRVU40Unl4eFFrRkJkVUlzWTBGQll5eERRVUZETEVOQlFVRTdRVUZGZEVNc01rSkJRV3RETEVsQlFYbENMRVZCUVVVc1UwRkJjMEk3U1VGRGFrWXNTVUZCVFN4SlFVRkpMRWRCUVVjc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4SFFVRkhMRk5CUVZNc1EwRkJReXhMUVVGTExFZEJRVWNzVTBGQlV5eERRVUZETEVOQlFVTTdTVUZETjBVc1NVRkJUU3hYUVVGWExFZEJRVWNzVTBGQlV5eEhRVUZITEZOQlFWTXNRMEZCUXl4WFFVRlhMRWRCUVVjc1NVRkJTU3hwUTBGQlpTeERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJRenRKUVVNNVJpeEpRVUZOTEZGQlFWRXNSMEZCUnl4VFFVRlRMRWRCUVVjc1UwRkJVeXhEUVVGRExGRkJRVkVzUjBGQlJ5eEpRVUZKTEdsRFFVRmxMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzBsQlEzSkdMRTFCUVUwc1EwRkJReXhKUVVGSkxEQkNRVUZYTEVOQlFVTXNTVUZCU1N4RlFVRkZMRmRCUVZjc1JVRkJSU3hSUVVGUkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdRVUZETlVRc1EwRkJRenRCUVV4bExIbENRVUZwUWl4dlFrRkxhRU1zUTBGQlFUdEJRVVZFTEc5Q1FVRnZRaXhKUVVGelF5eEZRVUZGTEZOQlFXOURPMGxCUlRsR0xFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNTVUZCU1N4dFFrRkJiVUlzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpORkxFbEJRVTBzUzBGQlN5eEhRVUZITEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRPVUlzUzBGQlN5eERRVUZETEdWQlFXVXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJSVzVETEVsQlFVMHNVVUZCVVN4SFFVRkhMSEZDUVVGeFFpeERRVUZETEVsQlFVa3NSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVONFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4bFFVRlJMRU5CUVdsQ0xFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVVjJSQ3hEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4SlFVRk5MRXRCUVVzc1IwRkJSeXh2UWtGQmIwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGREwwTXNTVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFXSXNRMEZCWVN4RFFVRkRMRU5CUVVNN1VVRkRka1FzVFVGQlRTeERRVUZETEVsQlFVa3NaVUZCVVN4RFFVRnBRaXhMUVVGTExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdTVUZEZGtRc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGRlJDd3JRa0ZEU1N4SlFVRnpReXhGUVVGRkxGTkJRVzFETzBsQlF6ZEZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkJMRXRCUVVzN1VVRkROVUlzU1VGQlRTeExRVUZMTEVkQlExQXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhUUVVGVExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4dFFrRkJiVUlzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFXeEVMRU5CUVd0RUxFTkJRVU1zUTBGQlF6dFJRVU14Uml4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm1MRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUzBGQlN5eEZRVUZGTEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUkN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRek5DTEVOQlFVTTdTVUZEU0N4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOTUxFTkJRVU03UVVGRlJDdzRRa0ZCT0VJc1EwRkJlVUk3U1VGRGNrUXNUVUZCVFN4RFFVRkRMRWxCUVVrc05rSkJRV01zUTBGRGNrSXNTVUZCU1N4cFEwRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4SlFVRkpMR2xEUVVGbExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVNelJpeERRVUZETzBGQlJVUXNOa0pCUVRaQ0xFTkJRWGxDTEVWQlFVVXNRMEZCZVVJN1NVRkRMMFVzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4WlFVRlpMRXRCUVVzc1EwRkJReXhEUVVGRExGbEJRVmtzUTBGQlF6dEJRVU16UXl4RFFVRkRJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpYVcxd2IzSjBJSHRDWldoaGRtbHZjbE4xWW1wbFkzUjlJR1p5YjIwZ0ozSjRhbk12UW1Wb1lYWnBiM0pUZFdKcVpXTjBKenRjYmx4dWFXMXdiM0owSUh0QlkzUnBkbUYwWldSU2IzVjBaU3dnUVdOMGFYWmhkR1ZrVW05MWRHVlRibUZ3YzJodmRDd2dVbTkxZEdWeVUzUmhkR1VzSUZKdmRYUmxjbE4wWVhSbFUyNWhjSE5vYjNSOUlHWnliMjBnSnk0dmNtOTFkR1Z5WDNOMFlYUmxKenRjYm1sdGNHOXlkQ0I3VkhKbFpVNXZaR1Y5SUdaeWIyMGdKeTR2ZFhScGJITXZkSEpsWlNjN1hHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmpjbVZoZEdWU2IzVjBaWEpUZEdGMFpTaGpkWEp5T2lCU2IzVjBaWEpUZEdGMFpWTnVZWEJ6YUc5MExDQndjbVYyVTNSaGRHVTZJRkp2ZFhSbGNsTjBZWFJsS1RvZ1VtOTFkR1Z5VTNSaGRHVWdlMXh1SUNCamIyNXpkQ0J5YjI5MElEMGdZM0psWVhSbFRtOWtaU2hqZFhKeUxsOXliMjkwTENCd2NtVjJVM1JoZEdVZ1B5QndjbVYyVTNSaGRHVXVYM0p2YjNRZ09pQjFibVJsWm1sdVpXUXBPMXh1SUNCamIyNXpkQ0J4ZFdWeWVWQmhjbUZ0Y3lBOUlIQnlaWFpUZEdGMFpTQS9JSEJ5WlhaVGRHRjBaUzV4ZFdWeWVWQmhjbUZ0Y3lBNklHNWxkeUJDWldoaGRtbHZjbE4xWW1wbFkzUW9ZM1Z5Y2k1eGRXVnllVkJoY21GdGN5azdYRzRnSUdOdmJuTjBJR1p5WVdkdFpXNTBJRDBnY0hKbGRsTjBZWFJsSUQ4Z2NISmxkbE4wWVhSbExtWnlZV2R0Wlc1MElEb2dibVYzSUVKbGFHRjJhVzl5VTNWaWFtVmpkQ2hqZFhKeUxtWnlZV2R0Wlc1MEtUdGNiaUFnY21WMGRYSnVJRzVsZHlCU2IzVjBaWEpUZEdGMFpTaHliMjkwTENCeGRXVnllVkJoY21GdGN5d2dabkpoWjIxbGJuUXNJR04xY25JcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCamNtVmhkR1ZPYjJSbEtHTjFjbkk2SUZSeVpXVk9iMlJsUEVGamRHbDJZWFJsWkZKdmRYUmxVMjVoY0hOb2IzUStMQ0J3Y21WMlUzUmhkR1UvT2lCVWNtVmxUbTlrWlR4QlkzUnBkbUYwWldSU2IzVjBaVDRwT2x4dUlDQWdJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFBpQjdYRzRnSUdsbUlDaHdjbVYyVTNSaGRHVWdKaVlnWlhGMVlXeFNiM1YwWlZOdVlYQnphRzkwY3lod2NtVjJVM1JoZEdVdWRtRnNkV1V1YzI1aGNITm9iM1FzSUdOMWNuSXVkbUZzZFdVcEtTQjdYRzRnSUNBZ1kyOXVjM1FnZG1Gc2RXVWdQU0J3Y21WMlUzUmhkR1V1ZG1Gc2RXVTdYRzRnSUNBZ2RtRnNkV1V1WDJaMWRIVnlaVk51WVhCemFHOTBJRDBnWTNWeWNpNTJZV3gxWlR0Y2JseHVJQ0FnSUdOdmJuTjBJR05vYVd4a2NtVnVJRDBnWTNKbFlYUmxUM0pTWlhWelpVTm9hV3hrY21WdUtHTjFjbklzSUhCeVpYWlRkR0YwWlNrN1hHNGdJQ0FnY21WMGRYSnVJRzVsZHlCVWNtVmxUbTlrWlR4QlkzUnBkbUYwWldSU2IzVjBaVDRvZG1Gc2RXVXNJR05vYVd4a2NtVnVLVHRjYmx4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdOdmJuTjBJSFpoYkhWbElEMGdZM0psWVhSbFFXTjBhWFpoZEdWa1VtOTFkR1VvWTNWeWNpNTJZV3gxWlNrN1hHNGdJQ0FnWTI5dWMzUWdZMmhwYkdSeVpXNGdQU0JqZFhKeUxtTm9hV3hrY21WdUxtMWhjQ2hqSUQwK0lHTnlaV0YwWlU1dlpHVW9ZeWtwTzF4dUlDQWdJSEpsZEhWeWJpQnVaWGNnVkhKbFpVNXZaR1U4UVdOMGFYWmhkR1ZrVW05MWRHVStLSFpoYkhWbExDQmphR2xzWkhKbGJpazdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnWTNKbFlYUmxUM0pTWlhWelpVTm9hV3hrY21WdUtGeHVJQ0FnSUdOMWNuSTZJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0xDQndjbVYyVTNSaGRHVTZJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFBpa2dlMXh1SUNCeVpYUjFjbTRnWTNWeWNpNWphR2xzWkhKbGJpNXRZWEFvWTJocGJHUWdQVDRnZTF4dUlDQWdJR052Ym5OMElHbHVaR1Y0SUQxY2JpQWdJQ0FnSUNBZ2NISmxkbE4wWVhSbExtTm9hV3hrY21WdUxtWnBibVJKYm1SbGVDaHdJRDArSUdWeGRXRnNVbTkxZEdWVGJtRndjMmh2ZEhNb2NDNTJZV3gxWlM1emJtRndjMmh2ZEN3Z1kyaHBiR1F1ZG1Gc2RXVXBLVHRjYmlBZ0lDQnBaaUFvYVc1a1pYZ2dQajBnTUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdOeVpXRjBaVTV2WkdVb1kyaHBiR1FzSUhCeVpYWlRkR0YwWlM1amFHbHNaSEpsYmx0cGJtUmxlRjBwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1kzSmxZWFJsVG05a1pTaGphR2xzWkNrN1hHNGdJQ0FnZlZ4dUlDQjlLVHRjYm4xY2JseHVablZ1WTNScGIyNGdZM0psWVhSbFFXTjBhWFpoZEdWa1VtOTFkR1VvWXpvZ1FXTjBhWFpoZEdWa1VtOTFkR1ZUYm1Gd2MyaHZkQ2tnZTF4dUlDQnlaWFIxY200Z2JtVjNJRUZqZEdsMllYUmxaRkp2ZFhSbEtGeHVJQ0FnSUNBZ2JtVjNJRUpsYUdGMmFXOXlVM1ZpYW1WamRDaGpMblZ5YkNrc0lHNWxkeUJDWldoaGRtbHZjbE4xWW1wbFkzUW9ZeTV3WVhKaGJYTXBMQ0JqTG05MWRHeGxkQ3dnWXk1amIyMXdiMjVsYm5Rc0lHTXBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxjWFZoYkZKdmRYUmxVMjVoY0hOb2IzUnpLR0U2SUVGamRHbDJZWFJsWkZKdmRYUmxVMjVoY0hOb2IzUXNJR0k2SUVGamRHbDJZWFJsWkZKdmRYUmxVMjVoY0hOb2IzUXBPaUJpYjI5c1pXRnVJSHRjYmlBZ2NtVjBkWEp1SUdFdVgzSnZkWFJsUTI5dVptbG5JRDA5UFNCaUxsOXliM1YwWlVOdmJtWnBaenRjYm4waVhYMD1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvY3JlYXRlX3JvdXRlcl9zdGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1N1YmplY3QnKTtcbnZhciB0aHJvd0Vycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvdGhyb3dFcnJvcicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbi8qKlxuICogQGNsYXNzIEJlaGF2aW9yU3ViamVjdDxUPlxuICovXG52YXIgQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmVoYXZpb3JTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJlaGF2aW9yU3ViamVjdChfdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgIH1cbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcmVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yXzEudGhyb3dFcnJvcih0aGlzLmVycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JfMS50aHJvd0Vycm9yKG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uICYmICFzdWJzY3JpcHRpb24uaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbmV4dC5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlID0gdmFsdWUpO1xuICAgIH07XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgdGhpcy5lcnJvclZhbHVlID0gZXJyKTtcbiAgICB9O1xuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XG59KFN1YmplY3RfMS5TdWJqZWN0KSk7XG5leHBvcnRzLkJlaGF2aW9yU3ViamVjdCA9IEJlaGF2aW9yU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlaGF2aW9yU3ViamVjdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL0JlaGF2aW9yU3ViamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBCZWhhdmlvclN1YmplY3RfMSA9IHJlcXVpcmUoJ3J4anMvQmVoYXZpb3JTdWJqZWN0Jyk7XG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKCcuL3NoYXJlZCcpO1xudmFyIHVybF90cmVlXzEgPSByZXF1aXJlKCcuL3VybF90cmVlJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi91dGlscy9jb2xsZWN0aW9uJyk7XG52YXIgdHJlZV8xID0gcmVxdWlyZSgnLi91dGlscy90cmVlJyk7XG52YXIgUm91dGVyU3RhdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb3V0ZXJTdGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3V0ZXJTdGF0ZShyb290LCBxdWVyeVBhcmFtcywgZnJhZ21lbnQsIHNuYXBzaG90KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHJvb3QpO1xuICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgIH1cbiAgICBSb3V0ZXJTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNuYXBzaG90LnRvU3RyaW5nKCk7IH07XG4gICAgcmV0dXJuIFJvdXRlclN0YXRlO1xufSh0cmVlXzEuVHJlZSkpO1xuZXhwb3J0cy5Sb3V0ZXJTdGF0ZSA9IFJvdXRlclN0YXRlO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlTdGF0ZSh1cmxUcmVlLCByb290Q29tcG9uZW50KSB7XG4gICAgdmFyIHNuYXBzaG90ID0gY3JlYXRlRW1wdHlTdGF0ZVNuYXBzaG90KHVybFRyZWUsIHJvb3RDb21wb25lbnQpO1xuICAgIHZhciBlbXB0eVVybCA9IG5ldyBCZWhhdmlvclN1YmplY3RfMS5CZWhhdmlvclN1YmplY3QoW25ldyB1cmxfdHJlZV8xLlVybFBhdGhXaXRoUGFyYW1zKCcnLCB7fSldKTtcbiAgICB2YXIgZW1wdHlQYXJhbXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICB2YXIgZW1wdHlRdWVyeVBhcmFtcyA9IG5ldyBCZWhhdmlvclN1YmplY3RfMS5CZWhhdmlvclN1YmplY3Qoe30pO1xuICAgIHZhciBmcmFnbWVudCA9IG5ldyBCZWhhdmlvclN1YmplY3RfMS5CZWhhdmlvclN1YmplY3QoJycpO1xuICAgIHZhciBhY3RpdmF0ZWQgPSBuZXcgQWN0aXZhdGVkUm91dGUoZW1wdHlVcmwsIGVtcHR5UGFyYW1zLCBzaGFyZWRfMS5QUklNQVJZX09VVExFVCwgcm9vdENvbXBvbmVudCwgc25hcHNob3Qucm9vdCk7XG4gICAgYWN0aXZhdGVkLnNuYXBzaG90ID0gc25hcHNob3Qucm9vdDtcbiAgICByZXR1cm4gbmV3IFJvdXRlclN0YXRlKG5ldyB0cmVlXzEuVHJlZU5vZGUoYWN0aXZhdGVkLCBbXSksIGVtcHR5UXVlcnlQYXJhbXMsIGZyYWdtZW50LCBzbmFwc2hvdCk7XG59XG5leHBvcnRzLmNyZWF0ZUVtcHR5U3RhdGUgPSBjcmVhdGVFbXB0eVN0YXRlO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlTdGF0ZVNuYXBzaG90KHVybFRyZWUsIHJvb3RDb21wb25lbnQpIHtcbiAgICB2YXIgZW1wdHlQYXJhbXMgPSB7fTtcbiAgICB2YXIgZW1wdHlRdWVyeVBhcmFtcyA9IHt9O1xuICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgIHZhciBhY3RpdmF0ZWQgPSBuZXcgQWN0aXZhdGVkUm91dGVTbmFwc2hvdChbXSwgZW1wdHlQYXJhbXMsIHNoYXJlZF8xLlBSSU1BUllfT1VUTEVULCByb290Q29tcG9uZW50LCBudWxsLCB1cmxUcmVlLnJvb3QsIC0xKTtcbiAgICByZXR1cm4gbmV3IFJvdXRlclN0YXRlU25hcHNob3QoJycsIG5ldyB0cmVlXzEuVHJlZU5vZGUoYWN0aXZhdGVkLCBbXSksIGVtcHR5UXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbn1cbnZhciBBY3RpdmF0ZWRSb3V0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWN0aXZhdGVkUm91dGUodXJsLCBwYXJhbXMsIG91dGxldCwgY29tcG9uZW50LCBmdXR1cmVTbmFwc2hvdCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMub3V0bGV0ID0gb3V0bGV0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5fZnV0dXJlU25hcHNob3QgPSBmdXR1cmVTbmFwc2hvdDtcbiAgICB9XG4gICAgQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbmFwc2hvdCA/IHRoaXMuc25hcHNob3QudG9TdHJpbmcoKSA6IFwiRnV0dXJlKFwiICsgdGhpcy5fZnV0dXJlU25hcHNob3QgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmF0ZWRSb3V0ZTtcbn0oKSk7XG5leHBvcnRzLkFjdGl2YXRlZFJvdXRlID0gQWN0aXZhdGVkUm91dGU7XG52YXIgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWN0aXZhdGVkUm91dGVTbmFwc2hvdCh1cmwsIHBhcmFtcywgb3V0bGV0LCBjb21wb25lbnQsIHJvdXRlQ29uZmlnLCB1cmxTZWdtZW50LCBsYXN0UGF0aEluZGV4KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5vdXRsZXQgPSBvdXRsZXQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLl9yb3V0ZUNvbmZpZyA9IHJvdXRlQ29uZmlnO1xuICAgICAgICB0aGlzLl91cmxTZWdtZW50ID0gdXJsU2VnbWVudDtcbiAgICAgICAgdGhpcy5fbGFzdFBhdGhJbmRleCA9IGxhc3RQYXRoSW5kZXg7XG4gICAgfVxuICAgIEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvU3RyaW5nKCk7IH0pLmpvaW4oJy8nKTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSB0aGlzLl9yb3V0ZUNvbmZpZyA/IHRoaXMuX3JvdXRlQ29uZmlnLnBhdGggOiAnJztcbiAgICAgICAgcmV0dXJuIFwiUm91dGUodXJsOidcIiArIHVybCArIFwiJywgcGF0aDonXCIgKyBtYXRjaGVkICsgXCInKVwiO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGl2YXRlZFJvdXRlU25hcHNob3Q7XG59KCkpO1xuZXhwb3J0cy5BY3RpdmF0ZWRSb3V0ZVNuYXBzaG90ID0gQWN0aXZhdGVkUm91dGVTbmFwc2hvdDtcbnZhciBSb3V0ZXJTdGF0ZVNuYXBzaG90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm91dGVyU3RhdGVTbmFwc2hvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb3V0ZXJTdGF0ZVNuYXBzaG90KHVybCwgcm9vdCwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHJvb3QpO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgfVxuICAgIFJvdXRlclN0YXRlU25hcHNob3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VyaWFsaXplTm9kZSh0aGlzLl9yb290KTsgfTtcbiAgICByZXR1cm4gUm91dGVyU3RhdGVTbmFwc2hvdDtcbn0odHJlZV8xLlRyZWUpKTtcbmV4cG9ydHMuUm91dGVyU3RhdGVTbmFwc2hvdCA9IFJvdXRlclN0YXRlU25hcHNob3Q7XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG5vZGUpIHtcbiAgICB2YXIgYyA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCA/IFwiIHsgXCIgKyBub2RlLmNoaWxkcmVuLm1hcChzZXJpYWxpemVOb2RlKS5qb2luKFwiLCBcIikgKyBcIiB9IFwiIDogJyc7XG4gICAgcmV0dXJuIFwiXCIgKyBub2RlLnZhbHVlICsgYztcbn1cbmZ1bmN0aW9uIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5zbmFwc2hvdCAmJiAhY29sbGVjdGlvbl8xLnNoYWxsb3dFcXVhbChyb3V0ZS5zbmFwc2hvdC5wYXJhbXMsIHJvdXRlLl9mdXR1cmVTbmFwc2hvdC5wYXJhbXMpKSB7XG4gICAgICAgIHJvdXRlLnNuYXBzaG90ID0gcm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICAgICAgICByb3V0ZS51cmwubmV4dChyb3V0ZS5zbmFwc2hvdC51cmwpO1xuICAgICAgICByb3V0ZS5wYXJhbXMubmV4dChyb3V0ZS5zbmFwc2hvdC5wYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm91dGUuc25hcHNob3QgPSByb3V0ZS5fZnV0dXJlU25hcHNob3Q7XG4gICAgfVxufVxuZXhwb3J0cy5hZHZhbmNlQWN0aXZhdGVkUm91dGUgPSBhZHZhbmNlQWN0aXZhdGVkUm91dGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljbTkxZEdWeVgzTjBZWFJsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2YzNKakwzSnZkWFJsY2w5emRHRjBaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdRVUZEUVN4blEwRkJPRUlzYzBKQlFYTkNMRU5CUVVNc1EwRkJRVHRCUVVseVJDeDFRa0ZCY1VNc1ZVRkJWU3hEUVVGRExFTkJRVUU3UVVGRGFFUXNlVUpCUVhGRUxGbEJRVmtzUTBGQlF5eERRVUZCTzBGQlEyeEZMREpDUVVFeVFpeHZRa0ZCYjBJc1EwRkJReXhEUVVGQk8wRkJRMmhFTEhGQ1FVRTJRaXhqUVVGakxFTkJRVU1zUTBGQlFUdEJRV3RDTlVNN1NVRkJhVU1zSzBKQlFXOUNPMGxCU1c1RUxIRkNRVU5KTEVsQlFUaENMRVZCUVZNc1YwRkJLMElzUlVGREwwUXNVVUZCTkVJc1JVRkJVeXhSUVVFMlFqdFJRVU16UlN4clFrRkJUU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVVkyUWl4blFrRkJWeXhIUVVGWUxGZEJRVmNzUTBGQmIwSTdVVUZETDBRc1lVRkJVU3hIUVVGU0xGRkJRVkVzUTBGQmIwSTdVVUZCVXl4aFFVRlJMRWRCUVZJc1VVRkJVU3hEUVVGeFFqdEpRVVUzUlN4RFFVRkRPMGxCUlVRc09FSkJRVkVzUjBGQlVpeGpRVUZ4UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla1FzYTBKQlFVTTdRVUZCUkN4RFFVRkRMRUZCV0VRc1EwRkJhVU1zVjBGQlNTeEhRVmR3UXp0QlFWaFpMRzFDUVVGWExHTkJWM1pDTEVOQlFVRTdRVUZGUkN3d1FrRkJhVU1zVDBGQlowSXNSVUZCUlN4aFFVRnRRanRKUVVOd1JTeEpRVUZOTEZGQlFWRXNSMEZCUnl4M1FrRkJkMElzUTBGQlF5eFBRVUZQTEVWQlFVVXNZVUZCWVN4RFFVRkRMRU5CUVVNN1NVRkRiRVVzU1VGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4cFEwRkJaU3hEUVVGRExFTkJRVU1zU1VGQlNTdzBRa0ZCYVVJc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNSRkxFbEJRVTBzVjBGQlZ5eEhRVUZITEVsQlFVa3NhVU5CUVdVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU0xUXl4SlFVRk5MR2RDUVVGblFpeEhRVUZITEVsQlFVa3NhVU5CUVdVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU5xUkN4SlFVRk5MRkZCUVZFc1IwRkJSeXhKUVVGSkxHbERRVUZsTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkRla01zU1VGQlRTeFRRVUZUTEVkQlExZ3NTVUZCU1N4alFVRmpMRU5CUVVNc1VVRkJVU3hGUVVGRkxGZEJRVmNzUlVGQlJTeDFRa0ZCWXl4RlFVRkZMR0ZCUVdFc1JVRkJSU3hSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZETlVZc1UwRkJVeXhEUVVGRExGRkJRVkVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTI1RExFMUJRVTBzUTBGQlF5eEpRVUZKTEZkQlFWY3NRMEZEYkVJc1NVRkJTU3hsUVVGUkxFTkJRV2xDTEZOQlFWTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSU3huUWtGQlowSXNSVUZCUlN4UlFVRlJMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03UVVGRGVrWXNRMEZCUXp0QlFWaGxMSGRDUVVGblFpeHRRa0ZYTDBJc1EwRkJRVHRCUVVWRUxHdERRVUZyUXl4UFFVRm5RaXhGUVVGRkxHRkJRVzFDTzBsQlEzSkZMRWxCUVUwc1YwRkJWeXhIUVVGSExFVkJRVVVzUTBGQlF6dEpRVU4yUWl4SlFVRk5MR2RDUVVGblFpeEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTTFRaXhKUVVGTkxGRkJRVkVzUjBGQlJ5eEZRVUZGTEVOQlFVTTdTVUZEY0VJc1NVRkJUU3hUUVVGVExFZEJRVWNzU1VGQlNTeHpRa0ZCYzBJc1EwRkRlRU1zUlVGQlJTeEZRVUZGTEZkQlFWY3NSVUZCUlN4MVFrRkJZeXhGUVVGRkxHRkJRV0VzUlVGQlJTeEpRVUZKTEVWQlFVVXNUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlF6VkZMRTFCUVUwc1EwRkJReXhKUVVGSkxHMUNRVUZ0UWl4RFFVTXhRaXhGUVVGRkxFVkJRVVVzU1VGQlNTeGxRVUZSTEVOQlFYbENMRk5CUVZNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlJTeG5Ra0ZCWjBJc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU16Uml4RFFVRkRPMEZCYVVKRU8wbEJVVVVzZDBKQlExY3NSMEZCYjBNc1JVRkJVeXhOUVVFd1FpeEZRVU4yUlN4TlFVRmpMRVZCUVZNc1UwRkJjMElzUlVGRGNFUXNZMEZCYzBNN1VVRkdMMElzVVVGQlJ5eEhRVUZJTEVkQlFVY3NRMEZCYVVNN1VVRkJVeXhYUVVGTkxFZEJRVTRzVFVGQlRTeERRVUZ2UWp0UlFVTjJSU3hYUVVGTkxFZEJRVTRzVFVGQlRTeERRVUZSTzFGQlFWTXNZMEZCVXl4SFFVRlVMRk5CUVZNc1EwRkJZVHRSUVVWMFJDeEpRVUZKTEVOQlFVTXNaVUZCWlN4SFFVRkhMR05CUVdNc1EwRkJRenRKUVVONFF5eERRVUZETzBsQlJVUXNhVU5CUVZFc1IwRkJVanRSUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVkQlFVY3NXVUZCVlN4SlFVRkpMRU5CUVVNc1pVRkJaU3hOUVVGSExFTkJRVU03U1VGRGRFWXNRMEZCUXp0SlFVTklMSEZDUVVGRE8wRkJRVVFzUTBGQlF5eEJRV3hDUkN4SlFXdENRenRCUVd4Q1dTeHpRa0ZCWXl4cFFrRnJRakZDTEVOQlFVRTdRVUZsUkR0SlFXbENSU3huUTBGRFZ5eEhRVUYzUWl4RlFVRlRMRTFCUVdNc1JVRkJVeXhOUVVGakxFVkJRM1JGTEZOQlFYTkNMRVZCUVVVc1YwRkJhMElzUlVGQlJTeFZRVUZ6UWl4RlFVTjZSU3hoUVVGeFFqdFJRVVprTEZGQlFVY3NSMEZCU0N4SFFVRkhMRU5CUVhGQ08xRkJRVk1zVjBGQlRTeEhRVUZPTEUxQlFVMHNRMEZCVVR0UlFVRlRMRmRCUVUwc1IwRkJUaXhOUVVGTkxFTkJRVkU3VVVGRGRFVXNZMEZCVXl4SFFVRlVMRk5CUVZNc1EwRkJZVHRSUVVVdlFpeEpRVUZKTEVOQlFVTXNXVUZCV1N4SFFVRkhMRmRCUVZjc1EwRkJRenRSUVVOb1F5eEpRVUZKTEVOQlFVTXNWMEZCVnl4SFFVRkhMRlZCUVZVc1EwRkJRenRSUVVNNVFpeEpRVUZKTEVOQlFVTXNZMEZCWXl4SFFVRkhMR0ZCUVdFc1EwRkJRenRKUVVOMFF5eERRVUZETzBsQlJVUXNlVU5CUVZFc1IwRkJVanRSUVVORkxFbEJRVTBzUjBGQlJ5eEhRVUZITEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVUVzUTBGQlF5eEpRVUZKTEU5QlFVRXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGYUxFTkJRVmtzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVOMFJDeEpRVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1dVRkJXU3hIUVVGSExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNTVUZCU1N4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVOb1JTeE5RVUZOTEVOQlFVTXNaMEpCUVdNc1IwRkJSeXhwUWtGQldTeFBRVUZQTEU5QlFVa3NRMEZCUXp0SlFVTnNSQ3hEUVVGRE8wbEJRMGdzTmtKQlFVTTdRVUZCUkN4RFFVRkRMRUZCTDBKRUxFbEJLMEpETzBGQkwwSlpMRGhDUVVGelFpeDVRa0VyUW14RExFTkJRVUU3UVVGbFJEdEpRVUY1UXl4MVEwRkJORUk3U1VGSmJrVXNOa0pCUTFjc1IwRkJWeXhGUVVGRkxFbEJRWE5ETEVWQlFWTXNWMEZCYlVJc1JVRkRMMFVzVVVGQlowSTdVVUZEZWtJc2EwSkJRVTBzU1VGQlNTeERRVUZETEVOQlFVTTdVVUZHU0N4UlFVRkhMRWRCUVVnc1IwRkJSeXhEUVVGUk8xRkJRV2xFTEdkQ1FVRlhMRWRCUVZnc1YwRkJWeXhEUVVGUk8xRkJReTlGTEdGQlFWRXNSMEZCVWl4UlFVRlJMRU5CUVZFN1NVRkZNMElzUTBGQlF6dEpRVVZFTEhORFFVRlJMRWRCUVZJc1kwRkJjVUlzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlF6RkVMREJDUVVGRE8wRkJRVVFzUTBGQlF5eEJRVmhFTEVOQlFYbERMRmRCUVVrc1IwRlhOVU03UVVGWVdTd3lRa0ZCYlVJc2MwSkJWeTlDTEVOQlFVRTdRVUZGUkN4MVFrRkJkVUlzU1VGQmMwTTdTVUZETTBRc1NVRkJUU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhIUVVGSExGRkJRVTBzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRkxMRWRCUVVjc1JVRkJSU3hEUVVGRE8wbEJRMnBITEUxQlFVMHNRMEZCUXl4TFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFZEJRVWNzUTBGQlJ5eERRVUZETzBGQlF6ZENMRU5CUVVNN1FVRlJSQ3dyUWtGQmMwTXNTMEZCY1VJN1NVRkRla1FzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1NVRkJTU3hEUVVGRExIbENRVUZaTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVrWXNTMEZCU3l4RFFVRkRMRkZCUVZFc1IwRkJSeXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETzFGQlEycERMRXRCUVVzc1EwRkJReXhIUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGNFTXNTMEZCU3l4RFFVRkRMRTFCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVOc1JDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhMUVVGTExFTkJRVU1zVVVGQlVTeEhRVUZITEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNN1NVRkRla01zUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZTWlN3MlFrRkJjVUlzZDBKQlVYQkRMRU5CUVVFaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SnBiWEJ2Y25RZ2UwTnZiWEJ2Ym1WdWRFWmhZM1J2Y25rc0lGUjVjR1Y5SUdaeWIyMGdKMEJoYm1kMWJHRnlMMk52Y21Vbk8xeHVhVzF3YjNKMElIdENaV2hoZG1sdmNsTjFZbXBsWTNSOUlHWnliMjBnSjNKNGFuTXZRbVZvWVhacGIzSlRkV0pxWldOMEp6dGNibWx0Y0c5eWRDQjdUMkp6WlhKMllXSnNaWDBnWm5KdmJTQW5jbmhxY3k5UFluTmxjblpoWW14bEp6dGNibHh1YVcxd2IzSjBJSHRTYjNWMFpYMGdabkp2YlNBbkxpOWpiMjVtYVdjbk8xeHVhVzF3YjNKMElIdFFVa2xOUVZKWlgwOVZWRXhGVkN3Z1VHRnlZVzF6ZlNCbWNtOXRJQ2N1TDNOb1lYSmxaQ2M3WEc1cGJYQnZjblFnZTFWeWJGQmhkR2hYYVhSb1VHRnlZVzF6TENCVmNteFRaV2R0Wlc1MExDQlZjbXhVY21WbGZTQm1jbTl0SUNjdUwzVnliRjkwY21WbEp6dGNibWx0Y0c5eWRDQjdjMmhoYkd4dmQwVnhkV0ZzZlNCbWNtOXRJQ2N1TDNWMGFXeHpMMk52Ykd4bFkzUnBiMjRuTzF4dWFXMXdiM0owSUh0VWNtVmxMQ0JVY21WbFRtOWtaWDBnWm5KdmJTQW5MaTkxZEdsc2N5OTBjbVZsSnp0Y2JseHVYRzR2S2lwY2JpQXFJRlJvWlNCemRHRjBaU0J2WmlCMGFHVWdjbTkxZEdWeUxseHVJQ3BjYmlBcUlDTWpJeUJWYzJGblpWeHVJQ3BjYmlBcUlHQmdZRnh1SUNvZ1kyeGhjM01nVFhsRGIyMXdiMjVsYm5RZ2UxeHVJQ29nSUNCamIyNXpkSEoxWTNSdmNpaHliM1YwWlhJNklGSnZkWFJsY2lrZ2UxeHVJQ29nSUNBZ0lHTnZibk4wSUhOMFlYUmxJRDBnY205MWRHVnlMbkp2ZFhSbGNsTjBZWFJsTzF4dUlDb2dJQ0FnSUdOdmJuTjBJR2xrT2lCUFluTmxjblpoWW14bFBITjBjbWx1Wno0Z1BTQnpkR0YwWlM1bWFYSnpkRU5vYVd4a0tITjBZWFJsTG5KdmIzUXBMbkJoY21GdGN5NXRZWEFvY0NBOVBpQndMbWxrS1R0Y2JpQXFJQ0FnSUNCamIyNXpkQ0JwYzBSbFluVm5PaUJQWW5ObGNuWmhZbXhsUEhOMGNtbHVaejRnUFNCemRHRjBaUzV4ZFdWeWVWQmhjbUZ0Y3k1dFlYQW9jU0E5UGlCeExtUmxZblZuS1R0Y2JpQXFJQ0FnZlZ4dUlDb2dmVnh1SUNvZ1lHQmdYRzRnS2k5Y2JtVjRjRzl5ZENCamJHRnpjeUJTYjNWMFpYSlRkR0YwWlNCbGVIUmxibVJ6SUZSeVpXVThRV04wYVhaaGRHVmtVbTkxZEdVK0lIdGNiaUFnTHlvcVhHNGdJQ0FxSUVCcGJuUmxjbTVoYkZ4dUlDQWdLaTljYmlBZ1kyOXVjM1J5ZFdOMGIzSW9YRzRnSUNBZ0lDQnliMjkwT2lCVWNtVmxUbTlrWlR4QlkzUnBkbUYwWldSU2IzVjBaVDRzSUhCMVlteHBZeUJ4ZFdWeWVWQmhjbUZ0Y3pvZ1QySnpaWEoyWVdKc1pUeFFZWEpoYlhNK0xGeHVJQ0FnSUNBZ2NIVmliR2xqSUdaeVlXZHRaVzUwT2lCUFluTmxjblpoWW14bFBITjBjbWx1Wno0c0lIQjFZbXhwWXlCemJtRndjMmh2ZERvZ1VtOTFkR1Z5VTNSaGRHVlRibUZ3YzJodmRDa2dlMXh1SUNBZ0lITjFjR1Z5S0hKdmIzUXBPMXh1SUNCOVhHNWNiaUFnZEc5VGRISnBibWNvS1RvZ2MzUnlhVzVuSUhzZ2NtVjBkWEp1SUhSb2FYTXVjMjVoY0hOb2IzUXVkRzlUZEhKcGJtY29LVHNnZlZ4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdZM0psWVhSbFJXMXdkSGxUZEdGMFpTaDFjbXhVY21WbE9pQlZjbXhVY21WbExDQnliMjkwUTI5dGNHOXVaVzUwT2lCVWVYQmxLVG9nVW05MWRHVnlVM1JoZEdVZ2UxeHVJQ0JqYjI1emRDQnpibUZ3YzJodmRDQTlJR055WldGMFpVVnRjSFI1VTNSaGRHVlRibUZ3YzJodmRDaDFjbXhVY21WbExDQnliMjkwUTI5dGNHOXVaVzUwS1R0Y2JpQWdZMjl1YzNRZ1pXMXdkSGxWY213Z1BTQnVaWGNnUW1Wb1lYWnBiM0pUZFdKcVpXTjBLRnR1WlhjZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhNb0p5Y3NJSHQ5S1YwcE8xeHVJQ0JqYjI1emRDQmxiWEIwZVZCaGNtRnRjeUE5SUc1bGR5QkNaV2hoZG1sdmNsTjFZbXBsWTNRb2UzMHBPMXh1SUNCamIyNXpkQ0JsYlhCMGVWRjFaWEo1VUdGeVlXMXpJRDBnYm1WM0lFSmxhR0YyYVc5eVUzVmlhbVZqZENoN2ZTazdYRzRnSUdOdmJuTjBJR1p5WVdkdFpXNTBJRDBnYm1WM0lFSmxhR0YyYVc5eVUzVmlhbVZqZENnbkp5azdYRzRnSUdOdmJuTjBJR0ZqZEdsMllYUmxaQ0E5WEc0Z0lDQWdJQ0J1WlhjZ1FXTjBhWFpoZEdWa1VtOTFkR1VvWlcxd2RIbFZjbXdzSUdWdGNIUjVVR0Z5WVcxekxDQlFVa2xOUVZKWlgwOVZWRXhGVkN3Z2NtOXZkRU52YlhCdmJtVnVkQ3dnYzI1aGNITm9iM1F1Y205dmRDazdYRzRnSUdGamRHbDJZWFJsWkM1emJtRndjMmh2ZENBOUlITnVZWEJ6YUc5MExuSnZiM1E3WEc0Z0lISmxkSFZ5YmlCdVpYY2dVbTkxZEdWeVUzUmhkR1VvWEc0Z0lDQWdJQ0J1WlhjZ1ZISmxaVTV2WkdVOFFXTjBhWFpoZEdWa1VtOTFkR1UrS0dGamRHbDJZWFJsWkN3Z1cxMHBMQ0JsYlhCMGVWRjFaWEo1VUdGeVlXMXpMQ0JtY21GbmJXVnVkQ3dnYzI1aGNITm9iM1FwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJqY21WaGRHVkZiWEIwZVZOMFlYUmxVMjVoY0hOb2IzUW9kWEpzVkhKbFpUb2dWWEpzVkhKbFpTd2djbTl2ZEVOdmJYQnZibVZ1ZERvZ1ZIbHdaU2s2SUZKdmRYUmxjbE4wWVhSbFUyNWhjSE5vYjNRZ2UxeHVJQ0JqYjI1emRDQmxiWEIwZVZCaGNtRnRjeUE5SUh0OU8xeHVJQ0JqYjI1emRDQmxiWEIwZVZGMVpYSjVVR0Z5WVcxeklEMGdlMzA3WEc0Z0lHTnZibk4wSUdaeVlXZHRaVzUwSUQwZ0p5YzdYRzRnSUdOdmJuTjBJR0ZqZEdsMllYUmxaQ0E5SUc1bGR5QkJZM1JwZG1GMFpXUlNiM1YwWlZOdVlYQnphRzkwS0Z4dUlDQWdJQ0FnVzEwc0lHVnRjSFI1VUdGeVlXMXpMQ0JRVWtsTlFWSlpYMDlWVkV4RlZDd2djbTl2ZEVOdmJYQnZibVZ1ZEN3Z2JuVnNiQ3dnZFhKc1ZISmxaUzV5YjI5MExDQXRNU2s3WEc0Z0lISmxkSFZ5YmlCdVpYY2dVbTkxZEdWeVUzUmhkR1ZUYm1Gd2MyaHZkQ2hjYmlBZ0lDQWdJQ2NuTENCdVpYY2dWSEpsWlU1dlpHVThRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZEQ0b1lXTjBhWFpoZEdWa0xDQmJYU2tzSUdWdGNIUjVVWFZsY25sUVlYSmhiWE1zSUdaeVlXZHRaVzUwS1R0Y2JuMWNibHh1THlvcVhHNGdLaUJEYjI1MFlXbHVjeUIwYUdVZ2FXNW1iM0p0WVhScGIyNGdZV0p2ZFhRZ1lTQmpiMjF3YjI1bGJuUWdiRzloWkdWa0lHbHVJR0Z1SUc5MWRHeGxkQzRnVkdobElHbHVabTl5YldGMGFXOXVJR2x6SUhCeWIzWnBaR1ZrWEc0Z0tpQjBhSEp2ZFdkb1hHNGdLaUIwYUdVZ2NHRnlZVzF6SUdGdVpDQjFjbXhUWldkdFpXNTBjeUJ2WW5ObGNuWmhZbXhsY3k1Y2JpQXFYRzRnS2lBakl5TWdWWE5oWjJWY2JpQXFYRzRnS2lCZ1lHQmNiaUFxSUdOc1lYTnpJRTE1UTI5dGNHOXVaVzUwSUh0Y2JpQXFJQ0FnWTI5dWMzUnlkV04wYjNJb2NtOTFkR1U2SUVGamRHbDJZWFJsWkZKdmRYUmxLU0I3WEc0Z0tpQWdJQ0FnWTI5dWMzUWdhV1E2SUU5aWMyVnlkbUZpYkdVOGMzUnlhVzVuUGlBOUlISnZkWFJsTG5CaGNtRnRjeTV0WVhBb2NDQTlQaUJ3TG1sa0tUdGNiaUFxSUNBZ2ZWeHVJQ29nZlZ4dUlDb2dZR0JnWEc0Z0tpOWNibVY0Y0c5eWRDQmpiR0Z6Y3lCQlkzUnBkbUYwWldSU2IzVjBaU0I3WEc0Z0lDOHFLaUJBYVc1MFpYSnVZV3dnS2k5Y2JpQWdYMloxZEhWeVpWTnVZWEJ6YUc5ME9pQkJZM1JwZG1GMFpXUlNiM1YwWlZOdVlYQnphRzkwTzF4dUlDQnpibUZ3YzJodmREb2dRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZER0Y2JseHVJQ0F2S2lwY2JpQWdJQ29nUUdsdWRHVnlibUZzWEc0Z0lDQXFMMXh1SUNCamIyNXpkSEoxWTNSdmNpaGNiaUFnSUNBZ0lIQjFZbXhwWXlCMWNtdzZJRTlpYzJWeWRtRmliR1U4VlhKc1VHRjBhRmRwZEdoUVlYSmhiWE5iWFQ0c0lIQjFZbXhwWXlCd1lYSmhiWE02SUU5aWMyVnlkbUZpYkdVOFVHRnlZVzF6UGl4Y2JpQWdJQ0FnSUhCMVlteHBZeUJ2ZFhSc1pYUTZJSE4wY21sdVp5d2djSFZpYkdsaklHTnZiWEJ2Ym1WdWREb2dWSGx3Wlh4emRISnBibWNzWEc0Z0lDQWdJQ0JtZFhSMWNtVlRibUZ3YzJodmREb2dRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZENrZ2UxeHVJQ0FnSUhSb2FYTXVYMloxZEhWeVpWTnVZWEJ6YUc5MElEMGdablYwZFhKbFUyNWhjSE5vYjNRN1hHNGdJSDFjYmx4dUlDQjBiMU4wY21sdVp5Z3BPaUJ6ZEhKcGJtY2dlMXh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpMbk51WVhCemFHOTBJRDhnZEdocGN5NXpibUZ3YzJodmRDNTBiMU4wY21sdVp5Z3BJRG9nWUVaMWRIVnlaU2drZTNSb2FYTXVYMloxZEhWeVpWTnVZWEJ6YUc5MGZTbGdPMXh1SUNCOVhHNTlYRzVjYmk4cUtseHVJQ29nUTI5dWRHRnBibk1nZEdobElHbHVabTl5YldGMGFXOXVJR0ZpYjNWMElHRWdZMjl0Y0c5dVpXNTBJR3h2WVdSbFpDQnBiaUJoYmlCdmRYUnNaWFFnWVhRZ1lTQndZWEowYVdOMWJHRnlJRzF2YldWdWRDQnBiaUIwYVcxbExseHVJQ3BjYmlBcUlDTWpJeUJWYzJGblpWeHVJQ3BjYmlBcUlHQmdZRnh1SUNvZ1kyeGhjM01nVFhsRGIyMXdiMjVsYm5RZ2UxeHVJQ29nSUNCamIyNXpkSEoxWTNSdmNpaHliM1YwWlRvZ1FXTjBhWFpoZEdWa1VtOTFkR1VwSUh0Y2JpQXFJQ0FnSUNCamIyNXpkQ0JwWkRvZ2MzUnlhVzVuSUQwZ2NtOTFkR1V1YzI1aGNITm9iM1F1Y0dGeVlXMXpMbWxrTzF4dUlDb2dJQ0I5WEc0Z0tpQjlYRzRnS2lCZ1lHQmNiaUFxTDF4dVpYaHdiM0owSUdOc1lYTnpJRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRZ2UxeHVJQ0F2S2lwY2JpQWdJQ29nUUdsdWRHVnlibUZzWEc0Z0lDQXFMMXh1SUNCZmNtVnpiMngyWldSRGIyMXdiMjVsYm5SR1lXTjBiM0o1T2lCRGIyMXdiMjVsYm5SR1lXTjBiM0o1UEdGdWVUNDdYRzVjYmlBZ0x5b3FJRUJwYm5SbGNtNWhiQ0FxS2k5Y2JpQWdYM0p2ZFhSbFEyOXVabWxuT2lCU2IzVjBaVHRjYmx4dUlDQXZLaW9nUUdsdWRHVnlibUZzSUNvcUwxeHVJQ0JmZFhKc1UyVm5iV1Z1ZERvZ1ZYSnNVMlZuYldWdWREdGNibHh1SUNCZmJHRnpkRkJoZEdoSmJtUmxlRG9nYm5WdFltVnlPMXh1WEc0Z0lDOHFLbHh1SUNBZ0tpQkFhVzUwWlhKdVlXeGNiaUFnSUNvdlhHNGdJR052Ym5OMGNuVmpkRzl5S0Z4dUlDQWdJQ0FnY0hWaWJHbGpJSFZ5YkRvZ1ZYSnNVR0YwYUZkcGRHaFFZWEpoYlhOYlhTd2djSFZpYkdsaklIQmhjbUZ0Y3pvZ1VHRnlZVzF6TENCd2RXSnNhV01nYjNWMGJHVjBPaUJ6ZEhKcGJtY3NYRzRnSUNBZ0lDQndkV0pzYVdNZ1kyOXRjRzl1Wlc1ME9pQlVlWEJsZkhOMGNtbHVaeXdnY205MWRHVkRiMjVtYVdjNklGSnZkWFJsTENCMWNteFRaV2R0Wlc1ME9pQlZjbXhUWldkdFpXNTBMRnh1SUNBZ0lDQWdiR0Z6ZEZCaGRHaEpibVJsZURvZ2JuVnRZbVZ5S1NCN1hHNGdJQ0FnZEdocGN5NWZjbTkxZEdWRGIyNW1hV2NnUFNCeWIzVjBaVU52Ym1acFp6dGNiaUFnSUNCMGFHbHpMbDkxY214VFpXZHRaVzUwSUQwZ2RYSnNVMlZuYldWdWREdGNiaUFnSUNCMGFHbHpMbDlzWVhOMFVHRjBhRWx1WkdWNElEMGdiR0Z6ZEZCaGRHaEpibVJsZUR0Y2JpQWdmVnh1WEc0Z0lIUnZVM1J5YVc1bktDazZJSE4wY21sdVp5QjdYRzRnSUNBZ1kyOXVjM1FnZFhKc0lEMGdkR2hwY3k1MWNtd3ViV0Z3S0hNZ1BUNGdjeTUwYjFOMGNtbHVaeWdwS1M1cWIybHVLQ2N2SnlrN1hHNGdJQ0FnWTI5dWMzUWdiV0YwWTJobFpDQTlJSFJvYVhNdVgzSnZkWFJsUTI5dVptbG5JRDhnZEdocGN5NWZjbTkxZEdWRGIyNW1hV2N1Y0dGMGFDQTZJQ2NuTzF4dUlDQWdJSEpsZEhWeWJpQmdVbTkxZEdVb2RYSnNPaWNrZTNWeWJIMG5MQ0J3WVhSb09pY2tlMjFoZEdOb1pXUjlKeWxnTzF4dUlDQjlYRzU5WEc1Y2JpOHFLbHh1SUNvZ1ZHaGxJSE4wWVhSbElHOW1JSFJvWlNCeWIzVjBaWElnWVhRZ1lTQndZWEowYVdOMWJHRnlJRzF2YldWdWRDQnBiaUIwYVcxbExseHVJQ3BjYmlBcUlDTWpJeUJWYzJGblpWeHVJQ3BjYmlBcUlHQmdZRnh1SUNvZ1kyeGhjM01nVFhsRGIyMXdiMjVsYm5RZ2UxeHVJQ29nSUNCamIyNXpkSEoxWTNSdmNpaHliM1YwWlhJNklGSnZkWFJsY2lrZ2UxeHVJQ29nSUNBZ0lHTnZibk4wSUhOdVlYQnphRzkwSUQwZ2NtOTFkR1Z5TG5KdmRYUmxjbE4wWVhSbExuTnVZWEJ6YUc5ME8xeHVJQ29nSUNCOVhHNGdLaUI5WEc0Z0tpQmdZR0JjYmlBcUwxeHVaWGh3YjNKMElHTnNZWE56SUZKdmRYUmxjbE4wWVhSbFUyNWhjSE5vYjNRZ1pYaDBaVzVrY3lCVWNtVmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0lIdGNiaUFnTHlvcVhHNGdJQ0FxSUVCcGJuUmxjbTVoYkZ4dUlDQWdLaTljYmlBZ1kyOXVjM1J5ZFdOMGIzSW9YRzRnSUNBZ0lDQndkV0pzYVdNZ2RYSnNPaUJ6ZEhKcGJtY3NJSEp2YjNRNklGUnlaV1ZPYjJSbFBFRmpkR2wyWVhSbFpGSnZkWFJsVTI1aGNITm9iM1ErTENCd2RXSnNhV01nY1hWbGNubFFZWEpoYlhNNklGQmhjbUZ0Y3l4Y2JpQWdJQ0FnSUhCMVlteHBZeUJtY21GbmJXVnVkRG9nYzNSeWFXNW5LU0I3WEc0Z0lDQWdjM1Z3WlhJb2NtOXZkQ2s3WEc0Z0lIMWNibHh1SUNCMGIxTjBjbWx1WnlncE9pQnpkSEpwYm1jZ2V5QnlaWFIxY200Z2MyVnlhV0ZzYVhwbFRtOWtaU2gwYUdsekxsOXliMjkwS1RzZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCelpYSnBZV3hwZW1WT2IyUmxLRzV2WkdVNklGUnlaV1ZPYjJSbFBFRmpkR2wyWVhSbFpGSnZkWFJsVTI1aGNITm9iM1ErS1RvZ2MzUnlhVzVuSUh0Y2JpQWdZMjl1YzNRZ1l5QTlJRzV2WkdVdVkyaHBiR1J5Wlc0dWJHVnVaM1JvSUQ0Z01DQS9JR0FnZXlBa2UyNXZaR1V1WTJocGJHUnlaVzR1YldGd0tITmxjbWxoYkdsNlpVNXZaR1VwTG1wdmFXNG9YQ0lzSUZ3aUtYMGdmU0JnSURvZ0p5YzdYRzRnSUhKbGRIVnliaUJnSkh0dWIyUmxMblpoYkhWbGZTUjdZMzFnTzF4dWZWeHVYRzVjYmk4cUtseHVJQ29nVkdobElHVjRjR1ZqZEdGMGFXOXVJR2x6SUhSb1lYUWdkR2hsSUdGamRHbDJZWFJsSUhKdmRYUmxJR2x6SUdOeVpXRjBaV1FnZDJsMGFDQjBhR1VnY21sbmFIUWdjMlYwSUc5bUlIQmhjbUZ0WlhSbGNuTXVYRzRnS2lCVGJ5QjNaU0J3ZFhOb0lHNWxkeUIyWVd4MVpYTWdhVzUwYnlCMGFHVWdiMkp6WlhKMllXSnNaWE1nYjI1c2VTQjNhR1Z1SUhSb1pYa2dZWEpsSUc1dmRDQjBhR1VnYVc1cGRHbGhiQ0IyWVd4MVpYTXVYRzRnS2lCQmJtUWdkMlVnWkdWMFpXTjBJSFJvWVhRZ1lua2dZMmhsWTJ0cGJtY2dhV1lnZEdobElITnVZWEJ6YUc5MElHWnBaV3hrSUdseklITmxkQzVjYmlBcUwxeHVaWGh3YjNKMElHWjFibU4wYVc5dUlHRmtkbUZ1WTJWQlkzUnBkbUYwWldSU2IzVjBaU2h5YjNWMFpUb2dRV04wYVhaaGRHVmtVbTkxZEdVcE9pQjJiMmxrSUh0Y2JpQWdhV1lnS0hKdmRYUmxMbk51WVhCemFHOTBJQ1ltSUNGemFHRnNiRzkzUlhGMVlXd29jbTkxZEdVdWMyNWhjSE5vYjNRdWNHRnlZVzF6TENCeWIzVjBaUzVmWm5WMGRYSmxVMjVoY0hOb2IzUXVjR0Z5WVcxektTa2dlMXh1SUNBZ0lISnZkWFJsTG5OdVlYQnphRzkwSUQwZ2NtOTFkR1V1WDJaMWRIVnlaVk51WVhCemFHOTBPMXh1SUNBZ0lDZzhZVzU1UG5KdmRYUmxMblZ5YkNrdWJtVjRkQ2h5YjNWMFpTNXpibUZ3YzJodmRDNTFjbXdwTzF4dUlDQWdJQ2c4WVc1NVBuSnZkWFJsTG5CaGNtRnRjeWt1Ym1WNGRDaHliM1YwWlM1emJtRndjMmh2ZEM1d1lYSmhiWE1wTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKdmRYUmxMbk51WVhCemFHOTBJRDBnY205MWRHVXVYMloxZEhWeVpWTnVZWEJ6YUc5ME8xeHVJQ0I5WEc1OUlsMTlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvcm91dGVyX3N0YXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBUcmVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlKHJvb3QpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmVlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb290LnZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUcmVlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucGF0aEZyb21Sb290KHQpO1xuICAgICAgICByZXR1cm4gcC5sZW5ndGggPiAxID8gcFtwLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIG4gPSBmaW5kTm9kZSh0LCB0aGlzLl9yb290KTtcbiAgICAgICAgcmV0dXJuIG4gPyBuLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC52YWx1ZTsgfSkgOiBbXTtcbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgbiA9IGZpbmROb2RlKHQsIHRoaXMuX3Jvb3QpO1xuICAgICAgICByZXR1cm4gbiAmJiBuLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyBuLmNoaWxkcmVuWzBdLnZhbHVlIDogbnVsbDtcbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLnNpYmxpbmdzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHAgPSBmaW5kUGF0aCh0LCB0aGlzLl9yb290LCBbXSk7XG4gICAgICAgIGlmIChwLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHZhciBjID0gcFtwLmxlbmd0aCAtIDJdLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy52YWx1ZTsgfSk7XG4gICAgICAgIHJldHVybiBjLmZpbHRlcihmdW5jdGlvbiAoY2MpIHsgcmV0dXJuIGNjICE9PSB0OyB9KTtcbiAgICB9O1xuICAgIFRyZWUucHJvdG90eXBlLnBhdGhGcm9tUm9vdCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmaW5kUGF0aCh0LCB0aGlzLl9yb290LCBbXSkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZhbHVlOyB9KTsgfTtcbiAgICBUcmVlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh0cmVlKSB7IHJldHVybiBjb250YWlucyh0aGlzLl9yb290LCB0cmVlLl9yb290KTsgfTtcbiAgICByZXR1cm4gVHJlZTtcbn0oKSk7XG5leHBvcnRzLlRyZWUgPSBUcmVlO1xuZnVuY3Rpb24gZmluZE5vZGUoZXhwZWN0ZWQsIGMpIHtcbiAgICBpZiAoZXhwZWN0ZWQgPT09IGMudmFsdWUpXG4gICAgICAgIHJldHVybiBjO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2MgPSBfYVtfaV07XG4gICAgICAgIHZhciByID0gZmluZE5vZGUoZXhwZWN0ZWQsIGNjKTtcbiAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kUGF0aChleHBlY3RlZCwgYywgY29sbGVjdGVkKSB7XG4gICAgY29sbGVjdGVkLnB1c2goYyk7XG4gICAgaWYgKGV4cGVjdGVkID09PSBjLnZhbHVlKVxuICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2MgPSBfYVtfaV07XG4gICAgICAgIHZhciBjbG9uZWQgPSBjb2xsZWN0ZWQuc2xpY2UoMCk7XG4gICAgICAgIHZhciByID0gZmluZFBhdGgoZXhwZWN0ZWQsIGNjLCBjbG9uZWQpO1xuICAgICAgICBpZiAocilcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjb250YWlucyh0cmVlLCBzdWJ0cmVlKSB7XG4gICAgaWYgKHRyZWUudmFsdWUgIT09IHN1YnRyZWUudmFsdWUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uKHN1YnRyZWVOb2RlKSB7XG4gICAgICAgIHZhciBzID0gdHJlZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52YWx1ZSA9PT0gc3VidHJlZU5vZGUudmFsdWU7IH0pO1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZmFsc2UgfTtcbiAgICAgICAgaWYgKCFjb250YWlucyhzWzBdLCBzdWJ0cmVlTm9kZSkpXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZmFsc2UgfTtcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdWJ0cmVlLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc3VidHJlZU5vZGUgPSBfYVtfaV07XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShzdWJ0cmVlTm9kZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIFRyZWVOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlTm9kZSh2YWx1ZSwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVHJlZU5vZGUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7IH07XG4gICAgcmV0dXJuIFRyZWVOb2RlO1xufSgpKTtcbmV4cG9ydHMuVHJlZU5vZGUgPSBUcmVlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmxaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OTFkR2xzY3k5MGNtVmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEpRVWxGTEdOQlFWa3NTVUZCYVVJN1VVRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVRkRMRU5CUVVNN1NVRkZja1FzYzBKQlFVa3NjMEpCUVVrN1lVRkJVaXhqUVVGblFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZET3pzN1QwRkJRVHRKUVVVeFF5eHhRa0ZCVFN4SFFVRk9MRlZCUVU4c1EwRkJTVHRSUVVOVUxFbEJRVTBzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGREwwSXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTXZReXhEUVVGRE8wbEJSVVFzZFVKQlFWRXNSMEZCVWl4VlFVRlRMRU5CUVVrN1VVRkRXQ3hKUVVGTkxFTkJRVU1zUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU5zUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVFc1EwRkJReXhKUVVGSkxFOUJRVUVzUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCVUN4RFFVRlBMRU5CUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU03U1VGREwwTXNRMEZCUXp0SlFVVkVMSGxDUVVGVkxFZEJRVllzVlVGQlZ5eERRVUZKTzFGQlEySXNTVUZCVFN4RFFVRkRMRWRCUVVjc1VVRkJVU3hEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRiRU1zVFVGQlRTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRPMGxCUTJwRkxFTkJRVU03U1VGRlJDeDFRa0ZCVVN4SFFVRlNMRlZCUVZNc1EwRkJTVHRSUVVOWUxFbEJRVTBzUTBGQlF5eEhRVUZITEZGQlFWRXNRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTjBReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVGRExFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTTdVVUZGTlVJc1NVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkJMRU5CUVVNc1NVRkJTU3hQUVVGQkxFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFWQXNRMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRja1FzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJRU3hGUVVGRkxFbEJRVWtzVDBGQlFTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RlFVRlNMRU5CUVZFc1EwRkJReXhEUVVGRE8wbEJRMnhETEVOQlFVTTdTVUZGUkN3eVFrRkJXU3hIUVVGYUxGVkJRV0VzUTBGQlNTeEpRVUZUTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVUVzUTBGQlF5eEpRVUZKTEU5QlFVRXNRMEZCUXl4RFFVRkRMRXRCUVVzc1JVRkJVQ3hEUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGYWtZc2RVSkJRVkVzUjBGQlVpeFZRVUZUTEVsQlFXRXNTVUZCWVN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU12UlN4WFFVRkRPMEZCUVVRc1EwRkJReXhCUVd4RFJDeEpRV3REUXp0QlFXeERXU3haUVVGSkxFOUJhME5vUWl4RFFVRkJPMEZCUlVRc2EwSkJRWEZDTEZGQlFWY3NSVUZCUlN4RFFVRmpPMGxCUXpsRExFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNTMEZCU3l4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTnVReXhIUVVGSExFTkJRVU1zUTBGQlZ5eFZRVUZWTEVWQlFWWXNTMEZCUVN4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGV0xHTkJRVlVzUlVGQlZpeEpRVUZWTEVOQlFVTTdVVUZCY2tJc1NVRkJTU3hGUVVGRkxGTkJRVUU3VVVGRFZDeEpRVUZOTEVOQlFVTXNSMEZCUnl4UlFVRlJMRU5CUVVNc1VVRkJVU3hGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEycERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1MwRkRha0k3U1VGRFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVVWRUxHdENRVUZ4UWl4UlFVRlhMRVZCUVVVc1EwRkJZeXhGUVVGRkxGTkJRWGRDTzBsQlEzaEZMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEYkVJc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeExRVUZMTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzBsQlJUTkRMRWRCUVVjc1EwRkJReXhEUVVGWExGVkJRVlVzUlVGQlZpeExRVUZCTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVZZc1kwRkJWU3hGUVVGV0xFbEJRVlVzUTBGQlF6dFJRVUZ5UWl4SlFVRkpMRVZCUVVVc1UwRkJRVHRSUVVOVUxFbEJRVTBzVFVGQlRTeEhRVUZITEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJFTXNTVUZCVFN4RFFVRkRMRWRCUVVjc1VVRkJVU3hEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZGTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRla01zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dExRVU5xUWp0SlFVVkVMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03UVVGRFdpeERRVUZETzBGQlJVUXNhMEpCUVhGQ0xFbEJRV2xDTEVWQlFVVXNUMEZCYjBJN1NVRkRNVVFzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1MwRkJTeXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzFGQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVVdlF6dFJRVU5GTEVsQlFVMHNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFVRXNTMEZCU3l4SlFVRkpMRTlCUVVFc1MwRkJTeXhEUVVGRExFdEJRVXNzUzBGQlN5eFhRVUZYTEVOQlFVTXNTMEZCU3l4RlFVRnFReXhEUVVGcFF5eERRVUZETEVOQlFVTTdVVUZETTBVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkJReXhuUWtGQlR5eExRVUZMTEVkQlFVTTdVVUZEYWtNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxGZEJRVmNzUTBGQlF5eERRVUZETzFsQlFVTXNaMEpCUVU4c1MwRkJTeXhIUVVGRE96dEpRVWhxUkN4SFFVRkhMRU5CUVVNc1EwRkJiMElzVlVGQlowSXNSVUZCYUVJc1MwRkJRU3hQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZvUWl4alFVRm5RaXhGUVVGb1FpeEpRVUZuUWl4RFFVRkRPMUZCUVhCRExFbEJRVWtzVjBGQlZ5eFRRVUZCT3pzN1MwRkpia0k3U1VGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVVWRU8wbEJRMFVzYTBKQlFXMUNMRXRCUVZFc1JVRkJVeXhSUVVGMVFqdFJRVUY0UXl4VlFVRkxMRWRCUVV3c1MwRkJTeXhEUVVGSE8xRkJRVk1zWVVGQlVTeEhRVUZTTEZGQlFWRXNRMEZCWlR0SlFVRkhMRU5CUVVNN1NVRkZMMFFzTWtKQlFWRXNSMEZCVWl4alFVRnhRaXhOUVVGTkxFTkJRVU1zWTBGQldTeEpRVUZKTEVOQlFVTXNTMEZCU3l4TlFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZFTEdWQlFVTTdRVUZCUkN4RFFVRkRMRUZCU2tRc1NVRkpRenRCUVVwWkxHZENRVUZSTEZkQlNYQkNMRU5CUVVFaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmxlSEJ2Y25RZ1kyeGhjM01nVkhKbFpUeFVQaUI3WEc0Z0lDOHFLaUJBYVc1MFpYSnVZV3dnS2k5Y2JpQWdYM0p2YjNRNklGUnlaV1ZPYjJSbFBGUStPMXh1WEc0Z0lHTnZibk4wY25WamRHOXlLSEp2YjNRNklGUnlaV1ZPYjJSbFBGUStLU0I3SUhSb2FYTXVYM0p2YjNRZ1BTQnliMjkwT3lCOVhHNWNiaUFnWjJWMElISnZiM1FvS1RvZ1ZDQjdJSEpsZEhWeWJpQjBhR2x6TGw5eWIyOTBMblpoYkhWbE95QjlYRzVjYmlBZ2NHRnlaVzUwS0hRNklGUXBPaUJVSUh0Y2JpQWdJQ0JqYjI1emRDQndJRDBnZEdocGN5NXdZWFJvUm5KdmJWSnZiM1FvZENrN1hHNGdJQ0FnY21WMGRYSnVJSEF1YkdWdVozUm9JRDRnTVNBL0lIQmJjQzVzWlc1bmRHZ2dMU0F5WFNBNklHNTFiR3c3WEc0Z0lIMWNibHh1SUNCamFHbHNaSEpsYmloME9pQlVLVG9nVkZ0ZElIdGNiaUFnSUNCamIyNXpkQ0J1SUQwZ1ptbHVaRTV2WkdVb2RDd2dkR2hwY3k1ZmNtOXZkQ2s3WEc0Z0lDQWdjbVYwZFhKdUlHNGdQeUJ1TG1Ob2FXeGtjbVZ1TG0xaGNDaDBJRDArSUhRdWRtRnNkV1VwSURvZ1cxMDdYRzRnSUgxY2JseHVJQ0JtYVhKemRFTm9hV3hrS0hRNklGUXBPaUJVSUh0Y2JpQWdJQ0JqYjI1emRDQnVJRDBnWm1sdVpFNXZaR1VvZEN3Z2RHaHBjeTVmY205dmRDazdYRzRnSUNBZ2NtVjBkWEp1SUc0Z0ppWWdiaTVqYUdsc1pISmxiaTVzWlc1bmRHZ2dQaUF3SUQ4Z2JpNWphR2xzWkhKbGJsc3dYUzUyWVd4MVpTQTZJRzUxYkd3N1hHNGdJSDFjYmx4dUlDQnphV0pzYVc1bmN5aDBPaUJVS1RvZ1ZGdGRJSHRjYmlBZ0lDQmpiMjV6ZENCd0lEMGdabWx1WkZCaGRHZ29kQ3dnZEdocGN5NWZjbTl2ZEN3Z1cxMHBPMXh1SUNBZ0lHbG1JQ2h3TG14bGJtZDBhQ0E4SURJcElISmxkSFZ5YmlCYlhUdGNibHh1SUNBZ0lHTnZibk4wSUdNZ1BTQndXM0F1YkdWdVozUm9JQzBnTWwwdVkyaHBiR1J5Wlc0dWJXRndLR01nUFQ0Z1l5NTJZV3gxWlNrN1hHNGdJQ0FnY21WMGRYSnVJR011Wm1sc2RHVnlLR05qSUQwK0lHTmpJQ0U5UFNCMEtUdGNiaUFnZlZ4dVhHNGdJSEJoZEdoR2NtOXRVbTl2ZENoME9pQlVLVG9nVkZ0ZElIc2djbVYwZFhKdUlHWnBibVJRWVhSb0tIUXNJSFJvYVhNdVgzSnZiM1FzSUZ0ZEtTNXRZWEFvY3lBOVBpQnpMblpoYkhWbEtUc2dmVnh1WEc0Z0lHTnZiblJoYVc1ektIUnlaV1U2SUZSeVpXVThWRDRwT2lCaWIyOXNaV0Z1SUhzZ2NtVjBkWEp1SUdOdmJuUmhhVzV6S0hSb2FYTXVYM0p2YjNRc0lIUnlaV1V1WDNKdmIzUXBPeUI5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1pwYm1ST2IyUmxQRlErS0dWNGNHVmpkR1ZrT2lCVUxDQmpPaUJVY21WbFRtOWtaVHhVUGlrNklGUnlaV1ZPYjJSbFBGUStJSHRjYmlBZ2FXWWdLR1Y0Y0dWamRHVmtJRDA5UFNCakxuWmhiSFZsS1NCeVpYUjFjbTRnWXp0Y2JpQWdabTl5SUNoc1pYUWdZMk1nYjJZZ1l5NWphR2xzWkhKbGJpa2dlMXh1SUNBZ0lHTnZibk4wSUhJZ1BTQm1hVzVrVG05a1pTaGxlSEJsWTNSbFpDd2dZMk1wTzF4dUlDQWdJR2xtSUNoeUtTQnlaWFIxY200Z2NqdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2JuVnNiRHRjYm4xY2JseHVablZ1WTNScGIyNGdabWx1WkZCaGRHZzhWRDRvWlhod1pXTjBaV1E2SUZRc0lHTTZJRlJ5WldWT2IyUmxQRlErTENCamIyeHNaV04wWldRNklGUnlaV1ZPYjJSbFBGUStXMTBwT2lCVWNtVmxUbTlrWlR4VVBsdGRJSHRjYmlBZ1kyOXNiR1ZqZEdWa0xuQjFjMmdvWXlrN1hHNGdJR2xtSUNobGVIQmxZM1JsWkNBOVBUMGdZeTUyWVd4MVpTa2djbVYwZFhKdUlHTnZiR3hsWTNSbFpEdGNibHh1SUNCbWIzSWdLR3hsZENCall5QnZaaUJqTG1Ob2FXeGtjbVZ1S1NCN1hHNGdJQ0FnWTI5dWMzUWdZMnh2Ym1Wa0lEMGdZMjlzYkdWamRHVmtMbk5zYVdObEtEQXBPMXh1SUNBZ0lHTnZibk4wSUhJZ1BTQm1hVzVrVUdGMGFDaGxlSEJsWTNSbFpDd2dZMk1zSUdOc2IyNWxaQ2s3WEc0Z0lDQWdhV1lnS0hJcElISmxkSFZ5YmlCeU8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlGdGRPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpiMjUwWVdsdWN6eFVQaWgwY21WbE9pQlVjbVZsVG05a1pUeFVQaXdnYzNWaWRISmxaVG9nVkhKbFpVNXZaR1U4VkQ0cE9pQmliMjlzWldGdUlIdGNiaUFnYVdZZ0tIUnlaV1V1ZG1Gc2RXVWdJVDA5SUhOMVluUnlaV1V1ZG1Gc2RXVXBJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JseHVJQ0JtYjNJZ0tHeGxkQ0J6ZFdKMGNtVmxUbTlrWlNCdlppQnpkV0owY21WbExtTm9hV3hrY21WdUtTQjdYRzRnSUNBZ1kyOXVjM1FnY3lBOUlIUnlaV1V1WTJocGJHUnlaVzR1Wm1sc2RHVnlLR05vYVd4a0lEMCtJR05vYVd4a0xuWmhiSFZsSUQwOVBTQnpkV0owY21WbFRtOWtaUzUyWVd4MVpTazdYRzRnSUNBZ2FXWWdLSE11YkdWdVozUm9JRDA5UFNBd0tTQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lDQWdhV1lnS0NGamIyNTBZV2x1Y3loeld6QmRMQ0J6ZFdKMGNtVmxUbTlrWlNrcElISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUIwY25WbE8xeHVmVnh1WEc1bGVIQnZjblFnWTJ4aGMzTWdWSEpsWlU1dlpHVThWRDRnZTF4dUlDQmpiMjV6ZEhKMVkzUnZjaWh3ZFdKc2FXTWdkbUZzZFdVNklGUXNJSEIxWW14cFl5QmphR2xzWkhKbGJqb2dWSEpsWlU1dlpHVThWRDViWFNrZ2UzMWNibHh1SUNCMGIxTjBjbWx1WnlncE9pQnpkSEpwYm1jZ2V5QnlaWFIxY200Z1lGUnlaV1ZPYjJSbEtDUjdkR2hwY3k1MllXeDFaWDBwWURzZ2ZWeHVmU0pkZlE9PVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bhbmd1bGFyL3JvdXRlci91dGlscy90cmVlLmpzXG4gKiogbW9kdWxlIGlkID0gNDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XG52YXIgdXJsX3RyZWVfMSA9IHJlcXVpcmUoJy4vdXJsX3RyZWUnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWxzL2NvbGxlY3Rpb24nKTtcbmZ1bmN0aW9uIGNyZWF0ZVVybFRyZWUocm91dGUsIHVybFRyZWUsIGNvbW1hbmRzLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpIHtcbiAgICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cmVlKHVybFRyZWUucm9vdCwgdXJsVHJlZS5yb290LCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENvbW1hbmRzID0gbm9ybWFsaXplQ29tbWFuZHMoY29tbWFuZHMpO1xuICAgIGlmIChuYXZpZ2F0ZVRvUm9vdChub3JtYWxpemVkQ29tbWFuZHMpKSB7XG4gICAgICAgIHJldHVybiB0cmVlKHVybFRyZWUucm9vdCwgbmV3IHVybF90cmVlXzEuVXJsU2VnbWVudChbXSwge30pLCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRpbmdQb3NpdGlvbiA9IGZpbmRTdGFydGluZ1Bvc2l0aW9uKG5vcm1hbGl6ZWRDb21tYW5kcywgdXJsVHJlZSwgcm91dGUpO1xuICAgIHZhciBzZWdtZW50ID0gc3RhcnRpbmdQb3NpdGlvbi5wcm9jZXNzQ2hpbGRyZW4gP1xuICAgICAgICB1cGRhdGVTZWdtZW50Q2hpbGRyZW4oc3RhcnRpbmdQb3NpdGlvbi5zZWdtZW50LCBzdGFydGluZ1Bvc2l0aW9uLmluZGV4LCBub3JtYWxpemVkQ29tbWFuZHMuY29tbWFuZHMpIDpcbiAgICAgICAgdXBkYXRlU2VnbWVudChzdGFydGluZ1Bvc2l0aW9uLnNlZ21lbnQsIHN0YXJ0aW5nUG9zaXRpb24uaW5kZXgsIG5vcm1hbGl6ZWRDb21tYW5kcy5jb21tYW5kcyk7XG4gICAgcmV0dXJuIHRyZWUoc3RhcnRpbmdQb3NpdGlvbi5zZWdtZW50LCBzZWdtZW50LCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xufVxuZXhwb3J0cy5jcmVhdGVVcmxUcmVlID0gY3JlYXRlVXJsVHJlZTtcbmZ1bmN0aW9uIHRyZWUob2xkU2VnbWVudCwgbmV3U2VnbWVudCwgdXJsVHJlZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KSB7XG4gICAgdmFyIHEgPSBxdWVyeVBhcmFtcyA/IHN0cmluZ2lmeShxdWVyeVBhcmFtcykgOiB1cmxUcmVlLnF1ZXJ5UGFyYW1zO1xuICAgIHZhciBmID0gZnJhZ21lbnQgPyBmcmFnbWVudCA6IHVybFRyZWUuZnJhZ21lbnQ7XG4gICAgaWYgKHVybFRyZWUucm9vdCA9PT0gb2xkU2VnbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IHVybF90cmVlXzEuVXJsVHJlZShuZXdTZWdtZW50LCBxLCBmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxUcmVlKHJlcGxhY2VTZWdtZW50KHVybFRyZWUucm9vdCwgb2xkU2VnbWVudCwgbmV3U2VnbWVudCksIHEsIGYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VTZWdtZW50KGN1cnJlbnQsIG9sZFNlZ21lbnQsIG5ld1NlZ21lbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB7fTtcbiAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChjdXJyZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoYywgb3V0bGV0TmFtZSkge1xuICAgICAgICBpZiAoYyA9PT0gb2xkU2VnbWVudCkge1xuICAgICAgICAgICAgY2hpbGRyZW5bb3V0bGV0TmFtZV0gPSBuZXdTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hpbGRyZW5bb3V0bGV0TmFtZV0gPSByZXBsYWNlU2VnbWVudChjLCBvbGRTZWdtZW50LCBuZXdTZWdtZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KGN1cnJlbnQucGF0aHNXaXRoUGFyYW1zLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBuYXZpZ2F0ZVRvUm9vdChub3JtYWxpemVkQ2hhbmdlKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRDaGFuZ2UuaXNBYnNvbHV0ZSAmJiBub3JtYWxpemVkQ2hhbmdlLmNvbW1hbmRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBub3JtYWxpemVkQ2hhbmdlLmNvbW1hbmRzWzBdID09ICcvJztcbn1cbnZhciBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzKGlzQWJzb2x1dGUsIG51bWJlck9mRG91YmxlRG90cywgY29tbWFuZHMpIHtcbiAgICAgICAgdGhpcy5pc0Fic29sdXRlID0gaXNBYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5udW1iZXJPZkRvdWJsZURvdHMgPSBudW1iZXJPZkRvdWJsZURvdHM7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICB9XG4gICAgcmV0dXJuIE5vcm1hbGl6ZWROYXZpZ2F0aW9uQ29tbWFuZHM7XG59KCkpO1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tbWFuZHMoY29tbWFuZHMpIHtcbiAgICBpZiAoKHR5cGVvZiBjb21tYW5kc1swXSA9PT0gJ3N0cmluZycpICYmIGNvbW1hbmRzLmxlbmd0aCA9PT0gMSAmJiBjb21tYW5kc1swXSA9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzKHRydWUsIDAsIGNvbW1hbmRzKTtcbiAgICB9XG4gICAgdmFyIG51bWJlck9mRG91YmxlRG90cyA9IDA7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBmYWxzZTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoISh0eXBlb2YgYyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICByZXMucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0cyA9IGMuc3BsaXQoJy8nKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGNjID0gcGFydHNbal07XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT0gMCAmJiBjYyA9PSAnLicpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA9PSAwICYmIGNjID09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjYyA9PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mRG91YmxlRG90cysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjYyAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChjYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNjICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOb3JtYWxpemVkTmF2aWdhdGlvbkNvbW1hbmRzKGlzQWJzb2x1dGUsIG51bWJlck9mRG91YmxlRG90cywgcmVzKTtcbn1cbnZhciBQb3NpdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9zaXRpb24oc2VnbWVudCwgcHJvY2Vzc0NoaWxkcmVuLCBpbmRleCkge1xuICAgICAgICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICB0aGlzLnByb2Nlc3NDaGlsZHJlbiA9IHByb2Nlc3NDaGlsZHJlbjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gUG9zaXRpb247XG59KCkpO1xuZnVuY3Rpb24gZmluZFN0YXJ0aW5nUG9zaXRpb24obm9ybWFsaXplZENoYW5nZSwgdXJsVHJlZSwgcm91dGUpIHtcbiAgICBpZiAobm9ybWFsaXplZENoYW5nZS5pc0Fic29sdXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odXJsVHJlZS5yb290LCB0cnVlLCAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocm91dGUuc25hcHNob3QuX2xhc3RQYXRoSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocm91dGUuc25hcHNob3QuX3VybFNlZ21lbnQsIHRydWUsIDApO1xuICAgIH1cbiAgICBlbHNlIGlmIChyb3V0ZS5zbmFwc2hvdC5fbGFzdFBhdGhJbmRleCArIDEgLSBub3JtYWxpemVkQ2hhbmdlLm51bWJlck9mRG91YmxlRG90cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocm91dGUuc25hcHNob3QuX3VybFNlZ21lbnQsIGZhbHNlLCByb3V0ZS5zbmFwc2hvdC5fbGFzdFBhdGhJbmRleCArIDEgLSBub3JtYWxpemVkQ2hhbmdlLm51bWJlck9mRG91YmxlRG90cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIFxcJy4uL1xcJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBhdGgoY29tbWFuZCkge1xuICAgIGlmICghKHR5cGVvZiBjb21tYW5kID09PSAnc3RyaW5nJykpXG4gICAgICAgIHJldHVybiBjb21tYW5kLnRvU3RyaW5nKCk7XG4gICAgdmFyIHBhcnRzID0gY29tbWFuZC50b1N0cmluZygpLnNwbGl0KCc6Jyk7XG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6IGNvbW1hbmQ7XG59XG5mdW5jdGlvbiBnZXRPdXRsZXQoY29tbWFuZHMpIHtcbiAgICBpZiAoISh0eXBlb2YgY29tbWFuZHNbMF0gPT09ICdzdHJpbmcnKSlcbiAgICAgICAgcmV0dXJuIHNoYXJlZF8xLlBSSU1BUllfT1VUTEVUO1xuICAgIHZhciBwYXJ0cyA9IGNvbW1hbmRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoJzonKTtcbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzBdIDogc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQ7XG59XG5mdW5jdGlvbiB1cGRhdGVTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKSB7XG4gICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHNlZ21lbnQgPSBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KFtdLCB7fSk7XG4gICAgfVxuICAgIGlmIChzZWdtZW50LnBhdGhzV2l0aFBhcmFtcy5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc2VnbWVudC5jaGlsZHJlbikubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2VnbWVudENoaWxkcmVuKHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKTtcbiAgICB9XG4gICAgdmFyIG0gPSBwcmVmaXhlZFdpdGgoc2VnbWVudCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgIHZhciBzbGljZWRDb21tYW5kcyA9IGNvbW1hbmRzLnNsaWNlKG0ubGFzdEluZGV4KTtcbiAgICBpZiAobS5tYXRjaCAmJiBzbGljZWRDb21tYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFNlZ21lbnQoc2VnbWVudC5wYXRoc1dpdGhQYXJhbXMsIHt9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobS5tYXRjaCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld1NlZ21lbnQoc2VnbWVudCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtLm1hdGNoKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTZWdtZW50Q2hpbGRyZW4oc2VnbWVudCwgMCwgc2xpY2VkQ29tbWFuZHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld1NlZ21lbnQoc2VnbWVudCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlZ21lbnRDaGlsZHJlbihzZWdtZW50LCBzdGFydEluZGV4LCBjb21tYW5kcykge1xuICAgIGlmIChjb21tYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxfdHJlZV8xLlVybFNlZ21lbnQoc2VnbWVudC5wYXRoc1dpdGhQYXJhbXMsIHt9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBvdXRsZXRfMSA9IGdldE91dGxldChjb21tYW5kcyk7XG4gICAgICAgIHZhciBjaGlsZHJlbl8xID0ge307XG4gICAgICAgIGNoaWxkcmVuXzFbb3V0bGV0XzFdID0gdXBkYXRlU2VnbWVudChzZWdtZW50LmNoaWxkcmVuW291dGxldF8xXSwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgICAgICBjb2xsZWN0aW9uXzEuZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRPdXRsZXQgIT09IG91dGxldF8xKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5fMVtjaGlsZE91dGxldF0gPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLCBjaGlsZHJlbl8xKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVmaXhlZFdpdGgoc2VnbWVudCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICB2YXIgY3VycmVudENvbW1hbmRJbmRleCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQYXRoSW5kZXggPSBzdGFydEluZGV4O1xuICAgIHZhciBub01hdGNoID0geyBtYXRjaDogZmFsc2UsIGxhc3RJbmRleDogMCB9O1xuICAgIHdoaWxlIChjdXJyZW50UGF0aEluZGV4IDwgc2VnbWVudC5wYXRoc1dpdGhQYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29tbWFuZEluZGV4ID49IGNvbW1hbmRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBub01hdGNoO1xuICAgICAgICB2YXIgcGF0aCA9IHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zW2N1cnJlbnRQYXRoSW5kZXhdO1xuICAgICAgICB2YXIgY3VyciA9IGdldFBhdGgoY29tbWFuZHNbY3VycmVudENvbW1hbmRJbmRleF0pO1xuICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnRDb21tYW5kSW5kZXggPCBjb21tYW5kcy5sZW5ndGggLSAxID8gY29tbWFuZHNbY3VycmVudENvbW1hbmRJbmRleCArIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGN1cnIgJiYgbmV4dCAmJiAodHlwZW9mIG5leHQgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgaWYgKCFjb21wYXJlKGN1cnIsIG5leHQsIHBhdGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub01hdGNoO1xuICAgICAgICAgICAgY3VycmVudENvbW1hbmRJbmRleCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjb21wYXJlKGN1cnIsIHt9LCBwYXRoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9NYXRjaDtcbiAgICAgICAgICAgIGN1cnJlbnRDb21tYW5kSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGF0aEluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB7IG1hdGNoOiB0cnVlLCBsYXN0SW5kZXg6IGN1cnJlbnRDb21tYW5kSW5kZXggfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5ld1NlZ21lbnQoc2VnbWVudCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICB2YXIgcGF0aHMgPSBzZWdtZW50LnBhdGhzV2l0aFBhcmFtcy5zbGljZSgwLCBzdGFydEluZGV4KTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGkgPT09IDAgJiYgKHR5cGVvZiBjb21tYW5kc1swXSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zW3N0YXJ0SW5kZXhdO1xuICAgICAgICAgICAgcGF0aHMucHVzaChuZXcgdXJsX3RyZWVfMS5VcmxQYXRoV2l0aFBhcmFtcyhwLnBhdGgsIGNvbW1hbmRzWzBdKSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyciA9IGdldFBhdGgoY29tbWFuZHNbaV0pO1xuICAgICAgICB2YXIgbmV4dCA9IChpIDwgY29tbWFuZHMubGVuZ3RoIC0gMSkgPyBjb21tYW5kc1tpICsgMV0gOiBudWxsO1xuICAgICAgICBpZiAoY3VyciAmJiBuZXh0ICYmICh0eXBlb2YgbmV4dCA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKG5ldyB1cmxfdHJlZV8xLlVybFBhdGhXaXRoUGFyYW1zKGN1cnIsIHN0cmluZ2lmeShuZXh0KSkpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aHMucHVzaChuZXcgdXJsX3RyZWVfMS5VcmxQYXRoV2l0aFBhcmFtcyhjdXJyLCB7fSkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgdXJsX3RyZWVfMS5VcmxTZWdtZW50KHBhdGhzLCB7fSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkocGFyYW1zKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGNvbGxlY3Rpb25fMS5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHJlc1trXSA9IFwiXCIgKyB2OyB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcGFyZShwYXRoLCBwYXJhbXMsIHBhdGhXaXRoUGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhdGggPT0gcGF0aFdpdGhQYXJhbXMucGF0aCAmJiBjb2xsZWN0aW9uXzEuc2hhbGxvd0VxdWFsKHBhcmFtcywgcGF0aFdpdGhQYXJhbXMucGFyYW1ldGVycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZM0psWVhSbFgzVnliRjkwY21WbExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMMk55WldGMFpWOTFjbXhmZEhKbFpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUTBFc2RVSkJRWEZETEZWQlFWVXNRMEZCUXl4RFFVRkJPMEZCUTJoRUxIbENRVUZ4UkN4WlFVRlpMRU5CUVVNc1EwRkJRVHRCUVVOc1JTd3lRa0ZCYjBNc2IwSkJRVzlDTEVOQlFVTXNRMEZCUVR0QlFVVjZSQ3gxUWtGRFNTeExRVUZ4UWl4RlFVRkZMRTlCUVdkQ0xFVkJRVVVzVVVGQlpTeEZRVUZGTEZkQlFXMUNMRVZCUXpkRkxGRkJRV2RDTzBsQlEyeENMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNeFFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4UFFVRlBMRVZCUVVVc1YwRkJWeXhGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzBsQlF6RkZMRU5CUVVNN1NVRkZSQ3hKUVVGTkxHdENRVUZyUWl4SFFVRkhMR2xDUVVGcFFpeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUTNaRUxFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFXTXNRMEZCUXl4clFrRkJhMElzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3h4UWtGQlZTeERRVUZETEVWQlFVVXNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSU3hQUVVGUExFVkJRVVVzVjBGQlZ5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUTNCR0xFTkJRVU03U1VGRlJDeEpRVUZOTEdkQ1FVRm5RaXhIUVVGSExHOUNRVUZ2UWl4RFFVRkRMR3RDUVVGclFpeEZRVUZGTEU5QlFVOHNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVOc1JpeEpRVUZOTEU5QlFVOHNSMEZCUnl4blFrRkJaMElzUTBGQlF5eGxRVUZsTzFGQlF6VkRMSEZDUVVGeFFpeERRVU5xUWl4blFrRkJaMElzUTBGQlF5eFBRVUZQTEVWQlFVVXNaMEpCUVdkQ0xFTkJRVU1zUzBGQlN5eEZRVUZGTEd0Q1FVRnJRaXhEUVVGRExGRkJRVkVzUTBGQlF6dFJRVU5zUml4aFFVRmhMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUMEZCVHl4RlFVRkZMR2RDUVVGblFpeERRVUZETEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTnFSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFOUJRVThzUlVGQlJTeFBRVUZQTEVWQlFVVXNUMEZCVHl4RlFVRkZMRmRCUVZjc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU5xUml4RFFVRkRPMEZCYkVKbExIRkNRVUZoTEdkQ1FXdENOVUlzUTBGQlFUdEJRVVZFTEdOQlEwa3NWVUZCYzBJc1JVRkJSU3hWUVVGelFpeEZRVUZGTEU5QlFXZENMRVZCUVVVc1YwRkJiVUlzUlVGRGNrWXNVVUZCWjBJN1NVRkRiRUlzU1VGQlRTeERRVUZETEVkQlFVY3NWMEZCVnl4SFFVRkhMRk5CUVZNc1EwRkJReXhYUVVGWExFTkJRVU1zUjBGQlJ5eFBRVUZQTEVOQlFVTXNWMEZCVnl4RFFVRkRPMGxCUTNKRkxFbEJRVTBzUTBGQlF5eEhRVUZITEZGQlFWRXNSMEZCUnl4UlFVRlJMRWRCUVVjc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF6dEpRVVZxUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeExRVUZMTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRhRU1zVFVGQlRTeERRVUZETEVsQlFVa3NhMEpCUVU4c1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNaRExFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJReXhKUVVGSkxHdENRVUZQTEVOQlFVTXNZMEZCWXl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzVlVGQlZTeEZRVUZGTEZWQlFWVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5xUml4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxIZENRVU5KTEU5QlFXMUNMRVZCUVVVc1ZVRkJjMElzUlVGQlJTeFZRVUZ6UWp0SlFVTnlSU3hKUVVGTkxGRkJRVkVzUjBGQlowTXNSVUZCUlN4RFFVRkRPMGxCUTJwRUxHOUNRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hWUVVGRExFTkJRV0VzUlVGQlJTeFZRVUZyUWp0UlFVTXhSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOeVFpeFJRVUZSTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWRCUVVjc1ZVRkJWU3hEUVVGRE8xRkJRM0JETEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xGRkJRVkVzUTBGQlF5eFZRVUZWTEVOQlFVTXNSMEZCUnl4alFVRmpMRU5CUVVNc1EwRkJReXhGUVVGRkxGVkJRVlVzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTnVSU3hEUVVGRE8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEU0N4TlFVRk5MRU5CUVVNc1NVRkJTU3h4UWtGQlZTeERRVUZETEU5QlFVOHNRMEZCUXl4bFFVRmxMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03UVVGRE0wUXNRMEZCUXp0QlFVVkVMSGRDUVVGM1FpeG5Ra0ZCT0VNN1NVRkRjRVVzVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExGVkJRVlVzU1VGQlNTeG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTTdVVUZEZUVVc1owSkJRV2RDTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFZEJRVWNzUTBGQlF6dEJRVU14UXl4RFFVRkRPMEZCUlVRN1NVRkRSU3h6UTBGRFZ5eFZRVUZ0UWl4RlFVRlRMR3RDUVVFd1FpeEZRVUZUTEZGQlFXVTdVVUZCT1VVc1pVRkJWU3hIUVVGV0xGVkJRVlVzUTBGQlV6dFJRVUZUTEhWQ1FVRnJRaXhIUVVGc1FpeHJRa0ZCYTBJc1EwRkJVVHRSUVVGVExHRkJRVkVzUjBGQlVpeFJRVUZSTEVOQlFVODdTVUZCUnl4RFFVRkRPMGxCUXk5R0xHMURRVUZETzBGQlFVUXNRMEZCUXl4QlFVaEVMRWxCUjBNN1FVRkZSQ3d5UWtGQk1rSXNVVUZCWlR0SlFVTjRReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExGRkJRVkVzUTBGQlF5eEpRVUZKTEZGQlFWRXNRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhKUVVGSkxGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pHTEUxQlFVMHNRMEZCUXl4SlFVRkpMRFJDUVVFMFFpeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03U1VGRE4wUXNRMEZCUXp0SlFVVkVMRWxCUVVrc2EwSkJRV3RDTEVkQlFVY3NRMEZCUXl4RFFVRkRPMGxCUXpOQ0xFbEJRVWtzVlVGQlZTeEhRVUZITEV0QlFVc3NRMEZCUXp0SlFVTjJRaXhKUVVGTkxFZEJRVWNzUjBGQlZTeEZRVUZGTEVOQlFVTTdTVUZGZEVJc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhSUVVGUkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNN1VVRkRla01zU1VGQlRTeERRVUZETEVkQlFVY3NVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSWFJDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMElzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOYUxGRkJRVkVzUTBGQlF6dFJRVU5ZTEVOQlFVTTdVVUZGUkN4SlFVRk5MRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUXpOQ0xFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRE8xbEJRM1JETEVsQlFVa3NSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVWRzUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRXQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVVXhRaXhEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU01UWl4VlFVRlZMRWRCUVVjc1NVRkJTU3hEUVVGRE8yZENRVU53UWl4RFFVRkRPMmRDUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEZEVJc2EwSkJRV3RDTEVWQlFVVXNRMEZCUXp0blFrRkRka0lzUTBGQlF6dG5Ra0ZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRM0JDTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlEyWXNRMEZCUXp0WlFVVklMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEVGl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRZaXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVObUxFTkJRVU03V1VGRFNDeERRVUZETzFGQlEwZ3NRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTdzBRa0ZCTkVJc1EwRkJReXhWUVVGVkxFVkJRVVVzYTBKQlFXdENMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU03UVVGREwwVXNRMEZCUXp0QlFVVkVPMGxCUTBVc2EwSkJRVzFDTEU5QlFXMUNMRVZCUVZNc1pVRkJkMElzUlVGQlV5eExRVUZoTzFGQlFURkZMRmxCUVU4c1IwRkJVQ3hQUVVGUExFTkJRVms3VVVGQlV5eHZRa0ZCWlN4SFFVRm1MR1ZCUVdVc1EwRkJVenRSUVVGVExGVkJRVXNzUjBGQlRDeExRVUZMTEVOQlFWRTdTVUZCUnl4RFFVRkRPMGxCUTI1SExHVkJRVU03UVVGQlJDeERRVUZETEVGQlJrUXNTVUZGUXp0QlFVVkVMRGhDUVVOSkxHZENRVUU0UXl4RlFVRkZMRTlCUVdkQ0xFVkJRMmhGTEV0QlFYRkNPMGxCUTNaQ0xFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYUVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlF6ZERMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhqUVVGakxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExGZEJRVmNzUlVGQlJTeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNMFFzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEdOQlFXTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1owSkJRV2RDTEVOQlFVTXNhMEpCUVd0Q0xFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjRSaXhOUVVGTkxFTkJRVU1zU1VGQlNTeFJRVUZSTEVOQlEyWXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhYUVVGWExFVkJRVVVzUzBGQlN5eEZRVU5xUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExHTkJRV01zUjBGQlJ5eERRVUZETEVkQlFVY3NaMEpCUVdkQ0xFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1EwRkJRenRKUVVNdlJTeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERKQ1FVRXlRaXhEUVVGRExFTkJRVU03U1VGREwwTXNRMEZCUXp0QlFVTklMRU5CUVVNN1FVRkZSQ3hwUWtGQmFVSXNUMEZCV1R0SlFVTXpRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4UFFVRlBMRXRCUVVzc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8wbEJRemxFTEVsQlFVMHNTMEZCU3l4SFFVRkhMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkROVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4UFFVRlBMRU5CUVVNN1FVRkRMME1zUTBGQlF6dEJRVVZFTEcxQ1FVRnRRaXhSUVVGbE8wbEJRMmhETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVGRExFMUJRVTBzUTBGQlF5eDFRa0ZCWXl4RFFVRkRPMGxCUXpsRUxFbEJRVTBzUzBGQlN5eEhRVUZITEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkRhRVFzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4MVFrRkJZeXhEUVVGRE8wRkJRM1JFTEVOQlFVTTdRVUZGUkN4MVFrRkJkVUlzVDBGQmJVSXNSVUZCUlN4VlFVRnJRaXhGUVVGRkxGRkJRV1U3U1VGRE4wVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEySXNUMEZCVHl4SFFVRkhMRWxCUVVrc2NVSkJRVlVzUTBGQlF5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkRia01zUTBGQlF6dEpRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhsUVVGbExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55Uml4TlFVRk5MRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNUMEZCVHl4RlFVRkZMRlZCUVZVc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU01UkN4RFFVRkRPMGxCUTBRc1NVRkJUU3hEUVVGRExFZEJRVWNzV1VGQldTeERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRlZMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03U1VGRGRFUXNTVUZCVFN4alFVRmpMRWRCUVVjc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1NVRkZia1FzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hqUVVGakxFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRNME1zVFVGQlRTeERRVUZETEVsQlFVa3NjVUpCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zWlVGQlpTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTNKRUxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOcVJTeE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEZWQlFWVXNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVONlJDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTI1Q0xFMUJRVTBzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF5eEZRVUZGTEdOQlFXTXNRMEZCUXl4RFFVRkRPMGxCUXpORUxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzBsQlEzcEVMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJSVVFzSzBKQlEwa3NUMEZCYlVJc1JVRkJSU3hWUVVGclFpeEZRVUZGTEZGQlFXVTdTVUZETVVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRekZDTEUxQlFVMHNRMEZCUXl4SlFVRkpMSEZDUVVGVkxFTkJRVU1zVDBGQlR5eERRVUZETEdWQlFXVXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOeVJDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhKUVVGTkxGRkJRVTBzUjBGQlJ5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1VVRkRia01zU1VGQlRTeFZRVUZSTEVkQlFXZERMRVZCUVVVc1EwRkJRenRSUVVOcVJDeFZRVUZSTEVOQlFVTXNVVUZCVFN4RFFVRkRMRWRCUVVjc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNVVUZCVFN4RFFVRkRMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzFGQlEycEdMRzlDUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4VlFVRkRMRXRCUVdsQ0xFVkJRVVVzVjBGQmJVSTdXVUZETDBRc1JVRkJSU3hEUVVGRExFTkJRVU1zVjBGQlZ5eExRVUZMTEZGQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRek5DTEZWQlFWRXNRMEZCUXl4WFFVRlhMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU03V1VGRGFFTXNRMEZCUXp0UlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMGdzVFVGQlRTeERRVUZETEVsQlFVa3NjVUpCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zWlVGQlpTeEZRVUZGTEZWQlFWRXNRMEZCUXl4RFFVRkRPMGxCUXpORUxFTkJRVU03UVVGRFNDeERRVUZETzBGQlJVUXNjMEpCUVhOQ0xFOUJRVzFDTEVWQlFVVXNWVUZCYTBJc1JVRkJSU3hSUVVGbE8wbEJRelZGTEVsQlFVa3NiVUpCUVcxQ0xFZEJRVWNzUTBGQlF5eERRVUZETzBsQlF6VkNMRWxCUVVrc1owSkJRV2RDTEVkQlFVY3NWVUZCVlN4RFFVRkRPMGxCUld4RExFbEJRVTBzVDBGQlR5eEhRVUZITEVWQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hUUVVGVExFVkJRVVVzUTBGQlF5eEZRVUZETEVOQlFVTTdTVUZETjBNc1QwRkJUeXhuUWtGQlowSXNSMEZCUnl4UFFVRlBMRU5CUVVNc1pVRkJaU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETzFGQlEzcEVMRVZCUVVVc1EwRkJReXhEUVVGRExHMUNRVUZ0UWl4SlFVRkpMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU03V1VGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMUZCUXpORUxFbEJRVTBzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4bFFVRmxMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hKUVVGTkxFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMRzFDUVVGdFFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndSQ3hKUVVGTkxFbEJRVWtzUjBGRFRpeHRRa0ZCYlVJc1IwRkJSeXhSUVVGUkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNSMEZCUnl4UlFVRlJMRU5CUVVNc2JVSkJRVzFDTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJSWHBHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hKUVVGSkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGREwwTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUXk5RExHMUNRVUZ0UWl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVNelFpeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03V1VGRE4wTXNiVUpCUVcxQ0xFVkJRVVVzUTBGQlF6dFJRVU40UWl4RFFVRkRPMUZCUTBRc1owSkJRV2RDTEVWQlFVVXNRMEZCUXp0SlFVTnlRaXhEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEVWQlFVTXNTMEZCU3l4RlFVRkZMRWxCUVVrc1JVRkJSU3hUUVVGVExFVkJRVVVzYlVKQlFXMUNMRVZCUVVNc1EwRkJRenRCUVVOMlJDeERRVUZETzBGQlJVUXNNRUpCUVRCQ0xFOUJRVzFDTEVWQlFVVXNWVUZCYTBJc1JVRkJSU3hSUVVGbE8wbEJRMmhHTEVsQlFVMHNTMEZCU3l4SFFVRkhMRTlCUVU4c1EwRkJReXhsUVVGbExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRKUVVNelJDeEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkRWaXhQUVVGUExFTkJRVU1zUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNN1VVRkZNMElzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUkN4SlFVRk5MRU5CUVVNc1IwRkJSeXhQUVVGUExFTkJRVU1zWlVGQlpTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRPMWxCUXpsRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N3MFFrRkJhVUlzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZGtRc1EwRkJReXhGUVVGRkxFTkJRVU03V1VGRFNpeFJRVUZSTEVOQlFVTTdVVUZEV0N4RFFVRkRPMUZCUlVRc1NVRkJUU3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhETEVsQlFVMHNTVUZCU1N4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExGRkJRVkVzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1VVRkJVU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkRhRVVzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4SlFVRkpMRWxCUVVrc1NVRkJTU3hEUVVGRExFOUJRVThzU1VGQlNTeExRVUZMTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc05FSkJRV2xDTEVOQlFVTXNTVUZCU1N4RlFVRkZMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtRc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5VTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N3MFFrRkJhVUlzUTBGQlF5eEpRVUZKTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNMVF5eERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTk9MRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NjVUpCUVZVc1EwRkJReXhMUVVGTExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdRVUZEYmtNc1EwRkJRenRCUVVWRUxHMUNRVUZ0UWl4TlFVRTBRanRKUVVNM1F5eEpRVUZOTEVkQlFVY3NSMEZCTkVJc1JVRkJSU3hEUVVGRE8wbEJRM2hETEc5Q1FVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxGVkJRVU1zUTBGQlRTeEZRVUZGTEVOQlFWTXNTVUZCU3l4UFFVRkJMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eExRVUZITEVOQlFVY3NSVUZCWml4RFFVRmxMRU5CUVVNc1EwRkJRenRKUVVONFJDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRPMEZCUTJJc1EwRkJRenRCUVVWRUxHbENRVU5KTEVsQlFWa3NSVUZCUlN4TlFVRTBRaXhGUVVGRkxHTkJRV2xETzBsQlF5OUZMRTFCUVUwc1EwRkJReXhKUVVGSkxFbEJRVWtzWTBGQll5eERRVUZETEVsQlFVa3NTVUZCU1N4NVFrRkJXU3hEUVVGRExFMUJRVTBzUlVGQlJTeGpRVUZqTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1FVRkRlRVlzUTBGQlF5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdRV04wYVhaaGRHVmtVbTkxZEdWOUlHWnliMjBnSnk0dmNtOTFkR1Z5WDNOMFlYUmxKenRjYm1sdGNHOXlkQ0I3VUZKSlRVRlNXVjlQVlZSTVJWUXNJRkJoY21GdGMzMGdabkp2YlNBbkxpOXphR0Z5WldRbk8xeHVhVzF3YjNKMElIdFZjbXhRWVhSb1YybDBhRkJoY21GdGN5d2dWWEpzVTJWbmJXVnVkQ3dnVlhKc1ZISmxaWDBnWm5KdmJTQW5MaTkxY214ZmRISmxaU2M3WEc1cGJYQnZjblFnZTJadmNrVmhZMmdzSUhOb1lXeHNiM2RGY1hWaGJIMGdabkp2YlNBbkxpOTFkR2xzY3k5amIyeHNaV04wYVc5dUp6dGNibHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR055WldGMFpWVnliRlJ5WldVb1hHNGdJQ0FnY205MWRHVTZJRUZqZEdsMllYUmxaRkp2ZFhSbExDQjFjbXhVY21WbE9pQlZjbXhVY21WbExDQmpiMjF0WVc1a2N6b2dZVzU1VzEwc0lIRjFaWEo1VUdGeVlXMXpPaUJRWVhKaGJYTXNYRzRnSUNBZ1puSmhaMjFsYm5RNklITjBjbWx1WnlrNklGVnliRlJ5WldVZ2UxeHVJQ0JwWmlBb1kyOXRiV0Z1WkhNdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUnlaV1VvZFhKc1ZISmxaUzV5YjI5MExDQjFjbXhVY21WbExuSnZiM1FzSUhWeWJGUnlaV1VzSUhGMVpYSjVVR0Z5WVcxekxDQm1jbUZuYldWdWRDazdYRzRnSUgxY2JseHVJQ0JqYjI1emRDQnViM0p0WVd4cGVtVmtRMjl0YldGdVpITWdQU0J1YjNKdFlXeHBlbVZEYjIxdFlXNWtjeWhqYjIxdFlXNWtjeWs3WEc0Z0lHbG1JQ2h1WVhacFoyRjBaVlJ2VW05dmRDaHViM0p0WVd4cGVtVmtRMjl0YldGdVpITXBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlIUnlaV1VvZFhKc1ZISmxaUzV5YjI5MExDQnVaWGNnVlhKc1UyVm5iV1Z1ZENoYlhTd2dlMzBwTENCMWNteFVjbVZsTENCeGRXVnllVkJoY21GdGN5d2dabkpoWjIxbGJuUXBPMXh1SUNCOVhHNWNiaUFnWTI5dWMzUWdjM1JoY25ScGJtZFFiM05wZEdsdmJpQTlJR1pwYm1SVGRHRnlkR2x1WjFCdmMybDBhVzl1S0c1dmNtMWhiR2w2WldSRGIyMXRZVzVrY3l3Z2RYSnNWSEpsWlN3Z2NtOTFkR1VwTzF4dUlDQmpiMjV6ZENCelpXZHRaVzUwSUQwZ2MzUmhjblJwYm1kUWIzTnBkR2x2Ymk1d2NtOWpaWE56UTJocGJHUnlaVzRnUDF4dUlDQWdJQ0FnZFhCa1lYUmxVMlZuYldWdWRFTm9hV3hrY21WdUtGeHVJQ0FnSUNBZ0lDQWdJSE4wWVhKMGFXNW5VRzl6YVhScGIyNHVjMlZuYldWdWRDd2djM1JoY25ScGJtZFFiM05wZEdsdmJpNXBibVJsZUN3Z2JtOXliV0ZzYVhwbFpFTnZiVzFoYm1SekxtTnZiVzFoYm1SektTQTZYRzRnSUNBZ0lDQjFjR1JoZEdWVFpXZHRaVzUwS0hOMFlYSjBhVzVuVUc5emFYUnBiMjR1YzJWbmJXVnVkQ3dnYzNSaGNuUnBibWRRYjNOcGRHbHZiaTVwYm1SbGVDd2dibTl5YldGc2FYcGxaRU52YlcxaGJtUnpMbU52YlcxaGJtUnpLVHRjYmlBZ2NtVjBkWEp1SUhSeVpXVW9jM1JoY25ScGJtZFFiM05wZEdsdmJpNXpaV2R0Wlc1MExDQnpaV2R0Wlc1MExDQjFjbXhVY21WbExDQnhkV1Z5ZVZCaGNtRnRjeXdnWm5KaFoyMWxiblFwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUIwY21WbEtGeHVJQ0FnSUc5c1pGTmxaMjFsYm5RNklGVnliRk5sWjIxbGJuUXNJRzVsZDFObFoyMWxiblE2SUZWeWJGTmxaMjFsYm5Rc0lIVnliRlJ5WldVNklGVnliRlJ5WldVc0lIRjFaWEo1VUdGeVlXMXpPaUJRWVhKaGJYTXNYRzRnSUNBZ1puSmhaMjFsYm5RNklITjBjbWx1WnlrNklGVnliRlJ5WldVZ2UxeHVJQ0JqYjI1emRDQnhJRDBnY1hWbGNubFFZWEpoYlhNZ1B5QnpkSEpwYm1kcFpua29jWFZsY25sUVlYSmhiWE1wSURvZ2RYSnNWSEpsWlM1eGRXVnllVkJoY21GdGN6dGNiaUFnWTI5dWMzUWdaaUE5SUdaeVlXZHRaVzUwSUQ4Z1puSmhaMjFsYm5RZ09pQjFjbXhVY21WbExtWnlZV2R0Wlc1ME8xeHVYRzRnSUdsbUlDaDFjbXhVY21WbExuSnZiM1FnUFQwOUlHOXNaRk5sWjIxbGJuUXBJSHRjYmlBZ0lDQnlaWFIxY200Z2JtVjNJRlZ5YkZSeVpXVW9ibVYzVTJWbmJXVnVkQ3dnY1N3Z1ppazdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdjbVYwZFhKdUlHNWxkeUJWY214VWNtVmxLSEpsY0d4aFkyVlRaV2R0Wlc1MEtIVnliRlJ5WldVdWNtOXZkQ3dnYjJ4a1UyVm5iV1Z1ZEN3Z2JtVjNVMlZuYldWdWRDa3NJSEVzSUdZcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsY0d4aFkyVlRaV2R0Wlc1MEtGeHVJQ0FnSUdOMWNuSmxiblE2SUZWeWJGTmxaMjFsYm5Rc0lHOXNaRk5sWjIxbGJuUTZJRlZ5YkZObFoyMWxiblFzSUc1bGQxTmxaMjFsYm5RNklGVnliRk5sWjIxbGJuUXBPaUJWY214VFpXZHRaVzUwSUh0Y2JpQWdZMjl1YzNRZ1kyaHBiR1J5Wlc0NklIdGJhMlY1T2lCemRISnBibWRkT2lCVmNteFRaV2R0Wlc1MGZTQTlJSHQ5TzF4dUlDQm1iM0pGWVdOb0tHTjFjbkpsYm5RdVkyaHBiR1J5Wlc0c0lDaGpPaUJWY214VFpXZHRaVzUwTENCdmRYUnNaWFJPWVcxbE9pQnpkSEpwYm1jcElEMCtJSHRjYmlBZ0lDQnBaaUFvWXlBOVBUMGdiMnhrVTJWbmJXVnVkQ2tnZTF4dUlDQWdJQ0FnWTJocGJHUnlaVzViYjNWMGJHVjBUbUZ0WlYwZ1BTQnVaWGRUWldkdFpXNTBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCamFHbHNaSEpsYmx0dmRYUnNaWFJPWVcxbFhTQTlJSEpsY0d4aFkyVlRaV2R0Wlc1MEtHTXNJRzlzWkZObFoyMWxiblFzSUc1bGQxTmxaMjFsYm5RcE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc0Z0lISmxkSFZ5YmlCdVpYY2dWWEpzVTJWbmJXVnVkQ2hqZFhKeVpXNTBMbkJoZEdoelYybDBhRkJoY21GdGN5d2dZMmhwYkdSeVpXNHBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnVZWFpwWjJGMFpWUnZVbTl2ZENodWIzSnRZV3hwZW1Wa1EyaGhibWRsT2lCT2IzSnRZV3hwZW1Wa1RtRjJhV2RoZEdsdmJrTnZiVzFoYm1SektUb2dZbTl2YkdWaGJpQjdYRzRnSUhKbGRIVnliaUJ1YjNKdFlXeHBlbVZrUTJoaGJtZGxMbWx6UVdKemIyeDFkR1VnSmlZZ2JtOXliV0ZzYVhwbFpFTm9ZVzVuWlM1amIyMXRZVzVrY3k1c1pXNW5kR2dnUFQwOUlERWdKaVpjYmlBZ0lDQWdJRzV2Y20xaGJHbDZaV1JEYUdGdVoyVXVZMjl0YldGdVpITmJNRjBnUFQwZ0p5OG5PMXh1ZlZ4dVhHNWpiR0Z6Y3lCT2IzSnRZV3hwZW1Wa1RtRjJhV2RoZEdsdmJrTnZiVzFoYm1SeklIdGNiaUFnWTI5dWMzUnlkV04wYjNJb1hHNGdJQ0FnSUNCd2RXSnNhV01nYVhOQlluTnZiSFYwWlRvZ1ltOXZiR1ZoYml3Z2NIVmliR2xqSUc1MWJXSmxjazltUkc5MVlteGxSRzkwY3pvZ2JuVnRZbVZ5TENCd2RXSnNhV01nWTI5dGJXRnVaSE02SUdGdWVWdGRLU0I3ZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ1YjNKdFlXeHBlbVZEYjIxdFlXNWtjeWhqYjIxdFlXNWtjem9nWVc1NVcxMHBPaUJPYjNKdFlXeHBlbVZrVG1GMmFXZGhkR2x2YmtOdmJXMWhibVJ6SUh0Y2JpQWdhV1lnS0NoMGVYQmxiMllnWTI5dGJXRnVaSE5iTUYwZ1BUMDlJQ2R6ZEhKcGJtY25LU0FtSmlCamIyMXRZVzVrY3k1c1pXNW5kR2dnUFQwOUlERWdKaVlnWTI5dGJXRnVaSE5iTUYwZ1BUMGdKeThuS1NCN1hHNGdJQ0FnY21WMGRYSnVJRzVsZHlCT2IzSnRZV3hwZW1Wa1RtRjJhV2RoZEdsdmJrTnZiVzFoYm1SektIUnlkV1VzSURBc0lHTnZiVzFoYm1SektUdGNiaUFnZlZ4dVhHNGdJR3hsZENCdWRXMWlaWEpQWmtSdmRXSnNaVVJ2ZEhNZ1BTQXdPMXh1SUNCc1pYUWdhWE5CWW5OdmJIVjBaU0E5SUdaaGJITmxPMXh1SUNCamIyNXpkQ0J5WlhNNklHRnVlVnRkSUQwZ1cxMDdYRzVjYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmpiMjF0WVc1a2N5NXNaVzVuZEdnN0lDc3JhU2tnZTF4dUlDQWdJR052Ym5OMElHTWdQU0JqYjIxdFlXNWtjMXRwWFR0Y2JseHVJQ0FnSUdsbUlDZ2hLSFI1Y0dWdlppQmpJRDA5UFNBbmMzUnlhVzVuSnlrcElIdGNiaUFnSUNBZ0lISmxjeTV3ZFhOb0tHTXBPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1kyOXVjM1FnY0dGeWRITWdQU0JqTG5Od2JHbDBLQ2N2SnlrN1hHNGdJQ0FnWm05eUlDaHNaWFFnYWlBOUlEQTdJR29nUENCd1lYSjBjeTVzWlc1bmRHZzdJQ3NyYWlrZ2UxeHVJQ0FnSUNBZ2JHVjBJR05qSUQwZ2NHRnlkSE5iYWwwN1hHNWNiaUFnSUNBZ0lDOHZJR1pwY25OMElHVjRjQ0JwY3lCMGNtVmhkR1ZrSUdsdUlHRWdjM0JsWTJsaGJDQjNZWGxjYmlBZ0lDQWdJR2xtSUNocElEMDlJREFwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR29nUFQwZ01DQW1KaUJqWXlBOVBTQW5MaWNwSUhzZ0lDOHZJQ0FuTGk5aEoxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhOcmFYQWdhWFJjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNocUlEMDlJREFnSmlZZ1kyTWdQVDBnSnljcElIc2dJQzh2SUNBbkwyRW5YRzRnSUNBZ0lDQWdJQ0FnYVhOQlluTnZiSFYwWlNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1kyTWdQVDBnSnk0dUp5a2dleUFnTHk4Z0lDY3VMaTloSjF4dUlDQWdJQ0FnSUNBZ0lHNTFiV0psY2s5bVJHOTFZbXhsUkc5MGN5c3JPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dOaklDRTlJQ2NuS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVZ6TG5CMWMyZ29ZMk1wTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hqWXlBaFBTQW5KeWtnZTF4dUlDQWdJQ0FnSUNBZ0lISmxjeTV3ZFhOb0tHTmpLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ1WlhjZ1RtOXliV0ZzYVhwbFpFNWhkbWxuWVhScGIyNURiMjF0WVc1a2N5aHBjMEZpYzI5c2RYUmxMQ0J1ZFcxaVpYSlBaa1J2ZFdKc1pVUnZkSE1zSUhKbGN5azdYRzU5WEc1Y2JtTnNZWE56SUZCdmMybDBhVzl1SUh0Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY0hWaWJHbGpJSE5sWjIxbGJuUTZJRlZ5YkZObFoyMWxiblFzSUhCMVlteHBZeUJ3Y205alpYTnpRMmhwYkdSeVpXNDZJR0p2YjJ4bFlXNHNJSEIxWW14cFl5QnBibVJsZURvZ2JuVnRZbVZ5S1NCN2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCbWFXNWtVM1JoY25ScGJtZFFiM05wZEdsdmJpaGNiaUFnSUNCdWIzSnRZV3hwZW1Wa1EyaGhibWRsT2lCT2IzSnRZV3hwZW1Wa1RtRjJhV2RoZEdsdmJrTnZiVzFoYm1SekxDQjFjbXhVY21WbE9pQlZjbXhVY21WbExGeHVJQ0FnSUhKdmRYUmxPaUJCWTNScGRtRjBaV1JTYjNWMFpTazZJRkJ2YzJsMGFXOXVJSHRjYmlBZ2FXWWdLRzV2Y20xaGJHbDZaV1JEYUdGdVoyVXVhWE5CWW5OdmJIVjBaU2tnZTF4dUlDQWdJSEpsZEhWeWJpQnVaWGNnVUc5emFYUnBiMjRvZFhKc1ZISmxaUzV5YjI5MExDQjBjblZsTENBd0tUdGNiaUFnZlNCbGJITmxJR2xtSUNoeWIzVjBaUzV6Ym1Gd2MyaHZkQzVmYkdGemRGQmhkR2hKYm1SbGVDQTlQVDBnTFRFcElIdGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lGQnZjMmwwYVc5dUtISnZkWFJsTG5OdVlYQnphRzkwTGw5MWNteFRaV2R0Wlc1MExDQjBjblZsTENBd0tUdGNiaUFnZlNCbGJITmxJR2xtSUNoeWIzVjBaUzV6Ym1Gd2MyaHZkQzVmYkdGemRGQmhkR2hKYm1SbGVDQXJJREVnTFNCdWIzSnRZV3hwZW1Wa1EyaGhibWRsTG01MWJXSmxjazltUkc5MVlteGxSRzkwY3lBK1BTQXdLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHNWxkeUJRYjNOcGRHbHZiaWhjYmlBZ0lDQWdJQ0FnY205MWRHVXVjMjVoY0hOb2IzUXVYM1Z5YkZObFoyMWxiblFzSUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0J5YjNWMFpTNXpibUZ3YzJodmRDNWZiR0Z6ZEZCaGRHaEpibVJsZUNBcklERWdMU0J1YjNKdFlXeHBlbVZrUTJoaGJtZGxMbTUxYldKbGNrOW1SRzkxWW14bFJHOTBjeWs3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RKYm5aaGJHbGtJRzUxYldKbGNpQnZaaUJjWENjdUxpOWNYQ2NuS1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJRWVhSb0tHTnZiVzFoYm1RNklHRnVlU2s2SUdGdWVTQjdYRzRnSUdsbUlDZ2hLSFI1Y0dWdlppQmpiMjF0WVc1a0lEMDlQU0FuYzNSeWFXNW5KeWtwSUhKbGRIVnliaUJqYjIxdFlXNWtMblJ2VTNSeWFXNW5LQ2s3WEc0Z0lHTnZibk4wSUhCaGNuUnpJRDBnWTI5dGJXRnVaQzUwYjFOMGNtbHVaeWdwTG5Od2JHbDBLQ2M2SnlrN1hHNGdJSEpsZEhWeWJpQndZWEowY3k1c1pXNW5kR2dnUGlBeElEOGdjR0Z5ZEhOYk1WMGdPaUJqYjIxdFlXNWtPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm5aWFJQZFhSc1pYUW9ZMjl0YldGdVpITTZJR0Z1ZVZ0ZEtUb2djM1J5YVc1bklIdGNiaUFnYVdZZ0tDRW9kSGx3Wlc5bUlHTnZiVzFoYm1Seld6QmRJRDA5UFNBbmMzUnlhVzVuSnlrcElISmxkSFZ5YmlCUVVrbE5RVkpaWDA5VlZFeEZWRHRjYmlBZ1kyOXVjM1FnY0dGeWRITWdQU0JqYjIxdFlXNWtjMXN3WFM1MGIxTjBjbWx1WnlncExuTndiR2wwS0NjNkp5azdYRzRnSUhKbGRIVnliaUJ3WVhKMGN5NXNaVzVuZEdnZ1BpQXhJRDhnY0dGeWRITmJNRjBnT2lCUVVrbE5RVkpaWDA5VlZFeEZWRHRjYm4xY2JseHVablZ1WTNScGIyNGdkWEJrWVhSbFUyVm5iV1Z1ZENoelpXZHRaVzUwT2lCVmNteFRaV2R0Wlc1MExDQnpkR0Z5ZEVsdVpHVjRPaUJ1ZFcxaVpYSXNJR052YlcxaGJtUnpPaUJoYm5sYlhTazZJRlZ5YkZObFoyMWxiblFnZTF4dUlDQnBaaUFvSVhObFoyMWxiblFwSUh0Y2JpQWdJQ0J6WldkdFpXNTBJRDBnYm1WM0lGVnliRk5sWjIxbGJuUW9XMTBzSUh0OUtUdGNiaUFnZlZ4dUlDQnBaaUFvYzJWbmJXVnVkQzV3WVhSb2MxZHBkR2hRWVhKaGJYTXViR1Z1WjNSb0lEMDlQU0F3SUNZbUlFOWlhbVZqZEM1clpYbHpLSE5sWjIxbGJuUXVZMmhwYkdSeVpXNHBMbXhsYm1kMGFDQStJREFwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkWEJrWVhSbFUyVm5iV1Z1ZEVOb2FXeGtjbVZ1S0hObFoyMWxiblFzSUhOMFlYSjBTVzVrWlhnc0lHTnZiVzFoYm1SektUdGNiaUFnZlZ4dUlDQmpiMjV6ZENCdElEMGdjSEpsWm1sNFpXUlhhWFJvS0hObFoyMWxiblFzSUhOMFlYSjBTVzVrWlhnc0lHTnZiVzFoYm1SektUdGNiaUFnWTI5dWMzUWdjMnhwWTJWa1EyOXRiV0Z1WkhNZ1BTQmpiMjF0WVc1a2N5NXpiR2xqWlNodExteGhjM1JKYm1SbGVDazdYRzVjYmlBZ2FXWWdLRzB1YldGMFkyZ2dKaVlnYzJ4cFkyVmtRMjl0YldGdVpITXViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNGdJQ0FnY21WMGRYSnVJRzVsZHlCVmNteFRaV2R0Wlc1MEtITmxaMjFsYm5RdWNHRjBhSE5YYVhSb1VHRnlZVzF6TENCN2ZTazdYRzRnSUgwZ1pXeHpaU0JwWmlBb2JTNXRZWFJqYUNBbUppQlBZbXBsWTNRdWEyVjVjeWh6WldkdFpXNTBMbU5vYVd4a2NtVnVLUzVzWlc1bmRHZ2dQVDA5SURBcElIdGNiaUFnSUNCeVpYUjFjbTRnWTNKbFlYUmxUbVYzVTJWbmJXVnVkQ2h6WldkdFpXNTBMQ0J6ZEdGeWRFbHVaR1Y0TENCamIyMXRZVzVrY3lrN1hHNGdJSDBnWld4elpTQnBaaUFvYlM1dFlYUmphQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjFjR1JoZEdWVFpXZHRaVzUwUTJocGJHUnlaVzRvYzJWbmJXVnVkQ3dnTUN3Z2MyeHBZMlZrUTI5dGJXRnVaSE1wTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGRIVnliaUJqY21WaGRHVk9aWGRUWldkdFpXNTBLSE5sWjIxbGJuUXNJSE4wWVhKMFNXNWtaWGdzSUdOdmJXMWhibVJ6S1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjFjR1JoZEdWVFpXZHRaVzUwUTJocGJHUnlaVzRvWEc0Z0lDQWdjMlZuYldWdWREb2dWWEpzVTJWbmJXVnVkQ3dnYzNSaGNuUkpibVJsZURvZ2JuVnRZbVZ5TENCamIyMXRZVzVrY3pvZ1lXNTVXMTBwT2lCVmNteFRaV2R0Wlc1MElIdGNiaUFnYVdZZ0tHTnZiVzFoYm1SekxteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQnVaWGNnVlhKc1UyVm5iV1Z1ZENoelpXZHRaVzUwTG5CaGRHaHpWMmwwYUZCaGNtRnRjeXdnZTMwcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHTnZibk4wSUc5MWRHeGxkQ0E5SUdkbGRFOTFkR3hsZENoamIyMXRZVzVrY3lrN1hHNGdJQ0FnWTI5dWMzUWdZMmhwYkdSeVpXNDZJSHRiYTJWNU9pQnpkSEpwYm1kZE9pQlZjbXhUWldkdFpXNTBmU0E5SUh0OU8xeHVJQ0FnSUdOb2FXeGtjbVZ1VzI5MWRHeGxkRjBnUFNCMWNHUmhkR1ZUWldkdFpXNTBLSE5sWjIxbGJuUXVZMmhwYkdSeVpXNWJiM1YwYkdWMFhTd2djM1JoY25SSmJtUmxlQ3dnWTI5dGJXRnVaSE1wTzF4dUlDQWdJR1p2Y2tWaFkyZ29jMlZuYldWdWRDNWphR2xzWkhKbGJpd2dLR05vYVd4a09pQlZjbXhUWldkdFpXNTBMQ0JqYUdsc1pFOTFkR3hsZERvZ2MzUnlhVzVuS1NBOVBpQjdYRzRnSUNBZ0lDQnBaaUFvWTJocGJHUlBkWFJzWlhRZ0lUMDlJRzkxZEd4bGRDa2dlMXh1SUNBZ0lDQWdJQ0JqYUdsc1pISmxibHRqYUdsc1pFOTFkR3hsZEYwZ1BTQmphR2xzWkR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5S1R0Y2JpQWdJQ0J5WlhSMWNtNGdibVYzSUZWeWJGTmxaMjFsYm5Rb2MyVm5iV1Z1ZEM1d1lYUm9jMWRwZEdoUVlYSmhiWE1zSUdOb2FXeGtjbVZ1S1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQndjbVZtYVhobFpGZHBkR2dvYzJWbmJXVnVkRG9nVlhKc1UyVm5iV1Z1ZEN3Z2MzUmhjblJKYm1SbGVEb2diblZ0WW1WeUxDQmpiMjF0WVc1a2N6b2dZVzU1VzEwcElIdGNiaUFnYkdWMElHTjFjbkpsYm5SRGIyMXRZVzVrU1c1a1pYZ2dQU0F3TzF4dUlDQnNaWFFnWTNWeWNtVnVkRkJoZEdoSmJtUmxlQ0E5SUhOMFlYSjBTVzVrWlhnN1hHNWNiaUFnWTI5dWMzUWdibTlOWVhSamFDQTlJSHR0WVhSamFEb2dabUZzYzJVc0lHeGhjM1JKYm1SbGVEb2dNSDA3WEc0Z0lIZG9hV3hsSUNoamRYSnlaVzUwVUdGMGFFbHVaR1Y0SUR3Z2MyVm5iV1Z1ZEM1d1lYUm9jMWRwZEdoUVlYSmhiWE11YkdWdVozUm9LU0I3WEc0Z0lDQWdhV1lnS0dOMWNuSmxiblJEYjIxdFlXNWtTVzVrWlhnZ1BqMGdZMjl0YldGdVpITXViR1Z1WjNSb0tTQnlaWFIxY200Z2JtOU5ZWFJqYUR0Y2JpQWdJQ0JqYjI1emRDQndZWFJvSUQwZ2MyVm5iV1Z1ZEM1d1lYUm9jMWRwZEdoUVlYSmhiWE5iWTNWeWNtVnVkRkJoZEdoSmJtUmxlRjA3WEc0Z0lDQWdZMjl1YzNRZ1kzVnljaUE5SUdkbGRGQmhkR2dvWTI5dGJXRnVaSE5iWTNWeWNtVnVkRU52YlcxaGJtUkpibVJsZUYwcE8xeHVJQ0FnSUdOdmJuTjBJRzVsZUhRZ1BWeHVJQ0FnSUNBZ0lDQmpkWEp5Wlc1MFEyOXRiV0Z1WkVsdVpHVjRJRHdnWTI5dGJXRnVaSE11YkdWdVozUm9JQzBnTVNBL0lHTnZiVzFoYm1SelcyTjFjbkpsYm5SRGIyMXRZVzVrU1c1a1pYZ2dLeUF4WFNBNklHNTFiR3c3WEc1Y2JpQWdJQ0JwWmlBb1kzVnljaUFtSmlCdVpYaDBJQ1ltSUNoMGVYQmxiMllnYm1WNGRDQTlQVDBnSjI5aWFtVmpkQ2NwS1NCN1hHNGdJQ0FnSUNCcFppQW9JV052YlhCaGNtVW9ZM1Z5Y2l3Z2JtVjRkQ3dnY0dGMGFDa3BJSEpsZEhWeWJpQnViMDFoZEdOb08xeHVJQ0FnSUNBZ1kzVnljbVZ1ZEVOdmJXMWhibVJKYm1SbGVDQXJQU0F5TzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnBaaUFvSVdOdmJYQmhjbVVvWTNWeWNpd2dlMzBzSUhCaGRHZ3BLU0J5WlhSMWNtNGdibTlOWVhSamFEdGNiaUFnSUNBZ0lHTjFjbkpsYm5SRGIyMXRZVzVrU1c1a1pYZ3JLenRjYmlBZ0lDQjlYRzRnSUNBZ1kzVnljbVZ1ZEZCaGRHaEpibVJsZUNzck8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIdHRZWFJqYURvZ2RISjFaU3dnYkdGemRFbHVaR1Y0T2lCamRYSnlaVzUwUTI5dGJXRnVaRWx1WkdWNGZUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1kzSmxZWFJsVG1WM1UyVm5iV1Z1ZENoelpXZHRaVzUwT2lCVmNteFRaV2R0Wlc1MExDQnpkR0Z5ZEVsdVpHVjRPaUJ1ZFcxaVpYSXNJR052YlcxaGJtUnpPaUJoYm5sYlhTazZJRlZ5YkZObFoyMWxiblFnZTF4dUlDQmpiMjV6ZENCd1lYUm9jeUE5SUhObFoyMWxiblF1Y0dGMGFITlhhWFJvVUdGeVlXMXpMbk5zYVdObEtEQXNJSE4wWVhKMFNXNWtaWGdwTzF4dUlDQnNaWFFnYVNBOUlEQTdYRzRnSUhkb2FXeGxJQ2hwSUR3Z1kyOXRiV0Z1WkhNdWJHVnVaM1JvS1NCN1hHNGdJQ0FnTHk4Z2FXWWdkMlVnYzNSaGNuUWdkMmwwYUNCaGJpQnZZbXBsWTNRZ2JHbDBaWEpoYkN3Z2QyVWdibVZsWkNCMGJ5QnlaWFZ6WlNCMGFHVWdjR0YwYUNCd1lYSjBJR1p5YjIwZ2RHaGxJSE5sWjIxbGJuUmNiaUFnSUNCcFppQW9hU0E5UFQwZ01DQW1KaUFvZEhsd1pXOW1JR052YlcxaGJtUnpXekJkSUQwOVBTQW5iMkpxWldOMEp5a3BJSHRjYmlBZ0lDQWdJR052Ym5OMElIQWdQU0J6WldkdFpXNTBMbkJoZEdoelYybDBhRkJoY21GdGMxdHpkR0Z5ZEVsdVpHVjRYVHRjYmlBZ0lDQWdJSEJoZEdoekxuQjFjMmdvYm1WM0lGVnliRkJoZEdoWGFYUm9VR0Z5WVcxektIQXVjR0YwYUN3Z1kyOXRiV0Z1WkhOYk1GMHBLVHRjYmlBZ0lDQWdJR2tyS3p0Y2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJR052Ym5OMElHTjFjbklnUFNCblpYUlFZWFJvS0dOdmJXMWhibVJ6VzJsZEtUdGNiaUFnSUNCamIyNXpkQ0J1WlhoMElEMGdLR2tnUENCamIyMXRZVzVrY3k1c1pXNW5kR2dnTFNBeEtTQS9JR052YlcxaGJtUnpXMmtnS3lBeFhTQTZJRzUxYkd3N1hHNGdJQ0FnYVdZZ0tHTjFjbklnSmlZZ2JtVjRkQ0FtSmlBb2RIbHdaVzltSUc1bGVIUWdQVDA5SUNkdlltcGxZM1FuS1NrZ2UxeHVJQ0FnSUNBZ2NHRjBhSE11Y0hWemFDaHVaWGNnVlhKc1VHRjBhRmRwZEdoUVlYSmhiWE1vWTNWeWNpd2djM1J5YVc1bmFXWjVLRzVsZUhRcEtTazdYRzRnSUNBZ0lDQnBJQ3M5SURJN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEJoZEdoekxuQjFjMmdvYm1WM0lGVnliRkJoZEdoWGFYUm9VR0Z5WVcxektHTjFjbklzSUh0OUtTazdYRzRnSUNBZ0lDQnBLeXM3WEc0Z0lDQWdmVnh1SUNCOVhHNGdJSEpsZEhWeWJpQnVaWGNnVlhKc1UyVm5iV1Z1ZENod1lYUm9jeXdnZTMwcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCemRISnBibWRwWm5rb2NHRnlZVzF6T2lCN1cydGxlVG9nYzNSeWFXNW5YVG9nWVc1NWZTazZJSHRiYTJWNU9pQnpkSEpwYm1kZE9pQnpkSEpwYm1kOUlIdGNiaUFnWTI5dWMzUWdjbVZ6T2lCN1cydGxlVG9nYzNSeWFXNW5YVG9nYzNSeWFXNW5mU0E5SUh0OU8xeHVJQ0JtYjNKRllXTm9LSEJoY21GdGN5d2dLSFk2SUdGdWVTd2dhem9nYzNSeWFXNW5LU0E5UGlCeVpYTmJhMTBnUFNCZ0pIdDJmV0FwTzF4dUlDQnlaWFIxY200Z2NtVnpPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpiMjF3WVhKbEtGeHVJQ0FnSUhCaGRHZzZJSE4wY21sdVp5d2djR0Z5WVcxek9pQjdXMnRsZVRvZ2MzUnlhVzVuWFRvZ1lXNTVmU3dnY0dGMGFGZHBkR2hRWVhKaGJYTTZJRlZ5YkZCaGRHaFhhWFJvVUdGeVlXMXpLVG9nWW05dmJHVmhiaUI3WEc0Z0lISmxkSFZ5YmlCd1lYUm9JRDA5SUhCaGRHaFhhWFJvVUdGeVlXMXpMbkJoZEdnZ0ppWWdjMmhoYkd4dmQwVnhkV0ZzS0hCaGNtRnRjeXdnY0dGMGFGZHBkR2hRWVhKaGJYTXVjR0Z5WVcxbGRHVnljeWs3WEc1OUlsMTlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvY3JlYXRlX3VybF90cmVlLmpzXG4gKiogbW9kdWxlIGlkID0gNDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBvZl8xID0gcmVxdWlyZSgncnhqcy9vYnNlcnZhYmxlL29mJyk7XG52YXIgcm91dGVyX3N0YXRlXzEgPSByZXF1aXJlKCcuL3JvdXRlcl9zdGF0ZScpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbnZhciB1cmxfdHJlZV8xID0gcmVxdWlyZSgnLi91cmxfdHJlZScpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbHMvY29sbGVjdGlvbicpO1xudmFyIHRyZWVfMSA9IHJlcXVpcmUoJy4vdXRpbHMvdHJlZScpO1xudmFyIE5vTWF0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vTWF0Y2goc2VnbWVudCkge1xuICAgICAgICBpZiAoc2VnbWVudCA9PT0gdm9pZCAwKSB7IHNlZ21lbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBOb01hdGNoO1xufSgpKTtcbmZ1bmN0aW9uIHJlY29nbml6ZShyb290Q29tcG9uZW50VHlwZSwgY29uZmlnLCB1cmxUcmVlLCB1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwcm9jZXNzU2VnbWVudChjb25maWcsIHVybFRyZWUucm9vdCwgc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpO1xuICAgICAgICB2YXIgcm9vdCA9IG5ldyByb3V0ZXJfc3RhdGVfMS5BY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KFtdLCB7fSwgc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQsIHJvb3RDb21wb25lbnRUeXBlLCBudWxsLCB1cmxUcmVlLnJvb3QsIC0xKTtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gbmV3IHRyZWVfMS5UcmVlTm9kZShyb290LCBjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBvZl8xLm9mKG5ldyByb3V0ZXJfc3RhdGVfMS5Sb3V0ZXJTdGF0ZVNuYXBzaG90KHVybCwgcm9vdE5vZGUsIHVybFRyZWUucXVlcnlQYXJhbXMsIHVybFRyZWUuZnJhZ21lbnQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzLmVycm9yKG5ldyBFcnJvcihcIkNhbm5vdCBtYXRjaCBhbnkgcm91dGVzOiAnXCIgKyBlLnNlZ21lbnQgKyBcIidcIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy5lcnJvcihlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnJlY29nbml6ZSA9IHJlY29nbml6ZTtcbmZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KGNvbmZpZywgc2VnbWVudCwgb3V0bGV0KSB7XG4gICAgaWYgKHNlZ21lbnQucGF0aHNXaXRoUGFyYW1zLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzU2VnbWVudENoaWxkcmVuKGNvbmZpZywgc2VnbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3Byb2Nlc3NQYXRoc1dpdGhQYXJhbXMoY29uZmlnLCBzZWdtZW50LCAwLCBzZWdtZW50LnBhdGhzV2l0aFBhcmFtcywgb3V0bGV0KV07XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnRDaGlsZHJlbihjb25maWcsIHNlZ21lbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB1cmxfdHJlZV8xLm1hcENoaWxkcmVuSW50b0FycmF5KHNlZ21lbnQsIGZ1bmN0aW9uIChjaGlsZCwgY2hpbGRPdXRsZXQpIHsgcmV0dXJuIHByb2Nlc3NTZWdtZW50KGNvbmZpZywgY2hpbGQsIGNoaWxkT3V0bGV0KTsgfSk7XG4gICAgY2hlY2tPdXRsZXROYW1lVW5pcXVlbmVzcyhjaGlsZHJlbik7XG4gICAgc29ydEFjdGl2YXRlZFJvdXRlU25hcHNob3RzKGNoaWxkcmVuKTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBzb3J0QWN0aXZhdGVkUm91dGVTbmFwc2hvdHMobm9kZXMpIHtcbiAgICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLnZhbHVlLm91dGxldCA9PT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChiLnZhbHVlLm91dGxldCA9PT0gc2hhcmVkXzEuUFJJTUFSWV9PVVRMRVQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGEudmFsdWUub3V0bGV0LmxvY2FsZUNvbXBhcmUoYi52YWx1ZS5vdXRsZXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1BhdGhzV2l0aFBhcmFtcyhjb25maWcsIHNlZ21lbnQsIHBhdGhJbmRleCwgcGF0aHMsIG91dGxldCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgY29uZmlnXzEgPSBjb25maWc7IF9pIDwgY29uZmlnXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByID0gY29uZmlnXzFbX2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NQYXRoc1dpdGhQYXJhbXNBZ2FpbnN0Um91dGUociwgc2VnbWVudCwgcGF0aEluZGV4LCBwYXRocywgb3V0bGV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE5vTWF0Y2gpKVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IE5vTWF0Y2goc2VnbWVudCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzUGF0aHNXaXRoUGFyYW1zQWdhaW5zdFJvdXRlKHJvdXRlLCBzZWdtZW50LCBwYXRoSW5kZXgsIHBhdGhzLCBvdXRsZXQpIHtcbiAgICBpZiAocm91dGUucmVkaXJlY3RUbylcbiAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICBpZiAoKHJvdXRlLm91dGxldCA/IHJvdXRlLm91dGxldCA6IHNoYXJlZF8xLlBSSU1BUllfT1VUTEVUKSAhPT0gb3V0bGV0KVxuICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSAnKionKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBwYXRocy5sZW5ndGggPiAwID8gY29sbGVjdGlvbl8xLmxhc3QocGF0aHMpLnBhcmFtZXRlcnMgOiB7fTtcbiAgICAgICAgdmFyIHNuYXBzaG90XzEgPSBuZXcgcm91dGVyX3N0YXRlXzEuQWN0aXZhdGVkUm91dGVTbmFwc2hvdChwYXRocywgcGFyYW1zLCBvdXRsZXQsIHJvdXRlLmNvbXBvbmVudCwgcm91dGUsIHNlZ21lbnQsIC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlXzEuVHJlZU5vZGUoc25hcHNob3RfMSwgW10pO1xuICAgIH1cbiAgICB2YXIgX2EgPSBtYXRjaChzZWdtZW50LCByb3V0ZSwgcGF0aHMpLCBjb25zdW1lZFBhdGhzID0gX2EuY29uc3VtZWRQYXRocywgcGFyYW1ldGVycyA9IF9hLnBhcmFtZXRlcnMsIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZDtcbiAgICB2YXIgc25hcHNob3QgPSBuZXcgcm91dGVyX3N0YXRlXzEuQWN0aXZhdGVkUm91dGVTbmFwc2hvdChjb25zdW1lZFBhdGhzLCBwYXJhbWV0ZXJzLCBvdXRsZXQsIHJvdXRlLmNvbXBvbmVudCwgcm91dGUsIHNlZ21lbnQsIHBhdGhJbmRleCArIGxhc3RDaGlsZCAtIDEpO1xuICAgIHZhciBzbGljZWRQYXRoID0gcGF0aHMuc2xpY2UobGFzdENoaWxkKTtcbiAgICB2YXIgY2hpbGRDb25maWcgPSByb3V0ZS5jaGlsZHJlbiA/IHJvdXRlLmNoaWxkcmVuIDogW107XG4gICAgaWYgKGNoaWxkQ29uZmlnLmxlbmd0aCA9PT0gMCAmJiBzbGljZWRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyZWVfMS5UcmVlTm9kZShzbmFwc2hvdCwgW10pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzbGljZWRQYXRoLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHByb2Nlc3NTZWdtZW50Q2hpbGRyZW4oY2hpbGRDb25maWcsIHNlZ21lbnQpO1xuICAgICAgICByZXR1cm4gbmV3IHRyZWVfMS5UcmVlTm9kZShzbmFwc2hvdCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNoaWxkID0gcHJvY2Vzc1BhdGhzV2l0aFBhcmFtcyhjaGlsZENvbmZpZywgc2VnbWVudCwgcGF0aEluZGV4ICsgbGFzdENoaWxkLCBzbGljZWRQYXRoLCBzaGFyZWRfMS5QUklNQVJZX09VVExFVCk7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZV8xLlRyZWVOb2RlKHNuYXBzaG90LCBbY2hpbGRdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaChzZWdtZW50LCByb3V0ZSwgcGF0aHMpIHtcbiAgICBpZiAocm91dGUucGF0aCA9PT0gJycpIHtcbiAgICAgICAgaWYgKHJvdXRlLnRlcm1pbmFsICYmIChPYmplY3Qua2V5cyhzZWdtZW50LmNoaWxkcmVuKS5sZW5ndGggPiAwIHx8IHBhdGhzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29uc3VtZWRQYXRoczogW10sIGxhc3RDaGlsZDogMCwgcGFyYW1ldGVyczoge30gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBwb3NQYXJhbWV0ZXJzID0ge307XG4gICAgdmFyIGNvbnN1bWVkUGF0aHMgPSBbXTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gcGF0aHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgaXNQb3NQYXJhbSA9IHAuc3RhcnRzV2l0aCgnOicpO1xuICAgICAgICBpZiAoIWlzUG9zUGFyYW0gJiYgcCAhPT0gY3VycmVudC5wYXRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goKTtcbiAgICAgICAgaWYgKGlzUG9zUGFyYW0pIHtcbiAgICAgICAgICAgIHBvc1BhcmFtZXRlcnNbcC5zdWJzdHJpbmcoMSldID0gY3VycmVudC5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN1bWVkUGF0aHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgfVxuICAgIGlmIChyb3V0ZS50ZXJtaW5hbCAmJiAoT2JqZWN0LmtleXMoc2VnbWVudC5jaGlsZHJlbikubGVuZ3RoID4gMCB8fCBjdXJyZW50SW5kZXggPCBwYXRocy5sZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb01hdGNoKCk7XG4gICAgfVxuICAgIHZhciBwYXJhbWV0ZXJzID0gY29sbGVjdGlvbl8xLm1lcmdlKHBvc1BhcmFtZXRlcnMsIGNvbnN1bWVkUGF0aHNbY29uc3VtZWRQYXRocy5sZW5ndGggLSAxXS5wYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4geyBjb25zdW1lZFBhdGhzOiBjb25zdW1lZFBhdGhzLCBsYXN0Q2hpbGQ6IGN1cnJlbnRJbmRleCwgcGFyYW1ldGVyczogcGFyYW1ldGVycyB9O1xufVxuZnVuY3Rpb24gY2hlY2tPdXRsZXROYW1lVW5pcXVlbmVzcyhub2Rlcykge1xuICAgIHZhciBuYW1lcyA9IHt9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHJvdXRlV2l0aFNhbWVPdXRsZXROYW1lID0gbmFtZXNbbi52YWx1ZS5vdXRsZXRdO1xuICAgICAgICBpZiAocm91dGVXaXRoU2FtZU91dGxldE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwID0gcm91dGVXaXRoU2FtZU91dGxldE5hbWUudXJsLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1N0cmluZygpOyB9KS5qb2luKCcvJyk7XG4gICAgICAgICAgICB2YXIgYyA9IG4udmFsdWUudXJsLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1N0cmluZygpOyB9KS5qb2luKCcvJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUd28gc2VnbWVudHMgY2Fubm90IGhhdmUgdGhlIHNhbWUgb3V0bGV0IG5hbWU6ICdcIiArIHAgKyBcIicgYW5kICdcIiArIGMgKyBcIicuXCIpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzW24udmFsdWUub3V0bGV0XSA9IG4udmFsdWU7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljbVZqYjJkdWFYcGxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDNKbFkyOW5ibWw2WlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRMEVzTWtKQlFYbENMR2xDUVVGcFFpeERRVUZETEVOQlFVRTdRVUZGTTBNc2JVSkJRV3RDTEc5Q1FVRnZRaXhEUVVGRExFTkJRVUU3UVVGSGRrTXNOa0pCUVRCRUxHZENRVUZuUWl4RFFVRkRMRU5CUVVFN1FVRkRNMFVzZFVKQlFUWkNMRlZCUVZVc1EwRkJReXhEUVVGQk8wRkJRM2hETEhsQ1FVRXlSU3haUVVGWkxFTkJRVU1zUTBGQlFUdEJRVU40Uml3eVFrRkJNRUlzYjBKQlFXOUNMRU5CUVVNc1EwRkJRVHRCUVVNdlF5eHhRa0ZCZFVJc1kwRkJZeXhEUVVGRExFTkJRVUU3UVVGRmRFTTdTVUZEUlN4cFFrRkJiVUlzVDBGQk1FSTdVVUZCYWtNc2RVSkJRV2xETEVkQlFXcERMR05CUVdsRE8xRkJRVEZDTEZsQlFVOHNSMEZCVUN4UFFVRlBMRU5CUVcxQ08wbEJRVWNzUTBGQlF6dEpRVU51UkN4alFVRkRPMEZCUVVRc1EwRkJReXhCUVVaRUxFbEJSVU03UVVGRlJDeHRRa0ZEU1N4cFFrRkJkVUlzUlVGQlJTeE5RVUZ2UWl4RlFVRkZMRTlCUVdkQ0xFVkJReTlFTEVkQlFWYzdTVUZEWWl4SlFVRkpMRU5CUVVNN1VVRkRTQ3hKUVVGTkxGRkJRVkVzUjBGQlJ5eGpRVUZqTEVOQlFVTXNUVUZCVFN4RlFVRkZMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzZFVKQlFXTXNRMEZCUXl4RFFVRkRPMUZCUTNSRkxFbEJRVTBzU1VGQlNTeEhRVUZITEVsQlFVa3NjVU5CUVhOQ0xFTkJRMjVETEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc2RVSkJRV01zUlVGQlJTeHBRa0ZCYVVJc1JVRkJSU3hKUVVGSkxFVkJRVVVzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1pGTEVsQlFVMHNVVUZCVVN4SFFVRkhMRWxCUVVrc1pVRkJVU3hEUVVGNVFpeEpRVUZKTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNN1VVRkRkRVVzVFVGQlRTeERRVUZETEU5QlFVVXNRMEZCUlN4SlFVRkpMR3REUVVGdFFpeERRVUZETEVkQlFVY3NSVUZCUlN4UlFVRlJMRVZCUVVVc1QwRkJUeXhEUVVGRExGZEJRVmNzUlVGQlJTeFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNMVJpeERRVUZGTzBsQlFVRXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5ZTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3hQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcENMRTFCUVUwc1EwRkJReXhKUVVGSkxIVkNRVUZWTEVOQlEycENMRlZCUVVNc1IwRkJhME03WjBKQlF5OUNMRTlCUVVFc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl3clFrRkJOa0lzUTBGQlF5eERRVUZETEU5QlFVOHNUVUZCUnl4RFFVRkRMRU5CUVVNN1dVRkJMMFFzUTBGQkswUXNRMEZCUXl4RFFVRkRPMUZCUXpORkxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRTFCUVUwc1EwRkJReXhKUVVGSkxIVkNRVUZWTEVOQlEycENMRlZCUVVNc1IwRkJhME1zU1VGQlN5eFBRVUZCTEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVm9zUTBGQldTeERRVUZETEVOQlFVTTdVVUZETlVRc1EwRkJRenRKUVVOSUxFTkJRVU03UVVGRFNDeERRVUZETzBGQmJrSmxMR2xDUVVGVExGbEJiVUo0UWl4RFFVRkJPMEZCUlVRc2QwSkJRMGtzVFVGQlpTeEZRVUZGTEU5QlFXMUNMRVZCUVVVc1RVRkJZenRKUVVOMFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1pVRkJaU3hEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrWXNUVUZCVFN4RFFVRkRMSE5DUVVGelFpeERRVUZETEUxQlFVMHNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOcVJDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFTkJRVU1zUTBGQlF5eHpRa0ZCYzBJc1EwRkJReXhOUVVGTkxFVkJRVVVzVDBGQlR5eEZRVUZGTEVOQlFVTXNSVUZCUlN4UFFVRlBMRU5CUVVNc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZGtZc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGRlJDeG5RMEZEU1N4TlFVRmxMRVZCUVVVc1QwRkJiVUk3U1VGRGRFTXNTVUZCVFN4UlFVRlJMRWRCUVVjc0swSkJRVzlDTEVOQlEycERMRTlCUVU4c1JVRkJSU3hWUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZYTEVsQlFVc3NUMEZCUVN4alFVRmpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZCTVVNc1EwRkJNRU1zUTBGQlF5eERRVUZETzBsQlEycEdMSGxDUVVGNVFpeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUTNCRExESkNRVUV5UWl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8wbEJRM1JETEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1FVRkRiRUlzUTBGQlF6dEJRVVZFTEhGRFFVRnhReXhMUVVGNVF6dEpRVU0xUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExGVkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTTdVVUZEWkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNTMEZCU3l4MVFrRkJZeXhEUVVGRE8xbEJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hMUVVGTExIVkNRVUZqTEVOQlFVTTdXVUZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhFTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU4wUkN4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOTUxFTkJRVU03UVVGRlJDeG5RMEZEU1N4TlFVRmxMRVZCUVVVc1QwRkJiVUlzUlVGQlJTeFRRVUZwUWl4RlFVRkZMRXRCUVRCQ0xFVkJRMjVHTEUxQlFXTTdTVUZEYUVJc1IwRkJSeXhEUVVGRExFTkJRVlVzVlVGQlRTeEZRVUZPTEdsQ1FVRk5MRVZCUVU0c2IwSkJRVTBzUlVGQlRpeEpRVUZOTEVOQlFVTTdVVUZCYUVJc1NVRkJTU3hEUVVGRExHVkJRVUU3VVVGRFVpeEpRVUZKTEVOQlFVTTdXVUZEU0N4TlFVRk5MRU5CUVVNc2EwTkJRV3RETEVOQlFVTXNRMEZCUXl4RlFVRkZMRTlCUVU4c1JVRkJSU3hUUVVGVExFVkJRVVVzUzBGQlN5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTJ4R0xFTkJRVVU3VVVGQlFTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMWdzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3hQUVVGUExFTkJRVU1zUTBGQlF6dG5Ra0ZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOMlF5eERRVUZETzB0QlEwWTdTVUZEUkN4TlFVRk5MRWxCUVVrc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBGQlF6ZENMRU5CUVVNN1FVRkZSQ3cwUTBGRFNTeExRVUZaTEVWQlFVVXNUMEZCYlVJc1JVRkJSU3hUUVVGcFFpeEZRVUZGTEV0QlFUQkNMRVZCUTJoR0xFMUJRV003U1VGRGFFSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF6dFJRVUZETEUxQlFVMHNTVUZCU1N4UFFVRlBMRVZCUVVVc1EwRkJRenRKUVVNeFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNSMEZCUnl4MVFrRkJZeXhEUVVGRExFdEJRVXNzVFVGQlRTeERRVUZETzFGQlFVTXNUVUZCVFN4SlFVRkpMRTlCUVU4c1JVRkJSU3hEUVVGRE8wbEJSVzVHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFdEJRVXNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjRRaXhKUVVGTkxFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1IwRkJSeXhwUWtGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRlZCUVZVc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRE9VUXNTVUZCVFN4VlFVRlJMRWRCUTFZc1NVRkJTU3h4UTBGQmMwSXNRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hGUVVGRkxFMUJRVTBzUlVGQlJTeExRVUZMTEVOQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXpSaXhOUVVGTkxFTkJRVU1zU1VGQlNTeGxRVUZSTEVOQlFYbENMRlZCUVZFc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU0xUkN4RFFVRkRPMGxCUlVRc1NVRkJRU3hwUTBGQk1rVXNSVUZCY0VVc1owTkJRV0VzUlVGQlJTd3dRa0ZCVlN4RlFVRkZMSGRDUVVGVExFTkJRV2xETzBsQlJUVkZMRWxCUVUwc1VVRkJVU3hIUVVGSExFbEJRVWtzY1VOQlFYTkNMRU5CUTNaRExHRkJRV0VzUlVGQlJTeFZRVUZWTEVWQlFVVXNUVUZCVFN4RlFVRkZMRXRCUVVzc1EwRkJReXhUUVVGVExFVkJRVVVzUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZEYkVVc1UwRkJVeXhIUVVGSExGTkJRVk1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXZRaXhKUVVGTkxGVkJRVlVzUjBGQlJ5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8wbEJRekZETEVsQlFVMHNWMEZCVnl4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNSMEZCUnl4RlFVRkZMRU5CUVVNN1NVRkZla1FzUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFbEJRVWtzVlVGQlZTeERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM2hFTEUxQlFVMHNRMEZCUXl4SlFVRkpMR1ZCUVZFc1EwRkJlVUlzVVVGQlVTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUnpWRUxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGREwwVXNTVUZCVFN4UlFVRlJMRWRCUVVjc2MwSkJRWE5DTEVOQlFVTXNWMEZCVnl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRemxFTEUxQlFVMHNRMEZCUXl4SlFVRkpMR1ZCUVZFc1EwRkJlVUlzVVVGQlVTeEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUld4RkxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRWxCUVUwc1MwRkJTeXhIUVVGSExITkNRVUZ6UWl4RFFVTm9ReXhYUVVGWExFVkJRVVVzVDBGQlR5eEZRVUZGTEZOQlFWTXNSMEZCUnl4VFFVRlRMRVZCUVVVc1ZVRkJWU3hGUVVGRkxIVkNRVUZqTEVOQlFVTXNRMEZCUXp0UlFVTTNSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeGxRVUZSTEVOQlFYbENMRkZCUVZFc1JVRkJSU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEYWtVc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGRlJDeGxRVUZsTEU5QlFXMUNMRVZCUVVVc1MwRkJXU3hGUVVGRkxFdEJRVEJDTzBsQlF6RkZMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnlSaXhOUVVGTkxFbEJRVWtzVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEZEVJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNUVUZCVFN4RFFVRkRMRVZCUVVNc1lVRkJZU3hGUVVGRkxFVkJRVVVzUlVGQlJTeFRRVUZUTEVWQlFVVXNRMEZCUXl4RlFVRkZMRlZCUVZVc1JVRkJSU3hGUVVGRkxFVkJRVU1zUTBGQlF6dFJRVU16UkN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRlRUlzU1VGQlRTeExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU01UWl4SlFVRk5MR0ZCUVdFc1IwRkJlVUlzUlVGQlJTeERRVUZETzBsQlF5OURMRWxCUVUwc1lVRkJZU3hIUVVGM1FpeEZRVUZGTEVOQlFVTTdTVUZGT1VNc1NVRkJTU3haUVVGWkxFZEJRVWNzUTBGQlF5eERRVUZETzBsQlJYSkNMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUlVGQlJTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRPMUZCUTNSRExFVkJRVVVzUTBGQlF5eERRVUZETEZsQlFWa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRE8xbEJRVU1zVFVGQlRTeEpRVUZKTEU5QlFVOHNSVUZCUlN4RFFVRkRPMUZCUTNSRUxFbEJRVTBzVDBGQlR5eEhRVUZITEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRenRSUVVWd1F5eEpRVUZOTEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJrSXNTVUZCVFN4VlFVRlZMRWRCUVVjc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVVnlReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZWQlFWVXNTVUZCU1N4RFFVRkRMRXRCUVVzc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF6dFpRVUZETEUxQlFVMHNTVUZCU1N4UFFVRlBMRVZCUVVVc1EwRkJRenRSUVVNelJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMllzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUXk5RExFTkJRVU03VVVGRFJDeGhRVUZoTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRelZDTEZsQlFWa3NSVUZCUlN4RFFVRkRPMGxCUTJwQ0xFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1VVRkJVU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNTVUZCU1N4WlFVRlpMRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm9SeXhOUVVGTkxFbEJRVWtzVDBGQlR5eEZRVUZGTEVOQlFVTTdTVUZEZEVJc1EwRkJRenRKUVVWRUxFbEJRVTBzVlVGQlZTeEhRVUZITEd0Q1FVRkxMRU5CUVVNc1lVRkJZU3hGUVVGRkxHRkJRV0VzUTBGQlF5eGhRVUZoTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzBsQlF6VkdMRTFCUVUwc1EwRkJReXhGUVVGRExHVkJRVUVzWVVGQllTeEZRVUZGTEZOQlFWTXNSVUZCUlN4WlFVRlpMRVZCUVVVc1dVRkJRU3hWUVVGVkxFVkJRVU1zUTBGQlF6dEJRVU01UkN4RFFVRkRPMEZCUlVRc2JVTkJRVzFETEV0QlFYbERPMGxCUXpGRkxFbEJRVTBzUzBGQlN5eEhRVUV3UXl4RlFVRkZMRU5CUVVNN1NVRkRlRVFzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRU5CUVVNN1VVRkRZaXhKUVVGSkxIVkNRVUYxUWl4SFFVRkhMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTNCRUxFVkJRVVVzUTBGQlF5eERRVUZETEhWQ1FVRjFRaXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0xUWl4SlFVRk5MRU5CUVVNc1IwRkJSeXgxUWtGQmRVSXNRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVUVzUTBGQlF5eEpRVUZKTEU5QlFVRXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGYUxFTkJRVmtzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVOMlJTeEpRVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVWQlFWb3NRMEZCV1N4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlEzWkVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zY1VSQlFXMUVMRU5CUVVNc1pVRkJWU3hEUVVGRExFOUJRVWtzUTBGQlF5eERRVUZETzFGQlEzWkdMRU5CUVVNN1VVRkRSQ3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETzBsQlEyeERMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMHdzUTBGQlF5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdWSGx3WlgwZ1puSnZiU0FuUUdGdVozVnNZWEl2WTI5eVpTYzdYRzVwYlhCdmNuUWdlMDlpYzJWeWRtRmliR1Y5SUdaeWIyMGdKM0o0YW5NdlQySnpaWEoyWVdKc1pTYzdYRzVwYlhCdmNuUWdlMDlpYzJWeWRtVnlmU0JtY205dElDZHllR3B6TDA5aWMyVnlkbVZ5Snp0Y2JtbHRjRzl5ZENCN2IyWWdmU0JtY205dElDZHllR3B6TDI5aWMyVnlkbUZpYkdVdmIyWW5PMXh1WEc1cGJYQnZjblFnZTFKdmRYUmxMQ0JTYjNWMFpYSkRiMjVtYVdkOUlHWnliMjBnSnk0dlkyOXVabWxuSnp0Y2JtbHRjRzl5ZENCN1FXTjBhWFpoZEdWa1VtOTFkR1ZUYm1Gd2MyaHZkQ3dnVW05MWRHVnlVM1JoZEdWVGJtRndjMmh2ZEgwZ1puSnZiU0FuTGk5eWIzVjBaWEpmYzNSaGRHVW5PMXh1YVcxd2IzSjBJSHRRVWtsTlFWSlpYMDlWVkV4RlZIMGdabkp2YlNBbkxpOXphR0Z5WldRbk8xeHVhVzF3YjNKMElIdFZjbXhRWVhSb1YybDBhRkJoY21GdGN5d2dWWEpzVTJWbmJXVnVkQ3dnVlhKc1ZISmxaU3dnYldGd1EyaHBiR1J5Wlc1SmJuUnZRWEp5WVhsOUlHWnliMjBnSnk0dmRYSnNYM1J5WldVbk8xeHVhVzF3YjNKMElIdHNZWE4wTENCdFpYSm5aWDBnWm5KdmJTQW5MaTkxZEdsc2N5OWpiMnhzWldOMGFXOXVKenRjYm1sdGNHOXlkQ0I3VkhKbFpVNXZaR1Y5SUdaeWIyMGdKeTR2ZFhScGJITXZkSEpsWlNjN1hHNWNibU5zWVhOeklFNXZUV0YwWTJnZ2UxeHVJQ0JqYjI1emRISjFZM1J2Y2lod2RXSnNhV01nYzJWbmJXVnVkRG9nVlhKc1UyVm5iV1Z1ZENBOUlHNTFiR3dwSUh0OVhHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJ5WldOdloyNXBlbVVvWEc0Z0lDQWdjbTl2ZEVOdmJYQnZibVZ1ZEZSNWNHVTZJRlI1Y0dVc0lHTnZibVpwWnpvZ1VtOTFkR1Z5UTI5dVptbG5MQ0IxY214VWNtVmxPaUJWY214VWNtVmxMRnh1SUNBZ0lIVnliRG9nYzNSeWFXNW5LVG9nVDJKelpYSjJZV0pzWlR4U2IzVjBaWEpUZEdGMFpWTnVZWEJ6YUc5MFBpQjdYRzRnSUhSeWVTQjdYRzRnSUNBZ1kyOXVjM1FnWTJocGJHUnlaVzRnUFNCd2NtOWpaWE56VTJWbmJXVnVkQ2hqYjI1bWFXY3NJSFZ5YkZSeVpXVXVjbTl2ZEN3Z1VGSkpUVUZTV1Y5UFZWUk1SVlFwTzF4dUlDQWdJR052Ym5OMElISnZiM1FnUFNCdVpYY2dRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZENoY2JpQWdJQ0FnSUNBZ1cxMHNJSHQ5TENCUVVrbE5RVkpaWDA5VlZFeEZWQ3dnY205dmRFTnZiWEJ2Ym1WdWRGUjVjR1VzSUc1MWJHd3NJSFZ5YkZSeVpXVXVjbTl2ZEN3Z0xURXBPMXh1SUNBZ0lHTnZibk4wSUhKdmIzUk9iMlJsSUQwZ2JtVjNJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0tISnZiM1FzSUdOb2FXeGtjbVZ1S1R0Y2JpQWdJQ0J5WlhSMWNtNGdiMllnS0c1bGR5QlNiM1YwWlhKVGRHRjBaVk51WVhCemFHOTBLSFZ5YkN3Z2NtOXZkRTV2WkdVc0lIVnliRlJ5WldVdWNYVmxjbmxRWVhKaGJYTXNJSFZ5YkZSeVpXVXVabkpoWjIxbGJuUXBLVHRjYmlBZ2ZTQmpZWFJqYUNBb1pTa2dlMXh1SUNBZ0lHbG1JQ2hsSUdsdWMzUmhibU5sYjJZZ1RtOU5ZWFJqYUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUc1bGR5QlBZbk5sY25aaFlteGxQRkp2ZFhSbGNsTjBZWFJsVTI1aGNITm9iM1ErS0Z4dUlDQWdJQ0FnSUNBZ0lDaHZZbk02SUU5aWMyVnlkbVZ5UEZKdmRYUmxjbE4wWVhSbFUyNWhjSE5vYjNRK0tTQTlQbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnZZbk11WlhKeWIzSW9ibVYzSUVWeWNtOXlLR0JEWVc1dWIzUWdiV0YwWTJnZ1lXNTVJSEp2ZFhSbGN6b2dKeVI3WlM1elpXZHRaVzUwZlNkZ0tTa3BPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lFOWljMlZ5ZG1GaWJHVThVbTkxZEdWeVUzUmhkR1ZUYm1Gd2MyaHZkRDRvWEc0Z0lDQWdJQ0FnSUNBZ0tHOWljem9nVDJKelpYSjJaWEk4VW05MWRHVnlVM1JoZEdWVGJtRndjMmh2ZEQ0cElEMCtJRzlpY3k1bGNuSnZjaWhsS1NrN1hHNGdJQ0FnZlZ4dUlDQjlYRzU5WEc1Y2JtWjFibU4wYVc5dUlIQnliMk5sYzNOVFpXZHRaVzUwS0Z4dUlDQWdJR052Ym1acFp6b2dVbTkxZEdWYlhTd2djMlZuYldWdWREb2dWWEpzVTJWbmJXVnVkQ3dnYjNWMGJHVjBPaUJ6ZEhKcGJtY3BPaUJVY21WbFRtOWtaVHhCWTNScGRtRjBaV1JTYjNWMFpWTnVZWEJ6YUc5MFBsdGRJSHRjYmlBZ2FXWWdLSE5sWjIxbGJuUXVjR0YwYUhOWGFYUm9VR0Z5WVcxekxteGxibWQwYUNBOVBUMGdNQ0FtSmlCUFltcGxZM1F1YTJWNWN5aHpaV2R0Wlc1MExtTm9hV3hrY21WdUtTNXNaVzVuZEdnZ1BpQXdLU0I3WEc0Z0lDQWdjbVYwZFhKdUlIQnliMk5sYzNOVFpXZHRaVzUwUTJocGJHUnlaVzRvWTI5dVptbG5MQ0J6WldkdFpXNTBLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J5WlhSMWNtNGdXM0J5YjJObGMzTlFZWFJvYzFkcGRHaFFZWEpoYlhNb1kyOXVabWxuTENCelpXZHRaVzUwTENBd0xDQnpaV2R0Wlc1MExuQmhkR2h6VjJsMGFGQmhjbUZ0Y3l3Z2IzVjBiR1YwS1YwN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdjSEp2WTJWemMxTmxaMjFsYm5SRGFHbHNaSEpsYmloY2JpQWdJQ0JqYjI1bWFXYzZJRkp2ZFhSbFcxMHNJSE5sWjIxbGJuUTZJRlZ5YkZObFoyMWxiblFwT2lCVWNtVmxUbTlrWlR4QlkzUnBkbUYwWldSU2IzVjBaVk51WVhCemFHOTBQbHRkSUh0Y2JpQWdZMjl1YzNRZ1kyaHBiR1J5Wlc0Z1BTQnRZWEJEYUdsc1pISmxia2x1ZEc5QmNuSmhlU2hjYmlBZ0lDQWdJSE5sWjIxbGJuUXNJQ2hqYUdsc1pDd2dZMmhwYkdSUGRYUnNaWFFwSUQwK0lIQnliMk5sYzNOVFpXZHRaVzUwS0dOdmJtWnBaeXdnWTJocGJHUXNJR05vYVd4a1QzVjBiR1YwS1NrN1hHNGdJR05vWldOclQzVjBiR1YwVG1GdFpWVnVhWEYxWlc1bGMzTW9ZMmhwYkdSeVpXNHBPMXh1SUNCemIzSjBRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZEhNb1kyaHBiR1J5Wlc0cE8xeHVJQ0J5WlhSMWNtNGdZMmhwYkdSeVpXNDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlITnZjblJCWTNScGRtRjBaV1JTYjNWMFpWTnVZWEJ6YUc5MGN5aHViMlJsY3pvZ1ZISmxaVTV2WkdVOFFXTjBhWFpoZEdWa1VtOTFkR1ZUYm1Gd2MyaHZkRDViWFNrNklIWnZhV1FnZTF4dUlDQnViMlJsY3k1emIzSjBLQ2hoTENCaUtTQTlQaUI3WEc0Z0lDQWdhV1lnS0dFdWRtRnNkV1V1YjNWMGJHVjBJRDA5UFNCUVVrbE5RVkpaWDA5VlZFeEZWQ2tnY21WMGRYSnVJQzB4TzF4dUlDQWdJR2xtSUNoaUxuWmhiSFZsTG05MWRHeGxkQ0E5UFQwZ1VGSkpUVUZTV1Y5UFZWUk1SVlFwSUhKbGRIVnliaUF4TzF4dUlDQWdJSEpsZEhWeWJpQmhMblpoYkhWbExtOTFkR3hsZEM1c2IyTmhiR1ZEYjIxd1lYSmxLR0l1ZG1Gc2RXVXViM1YwYkdWMEtUdGNiaUFnZlNrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhCeWIyTmxjM05RWVhSb2MxZHBkR2hRWVhKaGJYTW9YRzRnSUNBZ1kyOXVabWxuT2lCU2IzVjBaVnRkTENCelpXZHRaVzUwT2lCVmNteFRaV2R0Wlc1MExDQndZWFJvU1c1a1pYZzZJRzUxYldKbGNpd2djR0YwYUhNNklGVnliRkJoZEdoWGFYUm9VR0Z5WVcxelcxMHNYRzRnSUNBZ2IzVjBiR1YwT2lCemRISnBibWNwT2lCVWNtVmxUbTlrWlR4QlkzUnBkbUYwWldSU2IzVjBaVk51WVhCemFHOTBQaUI3WEc0Z0lHWnZjaUFvYkdWMElISWdiMllnWTI5dVptbG5LU0I3WEc0Z0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ3Y205alpYTnpVR0YwYUhOWGFYUm9VR0Z5WVcxelFXZGhhVzV6ZEZKdmRYUmxLSElzSUhObFoyMWxiblFzSUhCaGRHaEpibVJsZUN3Z2NHRjBhSE1zSUc5MWRHeGxkQ2s3WEc0Z0lDQWdmU0JqWVhSamFDQW9aU2tnZTF4dUlDQWdJQ0FnYVdZZ0tDRW9aU0JwYm5OMFlXNWpaVzltSUU1dlRXRjBZMmdwS1NCMGFISnZkeUJsTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0IwYUhKdmR5QnVaWGNnVG05TllYUmphQ2h6WldkdFpXNTBLVHRjYm4xY2JseHVablZ1WTNScGIyNGdjSEp2WTJWemMxQmhkR2h6VjJsMGFGQmhjbUZ0YzBGbllXbHVjM1JTYjNWMFpTaGNiaUFnSUNCeWIzVjBaVG9nVW05MWRHVXNJSE5sWjIxbGJuUTZJRlZ5YkZObFoyMWxiblFzSUhCaGRHaEpibVJsZURvZ2JuVnRZbVZ5TENCd1lYUm9jem9nVlhKc1VHRjBhRmRwZEdoUVlYSmhiWE5iWFN4Y2JpQWdJQ0J2ZFhSc1pYUTZJSE4wY21sdVp5azZJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0lIdGNiaUFnYVdZZ0tISnZkWFJsTG5KbFpHbHlaV04wVkc4cElIUm9jbTkzSUc1bGR5Qk9iMDFoZEdOb0tDazdYRzRnSUdsbUlDZ29jbTkxZEdVdWIzVjBiR1YwSUQ4Z2NtOTFkR1V1YjNWMGJHVjBJRG9nVUZKSlRVRlNXVjlQVlZSTVJWUXBJQ0U5UFNCdmRYUnNaWFFwSUhSb2NtOTNJRzVsZHlCT2IwMWhkR05vS0NrN1hHNWNiaUFnYVdZZ0tISnZkWFJsTG5CaGRHZ2dQVDA5SUNjcUtpY3BJSHRjYmlBZ0lDQmpiMjV6ZENCd1lYSmhiWE1nUFNCd1lYUm9jeTVzWlc1bmRHZ2dQaUF3SUQ4Z2JHRnpkQ2h3WVhSb2N5a3VjR0Z5WVcxbGRHVnljeUE2SUh0OU8xeHVJQ0FnSUdOdmJuTjBJSE51WVhCemFHOTBJRDFjYmlBZ0lDQWdJQ0FnYm1WM0lFRmpkR2wyWVhSbFpGSnZkWFJsVTI1aGNITm9iM1FvY0dGMGFITXNJSEJoY21GdGN5d2diM1YwYkdWMExDQnliM1YwWlM1amIyMXdiMjVsYm5Rc0lISnZkWFJsTENCelpXZHRaVzUwTENBdE1TazdYRzRnSUNBZ2NtVjBkWEp1SUc1bGR5QlVjbVZsVG05a1pUeEJZM1JwZG1GMFpXUlNiM1YwWlZOdVlYQnphRzkwUGloemJtRndjMmh2ZEN3Z1cxMHBPMXh1SUNCOVhHNWNiaUFnWTI5dWMzUWdlMk52Ym5OMWJXVmtVR0YwYUhNc0lIQmhjbUZ0WlhSbGNuTXNJR3hoYzNSRGFHbHNaSDBnUFNCdFlYUmphQ2h6WldkdFpXNTBMQ0J5YjNWMFpTd2djR0YwYUhNcE8xeHVYRzRnSUdOdmJuTjBJSE51WVhCemFHOTBJRDBnYm1WM0lFRmpkR2wyWVhSbFpGSnZkWFJsVTI1aGNITm9iM1FvWEc0Z0lDQWdJQ0JqYjI1emRXMWxaRkJoZEdoekxDQndZWEpoYldWMFpYSnpMQ0J2ZFhSc1pYUXNJSEp2ZFhSbExtTnZiWEJ2Ym1WdWRDd2djbTkxZEdVc0lITmxaMjFsYm5Rc1hHNGdJQ0FnSUNCd1lYUm9TVzVrWlhnZ0t5QnNZWE4wUTJocGJHUWdMU0F4S1R0Y2JpQWdZMjl1YzNRZ2MyeHBZMlZrVUdGMGFDQTlJSEJoZEdoekxuTnNhV05sS0d4aGMzUkRhR2xzWkNrN1hHNGdJR052Ym5OMElHTm9hV3hrUTI5dVptbG5JRDBnY205MWRHVXVZMmhwYkdSeVpXNGdQeUJ5YjNWMFpTNWphR2xzWkhKbGJpQTZJRnRkTzF4dVhHNGdJR2xtSUNoamFHbHNaRU52Ym1acFp5NXNaVzVuZEdnZ1BUMDlJREFnSmlZZ2MyeHBZMlZrVUdGMGFDNXNaVzVuZEdnZ1BUMDlJREFwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdibVYzSUZSeVpXVk9iMlJsUEVGamRHbDJZWFJsWkZKdmRYUmxVMjVoY0hOb2IzUStLSE51WVhCemFHOTBMQ0JiWFNrN1hHNWNiaUFnSUNBdkx5QlVUMFJQT2lCamFHVmpheUIwYUdGMElIUm9aU0J5YVdkb2RDQnpaV2R0Wlc1MElHbHpJSEJ5WlhObGJuUmNiaUFnZlNCbGJITmxJR2xtSUNoemJHbGpaV1JRWVhSb0xteGxibWQwYUNBOVBUMGdNQ0FtSmlCUFltcGxZM1F1YTJWNWN5aHpaV2R0Wlc1MExtTm9hV3hrY21WdUtTNXNaVzVuZEdnZ1BpQXdLU0I3WEc0Z0lDQWdZMjl1YzNRZ1kyaHBiR1J5Wlc0Z1BTQndjbTlqWlhOelUyVm5iV1Z1ZEVOb2FXeGtjbVZ1S0dOb2FXeGtRMjl1Wm1sbkxDQnpaV2R0Wlc1MEtUdGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lGUnlaV1ZPYjJSbFBFRmpkR2wyWVhSbFpGSnZkWFJsVTI1aGNITm9iM1ErS0hOdVlYQnphRzkwTENCamFHbHNaSEpsYmlrN1hHNWNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQmpiMjV6ZENCamFHbHNaQ0E5SUhCeWIyTmxjM05RWVhSb2MxZHBkR2hRWVhKaGJYTW9YRzRnSUNBZ0lDQWdJR05vYVd4a1EyOXVabWxuTENCelpXZHRaVzUwTENCd1lYUm9TVzVrWlhnZ0t5QnNZWE4wUTJocGJHUXNJSE5zYVdObFpGQmhkR2dzSUZCU1NVMUJVbGxmVDFWVVRFVlVLVHRjYmlBZ0lDQnlaWFIxY200Z2JtVjNJRlJ5WldWT2IyUmxQRUZqZEdsMllYUmxaRkp2ZFhSbFUyNWhjSE5vYjNRK0tITnVZWEJ6YUc5MExDQmJZMmhwYkdSZEtUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ0WVhSamFDaHpaV2R0Wlc1ME9pQlZjbXhUWldkdFpXNTBMQ0J5YjNWMFpUb2dVbTkxZEdVc0lIQmhkR2h6T2lCVmNteFFZWFJvVjJsMGFGQmhjbUZ0YzF0ZEtTQjdYRzRnSUdsbUlDaHliM1YwWlM1d1lYUm9JRDA5UFNBbkp5a2dlMXh1SUNBZ0lHbG1JQ2h5YjNWMFpTNTBaWEp0YVc1aGJDQW1KaUFvVDJKcVpXTjBMbXRsZVhNb2MyVm5iV1Z1ZEM1amFHbHNaSEpsYmlrdWJHVnVaM1JvSUQ0Z01DQjhmQ0J3WVhSb2N5NXNaVzVuZEdnZ1BpQXdLU2tnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUU1dlRXRjBZMmdvS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIdGpiMjV6ZFcxbFpGQmhkR2h6T2lCYlhTd2diR0Z6ZEVOb2FXeGtPaUF3TENCd1lYSmhiV1YwWlhKek9pQjdmWDA3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnWTI5dWMzUWdjR0YwYUNBOUlISnZkWFJsTG5CaGRHZzdYRzRnSUdOdmJuTjBJSEJoY25SeklEMGdjR0YwYUM1emNHeHBkQ2duTHljcE8xeHVJQ0JqYjI1emRDQndiM05RWVhKaGJXVjBaWEp6T2lCN1cydGxlVG9nYzNSeWFXNW5YVG9nWVc1NWZTQTlJSHQ5TzF4dUlDQmpiMjV6ZENCamIyNXpkVzFsWkZCaGRHaHpPaUJWY214UVlYUm9WMmwwYUZCaGNtRnRjMXRkSUQwZ1cxMDdYRzVjYmlBZ2JHVjBJR04xY25KbGJuUkpibVJsZUNBOUlEQTdYRzVjYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQndZWEowY3k1c1pXNW5kR2c3SUNzcmFTa2dlMXh1SUNBZ0lHbG1JQ2hqZFhKeVpXNTBTVzVrWlhnZ1BqMGdjR0YwYUhNdWJHVnVaM1JvS1NCMGFISnZkeUJ1WlhjZ1RtOU5ZWFJqYUNncE8xeHVJQ0FnSUdOdmJuTjBJR04xY25KbGJuUWdQU0J3WVhSb2MxdGpkWEp5Wlc1MFNXNWtaWGhkTzF4dVhHNGdJQ0FnWTI5dWMzUWdjQ0E5SUhCaGNuUnpXMmxkTzF4dUlDQWdJR052Ym5OMElHbHpVRzl6VUdGeVlXMGdQU0J3TG5OMFlYSjBjMWRwZEdnb0p6b25LVHRjYmx4dUlDQWdJR2xtSUNnaGFYTlFiM05RWVhKaGJTQW1KaUJ3SUNFOVBTQmpkWEp5Wlc1MExuQmhkR2dwSUhSb2NtOTNJRzVsZHlCT2IwMWhkR05vS0NrN1hHNGdJQ0FnYVdZZ0tHbHpVRzl6VUdGeVlXMHBJSHRjYmlBZ0lDQWdJSEJ2YzFCaGNtRnRaWFJsY25OYmNDNXpkV0p6ZEhKcGJtY29NU2xkSUQwZ1kzVnljbVZ1ZEM1d1lYUm9PMXh1SUNBZ0lIMWNiaUFnSUNCamIyNXpkVzFsWkZCaGRHaHpMbkIxYzJnb1kzVnljbVZ1ZENrN1hHNGdJQ0FnWTNWeWNtVnVkRWx1WkdWNEt5czdYRzRnSUgxY2JseHVJQ0JwWmlBb2NtOTFkR1V1ZEdWeWJXbHVZV3dnSmlZZ0tFOWlhbVZqZEM1clpYbHpLSE5sWjIxbGJuUXVZMmhwYkdSeVpXNHBMbXhsYm1kMGFDQStJREFnZkh3Z1kzVnljbVZ1ZEVsdVpHVjRJRHdnY0dGMGFITXViR1Z1WjNSb0tTa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5Qk9iMDFoZEdOb0tDazdYRzRnSUgxY2JseHVJQ0JqYjI1emRDQndZWEpoYldWMFpYSnpJRDBnYldWeVoyVW9jRzl6VUdGeVlXMWxkR1Z5Y3l3Z1kyOXVjM1Z0WldSUVlYUm9jMXRqYjI1emRXMWxaRkJoZEdoekxteGxibWQwYUNBdElERmRMbkJoY21GdFpYUmxjbk1wTzF4dUlDQnlaWFIxY200Z2UyTnZibk4xYldWa1VHRjBhSE1zSUd4aGMzUkRhR2xzWkRvZ1kzVnljbVZ1ZEVsdVpHVjRMQ0J3WVhKaGJXVjBaWEp6ZlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnWTJobFkydFBkWFJzWlhST1lXMWxWVzVwY1hWbGJtVnpjeWh1YjJSbGN6b2dWSEpsWlU1dlpHVThRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZEQ1YlhTazZJSFp2YVdRZ2UxeHVJQ0JqYjI1emRDQnVZVzFsY3pvZ2UxdHJPaUJ6ZEhKcGJtZGRPaUJCWTNScGRtRjBaV1JTYjNWMFpWTnVZWEJ6YUc5MGZTQTlJSHQ5TzF4dUlDQnViMlJsY3k1bWIzSkZZV05vS0c0Z1BUNGdlMXh1SUNBZ0lHeGxkQ0J5YjNWMFpWZHBkR2hUWVcxbFQzVjBiR1YwVG1GdFpTQTlJRzVoYldWelcyNHVkbUZzZFdVdWIzVjBiR1YwWFR0Y2JpQWdJQ0JwWmlBb2NtOTFkR1ZYYVhSb1UyRnRaVTkxZEd4bGRFNWhiV1VwSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJSEFnUFNCeWIzVjBaVmRwZEdoVFlXMWxUM1YwYkdWMFRtRnRaUzUxY213dWJXRndLSE1nUFQ0Z2N5NTBiMU4wY21sdVp5Z3BLUzVxYjJsdUtDY3ZKeWs3WEc0Z0lDQWdJQ0JqYjI1emRDQmpJRDBnYmk1MllXeDFaUzUxY213dWJXRndLSE1nUFQ0Z2N5NTBiMU4wY21sdVp5Z3BLUzVxYjJsdUtDY3ZKeWs3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9ZRlIzYnlCelpXZHRaVzUwY3lCallXNXViM1FnYUdGMlpTQjBhR1VnYzJGdFpTQnZkWFJzWlhRZ2JtRnRaVG9nSnlSN2NIMG5JR0Z1WkNBbkpIdGpmU2N1WUNrN1hHNGdJQ0FnZlZ4dUlDQWdJRzVoYldWelcyNHVkbUZzZFdVdWIzVjBiR1YwWFNBOUlHNHVkbUZzZFdVN1hHNGdJSDBwTzF4dWZTSmRmUT09XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQGFuZ3VsYXIvcm91dGVyL3JlY29nbml6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9tYXAnKTtcbnJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL3RvUHJvbWlzZScpO1xudmFyIGZvcmtKb2luXzEgPSByZXF1aXJlKCdyeGpzL29ic2VydmFibGUvZm9ya0pvaW4nKTtcbnZhciBmcm9tUHJvbWlzZV8xID0gcmVxdWlyZSgncnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJyk7XG5mdW5jdGlvbiByZXNvbHZlKHJlc29sdmVyLCBzdGF0ZSkge1xuICAgIHJldHVybiByZXNvbHZlTm9kZShyZXNvbHZlciwgc3RhdGUuX3Jvb3QpLm1hcChmdW5jdGlvbiAoXykgeyByZXR1cm4gc3RhdGU7IH0pO1xufVxuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmZ1bmN0aW9uIHJlc29sdmVOb2RlKHJlc29sdmVyLCBub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmcm9tUHJvbWlzZV8xLmZyb21Qcm9taXNlKHJlc29sdmVyLnJlc29sdmVDb21wb25lbnQobm9kZS52YWx1ZS5jb21wb25lbnQpLnRoZW4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUuX3Jlc29sdmVkQ29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gcmVzb2x2ZU5vZGUocmVzb2x2ZXIsIGMpLnRvUHJvbWlzZSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luXzEuZm9ya0pvaW4oYykubWFwKGZ1bmN0aW9uIChfKSB7IHJldHVybiByZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50KG5vZGUudmFsdWUuY29tcG9uZW50KS50aGVuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlLl9yZXNvbHZlZENvbXBvbmVudEZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH0pOyB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljbVZ6YjJ4MlpTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTl5WlhOdmJIWmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFTeFJRVUZQTEhWQ1FVRjFRaXhEUVVGRExFTkJRVUU3UVVGREwwSXNVVUZCVHl3MlFrRkJOa0lzUTBGQlF5eERRVUZCTzBGQlNYSkRMSGxDUVVGMVFpd3dRa0ZCTUVJc1EwRkJReXhEUVVGQk8wRkJRMnhFTERSQ1FVRXdRaXcyUWtGQk5rSXNRMEZCUXl4RFFVRkJPMEZCUzNoRUxHbENRVU5KTEZGQlFUSkNMRVZCUVVVc1MwRkJNRUk3U1VGRGVrUXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhSUVVGUkxFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGQkxFTkJRVU1zU1VGQlNTeFBRVUZCTEV0QlFVc3NSVUZCVEN4RFFVRkxMRU5CUVVNc1EwRkJRenRCUVVNMVJDeERRVUZETzBGQlNHVXNaVUZCVHl4VlFVZDBRaXhEUVVGQk8wRkJSVVFzY1VKQlEwa3NVVUZCTWtJc1JVRkJSU3hKUVVGelF6dEpRVU55UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlDTEUxQlFVMHNRMEZCUXl4NVFrRkJWeXhEUVVGRExGRkJRVkVzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJUU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGQkxFOUJRVTg3V1VGRGJFWXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXg1UWtGQmVVSXNSMEZCUnl4UFFVRlBMRU5CUVVNN1dVRkRMME1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRjRUlzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVk9MRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEVsQlFVMHNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVRXNRMEZCUXl4SlFVRkpMRTlCUVVFc1YwRkJWeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRVZCUVVVc1JVRkJjRU1zUTBGQmIwTXNRMEZCUXl4RFFVRkRPMUZCUTNaRkxFMUJRVTBzUTBGQlF5eHRRa0ZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGRGJFSXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hSUVVGUkxFTkJRVU1zWjBKQlFXZENMRU5CUVUwc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJRU3hQUVVGUE8xbEJRM0JGTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc2VVSkJRWGxDTEVkQlFVY3NUMEZCVHl4RFFVRkRPMWxCUXk5RExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTNCQ0xFTkJRVU1zUTBGQlF5eEZRVWhITEVOQlIwZ3NRMEZCUXl4RFFVRkRPMGxCUTFZc1EwRkJRenRCUVVOSUxFTkJRVU1pTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKcGJYQnZjblFnSjNKNGFuTXZZV1JrTDI5d1pYSmhkRzl5TDIxaGNDYzdYRzVwYlhCdmNuUWdKM0o0YW5NdllXUmtMMjl3WlhKaGRHOXlMM1J2VUhKdmJXbHpaU2M3WEc1Y2JtbHRjRzl5ZENCN1EyOXRjRzl1Wlc1MFVtVnpiMngyWlhKOUlHWnliMjBnSjBCaGJtZDFiR0Z5TDJOdmNtVW5PMXh1YVcxd2IzSjBJSHRQWW5ObGNuWmhZbXhsZlNCbWNtOXRJQ2R5ZUdwekwwOWljMlZ5ZG1GaWJHVW5PMXh1YVcxd2IzSjBJSHRtYjNKclNtOXBibjBnWm5KdmJTQW5jbmhxY3k5dlluTmxjblpoWW14bEwyWnZjbXRLYjJsdUp6dGNibWx0Y0c5eWRDQjdabkp2YlZCeWIyMXBjMlY5SUdaeWIyMGdKM0o0YW5NdmIySnpaWEoyWVdKc1pTOW1jbTl0VUhKdmJXbHpaU2M3WEc1Y2JtbHRjRzl5ZENCN1FXTjBhWFpoZEdWa1VtOTFkR1ZUYm1Gd2MyaHZkQ3dnVW05MWRHVnlVM1JoZEdWVGJtRndjMmh2ZEgwZ1puSnZiU0FuTGk5eWIzVjBaWEpmYzNSaGRHVW5PMXh1YVcxd2IzSjBJSHRVY21WbFRtOWtaWDBnWm5KdmJTQW5MaTkxZEdsc2N5OTBjbVZsSnp0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlISmxjMjlzZG1Vb1hHNGdJQ0FnY21WemIyeDJaWEk2SUVOdmJYQnZibVZ1ZEZKbGMyOXNkbVZ5TENCemRHRjBaVG9nVW05MWRHVnlVM1JoZEdWVGJtRndjMmh2ZENrNklFOWljMlZ5ZG1GaWJHVThVbTkxZEdWeVUzUmhkR1ZUYm1Gd2MyaHZkRDRnZTF4dUlDQnlaWFIxY200Z2NtVnpiMngyWlU1dlpHVW9jbVZ6YjJ4MlpYSXNJSE4wWVhSbExsOXliMjkwS1M1dFlYQW9YeUE5UGlCemRHRjBaU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsYzI5c2RtVk9iMlJsS0Z4dUlDQWdJSEpsYzI5c2RtVnlPaUJEYjIxd2IyNWxiblJTWlhOdmJIWmxjaXdnYm05a1pUb2dWSEpsWlU1dlpHVThRV04wYVhaaGRHVmtVbTkxZEdWVGJtRndjMmh2ZEQ0cE9pQlBZbk5sY25aaFlteGxQR0Z1ZVQ0Z2UxeHVJQ0JwWmlBb2JtOWtaUzVqYUdsc1pISmxiaTVzWlc1bmRHZ2dQVDA5SURBcElIdGNiaUFnSUNCeVpYUjFjbTRnWm5KdmJWQnliMjFwYzJVb2NtVnpiMngyWlhJdWNtVnpiMngyWlVOdmJYQnZibVZ1ZENnOFlXNTVQbTV2WkdVdWRtRnNkV1V1WTI5dGNHOXVaVzUwS1M1MGFHVnVLR1poWTNSdmNua2dQVDRnZTF4dUlDQWdJQ0FnYm05a1pTNTJZV3gxWlM1ZmNtVnpiMngyWldSRGIyMXdiMjVsYm5SR1lXTjBiM0o1SUQwZ1ptRmpkRzl5ZVR0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ1YjJSbExuWmhiSFZsTzF4dUlDQWdJSDBwS1R0Y2JseHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHTnZibk4wSUdNZ1BTQnViMlJsTG1Ob2FXeGtjbVZ1TG0xaGNDaGpJRDArSUhKbGMyOXNkbVZPYjJSbEtISmxjMjlzZG1WeUxDQmpLUzUwYjFCeWIyMXBjMlVvS1NrN1hHNGdJQ0FnY21WMGRYSnVJR1p2Y210S2IybHVLR01wTG0xaGNDaGNiaUFnSUNBZ0lDQWdYeUE5UGlCeVpYTnZiSFpsY2k1eVpYTnZiSFpsUTI5dGNHOXVaVzUwS0R4aGJuaytibTlrWlM1MllXeDFaUzVqYjIxd2IyNWxiblFwTG5Sb1pXNG9abUZqZEc5eWVTQTlQaUI3WEc0Z0lDQWdJQ0FnSUNBZ2JtOWtaUzUyWVd4MVpTNWZjbVZ6YjJ4MlpXUkRiMjF3YjI1bGJuUkdZV04wYjNKNUlEMGdabUZqZEc5eWVUdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdibTlrWlM1MllXeDFaVHRjYmlBZ0lDQWdJQ0FnZlNrcE8xeHVJQ0I5WEc1OUlsMTlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvcmVzb2x2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRvUHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdG9Qcm9taXNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gdG9Qcm9taXNlXzEudG9Qcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9Qcm9taXNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3RvUHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUHJvbWlzZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vUHJvbWlzZU9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbVByb21pc2UgPSBQcm9taXNlT2JzZXJ2YWJsZV8xLlByb21pc2VPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21Qcm9taXNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUm91dGVyT3V0bGV0TWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJPdXRsZXRNYXAoKSB7XG4gICAgICAgIHRoaXMuX291dGxldHMgPSB7fTtcbiAgICB9XG4gICAgUm91dGVyT3V0bGV0TWFwLnByb3RvdHlwZS5yZWdpc3Rlck91dGxldCA9IGZ1bmN0aW9uIChuYW1lLCBvdXRsZXQpIHsgdGhpcy5fb3V0bGV0c1tuYW1lXSA9IG91dGxldDsgfTtcbiAgICByZXR1cm4gUm91dGVyT3V0bGV0TWFwO1xufSgpKTtcbmV4cG9ydHMuUm91dGVyT3V0bGV0TWFwID0gUm91dGVyT3V0bGV0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY205MWRHVnlYMjkxZEd4bGRGOXRZWEF1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmNtOTFkR1Z5WDI5MWRHeGxkRjl0WVhBdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVXRCTzBsQlFVRTdVVUZGUlN4aFFVRlJMRWRCUVcxRExFVkJRVVVzUTBGQlF6dEpRVVZvUkN4RFFVRkRPMGxCUkVNc2QwTkJRV01zUjBGQlpDeFZRVUZsTEVsQlFWa3NSVUZCUlN4TlFVRnZRaXhKUVVGVkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU0xUml4elFrRkJRenRCUVVGRUxFTkJRVU1zUVVGS1JDeEpRVWxETzBGQlNsa3NkVUpCUVdVc2EwSkJTVE5DTEVOQlFVRWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpwYlhCdmNuUWdlMUp2ZFhSbGNrOTFkR3hsZEgwZ1puSnZiU0FuTGk5a2FYSmxZM1JwZG1WekwzSnZkWFJsY2w5dmRYUnNaWFFuTzF4dVhHNHZLaXBjYmlBcUlFQnBiblJsY201aGJGeHVJQ292WEc1bGVIQnZjblFnWTJ4aGMzTWdVbTkxZEdWeVQzVjBiR1YwVFdGd0lIdGNiaUFnTHlvcUlFQnBiblJsY201aGJDQXFMMXh1SUNCZmIzVjBiR1YwY3pvZ2UxdHVZVzFsT2lCemRISnBibWRkT2lCU2IzVjBaWEpQZFhSc1pYUjlJRDBnZTMwN1hHNGdJSEpsWjJsemRHVnlUM1YwYkdWMEtHNWhiV1U2SUhOMGNtbHVaeXdnYjNWMGJHVjBPaUJTYjNWMFpYSlBkWFJzWlhRcE9pQjJiMmxrSUhzZ2RHaHBjeTVmYjNWMGJHVjBjMXR1WVcxbFhTQTlJRzkxZEd4bGREc2dmVnh1ZlZ4dUlsMTlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvcm91dGVyX291dGxldF9tYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA0MzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKCcuLi9yb3V0ZXInKTtcbnZhciB1cmxfdHJlZV8xID0gcmVxdWlyZSgnLi4vdXJsX3RyZWUnKTtcbnZhciByb3V0ZXJfbGlua18xID0gcmVxdWlyZSgnLi9yb3V0ZXJfbGluaycpO1xudmFyIFJvdXRlckxpbmtBY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtBY3RpdmUocm91dGVyLCBlbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9ucyA9IHsgZXhhY3Q6IHRydWUgfTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiByb3V0ZXJfMS5OYXZpZ2F0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGlua3MuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gZGF0YS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7IHRoaXMudXBkYXRlKCk7IH07XG4gICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMubGlua3MgfHwgdGhpcy5saW5rcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjdXJyZW50VXJsVHJlZSA9IHRoaXMucm91dGVyLnBhcnNlVXJsKHRoaXMucm91dGVyLnVybCk7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IHRoaXMubGlua3MucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGxpbmspIHtcbiAgICAgICAgICAgIHJldHVybiByZXMgfHwgdXJsX3RyZWVfMS5jb250YWluc1RyZWUoY3VycmVudFVybFRyZWUsIGxpbmsudXJsVHJlZSwgX3RoaXMucm91dGVyTGlua0FjdGl2ZU9wdGlvbnMuZXhhY3QpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoX3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjLCBpc0FjdGl2ZSk7IH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5Db250ZW50Q2hpbGRyZW4ocm91dGVyX2xpbmtfMS5Sb3V0ZXJMaW5rKSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgY29yZV8xLlF1ZXJ5TGlzdClcbiAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJsaW5rc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLCBcInJvdXRlckxpbmtBY3RpdmVPcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIG51bGwpO1xuICAgIFJvdXRlckxpbmtBY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW3JvdXRlckxpbmtBY3RpdmVdJyB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW3JvdXRlcl8xLlJvdXRlciwgY29yZV8xLkVsZW1lbnRSZWYsIGNvcmVfMS5SZW5kZXJlcl0pXG4gICAgXSwgUm91dGVyTGlua0FjdGl2ZSk7XG4gICAgcmV0dXJuIFJvdXRlckxpbmtBY3RpdmU7XG59KCkpO1xuZXhwb3J0cy5Sb3V0ZXJMaW5rQWN0aXZlID0gUm91dGVyTGlua0FjdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNtOTFkR1Z5WDJ4cGJtdGZZV04wYVhabExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJScGNtVmpkR2wyWlhNdmNtOTFkR1Z5WDJ4cGJtdGZZV04wYVhabExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096czdRVUZCUVN4eFFrRkJlVWdzWlVGQlpTeERRVUZETEVOQlFVRTdRVUZIZWtrc2RVSkJRVzlETEZkQlFWY3NRMEZCUXl4RFFVRkJPMEZCUTJoRUxIbENRVUV5UWl4aFFVRmhMRU5CUVVNc1EwRkJRVHRCUVVWNlF5dzBRa0ZCZVVJc1pVRkJaU3hEUVVGRExFTkJRVUU3UVVGUGVrTTdTVUZWUlN3d1FrRkJiMElzVFVGQll5eEZRVUZWTEU5QlFXMUNMRVZCUVZVc1VVRkJhMEk3VVVGV04wWXNhVUpCSzBORE8xRkJja054UWl4WFFVRk5MRWRCUVU0c1RVRkJUU3hEUVVGUk8xRkJRVlVzV1VGQlR5eEhRVUZRTEU5QlFVOHNRMEZCV1R0UlFVRlZMR0ZCUVZFc1IwRkJVaXhSUVVGUkxFTkJRVlU3VVVGU2JrWXNXVUZCVHl4SFFVRmhMRVZCUVVVc1EwRkJRenRSUVVka0xEUkNRVUYxUWl4SFFVRTBRaXhGUVVGRExFdEJRVXNzUlVGQlJTeEpRVUZKTEVWQlFVTXNRMEZCUXp0UlFVMW9SaXhKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExGVkJRVUVzUTBGQlF6dFpRVU16UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExGbEJRVmtzYzBKQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJReTlDTEV0QlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJRenRaUVVOb1FpeERRVUZETzFGQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVFzTmtOQlFXdENMRWRCUVd4Q08xRkJRVUVzYVVKQlIwTTdVVUZHUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hMUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVWQlFXSXNRMEZCWVN4RFFVRkRMRU5CUVVNN1VVRkRha1FzU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRPMGxCUTJoQ0xFTkJRVU03U1VGSFJDeHpRa0ZCU1N3NFEwRkJaMEk3WVVGQmNFSXNWVUZCY1VJc1NVRkJjVUk3V1VGRGVFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM2hDTEVsQlFVa3NRMEZCUXl4UFFVRlBMRWRCUVZFc1NVRkJTU3hEUVVGRE8xbEJRek5DTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeEpRVUZKTEVOQlFVTXNUMEZCVHl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZEYWtNc1EwRkJRenRSUVVOSUxFTkJRVU03T3p0UFFVRkJPMGxCUlVRc2MwTkJRVmNzUjBGQldDeFZRVUZaTEU5QlFWY3NTVUZCVXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEyaEVMSE5EUVVGWExFZEJRVmdzWTBGQmNVSXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGTDBNc2FVTkJRVTBzUjBGQlpEdFJRVUZCTEdsQ1FWZERPMUZCVmtNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4SlFVRkpMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNRMEZCUXp0WlFVRkRMRTFCUVUwc1EwRkJRenRSUVVWdVJDeEpRVUZOTEdOQlFXTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJRemRFTEVsQlFVMHNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVU01UWl4VlFVRkRMRWRCUVVjc1JVRkJSU3hKUVVGSk8xbEJRMDRzVDBGQlFTeEhRVUZITEVsQlFVa3NkVUpCUVZrc1EwRkJReXhqUVVGakxFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkpMRU5CUVVNc2RVSkJRWFZDTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUVhKR0xFTkJRWEZHTEVWQlEzcEdMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJSVmdzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUTJoQ0xGVkJRVUVzUTBGQlF5eEpRVUZKTEU5QlFVRXNTMEZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhsUVVGbExFTkJRVU1zUzBGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4aFFVRmhMRVZCUVVVc1EwRkJReXhGUVVGRkxGRkJRVkVzUTBGQlF5eEZRVUYwUlN4RFFVRnpSU3hEUVVGRExFTkJRVU03U1VGRGJrWXNRMEZCUXp0SlFUZERSRHRSUVVGRExITkNRVUZsTEVOQlFVTXNkMEpCUVZVc1EwRkJRenM3YlVSQlFVRTdTVUZKTlVJN1VVRkJReXhaUVVGTExFVkJRVVU3TzNGRlFVRkJPMGxCYTBKU08xRkJRVU1zV1VGQlN5eEZRVUZGT3pzN05FUkJRVUU3U1VGNFFsWTdVVUZCUXl4blFrRkJVeXhEUVVGRExFVkJRVU1zVVVGQlVTeEZRVUZGTEc5Q1FVRnZRaXhGUVVGRExFTkJRVU03TzNkQ1FVRkJPMGxCWjBRMVF5eDFRa0ZCUXp0QlFVRkVMRU5CUVVNc1FVRXZRMFFzU1VFclEwTTdRVUV2UTFrc2QwSkJRV2RDTEcxQ1FTdEROVUlzUTBGQlFTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdRV1owWlhKRGIyNTBaVzUwU1c1cGRDd2dRMjl1ZEdWdWRFTm9hV3hrY21WdUxDQkVhWEpsWTNScGRtVXNJRVZzWlcxbGJuUlNaV1lzSUVsdWNIVjBMQ0JQYmtOb1lXNW5aWE1zSUU5dVJHVnpkSEp2ZVN3Z1VYVmxjbmxNYVhOMExDQlNaVzVrWlhKbGNuMGdabkp2YlNBblFHRnVaM1ZzWVhJdlkyOXlaU2M3WEc1cGJYQnZjblFnZTFOMVluTmpjbWx3ZEdsdmJuMGdabkp2YlNBbmNuaHFjeTlUZFdKelkzSnBjSFJwYjI0bk8xeHVYRzVwYlhCdmNuUWdlMDVoZG1sbllYUnBiMjVGYm1Rc0lGSnZkWFJsY24wZ1puSnZiU0FuTGk0dmNtOTFkR1Z5Snp0Y2JtbHRjRzl5ZENCN1kyOXVkR0ZwYm5OVWNtVmxmU0JtY205dElDY3VMaTkxY214ZmRISmxaU2M3WEc1Y2JtbHRjRzl5ZENCN1VtOTFkR1Z5VEdsdWEzMGdabkp2YlNBbkxpOXliM1YwWlhKZmJHbHVheWM3WEc1Y2JtbHVkR1Z5Wm1GalpTQlNiM1YwWlhKTWFXNXJRV04wYVhabFQzQjBhVzl1Y3lCN1hHNGdJR1Y0WVdOME9pQmliMjlzWldGdU8xeHVmVnh1WEc1QVJHbHlaV04wYVhabEtIdHpaV3hsWTNSdmNqb2dKMXR5YjNWMFpYSk1hVzVyUVdOMGFYWmxYU2Q5S1Z4dVpYaHdiM0owSUdOc1lYTnpJRkp2ZFhSbGNreHBibXRCWTNScGRtVWdhVzF3YkdWdFpXNTBjeUJQYmtOb1lXNW5aWE1zSUU5dVJHVnpkSEp2ZVN3Z1FXWjBaWEpEYjI1MFpXNTBTVzVwZENCN1hHNGdJRUJEYjI1MFpXNTBRMmhwYkdSeVpXNG9VbTkxZEdWeVRHbHVheWtnY0hKcGRtRjBaU0JzYVc1cmN6b2dVWFZsY25sTWFYTjBQRkp2ZFhSbGNreHBibXMrTzF4dUlDQndjbWwyWVhSbElHTnNZWE56WlhNNklITjBjbWx1WjF0ZElEMGdXMTA3WEc0Z0lIQnlhWFpoZEdVZ2MzVmljMk55YVhCMGFXOXVPaUJUZFdKelkzSnBjSFJwYjI0N1hHNWNiaUFnUUVsdWNIVjBLQ2tnY0hKcGRtRjBaU0J5YjNWMFpYSk1hVzVyUVdOMGFYWmxUM0IwYVc5dWN6b2dVbTkxZEdWeVRHbHVhMEZqZEdsMlpVOXdkR2x2Ym5NZ1BTQjdaWGhoWTNRNklIUnlkV1Y5TzF4dVhHNGdJQzhxS2x4dUlDQWdLaUJBYVc1MFpYSnVZV3hjYmlBZ0lDb3ZYRzRnSUdOdmJuTjBjblZqZEc5eUtIQnlhWFpoZEdVZ2NtOTFkR1Z5T2lCU2IzVjBaWElzSUhCeWFYWmhkR1VnWld4bGJXVnVkRG9nUld4bGJXVnVkRkpsWml3Z2NISnBkbUYwWlNCeVpXNWtaWEpsY2pvZ1VtVnVaR1Z5WlhJcElIdGNiaUFnSUNCMGFHbHpMbk4xWW5OamNtbHdkR2x2YmlBOUlISnZkWFJsY2k1bGRtVnVkSE11YzNWaWMyTnlhV0psS0hNZ1BUNGdlMXh1SUNBZ0lDQWdhV1lnS0hNZ2FXNXpkR0Z1WTJWdlppQk9ZWFpwWjJGMGFXOXVSVzVrS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZFhCa1lYUmxLQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc0Z0lIMWNibHh1SUNCdVowRm1kR1Z5UTI5dWRHVnVkRWx1YVhRb0tUb2dkbTlwWkNCN1hHNGdJQ0FnZEdocGN5NXNhVzVyY3k1amFHRnVaMlZ6TG5OMVluTmpjbWxpWlNoeklEMCtJSFJvYVhNdWRYQmtZWFJsS0NrcE8xeHVJQ0FnSUhSb2FYTXVkWEJrWVhSbEtDazdYRzRnSUgxY2JseHVJQ0JBU1c1d2RYUW9LVnh1SUNCelpYUWdjbTkxZEdWeVRHbHVhMEZqZEdsMlpTaGtZWFJoT2lCemRISnBibWRiWFh4emRISnBibWNwSUh0Y2JpQWdJQ0JwWmlBb1FYSnlZWGt1YVhOQmNuSmhlU2hrWVhSaEtTa2dlMXh1SUNBZ0lDQWdkR2hwY3k1amJHRnpjMlZ6SUQwZ1BHRnVlVDVrWVhSaE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0IwYUdsekxtTnNZWE56WlhNZ1BTQmtZWFJoTG5Od2JHbDBLQ2NnSnlrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2JtZFBia05vWVc1blpYTW9ZMmhoYm1kbGN6b2dlMzBwT2lCaGJua2dleUIwYUdsekxuVndaR0YwWlNncE95QjlYRzRnSUc1blQyNUVaWE4wY205NUtDazZJR0Z1ZVNCN0lIUm9hWE11YzNWaWMyTnlhWEIwYVc5dUxuVnVjM1ZpYzJOeWFXSmxLQ2s3SUgxY2JseHVJQ0J3Y21sMllYUmxJSFZ3WkdGMFpTZ3BPaUIyYjJsa0lIdGNiaUFnSUNCcFppQW9JWFJvYVhNdWJHbHVhM01nZkh3Z2RHaHBjeTVzYVc1cmN5NXNaVzVuZEdnZ1BUMDlJREFwSUhKbGRIVnlianRjYmx4dUlDQWdJR052Ym5OMElHTjFjbkpsYm5SVmNteFVjbVZsSUQwZ2RHaHBjeTV5YjNWMFpYSXVjR0Z5YzJWVmNtd29kR2hwY3k1eWIzVjBaWEl1ZFhKc0tUdGNiaUFnSUNCamIyNXpkQ0JwYzBGamRHbDJaU0E5SUhSb2FYTXViR2x1YTNNdWNtVmtkV05sS0Z4dUlDQWdJQ0FnSUNBb2NtVnpMQ0JzYVc1cktTQTlQbHh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVnpJSHg4SUdOdmJuUmhhVzV6VkhKbFpTaGpkWEp5Wlc1MFZYSnNWSEpsWlN3Z2JHbHVheTUxY214VWNtVmxMQ0IwYUdsekxuSnZkWFJsY2t4cGJtdEJZM1JwZG1WUGNIUnBiMjV6TG1WNFlXTjBLU3hjYmlBZ0lDQWdJQ0FnWm1Gc2MyVXBPMXh1WEc0Z0lDQWdkR2hwY3k1amJHRnpjMlZ6TG1admNrVmhZMmdvWEc0Z0lDQWdJQ0FnSUdNZ1BUNGdkR2hwY3k1eVpXNWtaWEpsY2k1elpYUkZiR1Z0Wlc1MFEyeGhjM01vZEdocGN5NWxiR1Z0Wlc1MExtNWhkR2wyWlVWc1pXMWxiblFzSUdNc0lHbHpRV04wYVhabEtTazdYRzRnSUgxY2JuMWNiaUpkZlE9PVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bhbmd1bGFyL3JvdXRlci9kaXJlY3RpdmVzL3JvdXRlcl9saW5rX2FjdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHJvdXRlcl9vdXRsZXRfbWFwXzEgPSByZXF1aXJlKCcuLi9yb3V0ZXJfb3V0bGV0X21hcCcpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG52YXIgUm91dGVyT3V0bGV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJPdXRsZXQocGFyZW50T3V0bGV0TWFwLCBsb2NhdGlvbiwgbmFtZSkge1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHBhcmVudE91dGxldE1hcC5yZWdpc3Rlck91dGxldChuYW1lID8gbmFtZSA6IHNoYXJlZF8xLlBSSU1BUllfT1VUTEVULCB0aGlzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiaXNBY3RpdmF0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5hY3RpdmF0ZWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZWQuaW5zdGFuY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlZFJvdXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0bGV0IGlzIG5vdCBhY3RpdmF0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmF0ZWRSb3V0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBhY3RpdmF0ZWRSb3V0ZSwgcHJvdmlkZXJzLCBvdXRsZXRNYXApIHtcbiAgICAgICAgdGhpcy5vdXRsZXRNYXAgPSBvdXRsZXRNYXA7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlZFJvdXRlID0gYWN0aXZhdGVkUm91dGU7XG4gICAgICAgIHZhciBpbmogPSBjb3JlXzEuUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMsIHRoaXMubG9jYXRpb24ucGFyZW50SW5qZWN0b3IpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZCA9IHRoaXMubG9jYXRpb24uY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHRoaXMubG9jYXRpb24ubGVuZ3RoLCBpbmosIFtdKTtcbiAgICB9O1xuICAgIFJvdXRlck91dGxldCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdyb3V0ZXItb3V0bGV0JyB9KSxcbiAgICAgICAgX19wYXJhbSgyLCBjb3JlXzEuQXR0cmlidXRlKCduYW1lJykpLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbcm91dGVyX291dGxldF9tYXBfMS5Sb3V0ZXJPdXRsZXRNYXAsIGNvcmVfMS5WaWV3Q29udGFpbmVyUmVmLCBTdHJpbmddKVxuICAgIF0sIFJvdXRlck91dGxldCk7XG4gICAgcmV0dXJuIFJvdXRlck91dGxldDtcbn0oKSk7XG5leHBvcnRzLlJvdXRlck91dGxldCA9IFJvdXRlck91dGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNtOTFkR1Z5WDI5MWRHeGxkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthWEpsWTNScGRtVnpMM0p2ZFhSbGNsOXZkWFJzWlhRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenRCUVVGQkxIRkNRVUZ4U1N4bFFVRmxMRU5CUVVNc1EwRkJRVHRCUVVOeVNpeHJRMEZCT0VJc2MwSkJRWE5DTEVOQlFVTXNRMEZCUVR0QlFVVnlSQ3gxUWtGQk5rSXNWMEZCVnl4RFFVRkRMRU5CUVVFN1FVRkhla003U1VGUlJTeHpRa0ZEU1N4bFFVRm5ReXhGUVVGVkxGRkJRVEJDTEVWQlEycEVMRWxCUVZrN1VVRkVWeXhoUVVGUkxFZEJRVklzVVVGQlVTeERRVUZyUWp0UlFVVjBSU3hsUVVGbExFTkJRVU1zWTBGQll5eERRVUZETEVsQlFVa3NSMEZCUnl4SlFVRkpMRWRCUVVjc2RVSkJRV01zUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTnlSU3hEUVVGRE8wbEJSVVFzYzBKQlFVa3NjVU5CUVZjN1lVRkJaaXhqUVVFMlFpeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZET3pzN1QwRkJRVHRKUVVOMlJDeHpRa0ZCU1N4dFEwRkJVenRoUVVGaU8xbEJRMFVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRE8yZENRVUZETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2VVSkJRWGxDTEVOQlFVTXNRMEZCUXp0WlFVTm9SU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkRha01zUTBGQlF6czdPMDlCUVVFN1NVRkRSQ3h6UWtGQlNTeDNRMEZCWXp0aFFVRnNRanRaUVVORkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJRenRuUWtGQlF5eE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSGxDUVVGNVFpeERRVUZETEVOQlFVTTdXVUZEYUVVc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTTdVVUZET1VJc1EwRkJRenM3TzA5QlFVRTdTVUZGUkN4cFEwRkJWU3hIUVVGV08xRkJRMFVzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrSXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF6dFpRVU42UWl4SlFVRkpMRU5CUVVNc1UwRkJVeXhIUVVGSExFbEJRVWtzUTBGQlF6dFJRVU40UWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxDdENRVUZSTEVkQlFWSXNWVUZEU1N4UFFVRTRRaXhGUVVGRkxHTkJRVGhDTEVWQlF6bEVMRk5CUVhWRExFVkJRVVVzVTBGQk1FSTdVVUZEY2tVc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eFRRVUZUTEVOQlFVTTdVVUZETTBJc1NVRkJTU3hEUVVGRExHVkJRV1VzUjBGQlJ5eGpRVUZqTEVOQlFVTTdVVUZEZEVNc1NVRkJUU3hIUVVGSExFZEJRVWNzZVVKQlFXdENMRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNVMEZCVXl4RlFVRkZMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdVVUZET1VZc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMR1ZCUVdVc1EwRkJReXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRVZCUVVVc1IwRkJSeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzBsQlEzcEdMRU5CUVVNN1NVRjJRMGc3VVVGQlF5eG5Ra0ZCVXl4RFFVRkRMRVZCUVVNc1VVRkJVU3hGUVVGRkxHVkJRV1VzUlVGQlF5eERRVUZETzIxQ1FWZG9ReXhuUWtGQlV5eERRVUZETEUxQlFVMHNRMEZCUXpzN2IwSkJXR1U3U1VGM1EzWkRMRzFDUVVGRE8wRkJRVVFzUTBGQlF5eEJRWFpEUkN4SlFYVkRRenRCUVhaRFdTeHZRa0ZCV1N4bFFYVkRlRUlzUTBGQlFTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdRWFIwY21saWRYUmxMQ0JEYjIxd2IyNWxiblJHWVdOMGIzSjVMQ0JEYjIxd2IyNWxiblJTWldZc0lFUnBjbVZqZEdsMlpTd2dVbVZtYkdWamRHbDJaVWx1YW1WamRHOXlMQ0JTWlhOdmJIWmxaRkpsWm14bFkzUnBkbVZRY205MmFXUmxjaXdnVm1sbGQwTnZiblJoYVc1bGNsSmxabjBnWm5KdmJTQW5RR0Z1WjNWc1lYSXZZMjl5WlNjN1hHNXBiWEJ2Y25RZ2UxSnZkWFJsY2s5MWRHeGxkRTFoY0gwZ1puSnZiU0FuTGk0dmNtOTFkR1Z5WDI5MWRHeGxkRjl0WVhBbk8xeHVhVzF3YjNKMElIdEJZM1JwZG1GMFpXUlNiM1YwWlgwZ1puSnZiU0FuTGk0dmNtOTFkR1Z5WDNOMFlYUmxKenRjYm1sdGNHOXlkQ0I3VUZKSlRVRlNXVjlQVlZSTVJWUjlJR1p5YjIwZ0p5NHVMM05vWVhKbFpDYzdYRzVjYmtCRWFYSmxZM1JwZG1Vb2UzTmxiR1ZqZEc5eU9pQW5jbTkxZEdWeUxXOTFkR3hsZENkOUtWeHVaWGh3YjNKMElHTnNZWE56SUZKdmRYUmxjazkxZEd4bGRDQjdYRzRnSUhCeWFYWmhkR1VnWVdOMGFYWmhkR1ZrT2lCRGIyMXdiMjVsYm5SU1pXWThZVzU1UGp0Y2JpQWdjSEpwZG1GMFpTQmZZV04wYVhaaGRHVmtVbTkxZEdVNklFRmpkR2wyWVhSbFpGSnZkWFJsTzF4dUlDQndkV0pzYVdNZ2IzVjBiR1YwVFdGd09pQlNiM1YwWlhKUGRYUnNaWFJOWVhBN1hHNWNiaUFnTHlvcVhHNGdJQ0FxSUVCcGJuUmxjbTVoYkZ4dUlDQWdLaTljYmlBZ1kyOXVjM1J5ZFdOMGIzSW9YRzRnSUNBZ0lDQndZWEpsYm5SUGRYUnNaWFJOWVhBNklGSnZkWFJsY2s5MWRHeGxkRTFoY0N3Z2NISnBkbUYwWlNCc2IyTmhkR2x2YmpvZ1ZtbGxkME52Ym5SaGFXNWxjbEpsWml4Y2JpQWdJQ0FnSUVCQmRIUnlhV0oxZEdVb0oyNWhiV1VuS1NCdVlXMWxPaUJ6ZEhKcGJtY3BJSHRjYmlBZ0lDQndZWEpsYm5SUGRYUnNaWFJOWVhBdWNtVm5hWE4wWlhKUGRYUnNaWFFvYm1GdFpTQS9JRzVoYldVZ09pQlFVa2xOUVZKWlgwOVZWRXhGVkN3Z2RHaHBjeWs3WEc0Z0lIMWNibHh1SUNCblpYUWdhWE5CWTNScGRtRjBaV1FvS1RvZ1ltOXZiR1ZoYmlCN0lISmxkSFZ5YmlBaElYUm9hWE11WVdOMGFYWmhkR1ZrT3lCOVhHNGdJR2RsZENCamIyMXdiMjVsYm5Rb0tUb2dUMkpxWldOMElIdGNiaUFnSUNCcFppQW9JWFJvYVhNdVlXTjBhWFpoZEdWa0tTQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owOTFkR3hsZENCcGN5QnViM1FnWVdOMGFYWmhkR1ZrSnlrN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVlXTjBhWFpoZEdWa0xtbHVjM1JoYm1ObE8xeHVJQ0I5WEc0Z0lHZGxkQ0JoWTNScGRtRjBaV1JTYjNWMFpTZ3BPaUJCWTNScGRtRjBaV1JTYjNWMFpTQjdYRzRnSUNBZ2FXWWdLQ0YwYUdsekxtRmpkR2wyWVhSbFpDa2dkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZFBkWFJzWlhRZ2FYTWdibTkwSUdGamRHbDJZWFJsWkNjcE8xeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxsOWhZM1JwZG1GMFpXUlNiM1YwWlR0Y2JpQWdmVnh1WEc0Z0lHUmxZV04wYVhaaGRHVW9LVG9nZG05cFpDQjdYRzRnSUNBZ2FXWWdLSFJvYVhNdVlXTjBhWFpoZEdWa0tTQjdYRzRnSUNBZ0lDQjBhR2x6TG1GamRHbDJZWFJsWkM1a1pYTjBjbTk1S0NrN1hHNGdJQ0FnSUNCMGFHbHpMbUZqZEdsMllYUmxaQ0E5SUc1MWJHdzdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdZV04wYVhaaGRHVW9YRzRnSUNBZ0lDQm1ZV04wYjNKNU9pQkRiMjF3YjI1bGJuUkdZV04wYjNKNVBHRnVlVDRzSUdGamRHbDJZWFJsWkZKdmRYUmxPaUJCWTNScGRtRjBaV1JTYjNWMFpTeGNiaUFnSUNBZ0lIQnliM1pwWkdWeWN6b2dVbVZ6YjJ4MlpXUlNaV1pzWldOMGFYWmxVSEp2ZG1sa1pYSmJYU3dnYjNWMGJHVjBUV0Z3T2lCU2IzVjBaWEpQZFhSc1pYUk5ZWEFwT2lCMmIybGtJSHRjYmlBZ0lDQjBhR2x6TG05MWRHeGxkRTFoY0NBOUlHOTFkR3hsZEUxaGNEdGNiaUFnSUNCMGFHbHpMbDloWTNScGRtRjBaV1JTYjNWMFpTQTlJR0ZqZEdsMllYUmxaRkp2ZFhSbE8xeHVJQ0FnSUdOdmJuTjBJR2x1YWlBOUlGSmxabXhsWTNScGRtVkpibXBsWTNSdmNpNW1jbTl0VW1WemIyeDJaV1JRY205MmFXUmxjbk1vY0hKdmRtbGtaWEp6TENCMGFHbHpMbXh2WTJGMGFXOXVMbkJoY21WdWRFbHVhbVZqZEc5eUtUdGNiaUFnSUNCMGFHbHpMbUZqZEdsMllYUmxaQ0E5SUhSb2FYTXViRzlqWVhScGIyNHVZM0psWVhSbFEyOXRjRzl1Wlc1MEtHWmhZM1J2Y25rc0lIUm9hWE11Ykc5allYUnBiMjR1YkdWdVozUm9MQ0JwYm1vc0lGdGRLVHRjYmlBZ2ZWeHVmVnh1SWwxOVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bhbmd1bGFyL3JvdXRlci9kaXJlY3RpdmVzL3JvdXRlcl9vdXRsZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uJyk7XG52YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uX3JvdXRlcl9wcm92aWRlcnMnKTtcbmZ1bmN0aW9uIHByb3ZpZGVSb3V0ZXIoY29uZmlnLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7IHByb3ZpZGU6IGNvbW1vbl8xLlBsYXRmb3JtTG9jYXRpb24sIHVzZUNsYXNzOiBwbGF0Zm9ybV9icm93c2VyXzEuQnJvd3NlclBsYXRmb3JtTG9jYXRpb24gfVxuICAgIF0uY29uY2F0KGNvbW1vbi5wcm92aWRlUm91dGVyKGNvbmZpZywgb3B0cykpO1xufVxuZXhwb3J0cy5wcm92aWRlUm91dGVyID0gcHJvdmlkZVJvdXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNtOTFkR1Z5WDNCeWIzWnBaR1Z5Y3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OXliM1YwWlhKZmNISnZkbWxrWlhKekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN4MVFrRkJLMElzYVVKQlFXbENMRU5CUVVNc1EwRkJRVHRCUVVOcVJDeHBRMEZCYzBNc01rSkJRVEpDTEVOQlFVTXNRMEZCUVR0QlFVVnNSU3hKUVVGWkxFMUJRVTBzVjBGQlRTd3lRa0ZCTWtJc1EwRkJReXhEUVVGQk8wRkJjMEp3UkN4MVFrRkJPRUlzVFVGQmIwSXNSVUZCUlN4SlFVRTRRanRKUVVFNVFpeHZRa0ZCT0VJc1IwRkJPVUlzVTBGQk9FSTdTVUZEYUVZc1RVRkJUU3hEUVVGRE8xRkJRMHdzUlVGQlF5eFBRVUZQTEVWQlFVVXNlVUpCUVdkQ0xFVkJRVVVzVVVGQlVTeEZRVUZGTERCRFFVRjFRaXhGUVVGRE8yRkJRek5FTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVU4wUXl4RFFVRkRPMEZCUTBvc1EwRkJRenRCUVV4bExIRkNRVUZoTEdkQ1FVczFRaXhEUVVGQklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElIdFFiR0YwWm05eWJVeHZZMkYwYVc5dWZTQm1jbTl0SUNkQVlXNW5kV3hoY2k5amIyMXRiMjRuTzF4dWFXMXdiM0owSUh0Q2NtOTNjMlZ5VUd4aGRHWnZjbTFNYjJOaGRHbHZibjBnWm5KdmJTQW5RR0Z1WjNWc1lYSXZjR3hoZEdadmNtMHRZbkp2ZDNObGNpYzdYRzVjYm1sdGNHOXlkQ0FxSUdGeklHTnZiVzF2YmlCbWNtOXRJQ2N1TDJOdmJXMXZibDl5YjNWMFpYSmZjSEp2ZG1sa1pYSnpKenRjYm1sdGNHOXlkQ0I3VW05MWRHVnlRMjl1Wm1sbmZTQm1jbTl0SUNjdUwyTnZibVpwWnljN1hHNWNibHh1THlvcVhHNGdLaUJCSUd4cGMzUWdiMllnZTBCc2FXNXJJRkJ5YjNacFpHVnlmWE11SUZSdklIVnpaU0IwYUdVZ2NtOTFkR1Z5TENCNWIzVWdiWFZ6ZENCaFpHUWdkR2hwY3lCMGJ5QjViM1Z5SUdGd2NHeHBZMkYwYVc5dUxseHVJQ3BjYmlBcUlDTWpJeUJGZUdGdGNHeGxYRzRnS2x4dUlDb2dZR0JnWEc0Z0tpQkFRMjl0Y0c5dVpXNTBLSHRrYVhKbFkzUnBkbVZ6T2lCYlVrOVZWRVZTWDBSSlVrVkRWRWxXUlZOZGZTbGNiaUFxSUdOc1lYTnpJRUZ3Y0VOdGNDQjdYRzRnS2lBZ0lDOHZJQzR1TGx4dUlDb2dmVnh1SUNwY2JpQXFJR052Ym5OMElISnZkWFJsY2lBOUlGdGNiaUFxSUNBZ2UzQmhkR2c2SUNjdmFHOXRaU2NzSUdOdmJYQnZibVZ1ZERvZ1NHOXRaWDFjYmlBcUlGMDdYRzRnS2x4dUlDb2dZbTl2ZEhOMGNtRndLRUZ3Y0VOdGNDd2dXM0J5YjNacFpHVlNiM1YwWlhJb2NtOTFkR1Z5S1YwcE8xeHVJQ29nWUdCZ1hHNGdLaTljYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJ3Y205MmFXUmxVbTkxZEdWeUtHTnZibVpwWnpvZ1VtOTFkR1Z5UTI5dVptbG5MQ0J2Y0hSek9pQmpiMjF0YjI0dVJYaDBjbUZQY0hScGIyNXpJRDBnZTMwcE9pQmhibmxiWFNCN1hHNGdJSEpsZEhWeWJpQmJYRzRnSUNBZ2UzQnliM1pwWkdVNklGQnNZWFJtYjNKdFRHOWpZWFJwYjI0c0lIVnpaVU5zWVhOek9pQkNjbTkzYzJWeVVHeGhkR1p2Y20xTWIyTmhkR2x2Ym4wc1hHNGdJQ0FnTGk0dVkyOXRiVzl1TG5CeWIzWnBaR1ZTYjNWMFpYSW9ZMjl1Wm1sbkxDQnZjSFJ6S1Z4dUlDQmRPMXh1ZlZ4dUlsMTlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYW5ndWxhci9yb3V0ZXIvcm91dGVyX3Byb3ZpZGVycy5qc1xuICoqIG1vZHVsZSBpZCA9IDQzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKCcuL3JvdXRlcicpO1xudmFyIHJvdXRlcl9vdXRsZXRfbWFwXzEgPSByZXF1aXJlKCcuL3JvdXRlcl9vdXRsZXRfbWFwJyk7XG52YXIgcm91dGVyX3N0YXRlXzEgPSByZXF1aXJlKCcuL3JvdXRlcl9zdGF0ZScpO1xudmFyIHVybF9zZXJpYWxpemVyXzEgPSByZXF1aXJlKCcuL3VybF9zZXJpYWxpemVyJyk7XG5leHBvcnRzLlJPVVRFUl9DT05GSUcgPSBuZXcgY29yZV8xLk9wYXF1ZVRva2VuKCdST1VURVJfQ09ORklHJyk7XG5leHBvcnRzLlJPVVRFUl9PUFRJT05TID0gbmV3IGNvcmVfMS5PcGFxdWVUb2tlbignUk9VVEVSX09QVElPTlMnKTtcbmZ1bmN0aW9uIHNldHVwUm91dGVyKHJlZiwgcmVzb2x2ZXIsIHVybFNlcmlhbGl6ZXIsIG91dGxldE1hcCwgbG9jYXRpb24sIGluamVjdG9yLCBjb25maWcsIG9wdHMpIHtcbiAgICBpZiAocmVmLmNvbXBvbmVudFR5cGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwIGF0IGxlYXN0IG9uZSBjb21wb25lbnQgYmVmb3JlIGluamVjdGluZyBSb3V0ZXIuJyk7XG4gICAgfVxuICAgIHZhciBjb21wb25lbnRUeXBlID0gcmVmLmNvbXBvbmVudFR5cGVzWzBdO1xuICAgIHZhciByID0gbmV3IHJvdXRlcl8xLlJvdXRlcihjb21wb25lbnRUeXBlLCByZXNvbHZlciwgdXJsU2VyaWFsaXplciwgb3V0bGV0TWFwLCBsb2NhdGlvbiwgaW5qZWN0b3IsIGNvbmZpZyk7XG4gICAgcmVmLnJlZ2lzdGVyRGlzcG9zZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHIuZGlzcG9zZSgpOyB9KTtcbiAgICBpZiAob3B0cy5lbmFibGVUcmFjaW5nKSB7XG4gICAgICAgIHIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5ncm91cChcIlJvdXRlciBFdmVudDogXCIgKyBlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLnNldHVwUm91dGVyID0gc2V0dXBSb3V0ZXI7XG5mdW5jdGlvbiBzZXR1cFJvdXRlckluaXRpYWxpemVyKGluamVjdG9yKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcHBSZWYgPSBpbmplY3Rvci5nZXQoY29yZV8xLkFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgaWYgKGFwcFJlZi5jb21wb25lbnRUeXBlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgYXBwUmVmLnJlZ2lzdGVyQm9vdHN0cmFwTGlzdGVuZXIoZnVuY3Rpb24gKCkgeyBpbmplY3Rvci5nZXQocm91dGVyXzEuUm91dGVyKS5pbml0aWFsTmF2aWdhdGlvbigpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluamVjdG9yLmdldChyb3V0ZXJfMS5Sb3V0ZXIpLmluaXRpYWxOYXZpZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LCAwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbn1cbmV4cG9ydHMuc2V0dXBSb3V0ZXJJbml0aWFsaXplciA9IHNldHVwUm91dGVySW5pdGlhbGl6ZXI7XG5mdW5jdGlvbiBwcm92aWRlUm91dGVyKF9jb25maWcsIF9vcHRzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeyBwcm92aWRlOiBleHBvcnRzLlJPVVRFUl9DT05GSUcsIHVzZVZhbHVlOiBfY29uZmlnIH0sIHsgcHJvdmlkZTogZXhwb3J0cy5ST1VURVJfT1BUSU9OUywgdXNlVmFsdWU6IF9vcHRzIH0sXG4gICAgICAgIGNvbW1vbl8xLkxvY2F0aW9uLCB7IHByb3ZpZGU6IGNvbW1vbl8xLkxvY2F0aW9uU3RyYXRlZ3ksIHVzZUNsYXNzOiBjb21tb25fMS5QYXRoTG9jYXRpb25TdHJhdGVneSB9LFxuICAgICAgICB7IHByb3ZpZGU6IHVybF9zZXJpYWxpemVyXzEuVXJsU2VyaWFsaXplciwgdXNlQ2xhc3M6IHVybF9zZXJpYWxpemVyXzEuRGVmYXVsdFVybFNlcmlhbGl6ZXIgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogcm91dGVyXzEuUm91dGVyLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogc2V0dXBSb3V0ZXIsXG4gICAgICAgICAgICBkZXBzOiBbXG4gICAgICAgICAgICAgICAgY29yZV8xLkFwcGxpY2F0aW9uUmVmLCBjb3JlXzEuQ29tcG9uZW50UmVzb2x2ZXIsIHVybF9zZXJpYWxpemVyXzEuVXJsU2VyaWFsaXplciwgcm91dGVyX291dGxldF9tYXBfMS5Sb3V0ZXJPdXRsZXRNYXAsIGNvbW1vbl8xLkxvY2F0aW9uLCBjb3JlXzEuSW5qZWN0b3IsXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5ST1VURVJfQ09ORklHLCBleHBvcnRzLlJPVVRFUl9PUFRJT05TXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlcl9vdXRsZXRfbWFwXzEuUm91dGVyT3V0bGV0TWFwLFxuICAgICAgICB7IHByb3ZpZGU6IHJvdXRlcl9zdGF0ZV8xLkFjdGl2YXRlZFJvdXRlLCB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocikgeyByZXR1cm4gci5yb3V0ZXJTdGF0ZS5yb290OyB9LCBkZXBzOiBbcm91dGVyXzEuUm91dGVyXSB9LFxuICAgICAgICB7IHByb3ZpZGU6IGNvcmVfMS5BUFBfSU5JVElBTElaRVIsIG11bHRpOiB0cnVlLCB1c2VGYWN0b3J5OiBzZXR1cFJvdXRlckluaXRpYWxpemVyLCBkZXBzOiBbY29yZV8xLkluamVjdG9yXSB9XG4gICAgXTtcbn1cbmV4cG9ydHMucHJvdmlkZVJvdXRlciA9IHByb3ZpZGVSb3V0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMjl0Ylc5dVgzSnZkWFJsY2w5d2NtOTJhV1JsY25NdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZZMjl0Ylc5dVgzSnZkWFJsY2w5d2NtOTJhV1JsY25NdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEhWQ1FVRXJSQ3hwUWtGQmFVSXNRMEZCUXl4RFFVRkJPMEZCUTJwR0xIRkNRVUYzUml4bFFVRmxMRU5CUVVNc1EwRkJRVHRCUVVkNFJ5eDFRa0ZCY1VJc1ZVRkJWU3hEUVVGRExFTkJRVUU3UVVGRGFFTXNhME5CUVRoQ0xIRkNRVUZ4UWl4RFFVRkRMRU5CUVVFN1FVRkRjRVFzTmtKQlFUWkNMR2RDUVVGblFpeERRVUZETEVOQlFVRTdRVUZET1VNc0swSkJRV3RFTEd0Q1FVRnJRaXhEUVVGRExFTkJRVUU3UVVGRmVFUXNjVUpCUVdFc1IwRkJSeXhKUVVGSkxHdENRVUZYTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNN1FVRkRha1FzYzBKQlFXTXNSMEZCUnl4SlFVRkpMR3RDUVVGWExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1EwRkJRenRCUVVsb1JTeHhRa0ZEU1N4SFFVRnRRaXhGUVVGRkxGRkJRVEpDTEVWQlFVVXNZVUZCTkVJc1JVRkRPVVVzVTBGQk1FSXNSVUZCUlN4UlFVRnJRaXhGUVVGRkxGRkJRV3RDTEVWQlFVVXNUVUZCYjBJc1JVRkRlRVlzU1VGQmEwSTdTVUZEY0VJc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEdOQlFXTXNRMEZCUXl4TlFVRk5MRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU51UXl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExESkVRVUV5UkN4RFFVRkRMRU5CUVVNN1NVRkRMMFVzUTBGQlF6dEpRVU5FTEVsQlFVMHNZVUZCWVN4SFFVRkhMRWRCUVVjc1EwRkJReXhqUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETlVNc1NVRkJUU3hEUVVGRExFZEJRMGdzU1VGQlNTeGxRVUZOTEVOQlFVTXNZVUZCWVN4RlFVRkZMRkZCUVZFc1JVRkJSU3hoUVVGaExFVkJRVVVzVTBGQlV5eEZRVUZGTEZGQlFWRXNSVUZCUlN4UlFVRlJMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRE9VWXNSMEZCUnl4RFFVRkRMSFZDUVVGMVFpeERRVUZETEdOQlFVMHNUMEZCUVN4RFFVRkRMRU5CUVVNc1QwRkJUeXhGUVVGRkxFVkJRVmdzUTBGQlZ5eERRVUZETEVOQlFVTTdTVUZGTDBNc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRka0lzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1ZVRkJRU3hEUVVGRE8xbEJRMnhDTEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc2JVSkJRWFZDTEVOQlFVTXNRMEZCUXl4WFFVRlpMRU5CUVVNc1NVRkJUU3hEUVVGRExFTkJRVU03V1VGRE5VUXNUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTXhRaXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJZc1QwRkJUeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFGQlEzSkNMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkRXQ3hEUVVGRE8wRkJkRUpsTEcxQ1FVRlhMR05CYzBJeFFpeERRVUZCTzBGQlJVUXNaME5CUVhWRExGRkJRV3RDTzBsQlNYWkVMRlZCUVZVc1EwRkJRenRSUVVOVUxFbEJRVTBzVFVGQlRTeEhRVUZITEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc2NVSkJRV01zUTBGQlF5eERRVUZETzFGQlF6VkRMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTXNUVUZCVFN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRFTXNUVUZCVFN4RFFVRkRMSGxDUVVGNVFpeERRVUZETEdOQlFWRXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhsUVVGTkxFTkJRVU1zUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVZc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhsUVVGTkxFTkJRVU1zUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hEUVVGRE8xRkJRek5ETEVOQlFVTTdTVUZEU0N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFRpeE5RVUZOTEVOQlFVTXNZMEZCVnl4UFFVRkJMRWxCUVVrc1JVRkJTaXhEUVVGSkxFTkJRVU03UVVGRGVrSXNRMEZCUXp0QlFXSmxMRGhDUVVGelFpeDVRa0ZoY2tNc1EwRkJRVHRCUVc5Q1JDeDFRa0ZCT0VJc1QwRkJjVUlzUlVGQlJTeExRVUZ0UWp0SlFVTjBSU3hOUVVGTkxFTkJRVU03VVVGRFRDeEZRVUZETEU5QlFVOHNSVUZCUlN4eFFrRkJZU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFBRVUZQTEVWQlFVTXNSVUZCUlN4RlFVRkRMRTlCUVU4c1JVRkJSU3h6UWtGQll5eEZRVUZGTEZGQlFWRXNSVUZCUlN4TFFVRkxMRVZCUVVNN1VVRkRka1lzYVVKQlFWRXNSVUZCUlN4RlFVRkRMRTlCUVU4c1JVRkJSU3g1UWtGQlowSXNSVUZCUlN4UlFVRlJMRVZCUVVVc05rSkJRVzlDTEVWQlFVTTdVVUZEY2tVc1JVRkJReXhQUVVGUExFVkJRVVVzT0VKQlFXRXNSVUZCUlN4UlFVRlJMRVZCUVVVc2NVTkJRVzlDTEVWQlFVTTdVVUZGZUVRN1dVRkRSU3hQUVVGUExFVkJRVVVzWlVGQlRUdFpRVU5tTEZWQlFWVXNSVUZCUlN4WFFVRlhPMWxCUTNaQ0xFbEJRVWtzUlVGQlJUdG5Ra0ZEU2l4eFFrRkJZeXhGUVVGRkxIZENRVUZwUWl4RlFVRkZMRGhDUVVGaExFVkJRVVVzYlVOQlFXVXNSVUZCUlN4cFFrRkJVU3hGUVVGRkxHVkJRVkU3WjBKQlEzSkdMSEZDUVVGaExFVkJRVVVzYzBKQlFXTTdZVUZET1VJN1UwRkRSanRSUVVWRUxHMURRVUZsTzFGQlEyWXNSVUZCUXl4UFFVRlBMRVZCUVVVc05rSkJRV01zUlVGQlJTeFZRVUZWTEVWQlFVVXNWVUZCUXl4RFFVRlRMRWxCUVVzc1QwRkJRU3hEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NSVUZCYkVJc1EwRkJhMElzUlVGQlJTeEpRVUZKTEVWQlFVVXNRMEZCUXl4bFFVRk5MRU5CUVVNc1JVRkJRenRSUVVkNFJpeEZRVUZETEU5QlFVOHNSVUZCUlN4elFrRkJaU3hGUVVGRkxFdEJRVXNzUlVGQlJTeEpRVUZKTEVWQlFVVXNWVUZCVlN4RlFVRkZMSE5DUVVGelFpeEZRVUZGTEVsQlFVa3NSVUZCUlN4RFFVRkRMR1ZCUVZFc1EwRkJReXhGUVVGRE8wdEJRemxHTEVOQlFVTTdRVUZEU2l4RFFVRkRPMEZCY2tKbExIRkNRVUZoTEdkQ1FYRkNOVUlzUTBGQlFTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdURzlqWVhScGIyNHNJRXh2WTJGMGFXOXVVM1J5WVhSbFoza3NJRkJoZEdoTWIyTmhkR2x2YmxOMGNtRjBaV2Q1ZlNCbWNtOXRJQ2RBWVc1bmRXeGhjaTlqYjIxdGIyNG5PMXh1YVcxd2IzSjBJSHRCVUZCZlNVNUpWRWxCVEVsYVJWSXNJRUZ3Y0d4cFkyRjBhVzl1VW1WbUxDQkRiMjF3YjI1bGJuUlNaWE52YkhabGNpd2dTVzVxWldOMGIzSXNJRTl3WVhGMVpWUnZhMlZ1ZlNCbWNtOXRJQ2RBWVc1bmRXeGhjaTlqYjNKbEp6dGNibHh1YVcxd2IzSjBJSHRTYjNWMFpYSkRiMjVtYVdkOUlHWnliMjBnSnk0dlkyOXVabWxuSnp0Y2JtbHRjRzl5ZENCN1VtOTFkR1Z5ZlNCbWNtOXRJQ2N1TDNKdmRYUmxjaWM3WEc1cGJYQnZjblFnZTFKdmRYUmxjazkxZEd4bGRFMWhjSDBnWm5KdmJTQW5MaTl5YjNWMFpYSmZiM1YwYkdWMFgyMWhjQ2M3WEc1cGJYQnZjblFnZTBGamRHbDJZWFJsWkZKdmRYUmxmU0JtY205dElDY3VMM0p2ZFhSbGNsOXpkR0YwWlNjN1hHNXBiWEJ2Y25RZ2UwUmxabUYxYkhSVmNteFRaWEpwWVd4cGVtVnlMQ0JWY214VFpYSnBZV3hwZW1WeWZTQm1jbTl0SUNjdUwzVnliRjl6WlhKcFlXeHBlbVZ5Snp0Y2JseHVaWGh3YjNKMElHTnZibk4wSUZKUFZWUkZVbDlEVDA1R1NVY2dQU0J1WlhjZ1QzQmhjWFZsVkc5clpXNG9KMUpQVlZSRlVsOURUMDVHU1VjbktUdGNibVY0Y0c5eWRDQmpiMjV6ZENCU1QxVlVSVkpmVDFCVVNVOU9VeUE5SUc1bGR5QlBjR0Z4ZFdWVWIydGxiaWduVWs5VlZFVlNYMDlRVkVsUFRsTW5LVHRjYmx4dVpYaHdiM0owSUdsdWRHVnlabUZqWlNCRmVIUnlZVTl3ZEdsdmJuTWdleUJsYm1GaWJHVlVjbUZqYVc1blB6b2dZbTl2YkdWaGJqc2dmVnh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnYzJWMGRYQlNiM1YwWlhJb1hHNGdJQ0FnY21WbU9pQkJjSEJzYVdOaGRHbHZibEpsWml3Z2NtVnpiMngyWlhJNklFTnZiWEJ2Ym1WdWRGSmxjMjlzZG1WeUxDQjFjbXhUWlhKcFlXeHBlbVZ5T2lCVmNteFRaWEpwWVd4cGVtVnlMRnh1SUNBZ0lHOTFkR3hsZEUxaGNEb2dVbTkxZEdWeVQzVjBiR1YwVFdGd0xDQnNiMk5oZEdsdmJqb2dURzlqWVhScGIyNHNJR2x1YW1WamRHOXlPaUJKYm1wbFkzUnZjaXdnWTI5dVptbG5PaUJTYjNWMFpYSkRiMjVtYVdjc1hHNGdJQ0FnYjNCMGN6b2dSWGgwY21GUGNIUnBiMjV6S1NCN1hHNGdJR2xtSUNoeVpXWXVZMjl0Y0c5dVpXNTBWSGx3WlhNdWJHVnVaM1JvSUQwOUlEQXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owSnZiM1J6ZEhKaGNDQmhkQ0JzWldGemRDQnZibVVnWTI5dGNHOXVaVzUwSUdKbFptOXlaU0JwYm1wbFkzUnBibWNnVW05MWRHVnlMaWNwTzF4dUlDQjlYRzRnSUdOdmJuTjBJR052YlhCdmJtVnVkRlI1Y0dVZ1BTQnlaV1l1WTI5dGNHOXVaVzUwVkhsd1pYTmJNRjA3WEc0Z0lHTnZibk4wSUhJZ1BWeHVJQ0FnSUNBZ2JtVjNJRkp2ZFhSbGNpaGpiMjF3YjI1bGJuUlVlWEJsTENCeVpYTnZiSFpsY2l3Z2RYSnNVMlZ5YVdGc2FYcGxjaXdnYjNWMGJHVjBUV0Z3TENCc2IyTmhkR2x2Yml3Z2FXNXFaV04wYjNJc0lHTnZibVpwWnlrN1hHNGdJSEpsWmk1eVpXZHBjM1JsY2tScGMzQnZjMlZNYVhOMFpXNWxjaWdvS1NBOVBpQnlMbVJwYzNCdmMyVW9LU2s3WEc1Y2JpQWdhV1lnS0c5d2RITXVaVzVoWW14bFZISmhZMmx1WnlrZ2UxeHVJQ0FnSUhJdVpYWmxiblJ6TG5OMVluTmpjbWxpWlNobElEMCtJSHRjYmlBZ0lDQWdJR052Ym5OdmJHVXVaM0p2ZFhBb1lGSnZkWFJsY2lCRmRtVnVkRG9nSkhzb1BHRnVlVDVsTG1OdmJuTjBjblZqZEc5eUtTNXVZVzFsZldBcE8xeHVJQ0FnSUNBZ1kyOXVjMjlzWlM1c2IyY29aUzUwYjFOMGNtbHVaeWdwS1R0Y2JpQWdJQ0FnSUdOdmJuTnZiR1V1Ykc5bktHVXBPMXh1SUNBZ0lDQWdZMjl1YzI5c1pTNW5jbTkxY0VWdVpDZ3BPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSEk3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQnpaWFIxY0ZKdmRYUmxja2x1YVhScFlXeHBlbVZ5S0dsdWFtVmpkRzl5T2lCSmJtcGxZM1J2Y2lrZ2UxeHVJQ0F2THlCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdllXNW5kV3hoY2k5aGJtZDFiR0Z5TDJsemMzVmxjeTg1TVRBeFhHNGdJQzh2SUVSbGJHRjVJSFJvWlNCeWIzVjBaWElnYVc1emRHRnVkR2xoZEdsdmJpQjBieUJoZG05cFpDQmphWEpqZFd4aGNpQmtaWEJsYm1SbGJtTjVJQ2hCY0hCc2FXTmhkR2x2YmxKbFppQXRQbHh1SUNBdkx5QkJVRkJmU1U1SlZFbEJURWxhUlZJZ0xUNGdVbTkxZEdWeUtWeHVJQ0J6WlhSVWFXMWxiM1YwS0NncElEMCtJSHRjYmlBZ0lDQmpiMjV6ZENCaGNIQlNaV1lnUFNCcGJtcGxZM1J2Y2k1blpYUW9RWEJ3YkdsallYUnBiMjVTWldZcE8xeHVJQ0FnSUdsbUlDaGhjSEJTWldZdVkyOXRjRzl1Wlc1MFZIbHdaWE11YkdWdVozUm9JRDA5SURBcElIdGNiaUFnSUNBZ0lHRndjRkpsWmk1eVpXZHBjM1JsY2tKdmIzUnpkSEpoY0V4cGMzUmxibVZ5S0NncElEMCtJSHNnYVc1cVpXTjBiM0l1WjJWMEtGSnZkWFJsY2lrdWFXNXBkR2xoYkU1aGRtbG5ZWFJwYjI0b0tUc2dmU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHbHVhbVZqZEc5eUxtZGxkQ2hTYjNWMFpYSXBMbWx1YVhScFlXeE9ZWFpwWjJGMGFXOXVLQ2s3WEc0Z0lDQWdmVnh1SUNCOUxDQXdLVHRjYmlBZ2NtVjBkWEp1SUNncE9pQmhibmtnUFQ0Z2JuVnNiRHRjYm4xY2JseHVMeW9xWEc0Z0tpQkJJR3hwYzNRZ2IyWWdlMEJzYVc1cklGQnliM1pwWkdWeWZYTXVJRlJ2SUhWelpTQjBhR1VnY205MWRHVnlMQ0I1YjNVZ2JYVnpkQ0JoWkdRZ2RHaHBjeUIwYnlCNWIzVnlJR0Z3Y0d4cFkyRjBhVzl1TGx4dUlDcGNiaUFxSUNNakl5QkZlR0Z0Y0d4bFhHNGdLbHh1SUNvZ1lHQmdYRzRnS2lCQVEyOXRjRzl1Wlc1MEtIdGthWEpsWTNScGRtVnpPaUJiVWs5VlZFVlNYMFJKVWtWRFZFbFdSVk5kZlNsY2JpQXFJR05zWVhOeklFRndjRU50Y0NCN1hHNGdLaUFnSUM4dklDNHVMbHh1SUNvZ2ZWeHVJQ3BjYmlBcUlHTnZibk4wSUhKdmRYUmxjaUE5SUZ0Y2JpQXFJQ0FnZTNCaGRHZzZJQ2N2YUc5dFpTY3NJR052YlhCdmJtVnVkRG9nU0c5dFpYMWNiaUFxSUYwN1hHNGdLbHh1SUNvZ1ltOXZkSE4wY21Gd0tFRndjRU50Y0N3Z1czQnliM1pwWkdWU2IzVjBaWElvY205MWRHVnlLVjBwTzF4dUlDb2dZR0JnWEc0Z0tpOWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQndjbTkyYVdSbFVtOTFkR1Z5S0Y5amIyNW1hV2M2SUZKdmRYUmxja052Ym1acFp5d2dYMjl3ZEhNNklFVjRkSEpoVDNCMGFXOXVjeWs2SUdGdWVWdGRJSHRjYmlBZ2NtVjBkWEp1SUZ0Y2JpQWdJQ0I3Y0hKdmRtbGtaVG9nVWs5VlZFVlNYME5QVGtaSlJ5d2dkWE5sVm1Gc2RXVTZJRjlqYjI1bWFXZDlMQ0I3Y0hKdmRtbGtaVG9nVWs5VlZFVlNYMDlRVkVsUFRsTXNJSFZ6WlZaaGJIVmxPaUJmYjNCMGMzMHNYRzRnSUNBZ1RHOWpZWFJwYjI0c0lIdHdjbTkyYVdSbE9pQk1iMk5oZEdsdmJsTjBjbUYwWldkNUxDQjFjMlZEYkdGemN6b2dVR0YwYUV4dlkyRjBhVzl1VTNSeVlYUmxaM2w5TEZ4dUlDQWdJSHR3Y205MmFXUmxPaUJWY214VFpYSnBZV3hwZW1WeUxDQjFjMlZEYkdGemN6b2dSR1ZtWVhWc2RGVnliRk5sY21saGJHbDZaWEo5TEZ4dVhHNGdJQ0FnZTF4dUlDQWdJQ0FnY0hKdmRtbGtaVG9nVW05MWRHVnlMRnh1SUNBZ0lDQWdkWE5sUm1GamRHOXllVG9nYzJWMGRYQlNiM1YwWlhJc1hHNGdJQ0FnSUNCa1pYQnpPaUJiWEc0Z0lDQWdJQ0FnSUVGd2NHeHBZMkYwYVc5dVVtVm1MQ0JEYjIxd2IyNWxiblJTWlhOdmJIWmxjaXdnVlhKc1UyVnlhV0ZzYVhwbGNpd2dVbTkxZEdWeVQzVjBiR1YwVFdGd0xDQk1iMk5oZEdsdmJpd2dTVzVxWldOMGIzSXNYRzRnSUNBZ0lDQWdJRkpQVlZSRlVsOURUMDVHU1Vjc0lGSlBWVlJGVWw5UFVGUkpUMDVUWEc0Z0lDQWdJQ0JkWEc0Z0lDQWdmU3hjYmx4dUlDQWdJRkp2ZFhSbGNrOTFkR3hsZEUxaGNDeGNiaUFnSUNCN2NISnZkbWxrWlRvZ1FXTjBhWFpoZEdWa1VtOTFkR1VzSUhWelpVWmhZM1J2Y25rNklDaHlPaUJTYjNWMFpYSXBJRDArSUhJdWNtOTFkR1Z5VTNSaGRHVXVjbTl2ZEN3Z1pHVndjem9nVzFKdmRYUmxjbDE5TEZ4dVhHNGdJQ0FnTHk4Z1ZISnBaMmRsY2lCcGJtbDBhV0ZzSUc1aGRtbG5ZWFJwYjI1Y2JpQWdJQ0I3Y0hKdmRtbGtaVG9nUVZCUVgwbE9TVlJKUVV4SldrVlNMQ0J0ZFd4MGFUb2dkSEoxWlN3Z2RYTmxSbUZqZEc5eWVUb2djMlYwZFhCU2IzVjBaWEpKYm1sMGFXRnNhWHBsY2l3Z1pHVndjem9nVzBsdWFtVmpkRzl5WFgxY2JpQWdYVHRjYm4xY2JpSmRmUT09XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQGFuZ3VsYXIvcm91dGVyL2NvbW1vbl9yb3V0ZXJfcHJvdmlkZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gNDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgeyBBcHBTZXJ2aWNlIH0gZnJvbSAnLi9hcHAuc2VydmljZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICcuL3RyYW5zbGF0ZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUHJvamVjdFNlcnZpY2UgfSBmcm9tICcuL3Byb2plY3Quc2VydmljZSc7XHJcbmltcG9ydCB7IFRhc2tTZXJ2aWNlIH0gZnJvbSAnLi90YXNrLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBSZWZlcmVuY2VTZXJ2aWNlIH0gZnJvbSAnLi9yZWZlcmVuY2Uuc2VydmljZSc7XHJcbmltcG9ydCB7IFN0YWZmU2VydmljZSB9IGZyb20gJy4vc3RhZmYuc2VydmljZSc7XHJcbmltcG9ydCB7IFVwbG9hZFNlcnZpY2UgfSBmcm9tICcuL3VwbG9hZC5zZXJ2aWNlJztcclxuXHJcbmV4cG9ydCB7IEFwcFNlcnZpY2UgfTtcclxuZXhwb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9O1xyXG5leHBvcnQgeyBQcm9qZWN0U2VydmljZSB9O1xyXG5leHBvcnQgeyBUYXNrU2VydmljZSB9O1xyXG5leHBvcnQgeyBSZWZlcmVuY2VTZXJ2aWNlIH07XHJcbmV4cG9ydCB7IFN0YWZmU2VydmljZSB9O1xyXG5leHBvcnQgeyBVcGxvYWRTZXJ2aWNlIH07XHJcblxyXG5leHBvcnQgY29uc3QgQVBQX1NFUlZJQ0VTID0gW1xyXG4gICAgQXBwU2VydmljZSxcclxuICAgIFRyYW5zbGF0ZVNlcnZpY2UsXHJcbiAgICBQcm9qZWN0U2VydmljZSxcclxuICAgIFRhc2tTZXJ2aWNlLFxyXG4gICAgUmVmZXJlbmNlU2VydmljZSxcclxuICAgIFN0YWZmU2VydmljZSxcclxuICAgIFVwbG9hZFNlcnZpY2VcclxuXTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2VydmljZXMvaW5kZXgudHNcbiAqKi8iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHAsIEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9odHRwJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcblxyXG5pbXBvcnQgeyBGRVRDSF9VU0VSX1BST0ZJTEUgfSBmcm9tICcuLi9yZWR1Y2Vycy9hdXRoZWQucmVkdWNlcic7XHJcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5pbXBvcnQgeyBwYXJzZVJlc3BvbnNlT2JqZWN0cyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbmNvbnN0IEhFQURFUlMgPSBuZXcgSGVhZGVycyh7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOCcsXHJcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbn0pO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQXBwU2VydmljZSB7XHJcblxyXG4gICAgaXNMb2dnZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGh0dHA6IEh0dHBcclxuICAgICkgeyB9XHJcblxyXG4gICAgZ2V0VXNlclByb2ZpbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQoJ3A/aWQ9dXNlcnByb2ZpbGUnLCB7IGhlYWRlcnM6IEhFQURFUlMgfSkubWFwKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IHBhcnNlUmVzcG9uc2VPYmplY3RzKHJlc3BvbnNlLmpzb24oKS5vYmplY3RzKTtcclxuICAgICAgICAgICAgbGV0IHBhZ2VTaXplID0gMjA7XHJcbiAgICAgICAgICAgIGlmIChyZXNbMF0ucGFnZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VTaXplID0gcmVzWzBdLnBhZ2VzaXplXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEZFVENIX1VTRVJfUFJPRklMRSxcclxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VyUHJvZmlsZTogcmVzLmVtcGxveWVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlczogcmVzLmxhbmd1YWdlLmxpc3RbMF0ubG9jYWxpemVkTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVVzZXJQcm9maWxlKHVzZXI6IFVzZXIpIHtcclxuICAgICAgICAvL1xyXG4gICAgfVxyXG5cclxuICAgIGxvZ291dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmRlbGV0ZSgnLycpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NlcnZpY2VzL2FwcC5zZXJ2aWNlLnRzXG4gKiovIiwiaW1wb3J0IHsgUHJvamVjdCB9IGZyb20gJy4uL21vZGVscyc7XHJcblxyXG5leHBvcnQgY29uc3QgRkVUQ0hfVVNFUl9QUk9GSUxFID0gJ0ZFVENIX1VTRVJfUFJPRklMRSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBdXRoZWRTdGF0ZSB7XHJcbiAgICB1c2VyUHJvZmlsZTogYW55LFxyXG4gICAgbGFuZ3VhZ2VzOiBhbnksXHJcbiAgICBwYWdlU2l6ZTogbnVtYmVyXHJcbn07XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGU6IElBdXRoZWRTdGF0ZSA9IHtcclxuICAgIHVzZXJQcm9maWxlOiBudWxsLFxyXG4gICAgbGFuZ3VhZ2VzOiB7fSxcclxuICAgIHBhZ2VTaXplOiAyMFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGF1dGhlZFJlZHVjZXIgPSAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIHt0eXBlLCBwYXlsb2FkfSk6IElBdXRoZWRTdGF0ZSA9PiB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIEZFVENIX1VTRVJfUFJPRklMRTpcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICB1c2VyUHJvZmlsZTogcGF5bG9hZC51c2VyUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgIGxhbmd1YWdlczogcGF5bG9hZC5sYW5ndWFnZXMsXHJcbiAgICAgICAgICAgICAgICBwYWdlU2l6ZTogcGF5bG9hZC5wYWdlU2l6ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3JlZHVjZXJzL2F1dGhlZC5yZWR1Y2VyLnRzXG4gKiovIiwiaW1wb3J0IHsgVVJMU2VhcmNoUGFyYW1zLCBSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVSTFNlYXJjaFBhcmFtcyhfcGFyYW1zKTogVVJMU2VhcmNoUGFyYW1zIHtcclxuICAgIGxldCBwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIGZvciAobGV0IHAgaW4gX3BhcmFtcykge1xyXG4gICAgICAgIHBhcmFtcy5zZXQoZW5jb2RlVVJJQ29tcG9uZW50KHApLCBlbmNvZGVVUklDb21wb25lbnQoX3BhcmFtc1twXSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZU9iaihvYmopOiBzdHJpbmcge1xyXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHByb3BlcnR5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbcHJvcGVydHldKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VPYmplY3RzKG9iamVjdHM6IGFueSk6IGFueSB7XHJcbiAgICBsZXQgcmVzdWx0OiBhbnkgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBvYmogb2Ygb2JqZWN0cykge1xyXG4gICAgICAgIGlmIChvYmoua2luZCkge1xyXG4gICAgICAgICAgICByZXN1bHRbb2JqLmtpbmRdID0gb2JqO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob2JqLmxpc3QgJiYgb2JqLm1ldGEgJiYgb2JqLnR5cGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0W29iai50eXBlXSA9IG9iajtcclxuICAgICAgICB9IGVsc2UgaWYgKG9iai5uYW1lICYmIG9iai52YWx1ZSkgeyAvLyBmc2lkP1xyXG4gICAgICAgICAgICByZXN1bHRbb2JqLm5hbWVdID0gb2JqLnZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxpc3RPYmplY3RzVG9LZXlWYWx1ZShsaXN0OiBhbnkpOiBhbnkge1xyXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgaWYgKGxpc3QpIHtcclxuICAgICAgICBmb3IgKGxldCBpdCBvZiBsaXN0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpdC5pZF0gPSBpdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUG9zdFJlc3BvbnNlKHJlc3BvbnNlOiBSZXNwb25zZSk6IGFueSB7XHJcbiAgICBsZXQganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIHtcclxuICAgICAgICBvazoganNvbi50eXBlID09PSAnRE9DVU1FTlRfU0FWRUQnLFxyXG4gICAgICAgIG1lc3NhZ2U6IGpzb24uY2FwdGlvbnMgPyBqc29uLmNhcHRpb25zLnR5cGUgOiBqc29uLm1lc3NhZ2VcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29va2llKG5hbWUsIHZhbHVlLCBkYXlzKTogdm9pZCB7XHJcbiAgICBsZXQgZXhwaXJlcztcclxuXHJcbiAgICBpZiAoZGF5cykge1xyXG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcclxuICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBleHBpcmVzID0gJyc7XHJcbiAgICB9XHJcbiAgICBkb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9Lyc7XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvdXRpbHMvdXRpbHMudHNcbiAqKi8iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHAsIEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9odHRwJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0ZVNlcnZpY2Uge1xyXG5cclxuICAgIHByaXZhdGUgdHJhbnNsYXRpb25zOiBhbnkgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgaHR0cDogSHR0cFxyXG4gICAgKSB7IH1cclxuXHJcbiAgICBmZXRjaFRyYW5zbGF0aW9ucygpIHtcclxuICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnLFxyXG4gICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KCdwP2lkPWNvbW1vbi1jYXB0aW9ucycsIHsgaGVhZGVyczogaGVhZGVycyB9KS5tYXAocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IHJlc3BvbnNlLmpzb24oKS5jYXB0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRyYW5zbGF0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2VydmljZXMvdHJhbnNsYXRlLnNlcnZpY2UudHNcbiAqKi8iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHAsIEhlYWRlcnMsIFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnbmcyLXRyYW5zbGF0ZS9uZzItdHJhbnNsYXRlJztcclxuXHJcbmltcG9ydCB7XHJcbiAgICBGRVRDSF9QUk9KRUNUUyxcclxuICAgIEZFVENIX1BST0pFQ1QsXHJcbiAgICBBRERfUFJPSkVDVFxyXG59IGZyb20gJy4uL3JlZHVjZXJzL3Byb2plY3RzLnJlZHVjZXInO1xyXG5pbXBvcnQgeyBQcm9qZWN0LCBUYXNrLCBUYXNrVHlwZSwgVGFnLCBVc2VyLCBBdHRhY2htZW50LCBPcmdhbml6YXRpb24gfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5pbXBvcnQgeyBjcmVhdGVVUkxTZWFyY2hQYXJhbXMsIHBhcnNlUmVzcG9uc2VPYmplY3RzLCBzZXJpYWxpemVPYmosIHRyYW5zZm9ybVBvc3RSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbmNvbnN0IEhFQURFUlMgPSBuZXcgSGVhZGVycyh7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOCcsXHJcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbn0pO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgUHJvamVjdFNlcnZpY2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgaHR0cDogSHR0cCxcclxuICAgICAgICBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZVxyXG4gICAgKSB7IH1cclxuXHJcbiAgICBnZXRQcm9qZWN0U3RhdHVzVHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlLmdldChbJ2RyYWZ0JywgJ3Byb2Nlc3NlZCcsICdmaW5pc2hlZCddKS5tYXAodCA9PiBbXHJcbiAgICAgICAgICAgIHsgdmFsdWU6ICdEUkFGVCcsIHRleHQ6IHQuZHJhZnQsIGRlZmF1bHQ6IHRydWUgfSxcclxuICAgICAgICAgICAgeyB2YWx1ZTogJ1BST0NFU1NFRCcsIHRleHQ6IHQucHJvY2Vzc2VkIH0sXHJcbiAgICAgICAgICAgIHsgdmFsdWU6ICdGSU5JU0hFRCcsIHRleHQ6IHQuZmluaXNoZWQgfVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZldGNoUHJvamVjdHMocXVlcnlQYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KCdwP2lkPXByb2plY3QtdmlldycsIHtcclxuICAgICAgICAgICAgaGVhZGVyczogSEVBREVSUyxcclxuICAgICAgICAgICAgc2VhcmNoOiBjcmVhdGVVUkxTZWFyY2hQYXJhbXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkub2JqZWN0c1swXSlcclxuICAgICAgICAgICAgLm1hcChkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRkVUQ0hfUFJPSkVDVFMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0czogPFByb2plY3RbXT5kYXRhLmxpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IGRhdGEubWV0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZldGNoUHJvamVjdEJ5SWQocHJvamVjdElkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAocHJvamVjdElkID09PSAnbmV3Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZih7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBGRVRDSF9QUk9KRUNULFxyXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Q6IG5ldyBQcm9qZWN0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldCgncD9pZD1wcm9qZWN0LWZvcm0mcHJvamVjdElkPScgKyBwcm9qZWN0SWQsIHsgaGVhZGVyczogSEVBREVSUyB9KVxyXG4gICAgICAgICAgICAubWFwKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gcGFyc2VSZXNwb25zZU9iamVjdHMocmVzcG9uc2UuanNvbigpLm9iamVjdHMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHByb2plY3QgPSA8UHJvamVjdD5kYXRhLnByb2plY3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5mc2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdC5mc2lkID0gZGF0YS5mc2lkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuYXR0YWNobWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3QuYXR0YWNobWVudHMgPSBkYXRhLmF0dGFjaG1lbnQubGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRkVUQ0hfUFJPSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Q6IDxQcm9qZWN0PnByb2plY3RcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlUHJvamVjdChwcm9qZWN0OiBQcm9qZWN0KSB7XHJcbiAgICAgICAgbGV0IHVybCA9ICdwP2lkPXByb2plY3QtZm9ybSZwcm9qZWN0SWQ9JyArIHByb2plY3QuaWQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5wb3N0KHVybCwgc2VyaWFsaXplT2JqKHByb2plY3QpLCB7IGhlYWRlcnM6IEhFQURFUlMgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiB0cmFuc2Zvcm1Qb3N0UmVzcG9uc2UocmVzcG9uc2UpKVxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gT2JzZXJ2YWJsZS50aHJvdyh0cmFuc2Zvcm1Qb3N0UmVzcG9uc2UoZXJyb3IpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlUHJvamVjdChwcm9qZWN0czogUHJvamVjdFtdKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5kZWxldGUoJ3A/aWQ9cHJvamVjdC12aWV3JnByb2plY3RJZHM9JyArIHByb2plY3RzLm1hcChpdCA9PiBpdC5pZCkuam9pbignLCcpKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVQcm9qZWN0QXR0YWNobWVudChwcm9qZWN0OiBQcm9qZWN0LCBhdHRhY2htZW50OiBBdHRhY2htZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5kZWxldGUoJ3A/aWQ9cHJvamVjdC1mb3JtJnByb2plY3RJZD0nICsgcHJvamVjdC5pZCArICcmYXR0YWNobWVudElkPScgKyBhdHRhY2htZW50LmlkKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zZXJ2aWNlcy9wcm9qZWN0LnNlcnZpY2UudHNcbiAqKi8iLCJpbXBvcnQgeyBQcm9qZWN0IH0gZnJvbSAnLi4vbW9kZWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCBGRVRDSF9QUk9KRUNUUyA9ICdGRVRDSF9QUk9KRUNUUyc7XHJcbmV4cG9ydCBjb25zdCBGRVRDSF9QUk9KRUNUID0gJ0ZFVENIX1BST0pFQ1QnO1xyXG5leHBvcnQgY29uc3QgQUREX1BST0pFQ1QgPSAnQUREX1BST0pFQ1QnO1xyXG5leHBvcnQgY29uc3QgVVBEQVRFX1BST0pFQ1QgPSAnVVBEQVRFX1BST0pFQ1QnO1xyXG5leHBvcnQgY29uc3QgREVMRVRFX1BST0pFQ1QgPSAnREVMRVRFX1BST0pFQ1QnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUHJvamVjdHNTdGF0ZSB7XHJcbiAgICBtZXRhOiB7fSxcclxuICAgIHByb2plY3RzOiBQcm9qZWN0W10sXHJcbiAgICBwcm9qZWN0OiBQcm9qZWN0LFxyXG4gICAgbG9hZGluZzogYm9vbGVhblxyXG59O1xyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlOiBJUHJvamVjdHNTdGF0ZSA9IHtcclxuICAgIG1ldGE6IHt9LFxyXG4gICAgcHJvamVjdHM6IFtdLFxyXG4gICAgcHJvamVjdDogdW5kZWZpbmVkLFxyXG4gICAgbG9hZGluZzogZmFsc2VcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwcm9qZWN0c1JlZHVjZXIgPSAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIHt0eXBlLCBwYXlsb2FkfSk6IElQcm9qZWN0c1N0YXRlID0+IHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgRkVUQ0hfUFJPSkVDVFM6XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgcHJvamVjdHM6IHBheWxvYWQucHJvamVjdHMsXHJcbiAgICAgICAgICAgICAgICBtZXRhOiBwYXlsb2FkLm1ldGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBGRVRDSF9QUk9KRUNUOlxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICAgICAgICAgIHByb2plY3Q6IHBheWxvYWQucHJvamVjdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIEFERF9QUk9KRUNUOlxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgY2FzZSBVUERBVEVfUFJPSkVDVDpcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIGNhc2UgREVMRVRFX1BST0pFQ1Q6XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3JlZHVjZXJzL3Byb2plY3RzLnJlZHVjZXIudHNcbiAqKi8iLCJleHBvcnQgeyBVc2VyIH0gZnJvbSAnLi91c2VyJztcclxuZXhwb3J0IHsgT3JnYW5pemF0aW9uIH0gZnJvbSAnLi9vcmdhbml6YXRpb24nO1xyXG5leHBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnLi9hdHRhY2htZW50JztcclxuZXhwb3J0IHsgUHJvamVjdCB9IGZyb20gJy4vcHJvamVjdCc7XHJcbmV4cG9ydCB7IFRhc2sgfSBmcm9tICcuL3Rhc2snO1xyXG5leHBvcnQgeyBUYWcgfSBmcm9tICcuL3RhZyc7XHJcbmV4cG9ydCB7IFRhc2tUeXBlIH0gZnJvbSAnLi90YXNrLXR5cGUnO1xyXG5leHBvcnQgeyBDb21tZW50IH0gZnJvbSAnLi9jb21tZW50JztcclxuZXhwb3J0IHsgUmVxdWVzdCB9IGZyb20gJy4vcmVxdWVzdCc7XHJcbmV4cG9ydCB7IFJlcXVlc3RUeXBlIH0gZnJvbSAnLi9yZXF1ZXN0LXR5cGUnO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9tb2RlbHMvaW5kZXgudHNcbiAqKi8iLCJleHBvcnQgY2xhc3MgVXNlciB7XHJcbiAgICBpZDogc3RyaW5nID0gJyc7XHJcbiAgICBsb2dpbjogc3RyaW5nO1xyXG4gICAgZW1haWw6IHN0cmluZztcclxuICAgIHVzZXJOYW1lOiBzdHJpbmcgPSAnQGFub255bW91cyc7XHJcbiAgICBvcmdhbml6YXRpb25JZDogc3RyaW5nO1xyXG4gICAgZGVwYXJ0bWVudElkOiBzdHJpbmc7XHJcbiAgICBwb3NpdGlvbklkOiBzdHJpbmc7XHJcbiAgICBhdmF0YXJVcmw6IHN0cmluZztcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9tb2RlbHMvdXNlci50c1xuICoqLyIsImV4cG9ydCBjbGFzcyBPcmdhbml6YXRpb24ge1xyXG4gICAgaWQ6IHN0cmluZyA9ICcnO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgYmluOiBzdHJpbmc7XHJcbiAgICBsb2NhbGl6ZWROYW1lOiBhbnk7XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvbW9kZWxzL29yZ2FuaXphdGlvbi50c1xuICoqLyIsImV4cG9ydCBjbGFzcyBBdHRhY2htZW50IHtcclxuICAgIGlkOiBzdHJpbmcgPSAnJztcclxuICAgIGZpZWxkTmFtZTogc3RyaW5nO1xyXG4gICAgcmVhbEZpbGVOYW1lOiBzdHJpbmc7XHJcbiAgICBhdXRob3I6IHN0cmluZztcclxuICAgIHJlZ0RhdGU6IERhdGU7XHJcbiAgICBzaXplOiBudW1iZXI7XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvbW9kZWxzL2F0dGFjaG1lbnQudHNcbiAqKi8iLCJpbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnLi9hdHRhY2htZW50JztcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9qZWN0IHtcclxuICAgIGlkOiBzdHJpbmcgPSAnJztcclxuICAgIGF1dGhvcjogc3RyaW5nO1xyXG4gICAgcmVnRGF0ZTogRGF0ZTtcclxuICAgIHdhc1JlYWQ6IGJvb2xlYW47XHJcbiAgICBmc2lkOiBzdHJpbmcgPSAnJyArIERhdGUubm93KCk7XHJcblxyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgc3RhdHVzOiBzdHJpbmcgPSAnRFJBRlQnO1xyXG4gICAgY3VzdG9tZXJJZDogc3RyaW5nO1xyXG4gICAgbWFuYWdlclVzZXJJZDogc3RyaW5nO1xyXG4gICAgcHJvZ3JhbW1lclVzZXJJZDogc3RyaW5nO1xyXG4gICAgdGVzdGVyVXNlcklkOiBzdHJpbmc7XHJcbiAgICBvYnNlcnZlclVzZXJJZHM6IHN0cmluZ1tdO1xyXG4gICAgY29tbWVudDogc3RyaW5nO1xyXG4gICAgZmluaXNoRGF0ZTogRGF0ZTtcclxuICAgIGhhc0F0dGFjaG1lbnRzOiBib29sZWFuO1xyXG4gICAgYXR0YWNobWVudElkczogc3RyaW5nW107XHJcblxyXG4gICAgYXR0YWNobWVudHM6IEF0dGFjaG1lbnRbXTtcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9tb2RlbHMvcHJvamVjdC50c1xuICoqLyIsImltcG9ydCB7IEF0dGFjaG1lbnQgfSBmcm9tICcuL2F0dGFjaG1lbnQnO1xyXG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSAnLi9yZXF1ZXN0JztcclxuXHJcbmV4cG9ydCBjbGFzcyBUYXNrIHtcclxuICAgIGlkOiBzdHJpbmcgPSAnJztcclxuICAgIGF1dGhvcjogc3RyaW5nO1xyXG4gICAgcmVnRGF0ZTogRGF0ZTtcclxuICAgIHdhc1JlYWQ6IGJvb2xlYW47XHJcbiAgICBmc2lkOiBzdHJpbmcgPSAnJyArIERhdGUubm93KCk7XHJcblxyXG4gICAgcHJvamVjdElkOiBzdHJpbmc7XHJcbiAgICBwYXJlbnRUYXNrSWQ6IHN0cmluZztcclxuICAgIGhhc1N1YnRhc2tzOiBzdHJpbmdbXTtcclxuICAgIHRhc2tUeXBlSWQ6IHN0cmluZztcclxuICAgIHN0YXR1czogc3RyaW5nID0gJ0RSQUZUJztcclxuICAgIHByaW9yaXR5OiBzdHJpbmcgPSAnTk9STUFMJztcclxuICAgIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBib2R5OiBzdHJpbmc7XHJcbiAgICBhc3NpZ25lZVVzZXJJZDogc3RyaW5nO1xyXG4gICAgc3RhcnREYXRlOiBEYXRlO1xyXG4gICAgZHVlRGF0ZTogRGF0ZTtcclxuICAgIHRhZ0lkczogc3RyaW5nW107XHJcbiAgICBoYXNBdHRhY2htZW50czogYm9vbGVhbjtcclxuICAgIGF0dGFjaG1lbnRJZHM6IHN0cmluZ1tdO1xyXG5cclxuICAgIGF0dGFjaG1lbnRzOiBBdHRhY2htZW50W107XHJcbiAgICByZXF1ZXN0czogUmVxdWVzdFtdO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL21vZGVscy90YXNrLnRzXG4gKiovIiwiZXhwb3J0IGNsYXNzIFRhZyB7XHJcbiAgICBpZDogc3RyaW5nID0gJyc7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgbG9jYWxpemVkTmFtZTogYW55O1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL21vZGVscy90YWcudHNcbiAqKi8iLCJleHBvcnQgY2xhc3MgVGFza1R5cGUge1xyXG4gICAgaWQ6IHN0cmluZyA9ICcnO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgbG9jYWxpemVkTmFtZTogYW55O1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL21vZGVscy90YXNrLXR5cGUudHNcbiAqKi8iLCJpbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnLi9hdHRhY2htZW50JztcclxuXHJcbmV4cG9ydCBjbGFzcyBDb21tZW50IHtcclxuICAgIGlkOiBzdHJpbmcgPSAnJztcclxuICAgIGZzaWQ6IHN0cmluZyA9ICcnICsgRGF0ZS5ub3coKTtcclxuICAgIHJlZ0RhdGU6IERhdGU7XHJcbiAgICB0YXNrSWQ6IHN0cmluZztcclxuICAgIGNvbW1lbnQ6IHN0cmluZztcclxuICAgIGF0dGFjaG1lbnRzOiBBdHRhY2htZW50W107XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvbW9kZWxzL2NvbW1lbnQudHNcbiAqKi8iLCJpbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnLi9hdHRhY2htZW50JztcclxuXHJcbmV4cG9ydCBjbGFzcyBSZXF1ZXN0IHtcclxuICAgIGlkOiBzdHJpbmcgPSAnJztcclxuICAgIGZzaWQ6IHN0cmluZyA9ICcnICsgRGF0ZS5ub3coKTtcclxuICAgIHJlZ0RhdGU6IERhdGU7XHJcbiAgICB0YXNrSWQ6IHN0cmluZztcclxuICAgIHJlcXVlc3RUeXBlSWQ6IHN0cmluZztcclxuICAgIHJlc29sdXRpb246IHN0cmluZztcclxuICAgIHJlc29sdXRpb25UaW1lOiBEYXRlO1xyXG4gICAgY29tbWVudDogc3RyaW5nO1xyXG4gICAgaGFzQXR0YWNobWVudHM6IGJvb2xlYW47XHJcbiAgICBhdHRhY2htZW50czogQXR0YWNobWVudFtdO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL21vZGVscy9yZXF1ZXN0LnRzXG4gKiovIiwiZXhwb3J0IGNsYXNzIFJlcXVlc3RUeXBlIHtcclxuICAgIGlkOiBzdHJpbmcgPSAnJztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGxvY2FsaXplZE5hbWU6IGFueTtcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9tb2RlbHMvcmVxdWVzdC10eXBlLnRzXG4gKiovIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBIdHRwLCBIZWFkZXJzLCBSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQge1xyXG4gICAgRkVUQ0hfVEFTS1MsXHJcbiAgICBGRVRDSF9UQVNLLFxyXG4gICAgQUREX1RBU0tcclxufSBmcm9tICcuLi9yZWR1Y2Vycy90YXNrcy5yZWR1Y2VyJztcclxuaW1wb3J0IHtcclxuICAgIEZFVENIX0NPTU1FTlRTLFxyXG4gICAgRkVUQ0hfUkVRVUVTVFNcclxufSBmcm9tICcuLi9yZWR1Y2Vycy90YXNrLnJlZHVjZXInO1xyXG5pbXBvcnQgeyBUYXNrLCBSZXF1ZXN0LCBDb21tZW50LCBBdHRhY2htZW50IH0gZnJvbSAnLi4vbW9kZWxzJztcclxuaW1wb3J0IHsgY3JlYXRlVVJMU2VhcmNoUGFyYW1zLCBwYXJzZVJlc3BvbnNlT2JqZWN0cywgc2VyaWFsaXplT2JqLCB0cmFuc2Zvcm1Qb3N0UmVzcG9uc2UgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcblxyXG5jb25zdCBIRUFERVJTID0gbmV3IEhlYWRlcnMoe1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnLFxyXG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG59KTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFRhc2tTZXJ2aWNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGh0dHA6IEh0dHAsXHJcbiAgICAgICAgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2VcclxuICAgICkgeyB9XHJcblxyXG4gICAgZ2V0VGFza1ByaW9yaXR5VHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlLmdldChbJ3VyZ2VudCcsICdoaWdoJywgJ21lZGl1bScsICdub3JtYWwnXSkubWFwKHQgPT4gW1xyXG4gICAgICAgICAgICB7IHZhbHVlOiAnTk9STUFMJywgdGV4dDogdC5ub3JtYWwsIGRlZmF1bHQ6IHRydWUgfSxcclxuICAgICAgICAgICAgeyB2YWx1ZTogJ01FRElVTScsIHRleHQ6IHQubWVkaXVtIH0sXHJcbiAgICAgICAgICAgIHsgdmFsdWU6ICdISUdIJywgdGV4dDogdC5oaWdoIH0sXHJcbiAgICAgICAgICAgIHsgdmFsdWU6ICdVUkdFTlQnLCB0ZXh0OiB0LnVyZ2VudCB9XHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGFza1N0YXR1c1R5cGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZS5nZXQoWydkcmFmdCcsICd3YWl0aW5nJywgJ3Byb2Nlc3NlZCcsICdmaW5pc2hlZCddKS5tYXAodCA9PiBbXHJcbiAgICAgICAgICAgIHsgdmFsdWU6ICdEUkFGVCcsIHRleHQ6IHQuZHJhZnQsIGRlZmF1bHQ6IHRydWUgfSxcclxuICAgICAgICAgICAgeyB2YWx1ZTogJ1dBSVRJTkcnLCB0ZXh0OiB0LndhaXRpbmcgfSxcclxuICAgICAgICAgICAgeyB2YWx1ZTogJ1BST0NFU1NFRCcsIHRleHQ6IHQucHJvY2Vzc2VkIH0sXHJcbiAgICAgICAgICAgIHsgdmFsdWU6ICdGSU5JU0hFRCcsIHRleHQ6IHQuZmluaXNoZWQgfVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZldGNoVGFza3MocXVlcnlQYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KCdwP2lkPXRhc2stdmlldycsIHtcclxuICAgICAgICAgICAgaGVhZGVyczogSEVBREVSUyxcclxuICAgICAgICAgICAgc2VhcmNoOiBjcmVhdGVVUkxTZWFyY2hQYXJhbXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkub2JqZWN0c1swXSlcclxuICAgICAgICAgICAgLm1hcChkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRkVUQ0hfVEFTS1MsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrczogPFRhc2tbXT5kYXRhLmxpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IGRhdGEubWV0YVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZmV0Y2hUYXNrQnlJZCh0YXNrSWQ6IHN0cmluZykge1xyXG4gICAgICAgIGlmICh0YXNrSWQgPT09ICduZXcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEZFVENIX1RBU0ssXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzazogbmV3IFRhc2soKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KCdwP2lkPXRhc2stZm9ybSZ0YXNrSWQ9JyArIHRhc2tJZCwgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBwYXJzZVJlc3BvbnNlT2JqZWN0cyhyZXNwb25zZS5qc29uKCkub2JqZWN0cyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFzayA9IDxUYXNrPmRhdGEudGFzaztcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZzaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLmZzaWQgPSBkYXRhLmZzaWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5hdHRhY2htZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5hdHRhY2htZW50cyA9IDxBdHRhY2htZW50W10+ZGF0YS5hdHRhY2htZW50Lmxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEZFVENIX1RBU0ssXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrOiA8VGFzaz50YXNrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlVGFzayh0YXNrOiBUYXNrKSB7XHJcbiAgICAgICAgbGV0IHVybCA9ICdwP2lkPXRhc2stZm9ybScgKyAodGFzay5pZCA/ICcmdGFza0lkPScgKyB0YXNrLmlkIDogJycpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIHNlcmlhbGl6ZU9iaih0YXNrKSwgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gdHJhbnNmb3JtUG9zdFJlc3BvbnNlKHJlc3BvbnNlKSlcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IE9ic2VydmFibGUudGhyb3codHJhbnNmb3JtUG9zdFJlc3BvbnNlKGVycm9yKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZVRhc2sodGFza3M6IFRhc2tbXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZGVsZXRlKCdwP2lkPXRhc2stdmlldyZ0YXNrSWRzPScgKyB0YXNrcy5tYXAoaXQgPT4gaXQuaWQpLmpvaW4oJywnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlVGFza0F0dGFjaG1lbnQodGFzazogVGFzaywgYXR0YWNobWVudDogQXR0YWNobWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZGVsZXRlKCdwP2lkPXRhc2stZm9ybSZ0YXNrSWQ9JyArIHRhc2suaWQgKyAnJmF0dGFjaG1lbnRJZD0nICsgYXR0YWNobWVudC5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZmV0Y2hUYXNrUmVxdWVzdHModGFzazogVGFzaywgcGFnZSA9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldCgncD9pZD10YXNrLXJlcXVlc3RzJnRhc2tJZD0nICsgdGFzay5pZCwgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gcGFyc2VSZXNwb25zZU9iamVjdHMocmVzcG9uc2UuanNvbigpLm9iamVjdHMpLnJlcXVlc3QgfHwge30pXHJcbiAgICAgICAgICAgIC5tYXAoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEZFVENIX1JFUVVFU1RTLFxyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IDxSZXF1ZXN0W10+ZGF0YS5saXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBkYXRhLm1ldGFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbmRUYXNrUmVxdWVzdChyZXF1ZXN0OiBSZXF1ZXN0KSB7XHJcbiAgICAgICAgbGV0IHVybCA9ICdwP2lkPXRhc2stcmVxdWVzdHMmdGFza0lkPScgKyByZXF1ZXN0LnRhc2tJZDtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnBvc3QodXJsLCBzZXJpYWxpemVPYmoocmVxdWVzdCksIHsgaGVhZGVyczogSEVBREVSUyB9KVxyXG4gICAgICAgICAgICAubWFwKHJlc3BvbnNlID0+IHRyYW5zZm9ybVBvc3RSZXNwb25zZShyZXNwb25zZSkpXHJcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiBPYnNlcnZhYmxlLnRocm93KHRyYW5zZm9ybVBvc3RSZXNwb25zZShlcnJvcikpKTtcclxuICAgIH1cclxuXHJcbiAgICBkb1JlcXVlc3RSZXNvbHV0aW9uKHJlcXVlc3Q6IFJlcXVlc3QsIHJlc29sdXRpb246IHN0cmluZykge1xyXG4gICAgICAgIGxldCB1cmwgPSAncD9pZD10YXNrLXJlcXVlc3RzJnJlcXVlc3RJZD0nICsgcmVxdWVzdC5pZCArICcmcmVzb2x1dGlvbj0nICsgcmVzb2x1dGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLnB1dCh1cmwsICcnLCB7IGhlYWRlcnM6IEhFQURFUlMgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiB0cmFuc2Zvcm1Qb3N0UmVzcG9uc2UocmVzcG9uc2UpKVxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gT2JzZXJ2YWJsZS50aHJvdyh0cmFuc2Zvcm1Qb3N0UmVzcG9uc2UoZXJyb3IpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlUmVxdWVzdChyZXF1ZXN0OiBSZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5kZWxldGUoJ3A/aWQ9dGFzay1yZXF1ZXN0cyZyZXF1ZXN0SWQ9JyArIHJlcXVlc3QuaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZVJlcXVlc3RBdHRhY2htZW50KHJlcXVlc3Q6IFJlcXVlc3QsIGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmRlbGV0ZSgncD9pZD10YXNrLXJlcXVlc3RzJnJlcXVlc3RJZD0nICsgcmVxdWVzdC5pZCArICcmYXR0YWNobWVudElkPScgKyBhdHRhY2htZW50LmlkKTtcclxuICAgIH1cclxuXHJcbiAgICBmZXRjaENvbW1lbnRzKHRhc2s6IFRhc2ssIHBhZ2UgPSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQoJ3A/aWQ9Y29tbWVudHMmdGFza0lkPScgKyB0YXNrLmlkLCB7IGhlYWRlcnM6IEhFQURFUlMgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiBwYXJzZVJlc3BvbnNlT2JqZWN0cyhyZXNwb25zZS5qc29uKCkub2JqZWN0cykuY29tbWVudCB8fCB7fSlcclxuICAgICAgICAgICAgLm1hcChkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRkVUQ0hfQ09NTUVOVFMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50czogPENvbW1lbnRbXT5kYXRhLmxpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IGRhdGEubWV0YVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2F2ZUNvbW1lbnQodGFzazogVGFzaywgY29tbWVudDogQ29tbWVudCkge1xyXG4gICAgICAgIGxldCB1cmwgPSAncD9pZD1jb21tZW50cyZ0YXNrSWQ9JyArIHRhc2suaWQgKyAoY29tbWVudC5pZCA/ICcmY29tbWVudElkPScgKyBjb21tZW50LmlkIDogJycpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIHNlcmlhbGl6ZU9iaihjb21tZW50KSwgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gdHJhbnNmb3JtUG9zdFJlc3BvbnNlKHJlc3BvbnNlKSlcclxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IE9ic2VydmFibGUudGhyb3codHJhbnNmb3JtUG9zdFJlc3BvbnNlKGVycm9yKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZUNvbW1lbnQoY29tbWVudDogQ29tbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZGVsZXRlKCdwP2lkPWNvbW1lbnRzJmNvbW1lbnRJZD0nICsgY29tbWVudC5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlQ29tbWVudEF0dGFjaG1lbnQoY29tbWVudDogQ29tbWVudCwgYXR0YWNobWVudDogQXR0YWNobWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZGVsZXRlKCdwP2lkPWNvbW1lbnRzJmNvbW1lbnRJZD0nICsgY29tbWVudC5pZCArICcmYXR0YWNobWVudElkPScgKyBhdHRhY2htZW50LmlkKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zZXJ2aWNlcy90YXNrLnNlcnZpY2UudHNcbiAqKi8iLCJpbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi4vbW9kZWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCBGRVRDSF9UQVNLUyA9ICdGRVRDSF9UQVNLUyc7XHJcbmV4cG9ydCBjb25zdCBGRVRDSF9UQVNLID0gJ0ZFVENIX1RBU0snO1xyXG5leHBvcnQgY29uc3QgQUREX1RBU0sgPSAnQUREX1RBU0snO1xyXG5leHBvcnQgY29uc3QgVVBEQVRFX1RBU0sgPSAnVVBEQVRFX1RBU0snO1xyXG5leHBvcnQgY29uc3QgREVMRVRFX1RBU0sgPSAnREVMRVRFX1RBU0snO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJVGFza3NTdGF0ZSB7XHJcbiAgICBtZXRhOiB7fSxcclxuICAgIHRhc2tzOiBUYXNrW10sXHJcbiAgICBsb2FkaW5nOiBib29sZWFuXHJcbn07XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGU6IElUYXNrc1N0YXRlID0ge1xyXG4gICAgbWV0YToge30sXHJcbiAgICB0YXNrczogW10sXHJcbiAgICBsb2FkaW5nOiBmYWxzZVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHRhc2tzUmVkdWNlciA9IChzdGF0ZSA9IGluaXRpYWxTdGF0ZSwge3R5cGUsIHBheWxvYWR9KTogSVRhc2tzU3RhdGUgPT4ge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBGRVRDSF9UQVNLUzpcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICB0YXNrczogcGF5bG9hZC50YXNrcyxcclxuICAgICAgICAgICAgICAgIG1ldGE6IHBheWxvYWQubWV0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIEZFVENIX1RBU0s6XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgdGFzazogcGF5bG9hZC50YXNrXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgQUREX1RBU0s6XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICBjYXNlIFVQREFURV9UQVNLOlxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgY2FzZSBERUxFVEVfVEFTSzpcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvcmVkdWNlcnMvdGFza3MucmVkdWNlci50c1xuICoqLyIsImltcG9ydCB7IFRhc2ssIFJlcXVlc3QsIENvbW1lbnQgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRBU0tfUkVRVUVTVF9ORVcgPSAnVEFTS19SRVFVRVNUX05FVyc7XHJcbmV4cG9ydCBjb25zdCBUQVNLX1JFUVVFU1RfQ0FOQ0VMID0gJ1RBU0tfUkVRVUVTVF9DQU5DRUwnO1xyXG5leHBvcnQgY29uc3QgRkVUQ0hfQ09NTUVOVFMgPSAnRkVUQ0hfQ09NTUVOVFMnO1xyXG5leHBvcnQgY29uc3QgRkVUQ0hfUkVRVUVTVFMgPSAnRkVUQ0hfUkVRVUVTVFMnO1xyXG5leHBvcnQgY29uc3QgVEFTS19DTE9TRSA9ICdUQVNLX0NMT1NFJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRhc2tTdGF0ZSB7XHJcbiAgICB0YXNrOiBUYXNrLFxyXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcclxuICAgIHJlcXVlc3RzOiBSZXF1ZXN0W10sXHJcbiAgICBzaG93UmVxdWVzdDogYm9vbGVhbixcclxuICAgIGNvbW1lbnRzOiBDb21tZW50W11cclxufTtcclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZTogSVRhc2tTdGF0ZSA9IHtcclxuICAgIHRhc2s6IG51bGwsXHJcbiAgICByZXF1ZXN0OiBudWxsLFxyXG4gICAgcmVxdWVzdHM6IFtdLFxyXG4gICAgc2hvd1JlcXVlc3Q6IGZhbHNlLFxyXG4gICAgY29tbWVudHM6IFtdXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGFza1JlZHVjZXIgPSAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIHt0eXBlLCBwYXlsb2FkfSk6IElUYXNrU3RhdGUgPT4ge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBGRVRDSF9SRVFVRVNUUzpcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0czogcGF5bG9hZC5yZXF1ZXN0c1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIFRBU0tfUkVRVUVTVF9ORVc6XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgdGFzazogcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHNob3dSZXF1ZXN0OiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgVEFTS19SRVFVRVNUX0NBTkNFTDpcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICBzaG93UmVxdWVzdDogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBGRVRDSF9DT01NRU5UUzpcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50czogcGF5bG9hZC5jb21tZW50c1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIFRBU0tfQ0xPU0U6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0YXNrOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RzOiBbXSxcclxuICAgICAgICAgICAgICAgIHNob3dSZXF1ZXN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbW1lbnRzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvcmVkdWNlcnMvdGFzay5yZWR1Y2VyLnRzXG4gKiovIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBIdHRwLCBIZWFkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5cclxuaW1wb3J0IHtcclxuICAgIEZFVENIX1RBR1MsXHJcbiAgICBGRVRDSF9UQVNLX1RZUEVTLFxyXG4gICAgRkVUQ0hfUkVRVUVTVF9UWVBFU1xyXG59IGZyb20gJy4uL3JlZHVjZXJzL3JlZmVyZW5jZS5yZWR1Y2VyJztcclxuaW1wb3J0IHsgVGFnLCBUYXNrVHlwZSwgUmVxdWVzdFR5cGUgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5cclxuY29uc3QgSEVBREVSUyA9IG5ldyBIZWFkZXJzKHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04JyxcclxuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcclxufSk7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBSZWZlcmVuY2VTZXJ2aWNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGh0dHA6IEh0dHAsXHJcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogU3RvcmU8YW55PlxyXG4gICAgKSB7IH1cclxuXHJcbiAgICBsb2FkUmVmZXJlbmNlKCkge1xyXG4gICAgICAgIHRoaXMuZmV0Y2hUYWdzKCkuc3Vic2NyaWJlKGFjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZldGNoVGFza1R5cGVzKCkuc3Vic2NyaWJlKGFjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZldGNoUmVxdWVzdFR5cGVzKCkuc3Vic2NyaWJlKGFjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmZXRjaFRhZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQoJy9SZWZlcmVuY2UvcD9pZD10YWdzJywgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpLm9iamVjdHNbMF0pXHJcbiAgICAgICAgICAgIC5tYXAoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEZFVENIX1RBR1MsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiA8VGFnW10+ZGF0YS5saXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBkYXRhLm1ldGFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZldGNoVGFza1R5cGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KCcvUmVmZXJlbmNlL3A/aWQ9dGFza3R5cGVzJywgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpLm9iamVjdHNbMF0pXHJcbiAgICAgICAgICAgIC5tYXAoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEZFVENIX1RBU0tfVFlQRVMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrVHlwZXM6IDxUYXNrVHlwZVtdPmRhdGEubGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogZGF0YS5tZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmZXRjaFJlcXVlc3RUeXBlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldCgnL1JlZmVyZW5jZS9wP2lkPXJlcXVlc3QtdHlwZXMnLCB7IGhlYWRlcnM6IEhFQURFUlMgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkub2JqZWN0c1swXSlcclxuICAgICAgICAgICAgLm1hcChkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRkVUQ0hfUkVRVUVTVF9UWVBFUyxcclxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlczogPFJlcXVlc3RUeXBlW10+ZGF0YS5saXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBkYXRhLm1ldGFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NlcnZpY2VzL3JlZmVyZW5jZS5zZXJ2aWNlLnRzXG4gKiovIiwiaW1wb3J0IHsgVGFnLCBUYXNrVHlwZSwgUmVxdWVzdFR5cGUgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZFVENIX1RBR1MgPSAnRkVUQ0hfVEFHUyc7XHJcbmV4cG9ydCBjb25zdCBGRVRDSF9UQVNLX1RZUEVTID0gJ0ZFVENIX1RBU0tfVFlQRVMnO1xyXG5leHBvcnQgY29uc3QgRkVUQ0hfUkVRVUVTVF9UWVBFUyA9ICdGRVRDSF9SRVFVRVNUX1RZUEVTJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJlZmVyZW5jZVN0YXRlIHtcclxuICAgIHRhZ3M6IFRhZ1tdLFxyXG4gICAgdGFza1R5cGVzOiBUYXNrVHlwZVtdLFxyXG4gICAgcmVxdWVzdFR5cGVzOiBSZXF1ZXN0VHlwZVtdXHJcbn07XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICB0YWdzOiBbXSxcclxuICAgIHRhc2tUeXBlczogW10sXHJcbiAgICByZXF1ZXN0VHlwZXM6IFtdXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlUmVkdWNlciA9IChzdGF0ZSA9IGluaXRpYWxTdGF0ZSwge3R5cGUsIHBheWxvYWR9KTogSVJlZmVyZW5jZVN0YXRlID0+IHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgRkVUQ0hfVEFHUzpcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICB0YWdzOiBwYXlsb2FkLnRhZ3NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBGRVRDSF9UQVNLX1RZUEVTOlxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICAgICAgICAgIHRhc2tUeXBlczogcGF5bG9hZC50YXNrVHlwZXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBGRVRDSF9SRVFVRVNUX1RZUEVTOlxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlczogcGF5bG9hZC5yZXF1ZXN0VHlwZXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9yZWR1Y2Vycy9yZWZlcmVuY2UucmVkdWNlci50c1xuICoqLyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSHR0cCwgSGVhZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5cclxuaW1wb3J0IHtcclxuICAgIEZFVENIX1VTRVJTLFxyXG4gICAgRkVUQ0hfT1JHQU5JWkFUSU9OU1xyXG59IGZyb20gJy4uL3JlZHVjZXJzL3N0YWZmLnJlZHVjZXInO1xyXG5pbXBvcnQgeyBPcmdhbml6YXRpb24sIFVzZXIgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5pbXBvcnQgeyBjcmVhdGVVUkxTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcblxyXG5jb25zdCBIRUFERVJTID0gbmV3IEhlYWRlcnMoe1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnLFxyXG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG59KTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0YWZmU2VydmljZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBodHRwOiBIdHRwXHJcbiAgICApIHsgfVxyXG5cclxuICAgIGZldGNoT3JnYW5pemF0aW9ucyhxdWVyeVBhcmFtcyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQoJy9TdGFmZi9wP2lkPWdldC1vcmdhbml6YXRpb25zJywge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBIRUFERVJTLFxyXG4gICAgICAgICAgICBzZWFyY2g6IGNyZWF0ZVVSTFNlYXJjaFBhcmFtcyhxdWVyeVBhcmFtcylcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubWFwKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKS5vYmplY3RzWzBdKVxyXG4gICAgICAgICAgICAubWFwKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBGRVRDSF9PUkdBTklaQVRJT05TLFxyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JnYW5pemF0aW9uczogPE9yZ2FuaXphdGlvbltdPmRhdGEubGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogZGF0YS5tZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmZXRjaFVzZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KCdwP2lkPXVzZXJzJywgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBGRVRDSF9VU0VSUyxcclxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJzOiA8VXNlcltdPnJlc3BvbnNlLmpzb24oKS5vYmplY3RzWzBdLmxpc3RcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NlcnZpY2VzL3N0YWZmLnNlcnZpY2UudHNcbiAqKi8iLCJpbXBvcnQgeyBPcmdhbml6YXRpb24sIFVzZXIgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZFVENIX09SR0FOSVpBVElPTlMgPSAnRkVUQ0hfT1JHQU5JWkFUSU9OUyc7XHJcbmV4cG9ydCBjb25zdCBGRVRDSF9VU0VSUyA9ICdGRVRDSF9VU0VSUyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTdGFmZlN0YXRlIHtcclxuICAgIG9yZ2FuaXphdGlvbnM6IE9yZ2FuaXphdGlvbltdLFxyXG4gICAgdXNlcnM6IFVzZXJbXVxyXG59O1xyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlOiBJU3RhZmZTdGF0ZSA9IHtcclxuICAgIG9yZ2FuaXphdGlvbnM6IFtdLFxyXG4gICAgdXNlcnM6IFtdXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc3RhZmZSZWR1Y2VyID0gKHN0YXRlID0gaW5pdGlhbFN0YXRlLCB7dHlwZSwgcGF5bG9hZH0pOiBJU3RhZmZTdGF0ZSA9PiB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIEZFVENIX09SR0FOSVpBVElPTlM6XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgb3JnYW5pemF0aW9uczogcGF5bG9hZC5vcmdhbml6YXRpb25zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgRkVUQ0hfVVNFUlM6XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgdXNlcnM6IHBheWxvYWQudXNlcnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9yZWR1Y2Vycy9zdGFmZi5yZWR1Y2VyLnRzXG4gKiovIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9SeCc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBVcGxvYWRTZXJ2aWNlIHtcclxuICAgIHB1YmxpYyBwcm9ncmVzcyQ6IE9ic2VydmFibGU8YW55PjtcclxuICAgIHByaXZhdGUgcHJvZ3Jlc3NPYnNlcnZlcjogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3MkID0gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzT2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgICAgICB9KS5zaGFyZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG1ha2VGaWxlUmVxdWVzdCh1cmw6IHN0cmluZywgcGFyYW1zOiBhbnksIGZpbGVzOiBGaWxlW10pOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgICAgICAgICAgIGxldCBmb3JtRGF0YTogRm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSxcclxuICAgICAgICAgICAgICAgIHhocjogWE1MSHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgndXBsb2Fkc1tdJywgZmlsZXNbaV0sIGZpbGVzW2ldLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrIGluIHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrLCBwYXJhbXNba10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IE1hdGgucm91bmQoZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAxMDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc09ic2VydmVyLm5leHQocHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xyXG4gICAgICAgICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2VydmljZXMvdXBsb2FkLnNlcnZpY2UudHNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xuLy8gU3ViamVjdCBpbXBvcnRlZCBiZWZvcmUgT2JzZXJ2YWJsZSB0byBieXBhc3MgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSBzaW5jZVxuLy8gU3ViamVjdCBleHRlbmRzIE9ic2VydmFibGUgYW5kIE9ic2VydmFibGUgcmVmZXJlbmNlcyBTdWJqZWN0IGluIGl0J3Ncbi8vIGRlZmluaXRpb25cbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1N1YmplY3QnKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3RfMS5TdWJqZWN0O1xuLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlO1xuLy8gc3RhdGljc1xuLyogdHNsaW50OmRpc2FibGU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjaycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvY29uY2F0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2RlZmVyJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2VtcHR5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2ZvcmtKb2luJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2Zyb20nKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvZnJvbUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4nKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvZ2VuZXJhdGUnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvaW50ZXJ2YWwnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvbWVyZ2UnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvcmFjZScpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9uZXZlcicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9vZicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9yYW5nZScpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS90aHJvdycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS90aW1lcicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS96aXAnKTtcbi8vb3BlcmF0b3JzXG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXInKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2J1ZmZlckNvdW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXJUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXJUb2dnbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2J1ZmZlcldoZW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NhY2hlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jYXRjaCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29tYmluZUFsbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29tYmluZUxhdGVzdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29uY2F0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jb25jYXRBbGwnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NvbmNhdE1hcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29uY2F0TWFwVG8nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NvdW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZW1hdGVyaWFsaXplJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZWJvdW5jZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGVsYXknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2RlbGF5V2hlbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2RvJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9leHBhbmQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2ZpbHRlcicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZmluYWxseScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZmlyc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2dyb3VwQnknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2lnbm9yZUVsZW1lbnRzJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9hdWRpdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvYXVkaXRUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9sYXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9sZXQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2V2ZXJ5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tYXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21hcFRvJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWVyZ2UnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21lcmdlQWxsJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tZXJnZU1hcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBUbycpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbXVsdGljYXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9vYnNlcnZlT24nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3BhcnRpdGlvbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcGx1Y2snKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3B1Ymxpc2gnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvcicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcHVibGlzaFJlcGxheScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcHVibGlzaExhc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3JhY2UnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3JlZHVjZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcmVwZWF0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9yZXRyeScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcmV0cnlXaGVuJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zYW1wbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NhbXBsZVRpbWUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NjYW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NoYXJlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zaW5nbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NraXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NraXBVbnRpbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2tpcFdoaWxlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zdGFydFdpdGgnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3N1YnNjcmliZU9uJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zd2l0Y2gnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3N3aXRjaE1hcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwVG8nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3Rha2UnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3Rha2VMYXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90YWtlVW50aWwnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3Rha2VXaGlsZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGhyb3R0bGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGltZW91dCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGltZW91dFdpdGgnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RvQXJyYXknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RvUHJvbWlzZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivd2luZG93Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivd2luZG93VGltZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivd2luZG93VG9nZ2xlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3dXaGVuJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvemlwJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci96aXBBbGwnKTtcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xudmFyIE9wZXJhdG9yXzEgPSByZXF1aXJlKCcuL09wZXJhdG9yJyk7XG5leHBvcnRzLk9wZXJhdG9yID0gT3BlcmF0b3JfMS5PcGVyYXRvcjtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbjtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyO1xudmFyIEFzeW5jU3ViamVjdF8xID0gcmVxdWlyZSgnLi9Bc3luY1N1YmplY3QnKTtcbmV4cG9ydHMuQXN5bmNTdWJqZWN0ID0gQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0O1xudmFyIFJlcGxheVN1YmplY3RfMSA9IHJlcXVpcmUoJy4vUmVwbGF5U3ViamVjdCcpO1xuZXhwb3J0cy5SZXBsYXlTdWJqZWN0ID0gUmVwbGF5U3ViamVjdF8xLlJlcGxheVN1YmplY3Q7XG52YXIgQmVoYXZpb3JTdWJqZWN0XzEgPSByZXF1aXJlKCcuL0JlaGF2aW9yU3ViamVjdCcpO1xuZXhwb3J0cy5CZWhhdmlvclN1YmplY3QgPSBCZWhhdmlvclN1YmplY3RfMS5CZWhhdmlvclN1YmplY3Q7XG52YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJyk7XG5leHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbnZhciBOb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoJy4vTm90aWZpY2F0aW9uJyk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbjtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvRW1wdHlFcnJvcicpO1xuZXhwb3J0cy5FbXB0eUVycm9yID0gRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3I7XG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xuZXhwb3J0cy5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yO1xudmFyIGFzYXBfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL2FzYXAnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBxdWV1ZV8xID0gcmVxdWlyZSgnLi9zY2hlZHVsZXIvcXVldWUnKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9pdGVyYXRvcicpO1xudmFyIG9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUnguU2NoZWR1bGVyXG4gKiBAcHJvcGVydHkge1NjaGVkdWxlcn0gcXVldWUgU2NoZWR1bGVzIG9uIGEgcXVldWUgaW4gdGhlIGN1cnJlbnQgZXZlbnQgZnJhbWVcbiAqICh0cmFtcG9saW5lIHNjaGVkdWxlcikuIFVzZSB0aGlzIGZvciBpdGVyYXRpb24gb3BlcmF0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBhc2FwIFNjaGVkdWxlcyBvbiB0aGUgbWljcm8gdGFzayBxdWV1ZSwgd2hpY2ggdXNlcyB0aGVcbiAqIGZhc3Rlc3QgdHJhbnNwb3J0IG1lY2hhbmlzbSBhdmFpbGFibGUsIGVpdGhlciBOb2RlLmpzJyBgcHJvY2Vzcy5uZXh0VGljaygpYFxuICogb3IgV2ViIFdvcmtlciBNZXNzYWdlQ2hhbm5lbCBvciBzZXRUaW1lb3V0IG9yIG90aGVycy4gVXNlIHRoaXMgZm9yXG4gKiBhc3luY2hyb25vdXMgY29udmVyc2lvbnMuXG4gKiBAcHJvcGVydHkge1NjaGVkdWxlcn0gYXN5bmMgU2NoZWR1bGVzIHdvcmsgd2l0aCBgc2V0SW50ZXJ2YWxgLiBVc2UgdGhpcyBmb3JcbiAqIHRpbWUtYmFzZWQgb3BlcmF0aW9ucy5cbiAqL1xudmFyIFNjaGVkdWxlciA9IHtcbiAgICBhc2FwOiBhc2FwXzEuYXNhcCxcbiAgICBhc3luYzogYXN5bmNfMS5hc3luYyxcbiAgICBxdWV1ZTogcXVldWVfMS5xdWV1ZVxufTtcbmV4cG9ydHMuU2NoZWR1bGVyID0gU2NoZWR1bGVyO1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSeC5TeW1ib2xcbiAqIEBwcm9wZXJ0eSB7U3ltYm9sfHN0cmluZ30gcnhTdWJzY3JpYmVyIEEgc3ltYm9sIHRvIHVzZSBhcyBhIHByb3BlcnR5IG5hbWUgdG9cbiAqIHJldHJpZXZlIGFuIFwiUnggc2FmZVwiIE9ic2VydmVyIGZyb20gYW4gb2JqZWN0LiBcIlJ4IHNhZmV0eVwiIGNhbiBiZSBkZWZpbmVkIGFzXG4gKiBhbiBvYmplY3QgdGhhdCBoYXMgYWxsIG9mIHRoZSB0cmFpdHMgb2YgYW4gUnggU3Vic2NyaWJlciwgaW5jbHVkaW5nIHRoZVxuICogYWJpbGl0eSB0byBhZGQgYW5kIHJlbW92ZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzdWJzY3JpcHRpb24gY2hhaW4gYW5kXG4gKiBndWFyYW50ZWVzIGludm9sdmluZyBldmVudCB0cmlnZ2VyaW5nIChjYW4ndCBcIm5leHRcIiBhZnRlciB1bnN1YnNjcmlwdGlvbixcbiAqIGV0YykuXG4gKiBAcHJvcGVydHkge1N5bWJvbHxzdHJpbmd9IG9ic2VydmFibGUgQSBzeW1ib2wgdG8gdXNlIGFzIGEgcHJvcGVydHkgbmFtZSB0b1xuICogcmV0cmlldmUgYW4gT2JzZXJ2YWJsZSBhcyBkZWZpbmVkIGJ5IHRoZSBbRUNNQVNjcmlwdCBcIk9ic2VydmFibGVcIiBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlKS5cbiAqIEBwcm9wZXJ0eSB7U3ltYm9sfHN0cmluZ30gaXRlcmF0b3IgVGhlIEVTNiBzeW1ib2wgdG8gdXNlIGFzIGEgcHJvcGVydHkgbmFtZVxuICogdG8gcmV0cmlldmUgYW4gaXRlcmF0b3IgZnJvbSBhbiBvYmplY3QuXG4gKi9cbnZhciBTeW1ib2wgPSB7XG4gICAgcnhTdWJzY3JpYmVyOiByeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcixcbiAgICBvYnNlcnZhYmxlOiBvYnNlcnZhYmxlLFxuICAgIGl0ZXJhdG9yOiBpdGVyYXRvcl8xLiQkaXRlcmF0b3Jcbn07XG5leHBvcnRzLlN5bWJvbCA9IFN5bWJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJ4LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvUnguanNcbiAqKiBtb2R1bGUgaWQgPSA0NzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBiaW5kQ2FsbGJhY2tfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvYmluZENhbGxiYWNrJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2sgPSBiaW5kQ2FsbGJhY2tfMS5iaW5kQ2FsbGJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kQ2FsbGJhY2suanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2suanNcbiAqKiBtb2R1bGUgaWQgPSA0ODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0JvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmJpbmRDYWxsYmFjayA9IEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlXzEuQm91bmRDYWxsYmFja09ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZENhbGxiYWNrLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2suanNcbiAqKiBtb2R1bGUgaWQgPSA0ODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBBc3luY1N1YmplY3RfMSA9IHJlcXVpcmUoJy4uL0FzeW5jU3ViamVjdCcpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlKGNhbGxiYWNrRnVuYywgc2VsZWN0b3IsIGFyZ3MsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0Z1bmMgPSBjYWxsYmFja0Z1bmM7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjYWxsYmFjayBBUEkgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5HaXZlIGl0IGEgZnVuY3Rpb24gYGZgIG9mIHR5cGUgYGYoeCwgY2FsbGJhY2spYCBhbmRcbiAgICAgKiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIGBnYCB0aGF0IHdoZW4gY2FsbGVkIGFzIGBnKHgpYCB3aWxsIG91dHB1dCBhblxuICAgICAqIE9ic2VydmFibGUuPC9zcGFuPlxuICAgICAqXG4gICAgICogYGJpbmRDYWxsYmFja2AgaXMgbm90IGFuIG9wZXJhdG9yIGJlY2F1c2UgaXRzIGlucHV0IGFuZCBvdXRwdXQgYXJlIG5vdFxuICAgICAqIE9ic2VydmFibGVzLiBUaGUgaW5wdXQgaXMgYSBmdW5jdGlvbiBgZnVuY2Agd2l0aCBzb21lIHBhcmFtZXRlcnMsIGJ1dCB0aGVcbiAgICAgKiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBgZnVuY2AgY2FsbHMgd2hlbiBpdCBpc1xuICAgICAqIGRvbmUuIFRoZSBvdXRwdXQgb2YgYGJpbmRDYWxsYmFja2AgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzYW1lXG4gICAgICogcGFyYW1ldGVycyBhcyBgZnVuY2AsIGV4Y2VwdCB0aGUgbGFzdCBvbmUgKHRoZSBjYWxsYmFjaykuIFdoZW4gdGhlIG91dHB1dFxuICAgICAqIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50cywgaXQgd2lsbCByZXR1cm4gYW4gT2JzZXJ2YWJsZSB3aGVyZSB0aGVcbiAgICAgKiByZXN1bHRzIHdpbGwgYmUgZGVsaXZlcmVkIHRvLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBqUXVlcnkncyBnZXRKU09OIHRvIGFuIE9ic2VydmFibGUgQVBJPC9jYXB0aW9uPlxuICAgICAqIC8vIFN1cHBvc2Ugd2UgaGF2ZSBqUXVlcnkuZ2V0SlNPTignL215L3VybCcsIGNhbGxiYWNrKVxuICAgICAqIHZhciBnZXRKU09OQXNPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2soalF1ZXJ5LmdldEpTT04pO1xuICAgICAqIHZhciByZXN1bHQgPSBnZXRKU09OQXNPYnNlcnZhYmxlKCcvbXkvdXJsJyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgYmluZE5vZGVDYWxsYmFja31cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNlbGVjdG9yIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZVxuICAgICAqIGNhbGxiYWNrIGFuZCBtYXBzIHRob3NlIGEgdmFsdWUgdG8gZW1pdCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gICAgICogY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLnBhcmFtczogKik6IE9ic2VydmFibGV9IEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICAgKiBPYnNlcnZhYmxlIHRoYXQgZGVsaXZlcnMgdGhlIHNhbWUgdmFsdWVzIHRoZSBjYWxsYmFjayB3b3VsZCBkZWxpdmVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGJpbmRDYWxsYmFja1xuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgQm91bmRDYWxsYmFja09ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHsgc2VsZWN0b3IgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlKGZ1bmMsIHNlbGVjdG9yLCBhcmdzLCBzY2hlZHVsZXIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQm91bmRDYWxsYmFja09ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgY2FsbGJhY2tGdW5jID0gdGhpcy5jYWxsYmFja0Z1bmM7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICBpZiAoIXNjaGVkdWxlcikge1xuICAgICAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdCA9IHRoaXMuc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3RfMS5Bc3luY1N1YmplY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXJGbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJBcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBoYW5kbGVyRm4uc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBzb3VyY2Uuc2VsZWN0b3IsIHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KHJlc3VsdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQoaW5uZXJBcmdzLmxlbmd0aCA9PT0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiBpbnN0YW5jZSB0byBhdm9pZCBjbG9zdXJlLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuc291cmNlID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7IHNvdXJjZTogdGhpcywgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZSA9IEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlO1xuZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgdmFyIGNhbGxiYWNrRnVuYyA9IHNvdXJjZS5jYWxsYmFja0Z1bmMsIGFyZ3MgPSBzb3VyY2UuYXJncywgc2NoZWR1bGVyID0gc291cmNlLnNjaGVkdWxlcjtcbiAgICB2YXIgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICBzdWJqZWN0ID0gc291cmNlLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKCkge1xuICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNvdXJjZS5zZWxlY3Rvciwgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8yID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogcmVzdWx0XzIsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlubmVyQXJncy5sZW5ndGggPT09IDEgPyBpbm5lckFyZ3NbMF0gOiBpbm5lckFyZ3M7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgaW4gd2l0aG91dCBjbG9zdXJlXG4gICAgICAgIGhhbmRsZXIuc291cmNlID0gc291cmNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGYuYWRkKHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIHN1YmplY3QuY29tcGxldGUoKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0LmVycm9yKGVycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvQm91bmRDYWxsYmFja09ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0ODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi9TdWJqZWN0Jyk7XG4vKipcbiAqIEBjbGFzcyBBc3luY1N1YmplY3Q8VD5cbiAqL1xudmFyIEFzeW5jU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1N1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNOZXh0ID0gZmFsc2U7XG4gICAgfVxuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmhhc05leHQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBBc3luY1N1YmplY3QucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNOZXh0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIHRvIGJsb2NrIG91ciBTdWJqZWN0U3Vic2NyaXB0aW9ucyBmcm9tXG4gICAgICAgIC8vIHNwbGljaW5nIHRoZW1zZWx2ZXMgb3V0IG9mIHRoZSBvYnNlcnZlcnMgbGlzdCBvbmUgYnkgb25lLlxuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTmV4dCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IG9ic2VydmVyc1tpbmRleF07XG4gICAgICAgICAgICAgICAgby5uZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIG8uY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzW2luZGV4XS5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jU3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuQXN5bmNTdWJqZWN0ID0gQXN5bmNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTdWJqZWN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvQXN5bmNTdWJqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYmluZE5vZGVDYWxsYmFja18xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5iaW5kTm9kZUNhbGxiYWNrID0gYmluZE5vZGVDYWxsYmFja18xLmJpbmROb2RlQ2FsbGJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kTm9kZUNhbGxiYWNrLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0JvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5iaW5kTm9kZUNhbGxiYWNrID0gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlXzEuQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmROb2RlQ2FsbGJhY2suanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2suanNcbiAqKiBtb2R1bGUgaWQgPSA0ODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBBc3luY1N1YmplY3RfMSA9IHJlcXVpcmUoJy4uL0FzeW5jU3ViamVjdCcpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBCb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlKGNhbGxiYWNrRnVuYywgc2VsZWN0b3IsIGFyZ3MsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0Z1bmMgPSBjYWxsYmFja0Z1bmM7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrIEFQSSB0byBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhblxuICAgICAqIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBqdXN0IGxpa2Uge0BsaW5rIGJpbmRDYWxsYmFja30sIGJ1dCB0aGVcbiAgICAgKiBjYWxsYmFjayBpcyBleHBlY3RlZCB0byBiZSBvZiB0eXBlIGBjYWxsYmFjayhlcnJvciwgcmVzdWx0KWAuPC9zcGFuPlxuICAgICAqXG4gICAgICogYGJpbmROb2RlQ2FsbGJhY2tgIGlzIG5vdCBhbiBvcGVyYXRvciBiZWNhdXNlIGl0cyBpbnB1dCBhbmQgb3V0cHV0IGFyZSBub3RcbiAgICAgKiBPYnNlcnZhYmxlcy4gVGhlIGlucHV0IGlzIGEgZnVuY3Rpb24gYGZ1bmNgIHdpdGggc29tZSBwYXJhbWV0ZXJzLCBidXQgdGhlXG4gICAgICogbGFzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYGZ1bmNgIGNhbGxzIHdoZW4gaXQgaXNcbiAgICAgKiBkb25lLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gZm9sbG93IE5vZGUuanMgY29udmVudGlvbnMsXG4gICAgICogd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayBpcyBhbiBlcnJvciwgd2hpbGUgcmVtYWluaW5nXG4gICAgICogYXJndW1lbnRzIGFyZSB0aGUgY2FsbGJhY2sgcmVzdWx0LiBUaGUgb3V0cHV0IG9mIGBiaW5kTm9kZUNhbGxiYWNrYCBpcyBhXG4gICAgICogZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGBmdW5jYCwgZXhjZXB0IHRoZSBsYXN0IG9uZSAodGhlXG4gICAgICogY2FsbGJhY2spLiBXaGVuIHRoZSBvdXRwdXQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYXJndW1lbnRzLCBpdCB3aWxsXG4gICAgICogcmV0dXJuIGFuIE9ic2VydmFibGUgd2hlcmUgdGhlIHJlc3VsdHMgd2lsbCBiZSBkZWxpdmVyZWQgdG8uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZWFkIGEgZmlsZSBmcm9tIHRoZSBmaWxlc3lzdGVtIGFuZCBnZXQgdGhlIGRhdGEgYXMgYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiBpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG4gICAgICogdmFyIHJlYWRGaWxlQXNPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZS5iaW5kTm9kZUNhbGxiYWNrKGZzLnJlYWRGaWxlKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gcmVhZEZpbGVBc09ic2VydmFibGUoJy4vcm9hZE5hbWVzLnR4dCcsICd1dGY4Jyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgYmluZENhbGxiYWNrfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc2VsZWN0b3IgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlXG4gICAgICogY2FsbGJhY2sgYW5kIG1hcHMgdGhvc2UgYSB2YWx1ZSB0byBlbWl0IG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBjYWxsYmFja3MuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24oLi4ucGFyYW1zOiAqKTogT2JzZXJ2YWJsZX0gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgICAqIE9ic2VydmFibGUgdGhhdCBkZWxpdmVycyB0aGUgc2FtZSB2YWx1ZXMgdGhlIE5vZGUuanMgY2FsbGJhY2sgd291bGRcbiAgICAgKiBkZWxpdmVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGJpbmROb2RlQ2FsbGJhY2tcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZnVuYywgc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkgeyBzZWxlY3RvciA9IHVuZGVmaW5lZDsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlKGZ1bmMsIHNlbGVjdG9yLCBhcmdzLCBzY2hlZHVsZXIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuYyA9IHRoaXMuY2FsbGJhY2tGdW5jO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSB0aGlzLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyRm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gc291cmNlLnNlbGVjdG9yLCBzdWJqZWN0ID0gc291cmNlLnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KHJlc3VsdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQoaW5uZXJBcmdzLmxlbmd0aCA9PT0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiBpbnN0YW5jZSB0byBhdm9pZCBjbG9zdXJlLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuc291cmNlID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7IHNvdXJjZTogdGhpcywgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlID0gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlO1xuZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgdmFyIGNhbGxiYWNrRnVuYyA9IHNvdXJjZS5jYWxsYmFja0Z1bmMsIGFyZ3MgPSBzb3VyY2UuYXJncywgc2NoZWR1bGVyID0gc291cmNlLnNjaGVkdWxlcjtcbiAgICB2YXIgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICBzdWJqZWN0ID0gc291cmNlLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKCkge1xuICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNvdXJjZS5zZWxlY3Rvciwgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICAgICAgdmFyIGVyciA9IGlubmVyQXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8yID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogcmVzdWx0XzIsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlubmVyQXJncy5sZW5ndGggPT09IDEgPyBpbm5lckFyZ3NbMF0gOiBpbm5lckFyZ3M7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgaW4gd2l0aG91dCBjbG9zdXJlXG4gICAgICAgIGhhbmRsZXIuc291cmNlID0gc291cmNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGYuYWRkKHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIHN1YmplY3QuY29tcGxldGUoKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0LmVycm9yKGVycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL0JvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9jb25jYXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNvbmNhdCA9IGNvbmNhdF8xLmNvbmNhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2NvbmNhdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvci9jb25jYXQnKTtcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0XzEuY29uY2F0U3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9jb25jYXQuanNcbiAqKiBtb2R1bGUgaWQgPSA0OTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWZlcl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9kZWZlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZGVmZXIgPSBkZWZlcl8xLmRlZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRGVmZXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0RlZmVyT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5kZWZlciA9IERlZmVyT2JzZXJ2YWJsZV8xLkRlZmVyT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvZGVmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0OTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRGVmZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmVyT2JzZXJ2YWJsZShvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlRmFjdG9yeSA9IG9ic2VydmFibGVGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCwgb24gc3Vic2NyaWJlLCBjYWxscyBhbiBPYnNlcnZhYmxlIGZhY3RvcnkgdG9cbiAgICAgKiBtYWtlIGFuIE9ic2VydmFibGUgZm9yIGVhY2ggbmV3IE9ic2VydmVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNyZWF0ZXMgdGhlIE9ic2VydmFibGUgbGF6aWx5LCB0aGF0IGlzLCBvbmx5IHdoZW4gaXRcbiAgICAgKiBpcyBzdWJzY3JpYmVkLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZGVmZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgZGVmZXJgIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRoZSBPYnNlcnZhYmxlIG9ubHkgd2hlbiB0aGUgT2JzZXJ2ZXJcbiAgICAgKiBzdWJzY3JpYmVzLCBhbmQgY3JlYXRlIGEgZnJlc2ggT2JzZXJ2YWJsZSBmb3IgZWFjaCBPYnNlcnZlci4gSXQgd2FpdHMgdW50aWxcbiAgICAgKiBhbiBPYnNlcnZlciBzdWJzY3JpYmVzIHRvIGl0LCBhbmQgdGhlbiBpdCBnZW5lcmF0ZXMgYW4gT2JzZXJ2YWJsZSxcbiAgICAgKiB0eXBpY2FsbHkgd2l0aCBhbiBPYnNlcnZhYmxlIGZhY3RvcnkgZnVuY3Rpb24uIEl0IGRvZXMgdGhpcyBhZnJlc2ggZm9yIGVhY2hcbiAgICAgKiBzdWJzY3JpYmVyLCBzbyBhbHRob3VnaCBlYWNoIHN1YnNjcmliZXIgbWF5IHRoaW5rIGl0IGlzIHN1YnNjcmliaW5nIHRvIHRoZVxuICAgICAqIHNhbWUgT2JzZXJ2YWJsZSwgaW4gZmFjdCBlYWNoIHN1YnNjcmliZXIgZ2V0cyBpdHMgb3duIGluZGl2aWR1YWxcbiAgICAgKiBPYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3Vic2NyaWJlIHRvIGVpdGhlciBhbiBPYnNlcnZhYmxlIG9mIGNsaWNrcyBvciBhbiBPYnNlcnZhYmxlIG9mIGludGVydmFsLCBhdCByYW5kb208L2NhcHRpb24+XG4gICAgICogdmFyIGNsaWNrc09ySW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICogICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBjbGlja3NPckludGVydmFsLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogT2JzZXJ2YWJsZXxQcm9taXNlfSBvYnNlcnZhYmxlRmFjdG9yeSBUaGUgT2JzZXJ2YWJsZVxuICAgICAqIGZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIE9ic2VydmVyIHRoYXQgc3Vic2NyaWJlcyB0byB0aGUgb3V0cHV0XG4gICAgICogT2JzZXJ2YWJsZS4gTWF5IGFsc28gcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBjb252ZXJ0ZWQgb24gdGhlIGZseVxuICAgICAqIHRvIGFuIE9ic2VydmFibGUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB3aG9zZSBPYnNlcnZlcnMnIHN1YnNjcmlwdGlvbnMgdHJpZ2dlclxuICAgICAqIGFuIGludm9jYXRpb24gb2YgdGhlIGdpdmVuIE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBkZWZlclxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRGVmZXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVyT2JzZXJ2YWJsZShvYnNlcnZhYmxlRmFjdG9yeSk7XG4gICAgfTtcbiAgICBEZWZlck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZlck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkRlZmVyT2JzZXJ2YWJsZSA9IERlZmVyT2JzZXJ2YWJsZTtcbnZhciBEZWZlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBmYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy50cnlEZWZlcigpO1xuICAgIH1cbiAgICBEZWZlclN1YnNjcmliZXIucHJvdG90eXBlLnRyeURlZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZlclN1YnNjcmliZXIucHJvdG90eXBlLl9jYWxsRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmFjdG9yeSgpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVmZXJTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmVyT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvRGVmZXJPYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZW1wdHlfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZW1wdHknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmVtcHR5ID0gZW1wdHlfMS5lbXB0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29ic2VydmFibGUvZW1wdHkuanNcbiAqKiBtb2R1bGUgaWQgPSA0OTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbmV4cG9ydHMuZW1wdHkgPSBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL2VtcHR5LmpzXG4gKiogbW9kdWxlIGlkID0gNDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb21FdmVudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbUV2ZW50ID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Zyb21FdmVudE9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbUV2ZW50ID0gRnJvbUV2ZW50T2JzZXJ2YWJsZV8xLkZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0OThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtbWl0dGVyKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLm9uID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoub2ZmID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdChzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgc291cmNlT2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE5vZGVMaXN0XSc7XG59XG5mdW5jdGlvbiBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiBzb3VyY2VPYmoudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJztcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tRXZlbnRPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21FdmVudE9ic2VydmFibGUoc291cmNlT2JqLCBldmVudE5hbWUsIHNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZU9iaiA9IHNvdXJjZU9iajtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBjb21pbmcgZnJvbSB0aGVcbiAgICAgKiBnaXZlbiBldmVudCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gRE9NIGV2ZW50cywgb3IgTm9kZVxuICAgICAqIEV2ZW50RW1pdHRlciBldmVudHMgb3Igb3RoZXJzLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbUV2ZW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGJ5IGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBcImV2ZW50IHRhcmdldFwiLFxuICAgICAqIHdoaWNoIG1heSBiZSBhbiBvYmplY3Qgd2l0aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCxcbiAgICAgKiBhIE5vZGUuanMgRXZlbnRFbWl0dGVyLCBhIGpRdWVyeSBzdHlsZSBFdmVudEVtaXR0ZXIsIGEgTm9kZUxpc3QgZnJvbSB0aGVcbiAgICAgKiBET00sIG9yIGFuIEhUTUxDb2xsZWN0aW9uIGZyb20gdGhlIERPTS4gVGhlIGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgd2hlblxuICAgICAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXNcbiAgICAgKiB1bnN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnQ8L2NhcHRpb24+XG4gICAgICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgICAgKiBjbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldExpa2V9IHRhcmdldCBUaGUgRE9NRWxlbWVudCwgZXZlbnQgdGFyZ2V0LCBOb2RlLmpzXG4gICAgICogRXZlbnRFbWl0dGVyLCBOb2RlTGlzdCBvciBIVE1MQ29sbGVjdGlvbiB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXIgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSBvZiBpbnRlcmVzdCwgYmVpbmcgZW1pdHRlZCBieSB0aGVcbiAgICAgKiBgdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFyZ3M6IGFueSk6IFR9IFtzZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAgICAgKiBwb3N0LXByb2Nlc3MgcmVzdWx0cy4gSXQgdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBldmVudCBoYW5kbGVyIGFuZFxuICAgICAqIHNob3VsZCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn1cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBmcm9tRXZlbnRcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZyb21FdmVudE9ic2VydmFibGUodGFyZ2V0LCBldmVudE5hbWUsIHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlO1xuICAgICAgICBpZiAoaXNOb2RlTGlzdChzb3VyY2VPYmopIHx8IGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZU9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqW2ldLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHNvdXJjZU9iai5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VPYmoub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHNvdXJjZU9iai5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VPYmoucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZU9iaiA9IHRoaXMuc291cmNlT2JqO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy5ldmVudE5hbWU7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRPYnNlcnZhYmxlID0gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudE9ic2VydmFibGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL0Zyb21FdmVudE9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmcm9tRXZlbnRQYXR0ZXJuXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb21FdmVudFBhdHRlcm4gPSBmcm9tRXZlbnRQYXR0ZXJuXzEuZnJvbUV2ZW50UGF0dGVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudFBhdHRlcm4uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzXG4gKiogbW9kdWxlIGlkID0gNTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mcm9tRXZlbnRQYXR0ZXJuID0gRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGVfMS5Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnRQYXR0ZXJuLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzXG4gKiogbW9kdWxlIGlkID0gNTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRIYW5kbGVyID0gYWRkSGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZW1vdmVIYW5kbGVyID0gcmVtb3ZlSGFuZGxlcjtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBhbiBBUEkgYmFzZWQgb24gYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnRzIGFueSBhZGRIYW5kbGVyL3JlbW92ZUhhbmRsZXIgQVBJIHRvIGFuXG4gICAgICogT2JzZXJ2YWJsZS48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2Zyb21FdmVudFBhdHRlcm4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgYnkgdXNpbmcgdGhlIGBhZGRIYW5kbGVyYCBhbmQgYHJlbW92ZUhhbmRsZXJgXG4gICAgICogZnVuY3Rpb25zIHRvIGFkZCBhbmQgcmVtb3ZlIHRoZSBoYW5kbGVycywgd2l0aCBhbiBvcHRpb25hbCBzZWxlY3RvclxuICAgICAqIGZ1bmN0aW9uIHRvIHByb2plY3QgdGhlIGV2ZW50IGFyZ3VtZW50cyB0byBhIHJlc3VsdC4gVGhlIGBhZGRIYW5kbGVyYCBpc1xuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBhbmQgYHJlbW92ZUhhbmRsZXJgIGlzXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnQ8L2NhcHRpb24+XG4gICAgICogZnVuY3Rpb24gYWRkQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgKiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gcmVtb3ZlQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgKiAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50UGF0dGVybihcbiAgICAgKiAgIGFkZENsaWNrSGFuZGxlcixcbiAgICAgKiAgIHJlbW92ZUNsaWNrSGFuZGxlclxuICAgICAqICk7XG4gICAgICogY2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihoYW5kbGVyOiBGdW5jdGlvbik6IGFueX0gYWRkSGFuZGxlciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAgICAgKiBhIGBoYW5kbGVyYCBmdW5jdGlvbiBhcyBhcmd1bWVudCBhbmQgYXR0YWNoZXMgaXQgc29tZWhvdyB0byB0aGUgYWN0dWFsXG4gICAgICogc291cmNlIG9mIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhbmRsZXI6IEZ1bmN0aW9uKTogdm9pZH0gcmVtb3ZlSGFuZGxlciBBIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiB0YWtlcyBhIGBoYW5kbGVyYCBmdW5jdGlvbiBhcyBhcmd1bWVudCBhbmQgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IHdhc1xuICAgICAqIHByZXZpb3VzbHkgYXR0YWNoZWQgdXNpbmcgYGFkZEhhbmRsZXJgLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYXJnczogYW55KTogVH0gW3NlbGVjdG9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0b1xuICAgICAqIHBvc3QtcHJvY2VzcyByZXN1bHRzLiBJdCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgYW5kXG4gICAgICogc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21FdmVudFBhdHRlcm5cbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlKGFkZEhhbmRsZXIsIHJlbW92ZUhhbmRsZXIsIHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGFkZEhhbmRsZXIgPSB0aGlzLmFkZEhhbmRsZXI7XG4gICAgICAgIHZhciByZW1vdmVIYW5kbGVyID0gdGhpcy5yZW1vdmVIYW5kbGVyO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHNlbGVjdG9yID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IocmVzdWx0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyBzdWJzY3JpYmVyLm5leHQoZSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGFkZEhhbmRsZXIpKGhhbmRsZXIpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHJlc3VsdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vVE9ETzogZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGZvcndhcmQgdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgcmVtb3ZlSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZSA9IEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL0Zyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbVByb21pc2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZnJvbVByb21pc2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb21Qcm9taXNlID0gZnJvbVByb21pc2VfMS5mcm9tUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21Qcm9taXNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1MDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBHZW5lcmF0ZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvR2VuZXJhdGVPYnNlcnZhYmxlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5nZW5lcmF0ZSA9IEdlbmVyYXRlT2JzZXJ2YWJsZV8xLkdlbmVyYXRlT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL2dlbmVyYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIHNlbGZTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEdlbmVyYXRlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyYXRlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZW5lcmF0ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5pdGVyYXRlID0gaXRlcmF0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgR2VuZXJhdGVPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGVPck9wdGlvbnMsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGVPck9wdGlvbnMuaW5pdGlhbFN0YXRlLCBpbml0aWFsU3RhdGVPck9wdGlvbnMuY29uZGl0aW9uLCBpbml0aWFsU3RhdGVPck9wdGlvbnMuaXRlcmF0ZSwgaW5pdGlhbFN0YXRlT3JPcHRpb25zLnJlc3VsdFNlbGVjdG9yIHx8IHNlbGZTZWxlY3RvciwgaW5pdGlhbFN0YXRlT3JPcHRpb25zLnNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlID09PSB1bmRlZmluZWQgfHwgaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihyZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZU9yT3B0aW9ucywgY29uZGl0aW9uLCBpdGVyYXRlLCBzZWxmU2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGVPck9wdGlvbnMsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBHZW5lcmF0ZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoR2VuZXJhdGVPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcjogc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgICBpdGVyYXRlOiB0aGlzLml0ZXJhdGUsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiB0aGlzLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3RvcjogdGhpcy5yZXN1bHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29uZGl0aW9uID0gX2EuY29uZGl0aW9uLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBpdGVyYXRlID0gX2EuaXRlcmF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25SZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gY29uZGl0aW9uKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25kaXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0U2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBpdGVyYXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICB9O1xuICAgIEdlbmVyYXRlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIGNvbmRpdGlvbiA9IHN0YXRlLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUubmVlZEl0ZXJhdGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5pdGVyYXRlKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUubmVlZEl0ZXJhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25SZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGNvbmRpdGlvbihzdGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29uZGl0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gc3RhdGUucmVzdWx0U2VsZWN0b3Ioc3RhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEdlbmVyYXRlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuR2VuZXJhdGVPYnNlcnZhYmxlID0gR2VuZXJhdGVPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJhdGVPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9HZW5lcmF0ZU9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpbnRlcnZhbF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9pbnRlcnZhbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuaW50ZXJ2YWwgPSBpbnRlcnZhbF8xLmludGVydmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJ2YWwuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9pbnRlcnZhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDUwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgSW50ZXJ2YWxPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0ludGVydmFsT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5pbnRlcnZhbCA9IEludGVydmFsT2JzZXJ2YWJsZV8xLkludGVydmFsT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnZhbC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvaW50ZXJ2YWwuanNcbiAqKiBtb2R1bGUgaWQgPSA1MDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEludGVydmFsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludGVydmFsT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnRlcnZhbE9ic2VydmFibGUocGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKHBlcmlvZCA9PT0gdm9pZCAwKSB7IHBlcmlvZCA9IDA7IH1cbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGVyaW9kID0gcGVyaW9kO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFpc051bWVyaWNfMS5pc051bWVyaWMocGVyaW9kKSB8fCBwZXJpb2QgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgfHwgdHlwZW9mIHNjaGVkdWxlci5zY2hlZHVsZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHNlcXVlbnRpYWwgbnVtYmVycyBldmVyeSBzcGVjaWZpZWRcbiAgICAgKiBpbnRlcnZhbCBvZiB0aW1lLCBvbiBhIHNwZWNpZmllZCBTY2hlZHVsZXIuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgaW5jcmVtZW50YWwgbnVtYmVycyBwZXJpb2RpY2FsbHkgaW4gdGltZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2ludGVydmFsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGludGVydmFsYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZlxuICAgICAqIGFzY2VuZGluZyBpbnRlZ2Vycywgd2l0aCBhIGNvbnN0YW50IGludGVydmFsIG9mIHRpbWUgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaXMgbm90IHNlbnQgaW1tZWRpYXRlbHksIGJ1dFxuICAgICAqIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IHBlcmlvZCBoYXMgcGFzc2VkLiBCeSBkZWZhdWx0LCB0aGlzIG9wZXJhdG9yIHVzZXMgdGhlXG4gICAgICogYGFzeW5jYCBTY2hlZHVsZXIgdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91IG1heSBwYXNzIGFueVxuICAgICAqIFNjaGVkdWxlciB0byBpdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiBudW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHRpbWVyfVxuICAgICAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2Q9MF0gVGhlIGludGVydmFsIHNpemUgaW4gbWlsbGlzZWNvbmRzIChieSBkZWZhdWx0KVxuICAgICAqIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBieSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2suXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzZXF1ZW50aWFsIG51bWJlciBlYWNoIHRpbWVcbiAgICAgKiBpbnRlcnZhbC5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBpbnRlcnZhbFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgSW50ZXJ2YWxPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAocGVyaW9kID09PSB2b2lkIDApIHsgcGVyaW9kID0gMDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsT2JzZXJ2YWJsZShwZXJpb2QsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBJbnRlcnZhbE9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBwZXJpb2QgPSBzdGF0ZS5wZXJpb2Q7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggKz0gMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIEludGVydmFsT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBwZXJpb2QgPSB0aGlzLnBlcmlvZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoSW50ZXJ2YWxPYnNlcnZhYmxlLmRpc3BhdGNoLCBwZXJpb2QsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgcGVyaW9kOiBwZXJpb2RcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVydmFsT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuSW50ZXJ2YWxPYnNlcnZhYmxlID0gSW50ZXJ2YWxPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJ2YWxPYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9JbnRlcnZhbE9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xuZnVuY3Rpb24gaXNOdW1lcmljKHZhbCkge1xuICAgIC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcbiAgICAvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG4gICAgLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gICAgLy8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG4gICAgcmV0dXJuICFpc0FycmF5XzEuaXNBcnJheSh2YWwpICYmICh2YWwgLSBwYXJzZUZsb2F0KHZhbCkgKyAxKSA+PSAwO1xufVxuZXhwb3J0cy5pc051bWVyaWMgPSBpc051bWVyaWM7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc051bWVyaWMuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy91dGlsL2lzTnVtZXJpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDUwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJhY2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JhY2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnJhY2UgPSByYWNlXzEucmFjZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9yYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIGZpcnN0IHNvdXJjZSBPYnNlcnZhYmxlIHRvIGVtaXQgYW4gaXRlbVxuICogZnJvbSB0aGUgY29tYmluYXRpb24gb2YgdGhpcyBPYnNlcnZhYmxlIGFuZCBzdXBwbGllZCBPYnNlcnZhYmxlc1xuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlc30gLi4ub2JzZXJ2YWJsZXMgc291cmNlcyB1c2VkIHRvIHJhY2UgZm9yIHdoaWNoIE9ic2VydmFibGUgZW1pdHMgZmlyc3QuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgb3V0cHV0IG9mIHRoZSBmaXJzdCBPYnNlcnZhYmxlIHRvIGVtaXQgYW4gaXRlbS5cbiAqIEBtZXRob2QgcmFjZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmFjZSgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gYXJyYXksIGl0IHdhcyBtb3N0IGxpa2VseSBjYWxsZWQgd2l0aFxuICAgIC8vIGBwYWlyKFtvYnMxLCBvYnMyLCAuLi5dKWBcbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXlfMS5pc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICBvYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICBvYnNlcnZhYmxlcy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiByYWNlU3RhdGljLmFwcGx5KHRoaXMsIG9ic2VydmFibGVzKTtcbn1cbmV4cG9ydHMucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb25seSBhcmd1bWVudCBpcyBhbiBhcnJheSwgaXQgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB3aXRoXG4gICAgLy8gYHBhaXIoW29iczEsIG9iczIsIC4uLl0pYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgUmFjZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5yYWNlU3RhdGljID0gcmFjZVN0YXRpYztcbnZhciBSYWNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhY2VPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgUmFjZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFJhY2VTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBSYWNlT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5SYWNlT3BlcmF0b3IgPSBSYWNlT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJhY2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFjZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFjZVN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmhhc0ZpcnN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIFJhY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMucHVzaChvYnNlcnZhYmxlKTtcbiAgICB9O1xuICAgIFJhY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlcyA9IHRoaXMub2JzZXJ2YWJsZXM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG9ic2VydmFibGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IG91dGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFjZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5SYWNlU3Vic2NyaWJlciA9IFJhY2VTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3JhY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1MTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBuZXZlcl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9uZXZlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUubmV2ZXIgPSBuZXZlcl8xLm5ldmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV2ZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9uZXZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTmV2ZXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL05ldmVyT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5uZXZlciA9IE5ldmVyT2JzZXJ2YWJsZV8xLk5ldmVyT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXZlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvbmV2ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1MTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIG5vb3BfMSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9vcCcpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBOZXZlck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXZlck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV2ZXJPYnNlcnZhYmxlKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkFuIE9ic2VydmFibGUgdGhhdCBuZXZlciBlbWl0cyBhbnl0aGluZy48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL25ldmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAgICAgKiBuZWl0aGVyIHZhbHVlcyBub3IgZXJyb3JzIG5vciB0aGUgY29tcGxldGlvbiBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkXG4gICAgICogZm9yIHRlc3RpbmcgcHVycG9zZXMgb3IgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyIE9ic2VydmFibGVzLiBQbGVhc2Ugbm90XG4gICAgICogdGhhdCBieSBuZXZlciBlbWl0dGluZyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhpcyBPYnNlcnZhYmxlIGtlZXBzIHRoZVxuICAgICAqIHN1YnNjcmlwdGlvbiBmcm9tIGJlaW5nIGRpc3Bvc2VkIGF1dG9tYXRpY2FsbHkuIFN1YnNjcmlwdGlvbnMgbmVlZCB0byBiZVxuICAgICAqIG1hbnVhbGx5IGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gbmV2ZXIgZW1pdCBhbnl0aGluZyBlbHNlIChub3QgZXZlbiBjb21wbGV0ZSkuPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnV2lsbCBub3QgYmUgY2FsbGVkJyk7XG4gICAgICogfVxuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLm5ldmVyKCkuc3RhcnRXaXRoKDcpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgaW5mbywgaW5mbyk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBIFwibmV2ZXJcIiBPYnNlcnZhYmxlOiBuZXZlciBlbWl0cyBhbnl0aGluZy5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBuZXZlclxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgTmV2ZXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXZlck9ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIE5ldmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIG5vb3BfMS5ub29wKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV2ZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5OZXZlck9ic2VydmFibGUgPSBOZXZlck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXZlck9ic2VydmFibGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL05ldmVyT2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1lbXB0eSAqL1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZXhwb3J0cy5ub29wID0gbm9vcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vb3AuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy91dGlsL25vb3AuanNcbiAqKiBtb2R1bGUgaWQgPSA1MTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByYW5nZV8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9yYW5nZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucmFuZ2UgPSByYW5nZV8xLnJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb2JzZXJ2YWJsZS9yYW5nZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1JhbmdlT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5yYW5nZSA9IFJhbmdlT2JzZXJ2YWJsZV8xLlJhbmdlT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvcmFuZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1MjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBSYW5nZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYW5nZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNlcXVlbmNlIG9mIG51bWJlcnMgd2l0aGluIGEgc3BlY2lmaWVkXG4gICAgICogcmFuZ2UuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgYSBzZXF1ZW5jZSBvZiBudW1iZXJzIGluIGEgcmFuZ2UuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9yYW5nZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIGByYW5nZWAgb3BlcmF0b3IgZW1pdHMgYSByYW5nZSBvZiBzZXF1ZW50aWFsIGludGVnZXJzLCBpbiBvcmRlciwgd2hlcmUgeW91XG4gICAgICogc2VsZWN0IHRoZSBgc3RhcnRgIG9mIHRoZSByYW5nZSBhbmQgaXRzIGBsZW5ndGhgLiBCeSBkZWZhdWx0LCB1c2VzIG5vXG4gICAgICogU2NoZWR1bGVyIGFuZCBqdXN0IGRlbGl2ZXJzIHRoZSBub3RpZmljYXRpb25zIHN5bmNocm9ub3VzbHksIGJ1dCBtYXkgdXNlXG4gICAgICogYW4gb3B0aW9uYWwgU2NoZWR1bGVyIHRvIHJlZ3VsYXRlIHRob3NlIGRlbGl2ZXJpZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyB0aGUgbnVtYmVycyAxIHRvIDEwPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayB0aW1lcn1cbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnRlZ2VyIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50PTBdIFRoZSBudW1iZXIgb2Ygc2VxdWVudGlhbCBpbnRlZ2VycyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb25zIG9mIHRoZSBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgbnVtYmVycyB0aGF0IGVtaXRzIGEgZmluaXRlIHJhbmdlIG9mXG4gICAgICogc2VxdWVudGlhbCBpbnRlZ2Vycy5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSByYW5nZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgUmFuZ2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdGFydCwgY291bnQsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFJhbmdlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGF0ZS5zdGFydCwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChzdGFydCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHN0YXRlLnN0YXJ0ID0gc3RhcnQgKyAxO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIFJhbmdlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuX2NvdW50O1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoUmFuZ2VPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LCBjb3VudDogY291bnQsIHN0YXJ0OiBzdGFydCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4KysgPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHN0YXJ0KyspO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2VPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5SYW5nZU9ic2VydmFibGUgPSBSYW5nZU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SYW5nZU9ic2VydmFibGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL1JhbmdlT2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3RpbWVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aW1lciA9IHRpbWVyXzEudGltZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vYnNlcnZhYmxlL3RpbWVyLmpzXG4gKiogbW9kdWxlIGlkID0gNTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBUaW1lck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vVGltZXJPYnNlcnZhYmxlJyk7XG5leHBvcnRzLnRpbWVyID0gVGltZXJPYnNlcnZhYmxlXzEuVGltZXJPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS90aW1lci5qc1xuICoqIG1vZHVsZSBpZCA9IDUyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgU2NoZWR1bGVyIHRvIHByb3ZpZGUgYSBub3Rpb24gb2YgdGltZSwgYnV0IHlvdVxuICAgICAqIG1heSBwYXNzIGFueSBTY2hlZHVsZXIgdG8gaXQuIElmIGBwZXJpb2RgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpLCBzdGFydGluZyBhZnRlciAzIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDMwMDAsIDEwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgb25lIG51bWJlciBhZnRlciBmaXZlIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDUwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaW50ZXJ2YWx9XG4gICAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRlfSBpbml0aWFsRGVsYXkgVGhlIGluaXRpYWwgZGVsYXkgdGltZSB0byB3YWl0IGJlZm9yZVxuICAgICAqIGVtaXR0aW5nIHRoZSBmaXJzdCB2YWx1ZSBvZiBgMGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2RdIFRoZSBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVtaXNzaW9ucyBvZiB0aGVcbiAgICAgKiBzdWJzZXF1ZW50IG51bWJlcnMuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGVyaW9kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBwZXJpb2QpO1xuICAgIH07XG4gICAgVGltZXJPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcGVyaW9kID0gX2EucGVyaW9kLCBkdWVUaW1lID0gX2EuZHVlVGltZSwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgZHVlVGltZSwge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LCBwZXJpb2Q6IHBlcmlvZCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlRpbWVyT2JzZXJ2YWJsZSA9IFRpbWVyT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVyT2JzZXJ2YWJsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29ic2VydmFibGUvVGltZXJPYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3ppcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuemlwID0gemlwXzEuemlwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29ic2VydmFibGUvemlwLmpzXG4gKiogbW9kdWxlIGlkID0gNTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL3ppcCcpO1xuZXhwb3J0cy56aXAgPSB6aXBfMS56aXBTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXAuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vYnNlcnZhYmxlL3ppcC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBQcm90bygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgb2JzZXJ2YWJsZXMudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gemlwU3RhdGljLmFwcGx5KHRoaXMsIG9ic2VydmFibGVzKTtcbn1cbmV4cG9ydHMuemlwUHJvdG8gPSB6aXBQcm90bztcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgWmlwT3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy56aXBTdGF0aWMgPSB6aXBTdGF0aWM7XG52YXIgWmlwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFppcE9wZXJhdG9yKHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgWmlwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLml0ZXJhdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvamVjdCA9ICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9qZWN0IDogbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljSXRlcmF0b3IodmFsdWVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgWmlwQnVmZmVySXRlcmF0b3IodGhpcy5kZXN0aW5hdGlvbiwgdGhpcywgdmFsdWUsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBsZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5zdGlsbFVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZXJhdG9yLnN1YnNjcmliZShpdGVyYXRvciwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUtLTsgLy8gbm90IGFuIG9ic2VydmFibGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5SW5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5jaGVja0l0ZXJhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgLy8gYWJvcnQgaWYgbm90IGFsbCBvZiB0aGVtIGhhdmUgdmFsdWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3IuaGFzVmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWl0ZXJhdG9yLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaXQncyBjb21wbGV0ZWQgbm93IHRoYXQgeW91J3ZlIGdvdHRlblxuICAgICAgICAgICAgLy8gdGhlIG5leHQgdmFsdWUuXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IuaGFzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByb2plY3QoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByb2plY3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5aaXBTdWJzY3JpYmVyID0gWmlwU3Vic2NyaWJlcjtcbnZhciBTdGF0aWNJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljSXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0ID0gdGhpcy5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICAgICAgcmV0dXJuIG5leHRSZXN1bHQgJiYgbmV4dFJlc3VsdC5kb25lO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0l0ZXJhdG9yO1xufSgpKTtcbnZhciBTdGF0aWNBcnJheUl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNBcnJheUl0ZXJhdG9yKGFycmF5KSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyBkb25lOiB0cnVlIH07XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID4gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID09PSB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FycmF5SXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBaaXBCdWZmZXJJdGVyYXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcEJ1ZmZlckl0ZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcEJ1ZmZlckl0ZXJhdG9yKGRlc3RpbmF0aW9uLCBwYXJlbnQsIG9ic2VydmFibGUsIGluZGV4KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGlsbFVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBOT1RFOiB0aGVyZSBpcyBhY3R1YWxseSBhIG5hbWUgY29sbGlzaW9uIGhlcmUgd2l0aCBTdWJzY3JpYmVyLm5leHQgYW5kIEl0ZXJhdG9yLm5leHRcbiAgICAvLyAgICB0aGlzIGlzIGxlZ2l0IGJlY2F1c2UgYG5leHQoKWAgd2lsbCBuZXZlciBiZSBjYWxsZWQgYnkgYSBzdWJzY3JpcHRpb24gaW4gdGhpcyBjYXNlLlxuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3ppcC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYnVmZmVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyID0gYnVmZmVyXzEuYnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyB1bnRpbCBgY2xvc2luZ05vdGlmaWVyYCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhhdCBhcnJheSBvbmx5IHdoZW4gYW5vdGhlciBPYnNlcnZhYmxlIGVtaXRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBCdWZmZXJzIHRoZSBpbmNvbWluZyBPYnNlcnZhYmxlIHZhbHVlcyB1bnRpbCB0aGUgZ2l2ZW4gYGNsb3NpbmdOb3RpZmllcmBcbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgYXQgd2hpY2ggcG9pbnQgaXQgZW1pdHMgdGhlIGJ1ZmZlciBvbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIGFuZCBzdGFydHMgYSBuZXcgYnVmZmVyIGludGVybmFsbHksIGF3YWl0aW5nIHRoZSBuZXh0IHRpbWVcbiAqIGBjbG9zaW5nTm90aWZpZXJgIGVtaXRzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk9uIGV2ZXJ5IGNsaWNrLCBlbWl0IGFycmF5IG9mIG1vc3QgcmVjZW50IGludGVydmFsIGV2ZW50czwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGJ1ZmZlcmVkID0gaW50ZXJ2YWwuYnVmZmVyKGNsaWNrcyk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8YW55Pn0gY2xvc2luZ05vdGlmaWVyIEFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIHRoZVxuICogYnVmZmVyIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBPYnNlcnZhYmxlIG9mIGJ1ZmZlcnMsIHdoaWNoIGFyZSBhcnJheXMgb2ZcbiAqIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXIoY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQnVmZmVyT3BlcmF0b3IoY2xvc2luZ05vdGlmaWVyKSk7XG59XG5leHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlcjtcbnZhciBCdWZmZXJPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyT3BlcmF0b3IoY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgICAgIHRoaXMuY2xvc2luZ05vdGlmaWVyID0gY2xvc2luZ05vdGlmaWVyO1xuICAgIH1cbiAgICBCdWZmZXJPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBCdWZmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllcikpO1xuICAgIH1cbiAgICBCdWZmZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIEJ1ZmZlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJ1ZmZlckNvdW50XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9idWZmZXJDb3VudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlckNvdW50ID0gYnVmZmVyQ291bnRfMS5idWZmZXJDb3VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlckNvdW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlckNvdW50LmpzXG4gKiogbW9kdWxlIGlkID0gNTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIHRoZSBzaXplIGhpdHMgdGhlIG1heGltdW1cbiAqIGBidWZmZXJTaXplYCBnaXZlbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhhdCBhcnJheSBvbmx5IHdoZW4gaXRzIHNpemUgcmVhY2hlcyBgYnVmZmVyU2l6ZWAuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyQ291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyBhIG51bWJlciBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYGJ1ZmZlclNpemVgIHRoZW5cbiAqIGVtaXRzIHRoZSBidWZmZXIgYW5kIGNsZWFycyBpdCwgYW5kIHN0YXJ0cyBhIG5ldyBidWZmZXIgZWFjaFxuICogYHN0YXJ0QnVmZmVyRXZlcnlgIHZhbHVlcy4gSWYgYHN0YXJ0QnVmZmVyRXZlcnlgIGlzIG5vdCBwcm92aWRlZCBvciBpc1xuICogYG51bGxgLCB0aGVuIG5ldyBidWZmZXJzIGFyZSBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlXG4gKiBhbmQgd2hlbiBlYWNoIGJ1ZmZlciBjbG9zZXMgYW5kIGlzIGVtaXR0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgZW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyLCAxKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHBhaXJ3aXNlfVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclNpemUgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgYnVmZmVyIGVtaXR0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0QnVmZmVyRXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IGJ1ZmZlci5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydEJ1ZmZlckV2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgYnVmZmVyIHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyBidWZmZXIgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIE9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyQ291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlckNvdW50KGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpIHtcbiAgICBpZiAoc3RhcnRCdWZmZXJFdmVyeSA9PT0gdm9pZCAwKSB7IHN0YXJ0QnVmZmVyRXZlcnkgPSBudWxsOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQnVmZmVyQ291bnRPcGVyYXRvcihidWZmZXJTaXplLCBzdGFydEJ1ZmZlckV2ZXJ5KSk7XG59XG5leHBvcnRzLmJ1ZmZlckNvdW50ID0gYnVmZmVyQ291bnQ7XG52YXIgQnVmZmVyQ291bnRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyQ291bnRPcGVyYXRvcihidWZmZXJTaXplLCBzdGFydEJ1ZmZlckV2ZXJ5KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJFdmVyeSA9IHN0YXJ0QnVmZmVyRXZlcnk7XG4gICAgfVxuICAgIEJ1ZmZlckNvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgQnVmZmVyQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5zdGFydEJ1ZmZlckV2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyQ291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlckNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlckNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbW11dO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgQnVmZmVyQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY291bnQgPSAodGhpcy5jb3VudCArPSAxKTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIGJ1ZmZlclNpemUgPSB0aGlzLmJ1ZmZlclNpemU7XG4gICAgICAgIHZhciBzdGFydEJ1ZmZlckV2ZXJ5ID0gKHRoaXMuc3RhcnRCdWZmZXJFdmVyeSA9PSBudWxsKSA/IGJ1ZmZlclNpemUgOiB0aGlzLnN0YXJ0QnVmZmVyRXZlcnk7XG4gICAgICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuICAgICAgICB2YXIgbGVuID0gYnVmZmVycy5sZW5ndGg7XG4gICAgICAgIHZhciByZW1vdmUgPSAtMTtcbiAgICAgICAgaWYgKGNvdW50ICUgc3RhcnRCdWZmZXJFdmVyeSA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSBidWZmZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlID0gaTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKHJlbW92ZSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgYnVmZmVycyA9IHRoaXMuYnVmZmVycztcbiAgICAgICAgd2hpbGUgKGJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlckNvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlckNvdW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyQ291bnQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBidWZmZXJUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9idWZmZXJUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyVGltZSA9IGJ1ZmZlclRpbWVfMS5idWZmZXJUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyB0aW1lIHBlcmlvZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhvc2UgYXJyYXlzIHBlcmlvZGljYWxseSBpbiB0aW1lLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlclRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIGZvciBhIHNwZWNpZmljIHRpbWUgZHVyYXRpb24gYGJ1ZmZlclRpbWVTcGFuYC5cbiAqIFVubGVzcyB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIGlzIGdpdmVuLCBpdCBlbWl0cyBhbmRcbiAqIHJlc2V0cyB0aGUgYnVmZmVyIGV2ZXJ5IGBidWZmZXJUaW1lU3BhbmAgbWlsbGlzZWNvbmRzLiBJZlxuICogYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIGlzIGdpdmVuLCB0aGlzIG9wZXJhdG9yIG9wZW5zIHRoZSBidWZmZXIgZXZlcnlcbiAqIGBidWZmZXJDcmVhdGlvbkludGVydmFsYCBtaWxsaXNlY29uZHMgYW5kIGNsb3NlcyAoZW1pdHMgYW5kIHJlc2V0cykgdGhlXG4gKiBidWZmZXIgZXZlcnkgYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgc2Vjb25kLCBlbWl0IGFuIGFycmF5IG9mIHRoZSByZWNlbnQgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJUaW1lKDEwMDApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IDUgc2Vjb25kcywgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgMiBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJUaW1lKDIwMDAsIDUwMDApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclRpbWVTcGFuIFRoZSBhbW91bnQgb2YgdGltZSB0byBmaWxsIGVhY2ggYnVmZmVyIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJDcmVhdGlvbkludGVydmFsXSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gc3RhcnQgbmV3XG4gKiBidWZmZXJzLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gKiBpbnRlcnZhbHMgdGhhdCBkZXRlcm1pbmUgYnVmZmVyIGJvdW5kYXJpZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVGltZShidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPT09IHZvaWQgMCkgeyBidWZmZXJDcmVhdGlvbkludGVydmFsID0gbnVsbDsgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQnVmZmVyVGltZU9wZXJhdG9yKGJ1ZmZlclRpbWVTcGFuLCBidWZmZXJDcmVhdGlvbkludGVydmFsLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuYnVmZmVyVGltZSA9IGJ1ZmZlclRpbWU7XG52YXIgQnVmZmVyVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJUaW1lT3BlcmF0b3IoYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlclRpbWVTcGFuID0gYnVmZmVyVGltZVNwYW47XG4gICAgICAgIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBCdWZmZXJUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgQnVmZmVyVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5idWZmZXJUaW1lU3BhbiwgdGhpcy5idWZmZXJDcmVhdGlvbkludGVydmFsLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlclRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGJ1ZmZlclRpbWVTcGFuLCBidWZmZXJDcmVhdGlvbkludGVydmFsLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlclRpbWVTcGFuID0gYnVmZmVyVGltZVNwYW47XG4gICAgICAgIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgICAgICBpZiAoYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCAhPT0gbnVsbCAmJiBidWZmZXJDcmVhdGlvbkludGVydmFsID49IDApIHtcbiAgICAgICAgICAgIHZhciBjbG9zZVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBidWZmZXI6IGJ1ZmZlciB9O1xuICAgICAgICAgICAgdmFyIGNyZWF0aW9uU3RhdGUgPSB7IGJ1ZmZlclRpbWVTcGFuOiBidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDogYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgc3Vic2NyaWJlcjogdGhpcywgc2NoZWR1bGVyOiBzY2hlZHVsZXIgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlckNsb3NlLCBidWZmZXJUaW1lU3BhbiwgY2xvc2VTdGF0ZSkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyQ3JlYXRpb24sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIGNyZWF0aW9uU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aW1lU3Bhbk9ubHlTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgYnVmZmVyOiBidWZmZXIsIGJ1ZmZlclRpbWVTcGFuOiBidWZmZXJUaW1lU3BhbiB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyVGltZVNwYW5Pbmx5LCBidWZmZXJUaW1lU3BhbiwgdGltZVNwYW5Pbmx5U3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyc1tpXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlcnMgPSBfYS5idWZmZXJzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcnMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbkJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGJ1ZmZlcnMuaW5kZXhPZihidWZmZXIpLCAxKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoQnVmZmVyVGltZVNwYW5Pbmx5KHN0YXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgIHZhciBwcmV2QnVmZmVyID0gc3RhdGUuYnVmZmVyO1xuICAgIGlmIChwcmV2QnVmZmVyKSB7XG4gICAgICAgIHN1YnNjcmliZXIuY2xvc2VCdWZmZXIocHJldkJ1ZmZlcik7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlciA9IHN1YnNjcmliZXIub3BlbkJ1ZmZlcigpO1xuICAgIGlmICghc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlLCBzdGF0ZS5idWZmZXJUaW1lU3Bhbik7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hCdWZmZXJDcmVhdGlvbihzdGF0ZSkge1xuICAgIHZhciBidWZmZXJDcmVhdGlvbkludGVydmFsID0gc3RhdGUuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgYnVmZmVyVGltZVNwYW4gPSBzdGF0ZS5idWZmZXJUaW1lU3Bhbiwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlcjtcbiAgICB2YXIgYnVmZmVyID0gc3Vic2NyaWJlci5vcGVuQnVmZmVyKCk7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgaWYgKCFzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgIGFjdGlvbi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyQ2xvc2UsIGJ1ZmZlclRpbWVTcGFuLCB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIsIGJ1ZmZlcjogYnVmZmVyIH0pKTtcbiAgICAgICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBidWZmZXJDcmVhdGlvbkludGVydmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNsb3NlKGFyZykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIGJ1ZmZlciA9IGFyZy5idWZmZXI7XG4gICAgc3Vic2NyaWJlci5jbG9zZUJ1ZmZlcihidWZmZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2J1ZmZlclRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBidWZmZXJUb2dnbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlclRvZ2dsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlclRvZ2dsZSA9IGJ1ZmZlclRvZ2dsZV8xLmJ1ZmZlclRvZ2dsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRvZ2dsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJUb2dnbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBzdGFydGluZyBmcm9tIGFuIGVtaXNzaW9uIGZyb21cbiAqIGBvcGVuaW5nc2AgYW5kIGVuZGluZyB3aGVuIHRoZSBvdXRwdXQgb2YgYGNsb3NpbmdTZWxlY3RvcmAgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LiBTdGFydHNcbiAqIGNvbGxlY3Rpbmcgb25seSB3aGVuIGBvcGVuaW5nYCBlbWl0cywgYW5kIGNhbGxzIHRoZSBgY2xvc2luZ1NlbGVjdG9yYFxuICogZnVuY3Rpb24gdG8gZ2V0IGFuIE9ic2VydmFibGUgdGhhdCB0ZWxscyB3aGVuIHRvIGNsb3NlIHRoZSBidWZmZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBieSBvcGVuaW5nIHRoZSBidWZmZXIgdmlhIHNpZ25hbHMgZnJvbSBhblxuICogT2JzZXJ2YWJsZSBwcm92aWRlZCB0byBgb3BlbmluZ3NgLCBhbmQgY2xvc2luZyBhbmQgc2VuZGluZyB0aGUgYnVmZmVycyB3aGVuXG4gKiBhIFN1YnNjcmliYWJsZSBvciBQcm9taXNlIHJldHVybmVkIGJ5IHRoZSBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBvdGhlciBzZWNvbmQsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDUwMG1zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBvcGVuaW5ncyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyVG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtTdWJzY3JpYmFibGVPclByb21pc2U8Tz59IG9wZW5pbmdzIEEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2Ugb2Ygbm90aWZpY2F0aW9ucyB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gKiB0aGUgdmFsdWUgZW1pdHRlZCBieSB0aGUgYG9wZW5pbmdzYCBvYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2UsXG4gKiB3aGljaCwgd2hlbiBpdCBlbWl0cywgc2lnbmFscyB0aGF0IHRoZSBhc3NvY2lhdGVkIGJ1ZmZlciBzaG91bGQgYmUgZW1pdHRlZFxuICogYW5kIGNsZWFyZWQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlclRvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuYnVmZmVyVG9nZ2xlID0gYnVmZmVyVG9nZ2xlO1xudmFyIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vcGVuaW5ncywgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJUb2dnbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9wZW5pbmdzID0gb3BlbmluZ3M7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb3BlbmluZ3MpKTtcbiAgICB9XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29udGV4dHNbaV0uYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHdoaWxlIChjb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHdoaWxlIChjb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoY29udGV4dC5idWZmZXIpO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgb3V0ZXJWYWx1ZSA/IHRoaXMuY2xvc2VCdWZmZXIob3V0ZXJWYWx1ZSkgOiB0aGlzLm9wZW5CdWZmZXIoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKGlubmVyU3ViLmNvbnRleHQpO1xuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbkJ1ZmZlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdTZWxlY3RvciA9IHRoaXMuY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IGNsb3NpbmdTZWxlY3Rvci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN1YnNjcmliZShjbG9zaW5nTm90aWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlQnVmZmVyID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgaWYgKGNvbnRleHRzICYmIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBjb250ZXh0LmJ1ZmZlciwgc3Vic2NyaXB0aW9uID0gY29udGV4dC5zdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnRleHRzLnNwbGljZShjb250ZXh0cy5pbmRleE9mKGNvbnRleHQpLCAxKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgYnVmZmVyID0gW107XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0geyBidWZmZXI6IGJ1ZmZlciwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gfTtcbiAgICAgICAgY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVG9nZ2xlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlLmpzXG4gKiogbW9kdWxlIGlkID0gNTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYnVmZmVyV2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYnVmZmVyV2hlbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlcldoZW4gPSBidWZmZXJXaGVuXzEuYnVmZmVyV2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlcldoZW4uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyV2hlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDU0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcywgdXNpbmcgYSBmYWN0b3J5IGZ1bmN0aW9uIG9mIGNsb3NpbmdcbiAqIE9ic2VydmFibGVzIHRvIGRldGVybWluZSB3aGVuIHRvIGNsb3NlLCBlbWl0LCBhbmQgcmVzZXQgdGhlIGJ1ZmZlci5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXkuIFdoZW4gaXRcbiAqIHN0YXJ0cyBjb2xsZWN0aW5nIHZhbHVlcywgaXQgY2FsbHMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0XG4gKiB0ZWxscyB3aGVuIHRvIGNsb3NlIHRoZSBidWZmZXIgYW5kIHJlc3RhcnQgY29sbGVjdGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9idWZmZXJXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE9wZW5zIGEgYnVmZmVyIGltbWVkaWF0ZWx5LCB0aGVuIGNsb3NlcyB0aGUgYnVmZmVyIHdoZW4gdGhlIG9ic2VydmFibGVcbiAqIHJldHVybmVkIGJ5IGNhbGxpbmcgYGNsb3NpbmdTZWxlY3RvcmAgZnVuY3Rpb24gZW1pdHMgYSB2YWx1ZS4gV2hlbiBpdCBjbG9zZXNcbiAqIHRoZSBidWZmZXIsIGl0IGltbWVkaWF0ZWx5IG9wZW5zIGEgbmV3IGJ1ZmZlciBhbmQgcmVwZWF0cyB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGFuIGFycmF5IG9mIHRoZSBsYXN0IGNsaWNrcyBldmVyeSBbMS01XSByYW5kb20gc2Vjb25kczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyV2hlbigoKSA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDAgKyBNYXRoLnJhbmRvbSgpICogNDAwMClcbiAqICk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2lnbmFscyBidWZmZXIgY2xvc3VyZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VFtdPn0gQW4gb2JzZXJ2YWJsZSBvZiBhcnJheXMgb2YgYnVmZmVyZWQgdmFsdWVzLlxuICogQG1ldGhvZCBidWZmZXJXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJXaGVuKGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlcldoZW5PcGVyYXRvcihjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuYnVmZmVyV2hlbiA9IGJ1ZmZlcldoZW47XG52YXIgQnVmZmVyV2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJXaGVuT3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgIH1cbiAgICBCdWZmZXJXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgQnVmZmVyV2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJXaGVuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlcldoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlcldoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wZW5CdWZmZXIoKTtcbiAgICB9XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5CdWZmZXIoKTtcbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbkJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb3NpbmdTdWJzY3JpcHRpb24gPSB0aGlzLmNsb3NpbmdTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChjbG9zaW5nU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjbG9zaW5nU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5jbG9zaW5nU2VsZWN0b3IpKCk7XG4gICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NpbmdTdWJzY3JpcHRpb24gPSBjbG9zaW5nU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdGhpcy5hZGQoY2xvc2luZ1N1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24uYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJXaGVuLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvYnVmZmVyV2hlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDU0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNhY2hlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9jYWNoZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNhY2hlID0gY2FjaGVfMS5jYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2NhY2hlLmpzXG4gKiogbW9kdWxlIGlkID0gNTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwdWJsaXNoUmVwbGF5XzEgPSByZXF1aXJlKCcuL3B1Ymxpc2hSZXBsYXknKTtcbi8qKlxuICogQHBhcmFtIGJ1ZmZlclNpemVcbiAqIEBwYXJhbSB3aW5kb3dUaW1lXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPGFueT59XG4gKiBAbWV0aG9kIGNhY2hlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjYWNoZShidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdm9pZCAwKSB7IGJ1ZmZlclNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAod2luZG93VGltZSA9PT0gdm9pZCAwKSB7IHdpbmRvd1RpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICByZXR1cm4gcHVibGlzaFJlcGxheV8xLnB1Ymxpc2hSZXBsYXkuY2FsbCh0aGlzLCBidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpLnJlZkNvdW50KCk7XG59XG5leHBvcnRzLmNhY2hlID0gY2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2NhY2hlLmpzXG4gKiogbW9kdWxlIGlkID0gNTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBSZXBsYXlTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9SZXBsYXlTdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyoqXG4gKiBAcGFyYW0gYnVmZmVyU2l6ZVxuICogQHBhcmFtIHdpbmRvd1RpbWVcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaFJlcGxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlcGxheShidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdm9pZCAwKSB7IGJ1ZmZlclNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAod2luZG93VGltZSA9PT0gdm9pZCAwKSB7IHdpbmRvd1RpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgbmV3IFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5wdWJsaXNoUmVwbGF5ID0gcHVibGlzaFJlcGxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hSZXBsYXkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9wdWJsaXNoUmVwbGF5LmpzXG4gKiogbW9kdWxlIGlkID0gNTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4vU3ViamVjdCcpO1xudmFyIHF1ZXVlXzEgPSByZXF1aXJlKCcuL3NjaGVkdWxlci9xdWV1ZScpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvci9vYnNlcnZlT24nKTtcbi8qKlxuICogQGNsYXNzIFJlcGxheVN1YmplY3Q8VD5cbiAqL1xudmFyIFJlcGxheVN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBsYXlTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChidWZmZXJTaXplID09PSB2b2lkIDApIHsgYnVmZmVyU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBpZiAod2luZG93VGltZSA9PT0gdm9pZCAwKSB7IHdpbmRvd1RpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplIDwgMSA/IDEgOiBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLl93aW5kb3dUaW1lID0gd2luZG93VGltZSA8IDEgPyAxIDogd2luZG93VGltZTtcbiAgICB9XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuX2dldE5vdygpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKG5ldyBSZXBsYXlFdmVudChub3csIHZhbHVlKSk7XG4gICAgICAgIHRoaXMuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzKG5vdyk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzKHRoaXMuX2dldE5vdygpKTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzdWJzY3JpYmVyID0gbmV3IG9ic2VydmVPbl8xLk9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgc2NoZWR1bGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBsZW4gPSBldmVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbiAmJiAhc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGV2ZW50c1tpbmRleF0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9zdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLl9nZXROb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zY2hlZHVsZXIgfHwgcXVldWVfMS5xdWV1ZSkubm93KCk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMgPSBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgIHZhciBidWZmZXJTaXplID0gdGhpcy5idWZmZXJTaXplO1xuICAgICAgICB2YXIgX3dpbmRvd1RpbWUgPSB0aGlzLl93aW5kb3dUaW1lO1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICAgIHZhciBldmVudHNDb3VudCA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBzcGxpY2VDb3VudCA9IDA7XG4gICAgICAgIC8vIFRyaW0gZXZlbnRzIHRoYXQgZmFsbCBvdXQgb2YgdGhlIHRpbWUgd2luZG93LlxuICAgICAgICAvLyBTdGFydCBhdCB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIEJyZWFrIGVhcmx5IG9uY2VcbiAgICAgICAgLy8gd2UgZW5jb3VudGVyIGFuIGV2ZW50IHRoYXQgZmFsbHMgd2l0aGluIHRoZSB3aW5kb3cuXG4gICAgICAgIHdoaWxlIChzcGxpY2VDb3VudCA8IGV2ZW50c0NvdW50KSB7XG4gICAgICAgICAgICBpZiAoKG5vdyAtIGV2ZW50c1tzcGxpY2VDb3VudF0udGltZSkgPCBfd2luZG93VGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BsaWNlQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRzQ291bnQgPiBidWZmZXJTaXplKSB7XG4gICAgICAgICAgICBzcGxpY2VDb3VudCA9IE1hdGgubWF4KHNwbGljZUNvdW50LCBldmVudHNDb3VudCAtIGJ1ZmZlclNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpY2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UoMCwgc3BsaWNlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwbGF5U3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuUmVwbGF5U3ViamVjdCA9IFJlcGxheVN1YmplY3Q7XG52YXIgUmVwbGF5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGxheUV2ZW50KHRpbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlcGxheUV2ZW50O1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheVN1YmplY3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9SZXBsYXlTdWJqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29tYmluZUFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29tYmluZUFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsXzEuY29tYmluZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVBbGwuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvY29tYmluZUFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDU0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi9jb21iaW5lTGF0ZXN0Jyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgYnkgd2FpdGluZ1xuICogZm9yIHRoZSBvdXRlciBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlLCB0aGVuIGFwcGx5aW5nIHtAbGluayBjb21iaW5lTGF0ZXN0fS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBieSBhcHBseWluZ1xuICoge0BsaW5rIGNvbWJpbmVMYXRlc3R9IHdoZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbWJpbmVBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogVGFrZXMgYW4gT2JzZXJ2YWJsZSBvZiBPYnNlcnZhYmxlcywgYW5kIGNvbGxlY3RzIGFsbCBPYnNlcnZhYmxlcyBmcm9tIGl0LlxuICogT25jZSB0aGUgb3V0ZXIgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsIGl0IHN1YnNjcmliZXMgdG8gYWxsIGNvbGxlY3RlZFxuICogT2JzZXJ2YWJsZXMgYW5kIGNvbWJpbmVzIHRoZWlyIHZhbHVlcyB1c2luZyB0aGUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKiBzdHJhdGVneSwgc3VjaCB0aGF0OlxuICogLSBFdmVyeSB0aW1lIGFuIGlubmVyIE9ic2VydmFibGUgZW1pdHMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cy5cbiAqIC0gV2hlbiB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSBlbWl0cywgaXQgZW1pdHMgYWxsIG9mIHRoZSBsYXRlc3QgdmFsdWVzIGJ5OlxuICogICAtIElmIGEgYHByb2plY3RgIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCBpcyBjYWxsZWQgd2l0aCBlYWNoIHJlY2VudCB2YWx1ZVxuICogICAgIGZyb20gZWFjaCBpbm5lciBPYnNlcnZhYmxlIGluIHdoYXRldmVyIG9yZGVyIHRoZXkgYXJyaXZlZCwgYW5kIHRoZSByZXN1bHRcbiAqICAgICBvZiB0aGUgYHByb2plY3RgIGZ1bmN0aW9uIGlzIHdoYXQgaXMgZW1pdHRlZCBieSB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiAgIC0gSWYgdGhlcmUgaXMgbm8gYHByb2plY3RgIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIG1vc3QgcmVjZW50XG4gKiAgICAgdmFsdWVzIGlzIGVtaXR0ZWQgYnkgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCB0d28gY2xpY2sgZXZlbnRzIHRvIGEgZmluaXRlIGludGVydmFsIE9ic2VydmFibGUsIHRoZW4gYXBwbHkgY29tYmluZUFsbDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKGV2ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoTWF0aC5yYW5kb20oKSoyMDAwKS50YWtlKDMpXG4gKiApLnRha2UoMik7XG4gKiB2YXIgcmVzdWx0ID0gaGlnaGVyT3JkZXIuY29tYmluZUFsbCgpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2plY3RdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG1hcCB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5uZXIgT2JzZXJ2YWJsZSBpbnRvIGEgbmV3IHJlc3VsdC4gVGFrZXMgZWFjaCBvZiB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlcyBmcm9tIGVhY2ggY29sbGVjdGVkIGlubmVyIE9ic2VydmFibGUgYXMgYXJndW1lbnRzLCBpbiBvcmRlci5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgcHJvamVjdGVkIHJlc3VsdHMgb3IgYXJyYXlzIG9mIHJlY2VudFxuICogdmFsdWVzLlxuICogQG1ldGhvZCBjb21iaW5lQWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb21iaW5lQWxsKHByb2plY3QpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBjb21iaW5lTGF0ZXN0XzEuQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuY29tYmluZUFsbCA9IGNvbWJpbmVBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lQWxsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvY29tYmluZUFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDU1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdEFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29uY2F0QWxsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0QWxsID0gY29uY2F0QWxsXzEuY29uY2F0QWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0QWxsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdEFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDU1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4vbWVyZ2VBbGwnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieVxuICogY29uY2F0ZW5hdGluZyB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMgaW4gb3JkZXIuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgYnkgcHV0dGluZyBvbmVcbiAqIGlubmVyIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdEFsbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBKb2lucyBldmVyeSBPYnNlcnZhYmxlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSAoYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSksIGluXG4gKiBhIHNlcmlhbCBmYXNoaW9uLiBJdCBzdWJzY3JpYmVzIHRvIGVhY2ggaW5uZXIgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIHRoZVxuICogcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLCBhbmQgbWVyZ2VzIGFsbCBvZiB0aGVpciB2YWx1ZXMgaW50b1xuICogdGhlIHJldHVybmVkIG9ic2VydmFibGUuXG4gKlxuICogX19XYXJuaW5nOl9fIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBPYnNlcnZhYmxlcyBxdWlja2x5IGFuZFxuICogZW5kbGVzc2x5LCBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVzIGl0IGVtaXRzIGdlbmVyYWxseSBjb21wbGV0ZSBzbG93ZXIgdGhhblxuICogdGhlIHNvdXJjZSBlbWl0cywgeW91IGNhbiBydW4gaW50byBtZW1vcnkgaXNzdWVzIGFzIHRoZSBpbmNvbWluZyBPYnNlcnZhYmxlc1xuICogY29sbGVjdCBpbiBhbiB1bmJvdW5kZWQgYnVmZmVyLlxuICpcbiAqIE5vdGU6IGBjb25jYXRBbGxgIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlQWxsYCB3aXRoIGNvbmN1cnJlbmN5IHBhcmFtZXRlciBzZXRcbiAqIHRvIGAxYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3IgZWFjaCBjbGljayBldmVudCwgdGljayBldmVyeSBzZWNvbmQgZnJvbSAwIHRvIDMsIHdpdGggbm8gY29uY3VycmVuY3k8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcChldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5jb25jYXRBbGwoKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGVtaXR0aW5nIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5uZXJcbiAqIE9ic2VydmFibGVzIGNvbmNhdGVuYXRlZC5cbiAqIEBtZXRob2QgY29uY2F0QWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKDEpKTtcbn1cbmV4cG9ydHMuY29uY2F0QWxsID0gY29uY2F0QWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0QWxsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvY29uY2F0QWxsLmpzXG4gKiogbW9kdWxlIGlkID0gNTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29uY2F0TWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbmNhdE1hcFRvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0TWFwVG8gPSBjb25jYXRNYXBUb18xLmNvbmNhdE1hcFRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwVG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0TWFwVG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1NTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlTWFwVG9fMSA9IHJlcXVpcmUoJy4vbWVyZ2VNYXBUbycpO1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBtdWx0aXBsZVxuICogdGltZXMgaW4gYSBzZXJpYWxpemVkIGZhc2hpb24gb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGNvbmNhdE1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWVcbiAqIGFsd2F5cyB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdE1hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIGdpdmVuIE9ic2VydmFibGUgYGlubmVyT2JzZXJ2YWJsZWAgcmVnYXJkbGVzc1xuICogb2YgdGhlIHNvdXJjZSB2YWx1ZSwgYW5kIHRoZW4gZmxhdHRlbnMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBFYWNoIG5ldyBgaW5uZXJPYnNlcnZhYmxlYFxuICogaW5zdGFuY2UgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlIHByZXZpb3VzXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCBpbnN0YW5jZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gaWYgc291cmNlIHZhbHVlcyBhcnJpdmUgZW5kbGVzc2x5IGFuZCBmYXN0ZXIgdGhhbiB0aGVpclxuICogY29ycmVzcG9uZGluZyBpbm5lciBPYnNlcnZhYmxlcyBjYW4gY29tcGxldGUsIGl0IHdpbGwgcmVzdWx0IGluIG1lbW9yeSBpc3N1ZXNcbiAqIGFzIGlubmVyIE9ic2VydmFibGVzIGFtYXNzIGluIGFuIHVuYm91bmRlZCBidWZmZXIgd2FpdGluZyBmb3IgdGhlaXIgdHVybiB0b1xuICogYmUgc3Vic2NyaWJlZCB0by5cbiAqXG4gKiBOb3RlOiBgY29uY2F0TWFwVG9gIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlTWFwVG9gIHdpdGggY29uY3VycmVuY3kgcGFyYW1ldGVyXG4gKiBzZXQgdG8gYDFgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCB0aWNrIGV2ZXJ5IHNlY29uZCBmcm9tIDAgdG8gMywgd2l0aCBubyBjb25jdXJyZW5jeTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmNvbmNhdE1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IGlubmVyT2JzZXJ2YWJsZSBBbiBPYnNlcnZhYmxlIHRvIHJlcGxhY2UgZWFjaCB2YWx1ZSBmcm9tXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBvZiB2YWx1ZXMgbWVyZ2VkIHRvZ2V0aGVyIGJ5IGpvaW5pbmcgdGhlXG4gKiBwYXNzZWQgb2JzZXJ2YWJsZSB3aXRoIGl0c2VsZiwgb25lIGFmdGVyIHRoZSBvdGhlciwgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZFxuICogZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCBjb25jYXRNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0TWFwVG8oaW5uZXJPYnNlcnZhYmxlLCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IG1lcmdlTWFwVG9fMS5NZXJnZU1hcFRvT3BlcmF0b3IoaW5uZXJPYnNlcnZhYmxlLCByZXN1bHRTZWxlY3RvciwgMSkpO1xufVxuZXhwb3J0cy5jb25jYXRNYXBUbyA9IGNvbmNhdE1hcFRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwVG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9jb25jYXRNYXBUby5qc1xuICoqIG1vZHVsZSBpZCA9IDU1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBzYW1lIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIG11bHRpcGxlXG4gKiB0aW1lcyBpbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgbWVyZ2VNYXB9LCBidXQgbWFwcyBlYWNoIHZhbHVlIGFsd2F5c1xuICogdG8gdGhlIHNhbWUgaW5uZXIgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZU1hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIGdpdmVuIE9ic2VydmFibGUgYGlubmVyT2JzZXJ2YWJsZWAgcmVnYXJkbGVzc1xuICogb2YgdGhlIHNvdXJjZSB2YWx1ZSwgYW5kIHRoZW4gbWVyZ2VzIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBpbnRvIG9uZVxuICogc2luZ2xlIE9ic2VydmFibGUsIHdoaWNoIGlzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3IgZWFjaCBjbGljayBldmVudCwgc3RhcnQgYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSB0aWNraW5nIGV2ZXJ5IDEgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MubWVyZ2VNYXBUbyhSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IGlubmVyT2JzZXJ2YWJsZSBBbiBPYnNlcnZhYmxlIHRvIHJlcGxhY2UgZWFjaCB2YWx1ZSBmcm9tXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIGdpdmVuXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCAoYW5kIG9wdGlvbmFsbHkgdHJhbnNmb3JtZWQgdGhyb3VnaCBgcmVzdWx0U2VsZWN0b3JgKSBldmVyeVxuICogdGltZSBhIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZU1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZU1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25jdXJyZW50ID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VNYXBUbyA9IG1lcmdlTWFwVG87XG4vLyBUT0RPOiBGaWd1cmUgb3V0IGNvcnJlY3Qgc2lnbmF0dXJlIGhlcmU6IGFuIE9wZXJhdG9yPE9ic2VydmFibGU8VD4sIFI+XG4vLyAgICAgICBuZWVkcyB0byBpbXBsZW1lbnQgY2FsbChvYnNlcnZlcjogU3Vic2NyaWJlcjxSPik6IFN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPj5cbnZhciBNZXJnZU1hcFRvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwVG9PcGVyYXRvcihpc2gsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICB0aGlzLmlzaCA9IGlzaDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZU1hcFRvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IE1lcmdlTWFwVG9TdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLmlzaCwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBUb09wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VNYXBUb09wZXJhdG9yID0gTWVyZ2VNYXBUb09wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZU1hcFRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBpc2gsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTZWxlY3RvciA9IHRoaXMucmVzdWx0U2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICB2YXIgaXNoID0gdGhpcy5pc2g7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgIHRoaXMuX2lubmVyU3ViKGlzaCwgZGVzdGluYXRpb24sIHJlc3VsdFNlbGVjdG9yLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCBkZXN0aW5hdGlvbiwgcmVzdWx0U2VsZWN0b3IsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGlzaCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTZWxlY3RSZXN1bHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBUb1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZU1hcFRvU3Vic2NyaWJlciA9IE1lcmdlTWFwVG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXBUby5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL21lcmdlTWFwVG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1NTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb3VudF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY291bnQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb3VudCA9IGNvdW50XzEuY291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9jb3VudC5qc1xuICoqIG1vZHVsZSBpZCA9IDU1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVtaXNzaW9ucyBvbiB0aGUgc291cmNlIGFuZCBlbWl0cyB0aGF0IG51bWJlciB3aGVuIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGVsbHMgaG93IG1hbnkgdmFsdWVzIHdlcmUgZW1pdHRlZCwgd2hlbiB0aGUgc291cmNlXG4gKiBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvdW50YCB0cmFuc2Zvcm1zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgaW50byBhbiBPYnNlcnZhYmxlIHRoYXRcbiAqIGVtaXRzIGEgc2luZ2xlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZVxuICogc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0ZXJtaW5hdGVzIHdpdGggYW4gZXJyb3IsIGBjb3VudGBcbiAqIHdpbGwgcGFzcyB0aGlzIGVycm9yIG5vdGlmaWNhdGlvbiBhbG9uZyB3aXRob3V0IGVtaXR0aW5nIGFuIHZhbHVlIGZpcnN0LiBJZlxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGRvZXMgbm90IHRlcm1pbmF0ZSBhdCBhbGwsIGBjb3VudGAgd2lsbCBuZWl0aGVyIGVtaXRcbiAqIGEgdmFsdWUgbm9yIHRlcm1pbmF0ZS4gVGhpcyBvcGVyYXRvciB0YWtlcyBhbiBvcHRpb25hbCBgcHJlZGljYXRlYCBmdW5jdGlvblxuICogYXMgYXJndW1lbnQsIGluIHdoaWNoIGNhc2UgdGhlIG91dHB1dCBlbWlzc2lvbiB3aWxsIHJlcHJlc2VudCB0aGUgbnVtYmVyIG9mXG4gKiBzb3VyY2UgdmFsdWVzIHRoYXQgbWF0Y2hlZCBgdHJ1ZWAgd2l0aCB0aGUgYHByZWRpY2F0ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnRzIGhvdyBtYW55IHNlY29uZHMgaGF2ZSBwYXNzZWQgYmVmb3JlIHRoZSBmaXJzdCBjbGljayBoYXBwZW5lZDwvY2FwdGlvbj5cbiAqIHZhciBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgc2Vjb25kc0JlZm9yZUNsaWNrID0gc2Vjb25kcy50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHZhciByZXN1bHQgPSBzZWNvbmRzQmVmb3JlQ2xpY2suY291bnQoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnRzIGhvdyBtYW55IG9kZCBudW1iZXJzIGFyZSB0aGVyZSBiZXR3ZWVuIDEgYW5kIDc8L2NhcHRpb24+XG4gKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgNyk7XG4gKiB2YXIgcmVzdWx0ID0gbnVtYmVycy5jb3VudChpID0+IGkgJSAyID09PSAxKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWF4fVxuICogQHNlZSB7QGxpbmsgbWlufVxuICogQHNlZSB7QGxpbmsgcmVkdWNlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGk6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogYm9vbGVhbn0gW3ByZWRpY2F0ZV0gQVxuICogYm9vbGVhbiBmdW5jdGlvbiB0byBzZWxlY3Qgd2hhdCB2YWx1ZXMgYXJlIHRvIGJlIGNvdW50ZWQuIEl0IGlzIHByb3ZpZGVkIHdpdGhcbiAqIGFyZ3VtZW50cyBvZjpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogLSBgaW5kZXhgOiB0aGUgKHplcm8tYmFzZWQpIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiAtIGBzb3VyY2VgOiB0aGUgc291cmNlIE9ic2VydmFibGUgaW5zdGFuY2UgaXRzZWxmLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBvbmUgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY291bnQgYXNcbiAqIGRlc2NyaWJlZCBhYm92ZS5cbiAqIEBtZXRob2QgY291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvdW50KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IENvdW50T3BlcmF0b3IocHJlZGljYXRlLCB0aGlzKSk7XG59XG5leHBvcnRzLmNvdW50ID0gY291bnQ7XG52YXIgQ291bnRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ291bnRPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIENvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJlZGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmNvdW50KTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvdW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvY291bnQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZW1hdGVyaWFsaXplXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZW1hdGVyaWFsaXplJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVtYXRlcmlhbGl6ZSA9IGRlbWF0ZXJpYWxpemVfMS5kZW1hdGVyaWFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVtYXRlcmlhbGl6ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZW1hdGVyaWFsaXplLmpzXG4gKiogbW9kdWxlIGlkID0gNTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgdHJhbnNmb3JtcyBOb3RpZmljYXRpb24gb2JqZWN0cyBpbnRvIHRoZSBpdGVtcyBvciBub3RpZmljYXRpb25zIHRoZXkgcmVwcmVzZW50LlxuICpcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYW5kIG5vdGlmaWNhdGlvbnMgZW1iZWRkZWQgaW4gTm90aWZpY2F0aW9uIG9iamVjdHMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGRlbWF0ZXJpYWxpemVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlbWF0ZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVNYXRlcmlhbGl6ZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5kZW1hdGVyaWFsaXplID0gZGVtYXRlcmlhbGl6ZTtcbnZhciBEZU1hdGVyaWFsaXplT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlTWF0ZXJpYWxpemVPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgRGVNYXRlcmlhbGl6ZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZU1hdGVyaWFsaXplT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZU1hdGVyaWFsaXplU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLm9ic2VydmUodGhpcy5kZXN0aW5hdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW1hdGVyaWFsaXplLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZGVtYXRlcmlhbGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRlYm91bmNlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWJvdW5jZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlID0gZGVib3VuY2VfMS5kZWJvdW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2RlYm91bmNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIGEgcGFydGljdWxhciB0aW1lIHNwYW5cbiAqIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlIGhhcyBwYXNzZWQgd2l0aG91dCBhbm90aGVyIHNvdXJjZSBlbWlzc2lvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWJvdW5jZVRpbWV9LCBidXQgdGhlIHRpbWUgc3BhbiBvZlxuICogZW1pc3Npb24gc2lsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVib3VuY2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlYm91bmNlYCBkZWxheXMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgZHJvcHMgcHJldmlvdXNcbiAqIHBlbmRpbmcgZGVsYXllZCBlbWlzc2lvbnMgaWYgYSBuZXcgdmFsdWUgYXJyaXZlcyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGFuZCBzcGF3bnMgYSBkdXJhdGlvbiBPYnNlcnZhYmxlIGJ5IGNhbGxpbmcgdGhlXG4gKiBgZHVyYXRpb25TZWxlY3RvcmAgZnVuY3Rpb24uIFRoZSB2YWx1ZSBpcyBlbWl0dGVkIG9ubHkgd2hlbiB0aGUgZHVyYXRpb25cbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSBvciBjb21wbGV0ZXMsIGFuZCBpZiBubyBvdGhlciB2YWx1ZSB3YXMgZW1pdHRlZCBvblxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHNpbmNlIHRoZSBkdXJhdGlvbiBPYnNlcnZhYmxlIHdhcyBzcGF3bmVkLiBJZiBhIG5ld1xuICogdmFsdWUgYXBwZWFycyBiZWZvcmUgdGhlIGR1cmF0aW9uIE9ic2VydmFibGUgZW1pdHMsIHRoZSBwcmV2aW91cyB2YWx1ZSB3aWxsXG4gKiBiZSBkcm9wcGVkIGFuZCB3aWxsIG5vdCBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBMaWtlIHtAbGluayBkZWJvdW5jZVRpbWV9LCB0aGlzIGlzIGEgcmF0ZS1saW1pdGluZyBvcGVyYXRvciwgYW5kIGFsc28gYVxuICogZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBuZWNlc3NhcmlseSBvY2N1ciBhdCB0aGVcbiAqIHNhbWUgdGltZSBhcyB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZSgoKSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogT2JzZXJ2YWJsZXxQcm9taXNlfSBkdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgZm9yIGNvbXB1dGluZyB0aGUgdGltZW91dFxuICogZHVyYXRpb24gZm9yIGVhY2ggc291cmNlIHZhbHVlLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gT2JzZXJ2YWJsZSByZXR1cm5lZCBieVxuICogYGR1cmF0aW9uU2VsZWN0b3JgLCBhbmQgbWF5IGRyb3Agc29tZSB2YWx1ZXMgaWYgdGhleSBvY2N1ciB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWJvdW5jZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbnZhciBEZWJvdW5jZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlYm91bmNlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kdXJhdGlvblNlbGVjdG9yLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeU5leHQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGR1cmF0aW9uKTtcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLmVtaXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZGVib3VuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1NjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWJvdW5jZVRpbWVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlYm91bmNlVGltZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZV8xLmRlYm91bmNlVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIGEgcGFydGljdWxhciB0aW1lIHNwYW5cbiAqIGhhcyBwYXNzZWQgd2l0aG91dCBhbm90aGVyIHNvdXJjZSBlbWlzc2lvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCBwYXNzZXMgb25seSB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlIGZyb20gZWFjaCBidXJzdCBvZiBlbWlzc2lvbnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVib3VuY2VUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZVRpbWVgIGRlbGF5cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wc1xuICogcHJldmlvdXMgcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyB2YWx1ZSBhcnJpdmVzIG9uIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoYXQgb25seSB3aGVuIGBkdWVUaW1lYCBlbm91Z2ggdGltZSBoYXMgcGFzc2VkXG4gKiB3aXRob3V0IGFueSBvdGhlciB2YWx1ZSBhcHBlYXJpbmcgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIG5ldyB2YWx1ZVxuICogYXBwZWFycyBiZWZvcmUgYGR1ZVRpbWVgIHNpbGVuY2Ugb2NjdXJzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbCBiZSBkcm9wcGVkXG4gKiBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSBmb3IgbW9yZSB0aGFuIG9uZVxuICogdmFsdWUgdG8gYmUgZW1pdHRlZCBpbiBhbnkgdGltZSB3aW5kb3cgb2YgZHVyYXRpb24gYGR1ZVRpbWVgLCBidXQgaXQgaXMgYWxzb1xuICogYSBkZWxheS1saWtlIG9wZXJhdG9yIHNpbmNlIG91dHB1dCBlbWlzc2lvbnMgZG8gbm90IG9jY3VyIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAqIHRoZXkgZGlkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gT3B0aW9uYWxseSB0YWtlcyBhIHtAbGluayBTY2hlZHVsZXJ9IGZvclxuICogbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2VUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlVGltZSBUaGUgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lXG4gKiB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGZvciB0aGUgd2luZG93IG9mXG4gKiB0aW1lIHJlcXVpcmVkIHRvIHdhaXQgZm9yIGVtaXNzaW9uIHNpbGVuY2UgYmVmb3JlIGVtaXR0aW5nIHRoZSBtb3N0IHJlY2VudFxuICogc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lb3V0IGZvciBlYWNoIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBgZHVlVGltZWAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyXG4gKiB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gZGVib3VuY2VUaW1lO1xudmFyIERlYm91bmNlVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIERlYm91bmNlVGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IERlYm91bmNlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdWVUaW1lLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVlVGltZSwgdGhpcykpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlZE5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuZGVib3VuY2VkTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhckRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChkZWJvdW5jZWRTdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlYm91bmNlZFN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBkZWJvdW5jZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoc3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXIuZGVib3VuY2VkTmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2VUaW1lLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZGVib3VuY2VUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVmYXVsdElmRW1wdHlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlZmF1bHRJZkVtcHR5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVmYXVsdElmRW1wdHkgPSBkZWZhdWx0SWZFbXB0eV8xLmRlZmF1bHRJZkVtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdElmRW1wdHkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkuanNcbiAqKiBtb2R1bGUgaWQgPSA1NjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyBhIGdpdmVuIHZhbHVlIGlmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgd2l0aG91dCBlbWl0dGluZyBhbnlcbiAqIGBuZXh0YCB2YWx1ZSwgb3RoZXJ3aXNlIG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JZiB0aGUgc291cmNlIE9ic2VydmFibGUgdHVybnMgb3V0IHRvIGJlIGVtcHR5LCB0aGVuXG4gKiB0aGlzIG9wZXJhdG9yIHdpbGwgZW1pdCBhIGRlZmF1bHQgdmFsdWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVmYXVsdElmRW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlZmF1bHRJZkVtcHR5YCBlbWl0cyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9yIGFcbiAqIHNwZWNpZmllZCBkZWZhdWx0IHZhbHVlIGlmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpcyBlbXB0eSAoY29tcGxldGVzIHdpdGhvdXRcbiAqIGhhdmluZyBlbWl0dGVkIGFueSBgbmV4dGAgdmFsdWUpLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPklmIG5vIGNsaWNrcyBoYXBwZW4gaW4gNSBzZWNvbmRzLCB0aGVuIGVtaXQgXCJubyBjbGlja3NcIjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzQmVmb3JlRml2ZSA9IGNsaWNrcy50YWtlVW50aWwoUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDAwKSk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzQmVmb3JlRml2ZS5kZWZhdWx0SWZFbXB0eSgnbm8gY2xpY2tzJyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICogQHNlZSB7QGxpbmsgbGFzdH1cbiAqXG4gKiBAcGFyYW0ge2FueX0gW2RlZmF1bHRWYWx1ZT1udWxsXSBUaGUgZGVmYXVsdCB2YWx1ZSB1c2VkIGlmIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgaXMgZW1wdHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZWl0aGVyIHRoZSBzcGVjaWZpZWRcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBubyBpdGVtcywgb3IgdGhlIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGRlZmF1bHRJZkVtcHR5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0SWZFbXB0eShkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHsgZGVmYXVsdFZhbHVlID0gbnVsbDsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSk7XG59XG5leHBvcnRzLmRlZmF1bHRJZkVtcHR5ID0gZGVmYXVsdElmRW1wdHk7XG52YXIgRGVmYXVsdElmRW1wdHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdElmRW1wdHlPcGVyYXRvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLmlzRW1wdHkgPSB0cnVlO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRJZkVtcHR5LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkuanNcbiAqKiBtb2R1bGUgaWQgPSA1NjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWxheVdoZW5fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlbGF5V2hlbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlbGF5V2hlbiA9IGRlbGF5V2hlbl8xLmRlbGF5V2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5V2hlbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9kZWxheVdoZW4uanNcbiAqKiBtb2R1bGUgaWQgPSA1NjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lIHNwYW5cbiAqIGRldGVybWluZWQgYnkgdGhlIGVtaXNzaW9ucyBvZiBhbm90aGVyIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgdGhlIHRpbWUgc3BhbiBvZiB0aGVcbiAqIGRlbGF5IGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWxheVdoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlbGF5V2hlbmAgdGltZSBzaGlmdHMgZWFjaCBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGFcbiAqIHRpbWUgc3BhbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgc291cmNlIGVtaXRzIGEgdmFsdWUsXG4gKiB0aGUgYGRlbGF5RHVyYXRpb25TZWxlY3RvcmAgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIHNvdXJjZSB2YWx1ZSBhc1xuICogYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuIGFuIE9ic2VydmFibGUsIGNhbGxlZCB0aGUgXCJkdXJhdGlvblwiIE9ic2VydmFibGUuXG4gKiBUaGUgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgd2hlbiB0aGUgZHVyYXRpb25cbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSBvciBjb21wbGV0ZXMuXG4gKlxuICogT3B0aW9uYWxseSwgYGRlbGF5V2hlbmAgdGFrZXMgYSBzZWNvbmQgYXJndW1lbnQsIGBzdWJzY3JpcHRpb25EZWxheWAsIHdoaWNoXG4gKiBpcyBhbiBPYnNlcnZhYmxlLiBXaGVuIGBzdWJzY3JpcHRpb25EZWxheWAgZW1pdHMgaXRzIGZpcnN0IHZhbHVlIG9yXG4gKiBjb21wbGV0ZXMsIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkIHRvIGFuZCBzdGFydHMgYmVoYXZpbmcgbGlrZVxuICogZGVzY3JpYmVkIGluIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGguIElmIGBzdWJzY3JpcHRpb25EZWxheWAgaXMgbm90IHByb3ZpZGVkLFxuICogYGRlbGF5V2hlbmAgd2lsbCBzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIHNvb24gYXMgdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGVhY2ggY2xpY2sgYnkgYSByYW5kb20gYW1vdW50IG9mIHRpbWUsIGJldHdlZW4gMCBhbmQgNSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5V2hlbihldmVudCA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKE1hdGgucmFuZG9tKCkgKiA1MDAwKVxuICogKTtcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IE9ic2VydmFibGV9IGRlbGF5RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXRcbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZSBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hpY2hcbiAqIGlzIHRoZW4gdXNlZCB0byBkZWxheSB0aGUgZW1pc3Npb24gb2YgdGhhdCBpdGVtIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogdW50aWwgdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uIGVtaXRzIGEgdmFsdWUuXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IHN1YnNjcmlwdGlvbkRlbGF5IEFuIE9ic2VydmFibGUgdGhhdCB0cmlnZ2VycyB0aGVcbiAqIHN1YnNjcmlwdGlvbiB0byB0aGUgc291cmNlIE9ic2VydmFibGUgb25jZSBpdCBlbWl0cyBhbnkgdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSBhbiBhbW91bnQgb2YgdGltZSBzcGVjaWZpZWQgYnkgdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgLlxuICogQG1ldGhvZCBkZWxheVdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlbGF5V2hlbihkZWxheUR1cmF0aW9uU2VsZWN0b3IsIHN1YnNjcmlwdGlvbkRlbGF5KSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbkRlbGF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlKHRoaXMsIHN1YnNjcmlwdGlvbkRlbGF5KVxuICAgICAgICAgICAgLmxpZnQobmV3IERlbGF5V2hlbk9wZXJhdG9yKGRlbGF5RHVyYXRpb25TZWxlY3RvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWxheVdoZW5PcGVyYXRvcihkZWxheUR1cmF0aW9uU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuZGVsYXlXaGVuID0gZGVsYXlXaGVuO1xudmFyIERlbGF5V2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheVdoZW5PcGVyYXRvcihkZWxheUR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IgPSBkZWxheUR1cmF0aW9uU2VsZWN0b3I7XG4gICAgfVxuICAgIERlbGF5V2hlbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IERlbGF5V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheVdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlbGF5V2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxheVdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbGF5V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlbGF5RHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yID0gZGVsYXlEdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KG91dGVyVmFsdWUpO1xuICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRlbGF5Tm90aWZpZXIgPSB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVsYXlOb3RpZmllcikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RGVsYXkoZGVsYXlOb3RpZmllciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnJlbW92ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25JZHggPSB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbklkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZXNbc3Vic2NyaXB0aW9uSWR4XTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbklkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2Uoc3Vic2NyaXB0aW9uSWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlEZWxheSA9IGZ1bmN0aW9uIChkZWxheU5vdGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm90aWZpZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGRlbGF5Tm90aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hZGQobm90aWZpZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLnB1c2gobm90aWZpZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnRyeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZWQgJiYgdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlbGF5V2hlblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlKHNvdXJjZSwgc3Vic2NyaXB0aW9uRGVsYXkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkRlbGF5ID0gc3Vic2NyaXB0aW9uRGVsYXk7XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRGVsYXkuc3Vic2NyaWJlKG5ldyBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIocGFyZW50LCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodW51c2VkKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Tb3VyY2UoKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMucGFyZW50LmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1NvdXJjZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5zdWJzY3JpYmVUb1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZVN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcy5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXlXaGVuLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZGVsYXlXaGVuLmpzXG4gKiogbW9kdWxlIGlkID0gNTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGlzdGluY3RVbnRpbENoYW5nZWRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxDaGFuZ2VkJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xLmRpc3RpbmN0VW50aWxDaGFuZ2VkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbENoYW5nZWQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkb18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kbyA9IGRvXzEuX2RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1NzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHJldHVyblxuICogYW4gT2JzZXJ2YWJsZSB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JbnRlcmNlcHRzIGVhY2ggZW1pc3Npb24gb24gdGhlIHNvdXJjZSBhbmQgcnVucyBhXG4gKiBmdW5jdGlvbiwgYnV0IHJldHVybnMgYW4gb3V0cHV0IHdoaWNoIGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYSBtaXJyb3JlZCBPYnNlcnZhYmxlIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG1vZGlmaWVkIHNvIHRoYXRcbiAqIHRoZSBwcm92aWRlZCBPYnNlcnZlciBpcyBjYWxsZWQgdG8gcGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSB2YWx1ZSxcbiAqIGVycm9yLCBhbmQgY29tcGxldGlvbiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UuIEFueSBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGluXG4gKiB0aGUgYWZvcmVtZW50aW9uZWQgT2JzZXJ2ZXIgb3IgaGFuZGxlcnMgYXJlIHNhZmVseSBzZW50IGRvd24gdGhlIGVycm9yIHBhdGhcbiAqIG9mIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHlvdXIgT2JzZXJ2YWJsZXMgZm9yIHRoZSBjb3JyZWN0IHZhbHVlc1xuICogb3IgcGVyZm9ybWluZyBvdGhlciBzaWRlIGVmZmVjdHMuXG4gKlxuICogTm90ZTogdGhpcyBpcyBkaWZmZXJlbnQgdG8gYSBgc3Vic2NyaWJlYCBvbiB0aGUgT2JzZXJ2YWJsZS4gSWYgdGhlIE9ic2VydmFibGVcbiAqIHJldHVybmVkIGJ5IGBkb2AgaXMgbm90IHN1YnNjcmliZWQsIHRoZSBzaWRlIGVmZmVjdHMgc3BlY2lmaWVkIGJ5IHRoZVxuICogT2JzZXJ2ZXIgd2lsbCBuZXZlciBoYXBwZW4uIGBkb2AgdGhlcmVmb3JlIHNpbXBseSBzcGllcyBvbiBleGlzdGluZ1xuICogZXhlY3V0aW9uLCBpdCBkb2VzIG5vdCB0cmlnZ2VyIGFuIGV4ZWN1dGlvbiB0byBoYXBwZW4gbGlrZSBgc3Vic2NyaWJlYCBkb2VzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrLCB3aGlsZSBhbHNvIGxvZ2dpbmcgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3NcbiAqICAgLmRvKGV2ID0+IGNvbnNvbGUubG9nKGV2KSlcbiAqICAgLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICogQHNlZSB7QGxpbmsgc3Vic2NyaWJlfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb259IFtuZXh0T3JPYnNlcnZlcl0gQSBub3JtYWwgT2JzZXJ2ZXIgb2JqZWN0IG9yIGFcbiAqIGNhbGxiYWNrIGZvciBgbmV4dGAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIGZvciBlcnJvcnMgaW4gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wbGV0ZV0gQ2FsbGJhY2sgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGlkZW50aWNhbCB0byB0aGUgc291cmNlLCBidXQgcnVucyB0aGVcbiAqIHNwZWNpZmllZCBPYnNlcnZlciBvciBjYWxsYmFjayhzKSBmb3IgZWFjaCBpdGVtLlxuICogQG1ldGhvZCBkb1xuICogQG5hbWUgZG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9kbyhuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSk7XG59XG5leHBvcnRzLl9kbyA9IF9kbztcbnZhciBEb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5uZXh0T3JPYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgRG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBEb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5uZXh0T3JPYnNlcnZlciwgdGhpcy5lcnJvciwgdGhpcy5jb21wbGV0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzYWZlU3Vic2NyaWJlcik7XG4gICAgICAgIHRoaXMuc2FmZVN1YnNjcmliZXIgPSBzYWZlU3Vic2NyaWJlcjtcbiAgICB9XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1NzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBleHBhbmRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2V4cGFuZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmV4cGFuZCA9IGV4cGFuZF8xLmV4cGFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGFuZC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9leHBhbmQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHdoZXJlIGZvciBlYWNoIGl0ZW0gaW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byBlYWNoIGl0ZW0sXG4gKiByZXN1bHRpbmcgaW4gYSBuZXcgdmFsdWUgdG8gdGhlbiBiZSBhcHBsaWVkIGFnYWluIHdpdGggdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvamVjdCB0aGUgZnVuY3Rpb24gZm9yIHByb2plY3RpbmcgdGhlIG5leHQgZW1pdHRlZCBpdGVtIG9mIHRoZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50XSB0aGUgbWF4IG51bWJlciBvZiBvYnNlcnZhYmxlcyB0aGF0IGNhbiBiZSBjcmVhdGVkIGNvbmN1cnJlbnRseS4gZGVmYXVsdHMgdG8gaW5maW5pdHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIFNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nIHRoZSBleHBhbnNpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSBjb250YWluaW5nIHRoZSBleHBhbnNpb25zIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgZXhwYW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleHBhbmQocHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IHVuZGVmaW5lZDsgfVxuICAgIGNvbmN1cnJlbnQgPSAoY29uY3VycmVudCB8fCAwKSA8IDEgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBjb25jdXJyZW50O1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEV4cGFuZE9wZXJhdG9yKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5leHBhbmQgPSBleHBhbmQ7XG52YXIgRXhwYW5kT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cGFuZE9wZXJhdG9yKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRXhwYW5kT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgRXhwYW5kU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMuY29uY3VycmVudCwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBFeHBhbmRPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLkV4cGFuZE9wZXJhdG9yID0gRXhwYW5kT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEV4cGFuZFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHBhbmRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cGFuZFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29uY3VycmVudCA8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFeHBhbmRTdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyLCByZXN1bHQgPSBhcmcucmVzdWx0LCB2YWx1ZSA9IGFyZy52YWx1ZSwgaW5kZXggPSBhcmcuaW5kZXg7XG4gICAgICAgIHN1YnNjcmliZXIuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIEV4cGFuZFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbi5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLnByb2plY3QpKHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgcmVzdWx0OiByZXN1bHQsIHZhbHVlOiB2YWx1ZSwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoRXhwYW5kU3Vic2NyaWJlci5kaXNwYXRjaCwgMCwgc3RhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5zdWJzY3JpYmVUb1Byb2plY3Rpb24gPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX25leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkICYmIHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFeHBhbmRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuRXhwYW5kU3Vic2NyaWJlciA9IEV4cGFuZFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBhbmQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9leHBhbmQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmaW5hbGx5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9maW5hbGx5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmluYWxseSA9IGZpbmFsbHlfMS5fZmluYWxseTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsbHkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZmluYWxseS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCB3aWxsIGNhbGwgYSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlblxuICogdGhlIHNvdXJjZSB0ZXJtaW5hdGVzIG9uIGNvbXBsZXRlIG9yIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmluYWxseVNlbGVjdG9yIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHNvdXJjZSB0ZXJtaW5hdGVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSwgYnV0IHdpbGwgY2FsbCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIG9uIHRlcm1pbmF0aW9uLlxuICogQG1ldGhvZCBmaW5hbGx5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfZmluYWxseShmaW5hbGx5U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoZmluYWxseVNlbGVjdG9yKSk7XG59XG5leHBvcnRzLl9maW5hbGx5ID0gX2ZpbmFsbHk7XG52YXIgRmluYWxseU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5hbGx5T3BlcmF0b3IoZmluYWxseVNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZmluYWxseVNlbGVjdG9yID0gZmluYWxseVNlbGVjdG9yO1xuICAgIH1cbiAgICBGaW5hbGx5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgRmluYWxseVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5maW5hbGx5U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaW5hbGx5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbmFsbHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBmaW5hbGx5U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGZpbmFsbHlTZWxlY3RvcikpO1xuICAgIH1cbiAgICByZXR1cm4gRmluYWxseVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5hbGx5LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvZmluYWxseS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpcnN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9maXJzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpcnN0ID0gZmlyc3RfMS5maXJzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0VtcHR5RXJyb3InKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUgKG9yIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IG1lZXRzIHNvbWUgY29uZGl0aW9uKVxuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIG9ubHkgdGhlIGZpcnN0IHZhbHVlLiBPciBlbWl0cyBvbmx5IHRoZSBmaXJzdFxuICogdmFsdWUgdGhhdCBwYXNzZXMgc29tZSB0ZXN0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpcnN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIElmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgYGZpcnN0YCBlbWl0cyB0aGUgZmlyc3QgdmFsdWUgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgdGhlbiBjb21wbGV0ZXMuIElmIGNhbGxlZCB3aXRoIGEgYHByZWRpY2F0ZWAgZnVuY3Rpb24sIGBmaXJzdGBcbiAqIGVtaXRzIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgc291cmNlIHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbi4gSXRcbiAqIG1heSBhbHNvIHRha2UgYSBgcmVzdWx0U2VsZWN0b3JgIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIG91dHB1dCB2YWx1ZSBmcm9tXG4gKiB0aGUgaW5wdXQgdmFsdWUsIGFuZCBhIGBkZWZhdWx0VmFsdWVgIHRvIGVtaXQgaW4gY2FzZSB0aGUgc291cmNlIGNvbXBsZXRlc1xuICogYmVmb3JlIGl0IGlzIGFibGUgdG8gZW1pdCBhIHZhbGlkIHZhbHVlLiBUaHJvd3MgYW4gZXJyb3IgaWYgYGRlZmF1bHRWYWx1ZWBcbiAqIHdhcyBub3QgcHJvdmlkZWQgYW5kIGEgbWF0Y2hpbmcgZWxlbWVudCBpcyBub3QgZm91bmQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IHRoZSBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gdGhlIERPTTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpcnN0KCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIHRoZSBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVY8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5maXJzdChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaW5kfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtFbXB0eUVycm9yfSBEZWxpdmVycyBhbiBFbXB0eUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmBcbiAqIGNhbGxiYWNrIGlmIHRoZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBiZWZvcmUgYW55IGBuZXh0YCBub3RpZmljYXRpb24gd2FzIHNlbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogYm9vbGVhbn0gW3ByZWRpY2F0ZV1cbiAqIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggaXRlbSB0byB0ZXN0IGZvciBjb25kaXRpb24gbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gW3Jlc3VsdFNlbGVjdG9yXSBBIGZ1bmN0aW9uIHRvXG4gKiBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpc1xuICogZnVuY3Rpb24gYXJlOlxuICogLSBgdmFsdWVgOiB0aGUgdmFsdWUgdGhhdCB3YXMgZW1pdHRlZCBvbiB0aGUgc291cmNlLlxuICogLSBgaW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge1J9IFtkZWZhdWx0VmFsdWVdIFRoZSBkZWZhdWx0IHZhbHVlIGVtaXR0ZWQgaW4gY2FzZSBubyB2YWxpZCB2YWx1ZVxuICogd2FzIGZvdW5kIG9uIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFR8Uj59IGFuIE9ic2VydmFibGUgb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZVxuICogY29uZGl0aW9uLlxuICogQG1ldGhvZCBmaXJzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmlyc3QocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmlyc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHRoaXMpKTtcbn1cbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcbnZhciBGaXJzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaXJzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgRmlyc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgRmlyc3RTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5kZWZhdWx0VmFsdWUsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlyc3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpcnN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpcnN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaXJzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJlZGljYXRlKHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXRGaW5hbCh2YWx1ZSk7XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdEZpbmFsKHJlc3VsdCk7XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl9lbWl0RmluYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29tcGxldGVkICYmIHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaXJzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBPYnNlcnZhYmxlIG9yIGEgc2VxdWVuY2Ugd2FzIHF1ZXJpZWQgYnV0IGhhcyBub1xuICogZWxlbWVudHMuXG4gKlxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayBsYXN0fVxuICogQHNlZSB7QGxpbmsgc2luZ2xlfVxuICpcbiAqIEBjbGFzcyBFbXB0eUVycm9yXG4gKi9cbnZhciBFbXB0eUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eUVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnbm8gZWxlbWVudHMgaW4gc2VxdWVuY2UnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0VtcHR5RXJyb3InO1xuICAgIH1cbiAgICByZXR1cm4gRW1wdHlFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuRW1wdHlFcnJvciA9IEVtcHR5RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbXB0eUVycm9yLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvdXRpbC9FbXB0eUVycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gNTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZ3JvdXBCeV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZ3JvdXBCeScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmdyb3VwQnkgPSBncm91cEJ5XzEuZ3JvdXBCeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwQnkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvZ3JvdXBCeS5qc1xuICoqIG1vZHVsZSBpZCA9IDU4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE1hcF8xID0gcmVxdWlyZSgnLi4vdXRpbC9NYXAnKTtcbnZhciBGYXN0TWFwXzEgPSByZXF1aXJlKCcuLi91dGlsL0Zhc3RNYXAnKTtcbi8qKlxuICogR3JvdXBzIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUgYWNjb3JkaW5nIHRvIGEgc3BlY2lmaWVkIGNyaXRlcmlvbixcbiAqIGFuZCBlbWl0cyB0aGVzZSBncm91cGVkIGl0ZW1zIGFzIGBHcm91cGVkT2JzZXJ2YWJsZXNgLCBvbmVcbiAqIHtAbGluayBHcm91cGVkT2JzZXJ2YWJsZX0gcGVyIGdyb3VwLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZ3JvdXBCeS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogS30ga2V5U2VsZWN0b3IgYSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSBrZXlcbiAqIGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogUn0gW2VsZW1lbnRTZWxlY3Rvcl0gYSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZVxuICogcmV0dXJuIGVsZW1lbnQgZm9yIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZ3JvdXBlZDogR3JvdXBlZE9ic2VydmFibGU8SyxSPik6IE9ic2VydmFibGU8YW55Pn0gW2R1cmF0aW9uU2VsZWN0b3JdXG4gKiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRvIGRldGVybWluZSBob3cgbG9uZyBlYWNoIGdyb3VwIHNob3VsZFxuICogZXhpc3QuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEdyb3VwZWRPYnNlcnZhYmxlPEssUj4+fSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAqIEdyb3VwZWRPYnNlcnZhYmxlcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUgYW5kIGVhY2hcbiAqIG9mIHdoaWNoIGVtaXRzIHRob3NlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgc2hhcmUgdGhhdCBrZXlcbiAqIHZhbHVlLlxuICogQG1ldGhvZCBncm91cEJ5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBncm91cEJ5KGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBHcm91cEJ5T3BlcmF0b3IodGhpcywga2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3RvcikpO1xufVxuZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeTtcbnZhciBHcm91cEJ5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwQnlPcGVyYXRvcihzb3VyY2UsIGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5lbGVtZW50U2VsZWN0b3IgPSBlbGVtZW50U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgfVxuICAgIEdyb3VwQnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBHcm91cEJ5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmtleVNlbGVjdG9yLCB0aGlzLmVsZW1lbnRTZWxlY3RvciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgR3JvdXBCeVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cEJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cEJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwga2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBudWxsO1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5hZGQoZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMua2V5U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ncm91cCh2YWx1ZSwga2V5KTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZ3JvdXAgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMgPSB0aGlzLmdyb3VwcyA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gbmV3IEZhc3RNYXBfMS5GYXN0TWFwKCkgOiBuZXcgTWFwXzEuTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICBncm91cHMuc2V0KGtleSwgZ3JvdXAgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKSk7XG4gICAgICAgICAgICB2YXIgZ3JvdXBlZE9ic2VydmFibGUgPSBuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCBncm91cCwgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0RHVyYXRpb24oa2V5LCBncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoZ3JvdXBlZE9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0RWxlbWVudCh2YWx1ZSwgZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cnlHcm91cE5leHQodmFsdWUsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9zZWxlY3RFbGVtZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBncm91cCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5lbGVtZW50U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyeUdyb3VwTmV4dChyZXN1bHQsIGdyb3VwKTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fc2VsZWN0RHVyYXRpb24gPSBmdW5jdGlvbiAoa2V5LCBncm91cCkge1xuICAgICAgICB2YXIgZHVyYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25TZWxlY3RvcihuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCBncm91cCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZChkdXJhdGlvbi5zdWJzY3JpYmUobmV3IEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHRoaXMpKSk7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUudHJ5R3JvdXBOZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBncm91cCkge1xuICAgICAgICBpZiAoIWdyb3VwLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICBncm91cC5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBncm91cC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzLmRlbGV0ZShrZXkpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNVbnN1YnNjcmliZWQgJiYgIXRoaXMuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0ZWRUb1Vuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXBEdXJhdGlvblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXBEdXJhdGlvblN1YnNjcmliZXIoa2V5LCBncm91cCwgcGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMudHJ5RXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgaWYgKCFncm91cC5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgZ3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVHcm91cCh0aGlzLmtleSk7XG4gICAgfTtcbiAgICBHcm91cER1cmF0aW9uU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgIGlmICghZ3JvdXAuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlR3JvdXAodGhpcy5rZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBBbiBPYnNlcnZhYmxlIHJlcHJlc2VudGluZyB2YWx1ZXMgYmVsb25naW5nIHRvIHRoZSBzYW1lIGdyb3VwIHJlcHJlc2VudGVkIGJ5XG4gKiBhIGNvbW1vbiBrZXkuIFRoZSB2YWx1ZXMgZW1pdHRlZCBieSBhIEdyb3VwZWRPYnNlcnZhYmxlIGNvbWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgY29tbW9uIGtleSBpcyBhdmFpbGFibGUgYXMgdGhlIGZpZWxkIGBrZXlgIG9uIGFcbiAqIEdyb3VwZWRPYnNlcnZhYmxlIGluc3RhbmNlLlxuICpcbiAqIEBjbGFzcyBHcm91cGVkT2JzZXJ2YWJsZTxLLCBUPlxuICovXG52YXIgR3JvdXBlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cGVkT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwU3ViamVjdCwgcmVmQ291bnRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdyb3VwU3ViamVjdCA9IGdyb3VwU3ViamVjdDtcbiAgICAgICAgdGhpcy5yZWZDb3VudFN1YnNjcmlwdGlvbiA9IHJlZkNvdW50U3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBHcm91cGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlZkNvdW50U3Vic2NyaXB0aW9uID0gX2EucmVmQ291bnRTdWJzY3JpcHRpb24sIGdyb3VwU3ViamVjdCA9IF9hLmdyb3VwU3ViamVjdDtcbiAgICAgICAgaWYgKHJlZkNvdW50U3Vic2NyaXB0aW9uICYmICFyZWZDb3VudFN1YnNjcmlwdGlvbi5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChuZXcgSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbihyZWZDb3VudFN1YnNjcmlwdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoZ3JvdXBTdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBlZE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkdyb3VwZWRPYnNlcnZhYmxlID0gR3JvdXBlZE9ic2VydmFibGU7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ocGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50LmNvdW50Kys7XG4gICAgfVxuICAgIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50LmlzVW5zdWJzY3JpYmVkICYmICF0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwYXJlbnQuY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY291bnQgPT09IDAgJiYgcGFyZW50LmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBCeS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2dyb3VwQnkuanNcbiAqKiBtb2R1bGUgaWQgPSA1ODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIE1hcFBvbHlmaWxsXzEgPSByZXF1aXJlKCcuL01hcFBvbHlmaWxsJyk7XG5leHBvcnRzLk1hcCA9IHJvb3RfMS5yb290Lk1hcCB8fCAoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwUG9seWZpbGxfMS5NYXBQb2x5ZmlsbDsgfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL3V0aWwvTWFwLmpzXG4gKiogbW9kdWxlIGlkID0gNTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXBQb2x5ZmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwUG9seWZpbGwoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNYXBQb2x5ZmlsbDtcbn0oKSk7XG5leHBvcnRzLk1hcFBvbHlmaWxsID0gTWFwUG9seWZpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBQb2x5ZmlsbC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL3V0aWwvTWFwUG9seWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA1ODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEZhc3RNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZhc3RNYXAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge307XG4gICAgfVxuICAgIEZhc3RNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEZhc3RNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2tleV07XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHZhbHVlc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCB2YWx1ZXNba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0ge307XG4gICAgfTtcbiAgICByZXR1cm4gRmFzdE1hcDtcbn0oKSk7XG5leHBvcnRzLkZhc3RNYXAgPSBGYXN0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmFzdE1hcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL3V0aWwvRmFzdE1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDU4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGlnbm9yZUVsZW1lbnRzXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9pZ25vcmVFbGVtZW50cycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHNfMS5pZ25vcmVFbGVtZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZUVsZW1lbnRzLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2lnbm9yZUVsZW1lbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gNTg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBub29wXzEgPSByZXF1aXJlKCcuLi91dGlsL25vb3AnKTtcbi8qKlxuICogSWdub3JlcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG9ubHkgcGFzc2VzIGNhbGxzIG9mIGBjb21wbGV0ZWAgb3IgYGVycm9yYC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lnbm9yZUVsZW1lbnRzLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIGVtcHR5IE9ic2VydmFibGUgdGhhdCBvbmx5IGNhbGxzIGBjb21wbGV0ZWBcbiAqIG9yIGBlcnJvcmAsIGJhc2VkIG9uIHdoaWNoIG9uZSBpcyBjYWxsZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBpZ25vcmVFbGVtZW50c1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gaWdub3JlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgSWdub3JlRWxlbWVudHNPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMuaWdub3JlRWxlbWVudHMgPSBpZ25vcmVFbGVtZW50cztcbjtcbnZhciBJZ25vcmVFbGVtZW50c09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c09wZXJhdG9yKCkge1xuICAgIH1cbiAgICBJZ25vcmVFbGVtZW50c09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSWdub3JlRWxlbWVudHNPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICBub29wXzEubm9vcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZUVsZW1lbnRzLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1ODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBhdWRpdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYXVkaXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5hdWRpdCA9IGF1ZGl0XzEuYXVkaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9hdWRpdC5qc1xuICoqIG1vZHVsZSBpZCA9IDU5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBJZ25vcmVzIHNvdXJjZSB2YWx1ZXMgZm9yIGEgZHVyYXRpb24gZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUsIHRoZW5cbiAqIGVtaXRzIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXNcbiAqIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYXVkaXRUaW1lfSwgYnV0IHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9hdWRpdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgYXVkaXRgIGlzIHNpbWlsYXIgdG8gYHRocm90dGxlYCwgYnV0IGVtaXRzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIHNpbGVuY2VkXG4gKiB0aW1lIHdpbmRvdywgaW5zdGVhZCBvZiB0aGUgZmlyc3QgdmFsdWUuIGBhdWRpdGAgZW1pdHMgdGhlIG1vc3QgcmVjZW50IHZhbHVlXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYXMgc29vbiBhcyBpdHMgaW50ZXJuYWxcbiAqIHRpbWVyIGJlY29tZXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hpbGUgdGhlIHRpbWVyIGlzIGVuYWJsZWQuXG4gKiBJbml0aWFsbHksIHRoZSB0aW1lciBpcyBkaXNhYmxlZC4gQXMgc29vbiBhcyB0aGUgZmlyc3Qgc291cmNlIHZhbHVlIGFycml2ZXMsXG4gKiB0aGUgdGltZXIgaXMgZW5hYmxlZCBieSBjYWxsaW5nIHRoZSBgZHVyYXRpb25TZWxlY3RvcmAgZnVuY3Rpb24gd2l0aCB0aGVcbiAqIHNvdXJjZSB2YWx1ZSwgd2hpY2ggcmV0dXJucyB0aGUgXCJkdXJhdGlvblwiIE9ic2VydmFibGUuIFdoZW4gdGhlIGR1cmF0aW9uXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLCB0aGUgdGltZXIgaXMgZGlzYWJsZWQsIHRoZW4gdGhlIG1vc3RcbiAqIHJlY2VudCBzb3VyY2UgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGlzIHByb2Nlc3NcbiAqIHJlcGVhdHMgZm9yIHRoZSBuZXh0IHNvdXJjZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmF1ZGl0KGV2ID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBPYnNlcnZhYmxlfFByb21pc2V9IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvblxuICogdGhhdCByZWNlaXZlcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBmb3IgY29tcHV0aW5nIHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyByYXRlLWxpbWl0aW5nIG9mXG4gKiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGF1ZGl0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBhdWRpdChkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQXVkaXRPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmF1ZGl0ID0gYXVkaXQ7XG52YXIgQXVkaXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXVkaXRPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgfVxuICAgIEF1ZGl0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgQXVkaXRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb25TZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1ZGl0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBdWRpdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXVkaXRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBBdWRpdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy50aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5kdXJhdGlvblNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB2YWx1ZSA9IF9hLnZhbHVlLCBoYXNWYWx1ZSA9IF9hLmhhc1ZhbHVlLCB0aHJvdHRsZWQgPSBfYS50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRocm90dGxlKCk7XG4gICAgfTtcbiAgICBBdWRpdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9hdWRpdC5qc1xuICoqIG1vZHVsZSBpZCA9IDU5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGF1ZGl0VGltZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYXVkaXRUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYXVkaXRUaW1lID0gYXVkaXRUaW1lXzEuYXVkaXRUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXRUaW1lLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2F1ZGl0VGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJZ25vcmVzIHNvdXJjZSB2YWx1ZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCB0aGVuIGVtaXRzIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW4gaXQgc2VlcyBhIHNvdXJjZSB2YWx1ZXMsIGl0IGlnbm9yZXMgdGhhdCBwbHVzXG4gKiB0aGUgbmV4dCBvbmVzIGZvciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gaXQgZW1pdHMgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYXVkaXRUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBhdWRpdFRpbWVgIGlzIHNpbWlsYXIgdG8gYHRocm90dGxlVGltZWAsIGJ1dCBlbWl0cyB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZVxuICogc2lsZW5jZWQgdGltZSB3aW5kb3csIGluc3RlYWQgb2YgdGhlIGZpcnN0IHZhbHVlLiBgYXVkaXRUaW1lYCBlbWl0cyB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBhcyBzb29uIGFzXG4gKiBpdHMgaW50ZXJuYWwgdGltZXIgYmVjb21lcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGlsZSB0aGVcbiAqIHRpbWVyIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdFxuICogc291cmNlIHZhbHVlIGFycml2ZXMsIHRoZSB0aW1lciBpcyBlbmFibGVkLiBBZnRlciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcyAob3JcbiAqIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgaGFzIHBhc3NlZCxcbiAqIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgdGhlbiB0aGUgbW9zdCByZWNlbnQgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuXG4gKiBPcHRpb25hbGx5IHRha2VzIGEge0BsaW5rIFNjaGVkdWxlcn0gZm9yIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmF1ZGl0VGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50IHNvdXJjZVxuICogdmFsdWUsIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcyBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseVxuICogYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSByYXRlLWxpbWl0aW5nIGJlaGF2aW9yLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHJhdGUtbGltaXRpbmcgb2ZcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgYXVkaXRUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBhdWRpdFRpbWUoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQXVkaXRUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5hdWRpdFRpbWUgPSBhdWRpdFRpbWU7XG52YXIgQXVkaXRUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGl0VGltZU9wZXJhdG9yKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgQXVkaXRUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgQXVkaXRUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1ZGl0VGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXVkaXRUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1ZGl0VGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXVkaXRUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgQXVkaXRUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVyYXRpb24sIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJUaHJvdHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgdmFsdWUgPSBfYS52YWx1ZSwgaGFzVmFsdWUgPSBfYS5oYXNWYWx1ZSwgdGhyb3R0bGVkID0gX2EudGhyb3R0bGVkO1xuICAgICAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1ZGl0VGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL2F1ZGl0VGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGxhc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2xhc3QnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5sYXN0ID0gbGFzdF8xLmxhc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL2xhc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1OTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvRW1wdHlFcnJvcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBsYXN0IGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBJdCBvcHRpb25hbGx5IHRha2VzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIGFzIGEgcGFyYW1ldGVyLCBpbiB3aGljaCBjYXNlLCByYXRoZXIgdGhhbiBlbWl0dGluZ1xuICogdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlIHdpbGwgZW1pdCB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbGFzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAdGhyb3dzIHtFbXB0eUVycm9yfSBEZWxpdmVycyBhbiBFbXB0eUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmBcbiAqIGNhbGxiYWNrIGlmIHRoZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBiZWZvcmUgYW55IGBuZXh0YCBub3RpZmljYXRpb24gd2FzIHNlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSB0aGUgY29uZGl0aW9uIGFueSBzb3VyY2UgZW1pdHRlZCBpdGVtIGhhcyB0byBzYXRpc2Z5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGxhc3QgaXRlbSBzYXRpc2Z5aW5nIHRoZSBnaXZlbiBjb25kaXRpb25cbiAqIGZyb20gdGhlIHNvdXJjZSwgb3IgYW4gTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiBpZiBubyBzdWNoIGl0ZW1zIGFyZSBlbWl0dGVkLlxuICogQHRocm93cyAtIFRocm93cyBpZiBubyBpdGVtcyB0aGF0IG1hdGNoIHRoZSBwcmVkaWNhdGUgYXJlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBsYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBsYXN0KHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IExhc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHRoaXMpKTtcbn1cbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG52YXIgTGFzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXN0T3BlcmF0b3IocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBMYXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IExhc3RTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5kZWZhdWx0VmFsdWUsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGFzdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTGFzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBMYXN0U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMYXN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9sYXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbGV0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9sZXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5sZXQgPSBsZXRfMS5sZXRQcm90bztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5sZXRCaW5kID0gbGV0XzEubGV0UHJvdG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbGV0LmpzXG4gKiogbW9kdWxlIGlkID0gNTk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQHBhcmFtIGZ1bmNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAbWV0aG9kIGxldFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbGV0UHJvdG8oZnVuYykge1xuICAgIHJldHVybiBmdW5jKHRoaXMpO1xufVxuZXhwb3J0cy5sZXRQcm90byA9IGxldFByb3RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvbGV0LmpzXG4gKiogbW9kdWxlIGlkID0gNTk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hcFRvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwVG8gPSBtYXBUb18xLm1hcFRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbWFwVG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1OThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyB0aGUgZ2l2ZW4gY29uc3RhbnQgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGV2ZXJ5IHRpbWUgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIHtAbGluayBtYXB9LCBidXQgaXQgbWFwcyBldmVyeSBzb3VyY2UgdmFsdWUgdG9cbiAqIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBldmVyeSB0aW1lLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRha2VzIGEgY29uc3RhbnQgYHZhbHVlYCBhcyBhcmd1bWVudCwgYW5kIGVtaXRzIHRoYXQgd2hlbmV2ZXIgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLiBJbiBvdGhlciB3b3JkcywgaWdub3JlcyB0aGUgYWN0dWFsIHNvdXJjZSB2YWx1ZSxcbiAqIGFuZCBzaW1wbHkgdXNlcyB0aGUgZW1pc3Npb24gbW9tZW50IHRvIGtub3cgd2hlbiB0byBlbWl0IHRoZSBnaXZlbiBgdmFsdWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgc3RyaW5nICdIaSc8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGdyZWV0aW5ncyA9IGNsaWNrcy5tYXBUbygnSGknKTtcbiAqIGdyZWV0aW5ncy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gbWFwIGVhY2ggc291cmNlIHZhbHVlIHRvLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBnaXZlbiBgdmFsdWVgIGV2ZXJ5IHRpbWVcbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBzb21ldGhpbmcuXG4gKiBAbWV0aG9kIG1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXBUbyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcFRvT3BlcmF0b3IodmFsdWUpKTtcbn1cbmV4cG9ydHMubWFwVG8gPSBtYXBUbztcbnZhciBNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBUb09wZXJhdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgTWFwVG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBNYXBUb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFRvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNYXBUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBUb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBUb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBUby5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL21hcFRvLmpzXG4gKiogbW9kdWxlIGlkID0gNTk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWF0ZXJpYWxpemVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hdGVyaWFsaXplJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWF0ZXJpYWxpemUgPSBtYXRlcmlhbGl6ZV8xLm1hdGVyaWFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0ZXJpYWxpemUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvbWF0ZXJpYWxpemUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHJlcHJlc2VudHMgYWxsIG9mIHRoZSBlbWlzc2lvbnMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGludG8gZW1pc3Npb25zIG1hcmtlZCB3aXRoIHRoZWlyIG9yaWdpbmFsIHR5cGVzXG4gKiB3aXRoaW4gYSBgTm90aWZpY2F0aW9uYCBvYmplY3RzLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWF0ZXJpYWxpemUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHNlZSB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICpcbiAqIEBzY2hlZHVsZXIgbWF0ZXJpYWxpemUgZG9lcyBub3Qgb3BlcmF0ZSBieSBkZWZhdWx0IG9uIGEgcGFydGljdWxhciBTY2hlZHVsZXIuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE5vdGlmaWNhdGlvbjxUPj59IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBtYXRlcmlhbGl6aW5nIHRoZSBpdGVtcyBhbmQgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1hdGVyaWFsaXplXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNYXRlcmlhbGl6ZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5tYXRlcmlhbGl6ZSA9IG1hdGVyaWFsaXplO1xudmFyIE1hdGVyaWFsaXplT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIE1hdGVyaWFsaXplT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgTWF0ZXJpYWxpemVTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXRlcmlhbGl6ZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWF0ZXJpYWxpemVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0ZXJpYWxpemVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIE1hdGVyaWFsaXplU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlRXJyb3IoZXJyKSk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0ZXJpYWxpemVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0ZXJpYWxpemUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9tYXRlcmlhbGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlTWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlTWFwVG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5mbGF0TWFwVG8gPSBtZXJnZU1hcFRvXzEubWVyZ2VNYXBUbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tZXJnZU1hcFRvID0gbWVyZ2VNYXBUb18xLm1lcmdlTWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcFRvLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwVG8uanNcbiAqKiBtb2R1bGUgaWQgPSA2MDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL211bHRpY2FzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm11bHRpY2FzdCA9IG11bHRpY2FzdF8xLm11bHRpY2FzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpY2FzdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9tdWx0aWNhc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA2MDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBvYnNlcnZlT25fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL29ic2VydmVPbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm9ic2VydmVPbiA9IG9ic2VydmVPbl8xLm9ic2VydmVPbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVPbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9vYnNlcnZlT24uanNcbiAqKiBtb2R1bGUgaWQgPSA2MDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwYXJ0aXRpb25fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3BhcnRpdGlvbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnBhcnRpdGlvbiA9IHBhcnRpdGlvbl8xLnBhcnRpdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpdGlvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9wYXJ0aXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2MDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIG5vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9ub3QnKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG4vKipcbiAqIFNwbGl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgaW50byB0d28sIG9uZSB3aXRoIHZhbHVlcyB0aGF0IHNhdGlzZnkgYVxuICogcHJlZGljYXRlLCBhbmQgYW5vdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRvbid0IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBmaWx0ZXJ9LCBidXQgcmV0dXJucyB0d28gT2JzZXJ2YWJsZXM6XG4gKiBvbmUgbGlrZSB0aGUgb3V0cHV0IG9mIHtAbGluayBmaWx0ZXJ9LCBhbmQgdGhlIG90aGVyIHdpdGggdmFsdWVzIHRoYXQgZGlkIG5vdFxuICogcGFzcyB0aGUgY29uZGl0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhcnRpdGlvbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgcGFydGl0aW9uYCBvdXRwdXRzIGFuIGFycmF5IHdpdGggdHdvIE9ic2VydmFibGVzIHRoYXQgcGFydGl0aW9uIHRoZSB2YWx1ZXNcbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRocm91Z2ggdGhlIGdpdmVuIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLiBUaGUgZmlyc3RcbiAqIE9ic2VydmFibGUgaW4gdGhhdCBhcnJheSBlbWl0cyBzb3VyY2UgdmFsdWVzIGZvciB3aGljaCB0aGUgcHJlZGljYXRlIGFyZ3VtZW50XG4gKiByZXR1cm5zIHRydWUuIFRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0cyBzb3VyY2UgdmFsdWVzIGZvciB3aGljaCB0aGVcbiAqIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlLiBUaGUgZmlyc3QgYmVoYXZlcyBsaWtlIHtAbGluayBmaWx0ZXJ9IGFuZCB0aGUgc2Vjb25kXG4gKiBiZWhhdmVzIGxpa2Uge0BsaW5rIGZpbHRlcn0gd2l0aCB0aGUgcHJlZGljYXRlIG5lZ2F0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UGFydGl0aW9uIGNsaWNrIGV2ZW50cyBpbnRvIHRob3NlIG9uIERJViBlbGVtZW50cyBhbmQgdGhvc2UgZWxzZXdoZXJlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYXJ0cyA9IGNsaWNrcy5wYXJ0aXRpb24oZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHZhciBjbGlja3NPbkRpdnMgPSBwYXJ0c1swXTtcbiAqIHZhciBjbGlja3NFbHNld2hlcmUgPSBwYXJ0c1sxXTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnRElWIGNsaWNrZWQ6ICcsIHgpKTtcbiAqIGNsaWNrc0Vsc2V3aGVyZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnT3RoZXIgY2xpY2tlZDogJywgeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGl0IHJldHVybnMgYHRydWVgLFxuICogdGhlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIGZpcnN0IE9ic2VydmFibGUgaW4gdGhlIHJldHVybmVkIGFycmF5LCBpZlxuICogYGZhbHNlYCB0aGUgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgc2Vjb25kIE9ic2VydmFibGUgaW4gdGhlIGFycmF5LiBUaGVcbiAqIGBpbmRleGAgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2UgZW1pc3Npb24gdGhhdCBoYXNcbiAqIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtbT2JzZXJ2YWJsZTxUPiwgT2JzZXJ2YWJsZTxUPl19IEFuIGFycmF5IHdpdGggdHdvIE9ic2VydmFibGVzOiBvbmVcbiAqIHdpdGggdmFsdWVzIHRoYXQgcGFzc2VkIHRoZSBwcmVkaWNhdGUsIGFuZCBhbm90aGVyIHdpdGggdmFsdWVzIHRoYXQgZGlkIG5vdFxuICogcGFzcyB0aGUgcHJlZGljYXRlLlxuICogQG1ldGhvZCBwYXJ0aXRpb25cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBmaWx0ZXJfMS5maWx0ZXIuY2FsbCh0aGlzLCBwcmVkaWNhdGUpLFxuICAgICAgICBmaWx0ZXJfMS5maWx0ZXIuY2FsbCh0aGlzLCBub3RfMS5ub3QocHJlZGljYXRlLCB0aGlzQXJnKSlcbiAgICBdO1xufVxuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aXRpb24uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9wYXJ0aXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2MDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbm90KHByZWQsIHRoaXNBcmcpIHtcbiAgICBmdW5jdGlvbiBub3RQcmVkKCkge1xuICAgICAgICByZXR1cm4gIShub3RQcmVkLnByZWQuYXBwbHkobm90UHJlZC50aGlzQXJnLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgbm90UHJlZC5wcmVkID0gcHJlZDtcbiAgICBub3RQcmVkLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIHJldHVybiBub3RQcmVkO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy91dGlsL25vdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHB1Ymxpc2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3B1Ymxpc2gnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5wdWJsaXNoID0gcHVibGlzaF8xLnB1Ymxpc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2guanNcbiAqKiBtb2R1bGUgaWQgPSA2MDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIFJldHVybnMgYSBDb25uZWN0YWJsZU9ic2VydmFibGUsIHdoaWNoIGlzIGEgdmFyaWV0eSBvZiBPYnNlcnZhYmxlIHRoYXQgd2FpdHMgdW50aWwgaXRzIGNvbm5lY3QgbWV0aG9kIGlzIGNhbGxlZFxuICogYmVmb3JlIGl0IGJlZ2lucyBlbWl0dGluZyBpdGVtcyB0byB0aG9zZSBPYnNlcnZlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdG8gaXQuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wdWJsaXNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4gYSBDb25uZWN0YWJsZU9ic2VydmFibGUgdGhhdCB1cG9uIGNvbm5lY3Rpb24gY2F1c2VzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0byBlbWl0IGl0ZW1zIHRvIGl0cyBPYnNlcnZlcnMuXG4gKiBAbWV0aG9kIHB1Ymxpc2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2goKSB7XG4gICAgcmV0dXJuIG11bHRpY2FzdF8xLm11bHRpY2FzdC5jYWxsKHRoaXMsIG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpKTtcbn1cbmV4cG9ydHMucHVibGlzaCA9IHB1Ymxpc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvcHVibGlzaC5qc1xuICoqIG1vZHVsZSBpZCA9IDYxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHB1Ymxpc2hCZWhhdmlvcl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaEJlaGF2aW9yID0gcHVibGlzaEJlaGF2aW9yXzEucHVibGlzaEJlaGF2aW9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaEJlaGF2aW9yLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvci5qc1xuICoqIG1vZHVsZSBpZCA9IDYxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQmVoYXZpb3JTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9CZWhhdmlvclN1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybiB7Q29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBwdWJsaXNoQmVoYXZpb3JcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hCZWhhdmlvcih2YWx1ZSkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0KHZhbHVlKSk7XG59XG5leHBvcnRzLnB1Ymxpc2hCZWhhdmlvciA9IHB1Ymxpc2hCZWhhdmlvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hCZWhhdmlvci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvci5qc1xuICoqIG1vZHVsZSBpZCA9IDYxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHB1Ymxpc2hSZXBsYXlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3B1Ymxpc2hSZXBsYXknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5wdWJsaXNoUmVwbGF5ID0gcHVibGlzaFJlcGxheV8xLnB1Ymxpc2hSZXBsYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoUmVwbGF5LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2hSZXBsYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA2MTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwdWJsaXNoTGFzdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcHVibGlzaExhc3QnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5wdWJsaXNoTGFzdCA9IHB1Ymxpc2hMYXN0XzEucHVibGlzaExhc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoTGFzdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9wdWJsaXNoTGFzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXN5bmNTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9Bc3luY1N1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaExhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hMYXN0KCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCkpO1xufVxuZXhwb3J0cy5wdWJsaXNoTGFzdCA9IHB1Ymxpc2hMYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaExhc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9wdWJsaXNoTGFzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJhY2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JhY2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5yYWNlID0gcmFjZV8xLnJhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3JhY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2MTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByZWR1Y2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JlZHVjZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnJlZHVjZSA9IHJlZHVjZV8xLnJlZHVjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9yZWR1Y2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2MTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBhcHBsaWVzIGEgc3BlY2lmaWVkIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIHRoZSBmaXJzdCBpdGVtIGVtaXR0ZWQgYnkgYSBzb3VyY2UgT2JzZXJ2YWJsZSxcbiAqIHRoZW4gZmVlZHMgdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uIGFsb25nIHdpdGggdGhlIHNlY29uZCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGludG8gdGhlIHNhbWVcbiAqIGZ1bmN0aW9uLCBhbmQgc28gb24gdW50aWwgYWxsIGl0ZW1zIGhhdmUgYmVlbiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoZSBmaW5hbCByZXN1bHQgZnJvbVxuICogdGhlIGZpbmFsIGNhbGwgdG8geW91ciBmdW5jdGlvbiBhcyBpdHMgc29sZSBpdGVtLlxuICogVGhpcyB0ZWNobmlxdWUsIHdoaWNoIGlzIGNhbGxlZCBcInJlZHVjZVwiIGhlcmUsIGlzIHNvbWV0aW1lcyBjYWxsZWQgXCJhZ2dyZWdhdGUsXCIgXCJmb2xkLFwiIFwiYWNjdW11bGF0ZSxcIiBcImNvbXByZXNzLFwiIG9yXG4gKiBcImluamVjdFwiIGluIG90aGVyIHByb2dyYW1taW5nIGNvbnRleHRzLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmVkdWNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7aW5pdGlhbFZhbHVlfSB0aGUgaW5pdGlhbCAoc2VlZCkgYWNjdW11bGF0b3IgdmFsdWVcbiAqIEBwYXJhbSB7YWNjdW11bGF0b3J9IGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVcbiAqIHJlc3VsdCBvZiB3aGljaCB3aWxsIGJlIHVzZWQgaW4gdGhlIG5leHQgYWNjdW11bGF0b3IgY2FsbC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNpbmdsZSBpdGVtIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhY2N1bXVsYXRpbmcgdGhlIG91dHB1dCBmcm9tIHRoZVxuICogaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHJlZHVjZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKHByb2plY3QsIHNlZWQpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWR1Y2VPcGVyYXRvcihwcm9qZWN0LCBzZWVkKSk7XG59XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbnZhciBSZWR1Y2VPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVkdWNlT3BlcmF0b3IocHJvamVjdCwgc2VlZCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgIH1cbiAgICBSZWR1Y2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBSZWR1Y2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5zZWVkKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5SZWR1Y2VPcGVyYXRvciA9IFJlZHVjZU9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZWR1Y2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVkdWNlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCBzZWVkKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjYyA9IHNlZWQ7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuaGFzU2VlZCA9IHR5cGVvZiBzZWVkICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgUmVkdWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUgfHwgKHRoaXMuaGFzVmFsdWUgPSB0aGlzLmhhc1NlZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlSZWR1Y2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY2MgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWR1Y2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UmVkdWNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodGhpcy5hY2MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2MgPSByZXN1bHQ7XG4gICAgfTtcbiAgICBSZWR1Y2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlIHx8IHRoaXMuaGFzU2VlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuYWNjKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuUmVkdWNlU3Vic2NyaWJlciA9IFJlZHVjZVN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9yZWR1Y2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2MThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByZXBlYXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JlcGVhdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnJlcGVhdCA9IHJlcGVhdF8xLnJlcGVhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9yZXBlYXQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcmVwZWF0cyB0aGUgc3RyZWFtIG9mIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IG1vc3QgY291bnQgdGltZXMsXG4gKiBvbiBhIHBhcnRpY3VsYXIgU2NoZWR1bGVyLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmVwZWF0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSB0aGUgU2NoZWR1bGVyIHRvIGVtaXQgdGhlIGl0ZW1zIG9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc291cmNlIE9ic2VydmFibGUgaXRlbXMgYXJlIHJlcGVhdGVkLCBhIGNvdW50IG9mIDAgd2lsbCB5aWVsZFxuICogYW4gZW1wdHkgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCByZXBlYXRzIHRoZSBzdHJlYW0gb2YgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgbW9zdFxuICogY291bnQgdGltZXMuXG4gKiBAbWV0aG9kIHJlcGVhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAtMTsgfVxuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVwZWF0T3BlcmF0b3IoLTEsIHRoaXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJlcGVhdE9wZXJhdG9yKGNvdW50IC0gMSwgdGhpcykpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xudmFyIFJlcGVhdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBlYXRPcGVyYXRvcihjb3VudCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJlcGVhdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFJlcGVhdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb3VudCwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJlcGVhdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBlYXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGVhdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvdW50LCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXBlYXRTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgc291cmNlID0gX2Euc291cmNlLCBjb3VudCA9IF9hLmNvdW50O1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvcmVwZWF0LmpzXG4gKiogbW9kdWxlIGlkID0gNjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmV0cnlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JldHJ5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmV0cnkgPSByZXRyeV8xLnJldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvcmV0cnkuanNcbiAqKiBtb2R1bGUgaWQgPSA2MjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmVzdWJzY3JpYmluZyB0byBpdCBpZiBpdCBjYWxscyBgZXJyb3JgIGFuZCB0aGVcbiAqIHByZWRpY2F0ZSByZXR1cm5zIHRydWUgZm9yIHRoYXQgc3BlY2lmaWMgZXhjZXB0aW9uIGFuZCByZXRyeSBjb3VudC5cbiAqIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBjYWxscyBgZXJyb3JgLCB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBmb3IgYSBtYXhpbXVtIG9mXG4gKiBjb3VudCByZXN1YnNjcmlwdGlvbnMgKGdpdmVuIGFzIGEgbnVtYmVyIHBhcmFtZXRlcikgcmF0aGVyIHRoYW4gcHJvcGFnYXRpbmcgdGhlIGBlcnJvcmAgY2FsbC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3JldHJ5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEFueSBhbmQgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUsIGV2ZW4gdGhvc2UgZW1pdHRlZFxuICogZHVyaW5nIGZhaWxlZCBzdWJzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgaWYgYW4gT2JzZXJ2YWJsZSBmYWlscyBhdCBmaXJzdCBidXQgZW1pdHMgWzEsIDJdIHRoZW4gc3VjY2VlZHMgdGhlIHNlY29uZFxuICogdGltZSBhbmQgZW1pdHM6IFsxLCAyLCAzLCA0LCA1XSB0aGVuIHRoZSBjb21wbGV0ZSBzdHJlYW0gb2YgZW1pc3Npb25zIGFuZCBub3RpZmljYXRpb25zXG4gKiB3b3VsZCBiZTogWzEsIDIsIDEsIDIsIDMsIDQsIDUsIGBjb21wbGV0ZWBdLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBiZWZvcmUgZmFpbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHRoZSByZXRyeSBsb2dpYy5cbiAqIEBtZXRob2QgcmV0cnlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJldHJ5KGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAtMTsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJldHJ5T3BlcmF0b3IoY291bnQsIHRoaXMpKTtcbn1cbmV4cG9ydHMucmV0cnkgPSByZXRyeTtcbnZhciBSZXRyeU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXRyeU9wZXJhdG9yKGNvdW50LCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBSZXRyeVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb3VudCwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmV0cnlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0cnlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY291bnQsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5U3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHNvdXJjZSA9IF9hLnNvdXJjZSwgY291bnQgPSBfYS5jb3VudDtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3JldHJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNjIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2FtcGxlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zYW1wbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGUgPSBzYW1wbGVfMS5zYW1wbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2FtcGxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuZXZlclxuICogYW5vdGhlciBPYnNlcnZhYmxlLCB0aGUgYG5vdGlmaWVyYCwgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc2FtcGxlVGltZX0sIGJ1dCBzYW1wbGVzIHdoZW5ldmVyXG4gKiB0aGUgYG5vdGlmaWVyYCBPYnNlcnZhYmxlIGVtaXRzIHNvbWV0aGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zYW1wbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogV2hlbmV2ZXIgdGhlIGBub3RpZmllcmAgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgYHNhbXBsZWBcbiAqIGxvb2tzIGF0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgZW1pdHMgd2hpY2hldmVyIHZhbHVlIGl0IGhhcyBtb3N0IHJlY2VudGx5XG4gKiBlbWl0dGVkIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZywgdW5sZXNzIHRoZSBzb3VyY2UgaGFzIG5vdCBlbWl0dGVkXG4gKiBhbnl0aGluZyBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcuIFRoZSBgbm90aWZpZXJgIGlzIHN1YnNjcmliZWQgdG8gYXMgc29vblxuICogYXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIHNhbXBsZSB0aGUgbW9zdCByZWNlbnQgXCJzZWNvbmRzXCIgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IHNlY29uZHMuc2FtcGxlKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHRvIHVzZSBmb3Igc2FtcGxpbmcgdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBzYW1wbGluZyB0aGVcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuZXZlciB0aGUgbm90aWZpZXIgT2JzZXJ2YWJsZVxuICogZW1pdHMgdmFsdWUgb3IgY29tcGxldGVzLlxuICogQG1ldGhvZCBzYW1wbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZShub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNhbXBsZU9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZTtcbnZhciBTYW1wbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FtcGxlT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBTYW1wbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBTYW1wbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhbXBsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYW1wbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhbXBsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5vdGlmaWVyKSk7XG4gICAgfVxuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLmVtaXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3Ivc2FtcGxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2FtcGxlVGltZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2FtcGxlVGltZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNhbXBsZVRpbWUgPSBzYW1wbGVUaW1lXzEuc2FtcGxlVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbXBsZVRpbWUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2FtcGxlVGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGhpblxuICogcGVyaW9kaWMgdGltZSBpbnRlcnZhbHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNhbXBsZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IHBlcmlvZGljIHRpbWVcbiAqIGludGVydmFscywgZW1pdHRpbmcgd2hhdCBpdCBzYW1wbGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NhbXBsZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNhbXBsZVRpbWVgIHBlcmlvZGljYWxseSBsb29rcyBhdCB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGVtaXRzIHdoaWNoZXZlclxuICogdmFsdWUgaXQgaGFzIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcsIHVubGVzcyB0aGVcbiAqIHNvdXJjZSBoYXMgbm90IGVtaXR0ZWQgYW55dGhpbmcgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLiBUaGUgc2FtcGxpbmdcbiAqIGhhcHBlbnMgcGVyaW9kaWNhbGx5IGluIHRpbWUgZXZlcnkgYHBlcmlvZGAgbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZSB1bml0XG4gKiBkZWZpbmVkIGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCBhcmd1bWVudCkuIFRoZSBzYW1wbGluZyBzdGFydHMgYXMgc29vbiBhc1xuICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgc2Vjb25kLCBlbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhdCBtb3N0IG9uY2U8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zYW1wbGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIFRoZSBzYW1wbGluZyBwZXJpb2QgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcyBvciB0aGVcbiAqIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBzYW1wbGluZyB0aGVcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWUgaW50ZXJ2YWwuXG4gKiBAbWV0aG9kIHNhbXBsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVRpbWUocGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5zYW1wbGVUaW1lID0gc2FtcGxlVGltZTtcbnZhciBTYW1wbGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIFNhbXBsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBTYW1wbGVUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnBlcmlvZCwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYW1wbGVUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhbXBsZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhbXBsZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucGVyaW9kID0gcGVyaW9kO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOb3RpZmljYXRpb24sIHBlcmlvZCwgeyBzdWJzY3JpYmVyOiB0aGlzLCBwZXJpb2Q6IHBlcmlvZCB9KSk7XG4gICAgfVxuICAgIFNhbXBsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNhbXBsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOb3RpZmljYXRpb24oc3RhdGUpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHBlcmlvZCA9IHN0YXRlLnBlcmlvZDtcbiAgICBzdWJzY3JpYmVyLm5vdGlmeU5leHQoKTtcbiAgICB0aGlzLnNjaGVkdWxlKHN0YXRlLCBwZXJpb2QpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlVGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3NhbXBsZVRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzaW5nbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NpbmdsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNpbmdsZSA9IHNpbmdsZV8xLnNpbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbmdsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9zaW5nbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvRW1wdHlFcnJvcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2luZ2xlIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzIGEgc3BlY2lmaWVkXG4gKiBwcmVkaWNhdGUsIGlmIHRoYXQgT2JzZXJ2YWJsZSBlbWl0cyBvbmUgc3VjaCBpdGVtLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgbW9yZSB0aGFuIG9uZSBzdWNoIGl0ZW0gb3Igbm9cbiAqIHN1Y2ggaXRlbXMsIG5vdGlmeSBvZiBhbiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gb3IgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiByZXNwZWN0aXZlbHkuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zaW5nbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHRocm93cyB7RW1wdHlFcnJvcn0gRGVsaXZlcnMgYW4gRW1wdHlFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgXG4gKiBjYWxsYmFjayBpZiB0aGUgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgYmVmb3JlIGFueSBgbmV4dGAgbm90aWZpY2F0aW9uIHdhcyBzZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZXZhbHVhdGUgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHNpbmdsZSBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlc1xuICogdGhlIHByZWRpY2F0ZS5cbiAuXG4gKiBAbWV0aG9kIHNpbmdsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2luZ2xlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNpbmdsZU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpcykpO1xufVxuZXhwb3J0cy5zaW5nbGUgPSBzaW5nbGU7XG52YXIgU2luZ2xlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbmdsZU9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgU2luZ2xlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgU2luZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNpbmdsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW5nbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbmdsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNlZW5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2luZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuYXBwbHlTaW5nbGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZWVuVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoJ1NlcXVlbmNlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWVuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5wcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbmdsZVN1YnNjcmliZXIucHJvdG90eXBlLnRyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLnNlZW5WYWx1ZSA/IHRoaXMuc2luZ2xlVmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2luZ2xlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3Ivc2luZ2xlLmpzXG4gKiogbW9kdWxlIGlkID0gNjMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2tpcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2tpcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNraXAgPSBza2lwXzEuc2tpcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXAuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGBuYCBpdGVtcyBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGUgYG5gIG9mIHRpbWVzLCBpdGVtcyBlbWl0dGVkIGJ5IHNvdXJjZSBPYnNlcnZhYmxlIHNob3VsZCBiZSBza2lwcGVkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXAodG90YWwpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTa2lwT3BlcmF0b3IodG90YWwpKTtcbn1cbmV4cG9ydHMuc2tpcCA9IHNraXA7XG52YXIgU2tpcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIH1cbiAgICBTa2lwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgU2tpcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNraXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2tpcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgU2tpcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCsrdGhpcy5jb3VudCA+IHRoaXMudG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNraXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3NraXAuanNcbiAqKiBtb2R1bGUgaWQgPSA2MzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBza2lwVW50aWxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NraXBVbnRpbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNraXBVbnRpbCA9IHNraXBVbnRpbF8xLnNraXBVbnRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXBVbnRpbC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9za2lwVW50aWwuanNcbiAqKiBtb2R1bGUgaWQgPSA2MzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBza2lwcyBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCBhIHNlY29uZCBPYnNlcnZhYmxlIGVtaXRzIGFuIGl0ZW0uXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSB0aGUgc2Vjb25kIE9ic2VydmFibGUgdGhhdCBoYXMgdG8gZW1pdCBhbiBpdGVtIGJlZm9yZSB0aGUgc291cmNlIE9ic2VydmFibGUncyBlbGVtZW50cyBiZWdpbiB0b1xuICogYmUgbWlycm9yZWQgYnkgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0c1xuICogYW4gaXRlbSwgdGhlbiBlbWl0cyB0aGUgcmVtYWluaW5nIGl0ZW1zLlxuICogQG1ldGhvZCBza2lwVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXBVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNraXBVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnNraXBVbnRpbCA9IHNraXBVbnRpbDtcbnZhciBTa2lwVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBTa2lwVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBTa2lwVW50aWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTa2lwVW50aWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNraXBVbnRpbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTa2lwVW50aWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNraXBVbnRpbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW5uZXJTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbm90aWZpZXIpKTtcbiAgICB9XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNraXBVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbm5lclN0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNraXBVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTa2lwVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0lubmVyU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNraXBVbnRpbFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFVudGlsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3Ivc2tpcFVudGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNjM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2tpcFdoaWxlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9za2lwV2hpbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwV2hpbGUgPSBza2lwV2hpbGVfMS5za2lwV2hpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwV2hpbGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcFdoaWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIGxvbmcgYXMgYSBzcGVjaWZpZWQgY29uZGl0aW9uIGhvbGRzXG4gKiB0cnVlLCBidXQgZW1pdHMgYWxsIGZ1cnRoZXIgc291cmNlIGl0ZW1zIGFzIHNvb24gYXMgdGhlIGNvbmRpdGlvbiBiZWNvbWVzIGZhbHNlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcFdoaWxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIGEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGl0ZW0gZW1pdHRlZCBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IGFuIE9ic2VydmFibGUgdGhhdCBiZWdpbnMgZW1pdHRpbmcgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2hlbiB0aGVcbiAqIHNwZWNpZmllZCBwcmVkaWNhdGUgYmVjb21lcyBmYWxzZS5cbiAqIEBtZXRob2Qgc2tpcFdoaWxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2tpcFdoaWxlT3BlcmF0b3IocHJlZGljYXRlKSk7XG59XG5leHBvcnRzLnNraXBXaGlsZSA9IHNraXBXaGlsZTtcbnZhciBTa2lwV2hpbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2tpcFdoaWxlT3BlcmF0b3IocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIH1cbiAgICBTa2lwV2hpbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBTa2lwV2hpbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFdoaWxlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTa2lwV2hpbGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2tpcFdoaWxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5za2lwcGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTa2lwV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAodGhpcy5za2lwcGluZykge1xuICAgICAgICAgICAgdGhpcy50cnlDYWxsUHJlZGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2tpcHBpbmcpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTa2lwV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlDYWxsUHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgICAgICAgICB0aGlzLnNraXBwaW5nID0gQm9vbGVhbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNraXBXaGlsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwV2hpbGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9za2lwV2hpbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzdGFydFdpdGhfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N0YXJ0V2l0aCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aF8xLnN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9zdGFydFdpdGguanNcbiAqKiBtb2R1bGUgaWQgPSA2MzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKCcuL2NvbmNhdCcpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiBhIHNwZWNpZmllZCBJdGVyYWJsZSBiZWZvcmUgaXQgYmVnaW5zIHRvIGVtaXQgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3RhcnRXaXRoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7VmFsdWVzfSBhbiBJdGVyYWJsZSB0aGF0IGNvbnRhaW5zIHRoZSBpdGVtcyB5b3Ugd2FudCB0aGUgbW9kaWZpZWQgT2JzZXJ2YWJsZSB0byBlbWl0IGZpcnN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICBhcnJheS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3N0YXJ0V2l0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHN1YnNjcmliZU9uXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zdWJzY3JpYmVPbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZU9uID0gc3Vic2NyaWJlT25fMS5zdWJzY3JpYmVPbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZU9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3N1YnNjcmliZU9uLmpzXG4gKiogbW9kdWxlIGlkID0gNjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVPbk9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU3Vic2NyaWJlT25PYnNlcnZhYmxlJyk7XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHN1YnNjcmliZXMgT2JzZXJ2ZXJzIHRvIHRoaXMgT2JzZXJ2YWJsZSBvbiB0aGUgc3BlY2lmaWVkIFNjaGVkdWxlci5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N1YnNjcmliZU9uLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSB0aGUgU2NoZWR1bGVyIHRvIHBlcmZvcm0gc3Vic2NyaXB0aW9uIGFjdGlvbnMgb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSB0aGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgc28gdGhhdCBpdHMgc3Vic2NyaXB0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBTY2hlZHVsZXJcbiAuXG4gKiBAbWV0aG9kIHN1YnNjcmliZU9uXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzdWJzY3JpYmVPbihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVPbk9ic2VydmFibGVfMS5TdWJzY3JpYmVPbk9ic2VydmFibGUodGhpcywgZGVsYXksIHNjaGVkdWxlcik7XG59XG5leHBvcnRzLnN1YnNjcmliZU9uID0gc3Vic2NyaWJlT247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVPbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3N1YnNjcmliZU9uLmpzXG4gKiogbW9kdWxlIGlkID0gNjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc2FwXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXNhcCcpO1xudmFyIGlzTnVtZXJpY18xID0gcmVxdWlyZSgnLi4vdXRpbC9pc051bWVyaWMnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgU3Vic2NyaWJlT25PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaWJlT25PYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZU9uT2JzZXJ2YWJsZShzb3VyY2UsIGRlbGF5VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChkZWxheVRpbWUgPT09IHZvaWQgMCkgeyBkZWxheVRpbWUgPSAwOyB9XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc2FwXzEuYXNhcDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZGVsYXlUaW1lID0gZGVsYXlUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFpc051bWVyaWNfMS5pc051bWVyaWMoZGVsYXlUaW1lKSB8fCBkZWxheVRpbWUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgfHwgdHlwZW9mIHNjaGVkdWxlci5zY2hlZHVsZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBhc2FwXzEuYXNhcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVPbk9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzYXBfMS5hc2FwOyB9XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlT25PYnNlcnZhYmxlKHNvdXJjZSwgZGVsYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVPbk9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmcuc291cmNlLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlT25PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5kZWxheVRpbWU7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFN1YnNjcmliZU9uT2JzZXJ2YWJsZS5kaXNwYXRjaCwgZGVsYXksIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZU9uT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3Vic2NyaWJlT25PYnNlcnZhYmxlID0gU3Vic2NyaWJlT25PYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlT25PYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb2JzZXJ2YWJsZS9TdWJzY3JpYmVPbk9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFzYXBTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vQXNhcFNjaGVkdWxlcicpO1xuZXhwb3J0cy5hc2FwID0gbmV3IEFzYXBTY2hlZHVsZXJfMS5Bc2FwU2NoZWR1bGVyKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc2FwLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvc2NoZWR1bGVyL2FzYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA2NDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXNhcEFjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc2FwQWN0aW9uJyk7XG52YXIgUXVldWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vUXVldWVTY2hlZHVsZXInKTtcbnZhciBBc2FwU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNhcFNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc2FwU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXNhcFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVOb3cgPSBmdW5jdGlvbiAod29yaywgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc2FwQWN0aW9uXzEuQXNhcEFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXNhcFNjaGVkdWxlcjtcbn0oUXVldWVTY2hlZHVsZXJfMS5RdWV1ZVNjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc2FwU2NoZWR1bGVyID0gQXNhcFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzYXBTY2hlZHVsZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBJbW1lZGlhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvSW1tZWRpYXRlJyk7XG52YXIgRnV0dXJlQWN0aW9uXzEgPSByZXF1aXJlKCcuL0Z1dHVyZUFjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBc2FwQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNhcEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc2FwQWN0aW9uKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXNhcEFjdGlvbi5wcm90b3R5cGUuX3NjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3NjaGVkdWxlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBzY2hlZHVsZXIuYWN0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgICBpZiAoIXNjaGVkdWxlci5zY2hlZHVsZWRJZCkge1xuICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlZElkID0gSW1tZWRpYXRlXzEuSW1tZWRpYXRlLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlZElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIuZmx1c2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXNhcEFjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBzY2hlZHVsZWRJZCA9IHNjaGVkdWxlci5zY2hlZHVsZWRJZCwgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl91bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHNjaGVkdWxlci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzY2hlZHVsZWRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlZElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBJbW1lZGlhdGVfMS5JbW1lZGlhdGUuY2xlYXJJbW1lZGlhdGUoc2NoZWR1bGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXNhcEFjdGlvbjtcbn0oRnV0dXJlQWN0aW9uXzEuRnV0dXJlQWN0aW9uKSk7XG5leHBvcnRzLkFzYXBBY3Rpb24gPSBBc2FwQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNhcEFjdGlvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL3NjaGVkdWxlci9Bc2FwQWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcblNvbWUgY3JlZGl0IGZvciB0aGlzIGhlbHBlciBnb2VzIHRvIGh0dHA6Ly9naXRodWIuY29tL1l1enVKUy9zZXRJbW1lZGlhdGVcbiovXG5cInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBJbW1lZGlhdGVEZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbW1lZGlhdGVEZWZpbml0aW9uKHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgaWYgKHJvb3Quc2V0SW1tZWRpYXRlICYmIHR5cGVvZiByb290LnNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSByb290LnNldEltbWVkaWF0ZS5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckltbWVkaWF0ZSA9IHJvb3QuY2xlYXJJbW1lZGlhdGUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEhhbmRsZSA9IDE7XG4gICAgICAgICAgICB0aGlzLnRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5Vc2VQcm9jZXNzTmV4dFRpY2soKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlUHJvY2Vzc05leHRUaWNrU2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVBvc3RNZXNzYWdlU2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhblVzZU1lc3NhZ2VDaGFubmVsKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVNZXNzYWdlQ2hhbm5lbFNldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYW5Vc2VSZWFkeVN0YXRlQ2hhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlUmVhZHlTdGF0ZUNoYW5nZVNldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVNldFRpbWVvdXRTZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaSA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjbGVhckltbWVkaWF0ZS5pbnN0YW5jZS50YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2kuaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jbGVhckltbWVkaWF0ZSA9IGNpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jYW5Vc2VQcm9jZXNzTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZ5KHRoaXMucm9vdC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY2FuVXNlTWVzc2FnZUNoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucm9vdC5NZXNzYWdlQ2hhbm5lbCk7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jYW5Vc2VSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLnJvb3QuZG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50ICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKTtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNhblVzZVBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgcm9vdC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChyb290LnBvc3RNZXNzYWdlICYmICFyb290LmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzXzEgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IHJvb3Qub25tZXNzYWdlO1xuICAgICAgICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91c18xID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm9vdC5wb3N0TWVzc2FnZSgnJywgJyonKTtcbiAgICAgICAgICAgIHJvb3Qub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXNfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLnBhcnRpYWxseUFwcGxpZWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiByZXN1bHQoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZXN1bHQsIGhhbmRsZXIgPSBfYS5oYW5kbGVyLCBhcmdzID0gX2EuYXJncztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChuZXcgRnVuY3Rpb24oJycgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm4uaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIGZuLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdGhpcy50YXNrc0J5SGFuZGxlW3RoaXMubmV4dEhhbmRsZV0gPSB0aGlzLnBhcnRpYWxseUFwcGxpZWQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEhhbmRsZSsrO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlUHJvY2Vzc05leHRUaWNrU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBzZXRJbW1lZGlhdGUuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgaW5zdGFuY2Uucm9vdC5wcm9jZXNzLm5leHRUaWNrKGluc3RhbmNlLnBhcnRpYWxseUFwcGxpZWQoaW5zdGFuY2UucnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlUG9zdE1lc3NhZ2VTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSAnc2V0SW1tZWRpYXRlJCcgKyByb290Lk1hdGgucmFuZG9tKCkgKyAnJCc7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbiBnbG9iYWxNZXNzYWdlSGFuZGxlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZ2xvYmFsTWVzc2FnZUhhbmRsZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSByb290ICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG9uR2xvYmFsTWVzc2FnZS5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBzZXRJbW1lZGlhdGUsIG1lc3NhZ2VQcmVmaXggPSBfYS5tZXNzYWdlUHJlZml4LCBpbnN0YW5jZSA9IF9hLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnJvb3QucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgJyonKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgZm4ubWVzc2FnZVByZWZpeCA9IG1lc3NhZ2VQcmVmaXg7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLnJ1bklmUHJlc2VudCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogJ1dhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLidcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gJ3RvbyBtdWNoIHJlY3Vyc2lvbicgZXJyb3IuXG4gICAgICAgICAgICB0aGlzLnJvb3Quc2V0VGltZW91dCh0aGlzLnBhcnRpYWxseUFwcGxpZWQodGhpcy5ydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0aGlzLnRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNyZWF0ZU1lc3NhZ2VDaGFubmVsU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyB0aGlzLnJvb3QuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgX3RoaXMucnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHNldEltbWVkaWF0ZSwgY2hhbm5lbCA9IF9hLmNoYW5uZWwsIGluc3RhbmNlID0gX2EuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlUmVhZHlTdGF0ZUNoYW5nZVNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gc2V0SW1tZWRpYXRlLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBpbnN0YW5jZS5yb290O1xuICAgICAgICAgICAgdmFyIGRvYyA9IHJvb3QuZG9jdW1lbnQ7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jcmVhdGVTZXRUaW1lb3V0U2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBzZXRJbW1lZGlhdGUuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgaW5zdGFuY2Uucm9vdC5zZXRUaW1lb3V0KGluc3RhbmNlLnBhcnRpYWxseUFwcGxpZWQoaW5zdGFuY2UucnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgcmV0dXJuIEltbWVkaWF0ZURlZmluaXRpb247XG59KCkpO1xuZXhwb3J0cy5JbW1lZGlhdGVEZWZpbml0aW9uID0gSW1tZWRpYXRlRGVmaW5pdGlvbjtcbmV4cG9ydHMuSW1tZWRpYXRlID0gbmV3IEltbWVkaWF0ZURlZmluaXRpb24ocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1tZWRpYXRlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvdXRpbC9JbW1lZGlhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4gKiogbW9kdWxlIGlkID0gNjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2gnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDY0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgYnlcbiAqIHN1YnNjcmliaW5nIHRvIG9ubHkgdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBvZiB0aG9zZSBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBieSBkcm9wcGluZyB0aGVcbiAqIHByZXZpb3VzIGlubmVyIE9ic2VydmFibGUgb25jZSBhIG5ldyBvbmUgYXBwZWFycy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHN3aXRjaGAgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMsIGFsc28ga25vd24gYXMgYVxuICogaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2UgZW1pdHRlZCBpbm5lclxuICogT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdWJzY3JpYmVzIHRvIHRoZSBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IHRoYXQuIFNvIGZhciwgaXQgYmVoYXZlc1xuICogbGlrZSB7QGxpbmsgbWVyZ2VBbGx9LiBIb3dldmVyLCB3aGVuIGEgbmV3IGlubmVyIE9ic2VydmFibGUgaXMgZW1pdHRlZCxcbiAqIGBzd2l0Y2hgIHVuc3Vic2NyaWJlcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmRcbiAqIHN1YnNjcmliZXMgdG8gdGhlIG5ldyBpbm5lciBPYnNlcnZhYmxlIGFuZCBiZWdpbnMgZW1pdHRpbmcgaXRlbXMgZnJvbSBpdC4gSXRcbiAqIGNvbnRpbnVlcyB0byBiZWhhdmUgbGlrZSB0aGlzIGZvciBzdWJzZXF1ZW50IGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogLy8gRWFjaCBjbGljayBldmVudCBpcyBtYXBwZWQgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IHRpY2tzIGV2ZXJ5IHNlY29uZFxuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogdmFyIHN3aXRjaGVkID0gaGlnaGVyT3JkZXIuc3dpdGNoKCk7XG4gKiAvLyBUaGUgb3V0Y29tZSBpcyB0aGF0IGBzd2l0Y2hlZGAgaXMgZXNzZW50aWFsbHkgYSB0aW1lciB0aGF0IHJlc3RhcnRzXG4gKiAvLyBvbiBldmVyeSBjbGljay4gVGhlIGludGVydmFsIE9ic2VydmFibGVzIGZyb20gb2xkZXIgY2xpY2tzIGRvIG5vdCBtZXJnZVxuICogLy8gd2l0aCB0aGUgY3VycmVudCBpbnRlcnZhbCBPYnNlcnZhYmxlLlxuICogc3dpdGNoZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlXG4gKiBPYnNlcnZhYmxlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaFxuICogQG5hbWUgc3dpdGNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfc3dpdGNoKCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaE9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5fc3dpdGNoID0gX3N3aXRjaDtcbnZhciBTd2l0Y2hPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFN3aXRjaE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFN3aXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUlubmVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlSW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgPiAwID8gdGhpcy5hY3RpdmUgLSAxIDogMDtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUlubmVyKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9zd2l0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSA2NDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N3aXRjaE1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaE1hcCA9IHN3aXRjaE1hcF8xLnN3aXRjaE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXAuanNcbiAqKiBtb2R1bGUgaWQgPSA2NTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLCBlbWl0dGluZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IHByb2plY3RlZCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBzd2l0Y2h9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlXG4gKiBpbm5lciBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieVxuICogdGhhdCBpbm5lciBPYnNlcnZhYmxlLiBXaGVuIGEgbmV3IGlubmVyIE9ic2VydmFibGUgaXMgZW1pdHRlZCwgYHN3aXRjaE1hcGBcbiAqIHN0b3BzIGVtaXR0aW5nIGl0ZW1zIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZCBiZWdpbnNcbiAqIGVtaXR0aW5nIGl0ZW1zIGZyb20gdGhlIG5ldyBvbmUuIEl0IGNvbnRpbnVlcyB0byBiZWhhdmUgbGlrZSB0aGlzIGZvclxuICogc3Vic2VxdWVudCBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXJ1biBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIG9uIGV2ZXJ5IGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Muc3dpdGNoTWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZX0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXA7XG52YXIgU3dpdGNoTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgU3dpdGNoTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5vdGlmeU5leHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOb3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzXG4gKiogbW9kdWxlIGlkID0gNjUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoTWFwVG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N3aXRjaE1hcFRvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3dpdGNoTWFwVG8gPSBzd2l0Y2hNYXBUb18xLnN3aXRjaE1hcFRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwVG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanNcbiAqKiBtb2R1bGUgaWQgPSA2NTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIGZsYXR0ZW5lZCBtdWx0aXBsZVxuICogdGltZXMgd2l0aCB7QGxpbmsgc3dpdGNofSBpbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc3dpdGNoTWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZVxuICogYWx3YXlzIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoTWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBmbGF0dGVucyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZXNcbiAqIGVtaXRzIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBpbnN0YW5jZSBvZlxuICogYGlubmVyT2JzZXJ2YWJsZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgZXZlcnkgdGltZSBhIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIGdpdmVuXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCAoYW5kIG9wdGlvbmFsbHkgdHJhbnNmb3JtZWQgdGhyb3VnaCBgcmVzdWx0U2VsZWN0b3JgKSBldmVyeVxuICogdGltZSBhIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlc1xuICogZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHN3aXRjaE1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwVG8gPSBzd2l0Y2hNYXBUbztcbnZhciBTd2l0Y2hNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBUb09wZXJhdG9yKG9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwVG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBUb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLnJlc3VsdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwVG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaE1hcFRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBUb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIGlubmVyLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5pbm5lciwgdmFsdWUsIHRoaXMuaW5kZXgrKykpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBUb1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwVG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci9zd2l0Y2hNYXBUby5qc1xuICoqIG1vZHVsZSBpZCA9IDY1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRha2VMYXN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90YWtlTGFzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRha2VMYXN0ID0gdGFrZUxhc3RfMS50YWtlTGFzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VMYXN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rha2VMYXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgbGFzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UmVtZW1iZXJzIHRoZSBsYXRlc3QgYGNvdW50YCB2YWx1ZXMsIHRoZW4gZW1pdHMgdGhvc2VcbiAqIG9ubHkgd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlTGFzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZUxhc3RgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGF0IG1vc3QgdGhlIGxhc3QgYGNvdW50YCB2YWx1ZXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YFxuICogdmFsdWVzIHRoZW4gYWxsIG9mIGl0cyB2YWx1ZXMgYXJlIGVtaXR0ZWQuIFRoaXMgb3BlcmF0b3IgbXVzdCB3YWl0IHVudGlsIHRoZVxuICogYGNvbXBsZXRlYCBub3RpZmljYXRpb24gZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGVtaXQgdGhlIGBuZXh0YFxuICogdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYmVjYXVzZSBvdGhlcndpc2UgaXQgaXMgaW1wb3NzaWJsZSB0byBrbm93XG4gKiB3aGV0aGVyIG9yIG5vdCBtb3JlIHZhbHVlcyB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIHNvdXJjZS4gRm9yIHRoaXMgcmVhc29uLFxuICogYWxsIHZhbHVlcyBhcmUgZW1pdHRlZCBzeW5jaHJvbm91c2x5LCBmb2xsb3dlZCBieSB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGxhc3QgMyB2YWx1ZXMgb2YgYW4gT2JzZXJ2YWJsZSB3aXRoIG1hbnkgdmFsdWVzPC9jYXB0aW9uPlxuICogdmFyIG1hbnkgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwMCk7XG4gKiB2YXIgbGFzdFRocmVlID0gbWFueS50YWtlTGFzdCgzKTtcbiAqIGxhc3RUaHJlZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2VMYXN0KGkpYCwgaXQgZGVsaXZlcnMgYW5cbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmAgY2FsbGJhY2sgaWYgYGkgPCAwYC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyB0byBlbWl0IGZyb20gdGhlIGVuZCBvZlxuICogdGhlIHNlcXVlbmNlIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhdCBtb3N0IHRoZSBsYXN0IGNvdW50XG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHRha2VMYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0YWtlTGFzdChjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZUxhc3RPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZUxhc3QgPSB0YWtlTGFzdDtcbnZhciBUYWtlTGFzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdE9wZXJhdG9yKHRvdGFsKSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgaWYgKHRoaXMudG90YWwgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUYWtlTGFzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFRha2VMYXN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnRvdGFsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZUxhc3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VMYXN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VMYXN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnJpbmcgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFRha2VMYXN0U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJpbmcgPSB0aGlzLnJpbmc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQrKztcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoIDwgdG90YWwpIHtcbiAgICAgICAgICAgIHJpbmcucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjb3VudCAlIHRvdGFsO1xuICAgICAgICAgICAgcmluZ1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFrZUxhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHRoaXMuY291bnQgPj0gdGhpcy50b3RhbCA/IHRoaXMudG90YWwgOiB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdmFyIHJpbmcgPSB0aGlzLnJpbmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKGNvdW50KyspICUgdG90YWw7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyaW5nW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZUxhc3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZUxhc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci90YWtlTGFzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDY1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRha2VXaGlsZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZVdoaWxlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVdoaWxlID0gdGFrZVdoaWxlXzEudGFrZVdoaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVdoaWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3Rha2VXaGlsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEVtaXRzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBzbyBsb25nIGFzIGVhY2ggdmFsdWUgc2F0aXNmaWVzXG4gKiB0aGUgZ2l2ZW4gYHByZWRpY2F0ZWAsIGFuZCB0aGVuIGNvbXBsZXRlcyBhcyBzb29uIGFzIHRoaXMgYHByZWRpY2F0ZWAgaXMgbm90XG4gKiBzYXRpc2ZpZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb25seSB3aGlsZSB0aGV5IHBhc3MgdGhlXG4gKiBjb25kaXRpb24gZ2l2ZW4uIFdoZW4gdGhlIGZpcnN0IHZhbHVlIGRvZXMgbm90IHNhdGlzZnksIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlV2hpbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VXaGlsZWAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEVhY2ggdmFsdWVcbiAqIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBpcyBnaXZlbiB0byB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhXG4gKiBib29sZWFuLCByZXByZXNlbnRpbmcgYSBjb25kaXRpb24gdG8gYmUgc2F0aXNmaWVkIGJ5IHRoZSBzb3VyY2UgdmFsdWVzLiBUaGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHRoZSBzb3VyY2UgdmFsdWVzIHVudGlsIHN1Y2ggdGltZSBhcyB0aGUgYHByZWRpY2F0ZWBcbiAqIHJldHVybnMgZmFsc2UsIGF0IHdoaWNoIHBvaW50IGB0YWtlV2hpbGVgIHN0b3BzIG1pcnJvcmluZyB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2sgZXZlbnRzIG9ubHkgd2hpbGUgdGhlIGNsaWVudFggcHJvcGVydHkgaXMgZ3JlYXRlciB0aGFuIDIwMDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRha2VXaGlsZShldiA9PiBldi5jbGllbnRYID4gMjAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGEgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHJldHVybnMgYSBib29sZWFuLlxuICogQWxzbyB0YWtlcyB0aGUgKHplcm8tYmFzZWQpIGluZGV4IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgc28gbG9uZyBhcyBlYWNoIHZhbHVlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGRlZmluZWQgYnkgdGhlXG4gKiBgcHJlZGljYXRlYCwgdGhlbiBjb21wbGV0ZXMuXG4gKiBAbWV0aG9kIHRha2VXaGlsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSkpO1xufVxuZXhwb3J0cy50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG52YXIgVGFrZVdoaWxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgVGFrZVdoaWxlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgVGFrZVdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VXaGlsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZVdoaWxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBUYWtlV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRPckNvbXBsZXRlKHZhbHVlLCByZXN1bHQpO1xuICAgIH07XG4gICAgVGFrZVdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dE9yQ29tcGxldGUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWRpY2F0ZVJlc3VsdCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoQm9vbGVhbihwcmVkaWNhdGVSZXN1bHQpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVdoaWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvdGFrZVdoaWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3R0bGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rocm90dGxlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGhyb3R0bGUgPSB0aHJvdHRsZV8xLnRocm90dGxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvdGhyb3R0bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYSBkdXJhdGlvbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXNcbiAqIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgdGhyb3R0bGVUaW1lfSwgYnV0IHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aHJvdHRsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVgIGVtaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB3aGVuIGl0cyBpbnRlcm5hbCB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZVxuICogdmFsdWUgYXJyaXZlcywgaXQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkIGJ5IGNhbGxpbmcgdGhlIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiB3aXRoIHRoZSBzb3VyY2UgdmFsdWUsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSBlbWl0cyBhXG4gKiB2YWx1ZSBvciBjb21wbGV0ZXMsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGVcbiAqIG5leHQgc291cmNlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGUoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IE9ic2VydmFibGV8UHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gZm9yIGVhY2ggc291cmNlIHZhbHVlLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvcikpO1xufVxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xudmFyIFRocm90dGxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgIH1cbiAgICBUaHJvdHRsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFRocm90dGxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGhyb3R0bGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUR1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLnRyeUR1cmF0aW9uU2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0QW5kVGhyb3R0bGUodmFsdWUsIGR1cmF0aW9uKTtcbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdEFuZFRocm90dGxlID0gZnVuY3Rpb24gKHZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhyb3R0bGVkID0gdGhpcy50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3Rocm90dGxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3R0bGVUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aHJvdHRsZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWVfMS50aHJvdHRsZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZVRpbWUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvdGhyb3R0bGVUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNjY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gaWdub3JlcyBzdWJzZXF1ZW50IHNvdXJjZVxuICogdmFsdWVzIGZvciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcywgdGhlbiByZXBlYXRzIHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGV0cyBhIHZhbHVlIHBhc3MsIHRoZW4gaWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciB0aGVcbiAqIG5leHQgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGhyb3R0bGVUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0aHJvdHRsZVRpbWVgIGVtaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB3aGVuIGl0cyBpbnRlcm5hbCB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZVxuICogdmFsdWUgYXJyaXZlcywgaXQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkLiBBZnRlciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkXG4gKiBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgaGFzIHBhc3NlZCwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLFxuICogYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuIE9wdGlvbmFsbHkgdGFrZXMgYVxuICoge0BsaW5rIFNjaGVkdWxlcn0gZm9yIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRocm90dGxlVGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgYW5vdGhlciB2YWx1ZSBhZnRlclxuICogZW1pdHRpbmcgdGhlIGxhc3QgdmFsdWUsIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcyBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWRcbiAqIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlVGltZShkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaHJvdHRsZVRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZTtcbnZhciBUaHJvdHRsZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb24sIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVyYXRpb24sIHsgc3Vic2NyaWJlcjogdGhpcyB9KSk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhyb3R0bGVkID0gdGhpcy50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlVGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3Rocm90dGxlVGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVvdXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3RpbWVvdXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gdGltZW91dF8xLnRpbWVvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3RpbWVvdXQuanNcbiAqKiBtb2R1bGUgaWQgPSA2NjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEBwYXJhbSBkdWVcbiAqIEBwYXJhbSBlcnJvclRvU2VuZFxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVvdXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQoZHVlLCBlcnJvclRvU2VuZCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKGVycm9yVG9TZW5kID09PSB2b2lkIDApIHsgZXJyb3JUb1NlbmQgPSBudWxsOyB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICB2YXIgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlXzEuaXNEYXRlKGR1ZSk7XG4gICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyAoK2R1ZSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkdWUpO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRpbWVvdXRPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIGVycm9yVG9TZW5kLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG52YXIgVGltZW91dE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lb3V0T3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCBlcnJvclRvU2VuZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLmVycm9yVG9TZW5kID0gZXJyb3JUb1NlbmQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaW1lb3V0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgVGltZW91dFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy5lcnJvclRvU2VuZCwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaW1lb3V0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVvdXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhYnNvbHV0ZVRpbWVvdXQsIHdhaXRGb3IsIGVycm9yVG9TZW5kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICAgICAgdGhpcy5lcnJvclRvU2VuZCA9IGVycm9yVG9TZW5kO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZSwgXCJwcmV2aW91c0luZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNJbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZSwgXCJoYXNDb21wbGV0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNDb21wbGV0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc291cmNlID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgICBpZiAoIXNvdXJjZS5oYXNDb21wbGV0ZWQgJiYgc291cmNlLnByZXZpb3VzSW5kZXggPT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgc291cmNlLm5vdGlmeVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVvdXRTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCwgdGhpcy53YWl0Rm9yLCB7IHN1YnNjcmliZXI6IHRoaXMsIGluZGV4OiBjdXJyZW50SW5kZXggfSk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lcnJvcih0aGlzLmVycm9yVG9TZW5kIHx8IG5ldyBFcnJvcigndGltZW91dCcpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci90aW1lb3V0LmpzXG4gKiogbW9kdWxlIGlkID0gNjY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGltZW91dFdpdGhfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3RpbWVvdXRXaXRoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGltZW91dFdpdGggPSB0aW1lb3V0V2l0aF8xLnRpbWVvdXRXaXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dFdpdGguanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3IvdGltZW91dFdpdGguanNcbiAqKiBtb2R1bGUgaWQgPSA2NjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEBwYXJhbSBkdWVcbiAqIEBwYXJhbSB3aXRoT2JzZXJ2YWJsZVxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVvdXRXaXRoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lb3V0V2l0aChkdWUsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHZhciBhYnNvbHV0ZVRpbWVvdXQgPSBpc0RhdGVfMS5pc0RhdGUoZHVlKTtcbiAgICB2YXIgd2FpdEZvciA9IGFic29sdXRlVGltZW91dCA/ICgrZHVlIC0gc2NoZWR1bGVyLm5vdygpKSA6IE1hdGguYWJzKGR1ZSk7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGltZW91dFdpdGhPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMudGltZW91dFdpdGggPSB0aW1lb3V0V2l0aDtcbnZhciBUaW1lb3V0V2l0aE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZW91dFdpdGhPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBUaW1lb3V0V2l0aFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy53aXRoT2JzZXJ2YWJsZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0V2l0aE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGltZW91dFdpdGhTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dFdpdGhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRXaXRoU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYWJzb2x1dGVUaW1lb3V0LCB3YWl0Rm9yLCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgICAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gd2l0aE9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLnRpbWVvdXRTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIGRlc3RpbmF0aW9uLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUsIFwicHJldmlvdXNJbmRleFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLCBcImhhc0NvbXBsZXRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NvbXBsZXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc291cmNlID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgICBpZiAoIXNvdXJjZS5oYXNDb21wbGV0ZWQgJiYgc291cmNlLnByZXZpb3VzSW5kZXggPT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgc291cmNlLmhhbmRsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgdGltZW91dFN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBpbmRleDogY3VycmVudEluZGV4IH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVvdXRXaXRoU3Vic2NyaWJlci5kaXNwYXRjaFRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGltZW91dFN0YXRlKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLl9oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuaGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB2YXIgd2l0aE9ic2VydmFibGUgPSB0aGlzLndpdGhPYnNlcnZhYmxlO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcy50aW1lb3V0U3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB3aXRoT2JzZXJ2YWJsZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGltZW91dFdpdGhTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXRXaXRoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3IvdGltZW91dFdpdGguanNcbiAqKiBtb2R1bGUgaWQgPSA2NzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aW5kb3dfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3dpbmRvdycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLndpbmRvdyA9IHdpbmRvd18xLndpbmRvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvdy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3cuanNcbiAqKiBtb2R1bGUgaWQgPSA2NzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgd2hlbmV2ZXJcbiAqIGB3aW5kb3dCb3VuZGFyaWVzYCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJ9LCBidXQgZW1pdHMgYSBuZXN0ZWQgT2JzZXJ2YWJsZVxuICogaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3cucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyBjb25uZWN0ZWQsIG5vbi1vdmVybGFwcGluZ1xuICogd2luZG93cy4gSXQgZW1pdHMgdGhlIGN1cnJlbnQgd2luZG93IGFuZCBvcGVucyBhIG5ldyBvbmUgd2hlbmV2ZXIgdGhlXG4gKiBPYnNlcnZhYmxlIGB3aW5kb3dCb3VuZGFyaWVzYCBlbWl0cyBhbiBpdGVtLiBCZWNhdXNlIGVhY2ggd2luZG93IGlzIGFuXG4gKiBPYnNlcnZhYmxlLCB0aGUgb3V0cHV0IGlzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+SW4gZXZlcnkgd2luZG93IG9mIDEgc2Vjb25kIGVhY2gsIGVtaXQgYXQgbW9zdCAyIGNsaWNrIGV2ZW50czwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3coaW50ZXJ2YWwpXG4gKiAgIC5tYXAod2luID0+IHdpbi50YWtlKDIpKSAvLyBlYWNoIHdpbmRvdyBoYXMgYXQgbW9zdCAyIGVtaXNzaW9uc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxhbnk+fSB3aW5kb3dCb3VuZGFyaWVzIEFuIE9ic2VydmFibGUgdGhhdCBjb21wbGV0ZXMgdGhlXG4gKiBwcmV2aW91cyB3aW5kb3cgYW5kIHN0YXJ0cyBhIG5ldyB3aW5kb3cuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBPYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGFyZVxuICogT2JzZXJ2YWJsZXMgZW1pdHRpbmcgdmFsdWVzIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgd2luZG93XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3cod2luZG93Qm91bmRhcmllcykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpbmRvd09wZXJhdG9yKHdpbmRvd0JvdW5kYXJpZXMpKTtcbn1cbmV4cG9ydHMud2luZG93ID0gd2luZG93O1xudmFyIFdpbmRvd09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dPcGVyYXRvcih3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgICAgIHRoaXMud2luZG93Qm91bmRhcmllcyA9IHdpbmRvd0JvdW5kYXJpZXM7XG4gICAgfVxuICAgIFdpbmRvd09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFdpbmRvd1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy53aW5kb3dCb3VuZGFyaWVzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLndpbmRvd0JvdW5kYXJpZXMgPSB3aW5kb3dCb3VuZGFyaWVzO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHdpbmRvd0JvdW5kYXJpZXMpKTtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93KCk7XG4gICAgfVxuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93KCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2luZG93Lm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2V2luZG93ID0gdGhpcy53aW5kb3c7XG4gICAgICAgIGlmIChwcmV2V2luZG93KSB7XG4gICAgICAgICAgICBwcmV2V2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIG5ld1dpbmRvdyA9IHRoaXMud2luZG93ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmFkZChuZXdXaW5kb3cpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KG5ld1dpbmRvdyk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3cuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci93aW5kb3cuanNcbiAqKiBtb2R1bGUgaWQgPSA2NzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aW5kb3dDb3VudF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2luZG93Q291bnQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dDb3VudCA9IHdpbmRvd0NvdW50XzEud2luZG93Q291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dDb3VudC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudC5qc1xuICoqIG1vZHVsZSBpZCA9IDY3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB3aXRoIGVhY2hcbiAqIG5lc3RlZCBPYnNlcnZhYmxlIGVtaXR0aW5nIGF0IG1vc3QgYHdpbmRvd1NpemVgIHZhbHVlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJDb3VudH0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd0NvdW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyBldmVyeSBgc3RhcnRXaW5kb3dFdmVyeWBcbiAqIGl0ZW1zLCBlYWNoIGNvbnRhaW5pbmcgbm8gbW9yZSB0aGFuIGB3aW5kb3dTaXplYCBpdGVtcy4gV2hlbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGNvbXBsZXRlcyBvciBlbmNvdW50ZXJzIGFuIGVycm9yLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHNcbiAqIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgcHJvcGFnYXRlcyB0aGUgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYHN0YXJ0V2luZG93RXZlcnlgIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBuZXcgd2luZG93cyBhcmVcbiAqIHN0YXJ0ZWQgaW1tZWRpYXRlbHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2UgYW5kIHdoZW4gZWFjaCB3aW5kb3cgY29tcGxldGVzXG4gKiB3aXRoIHNpemUgYHdpbmRvd1NpemVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPklnbm9yZSBldmVyeSAzcmQgY2xpY2sgZXZlbnQsIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IG9uZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvd0NvdW50KDMpXG4gKiAgIC5tYXAod2luID0+IHdpbi5za2lwKDEpKSAvLyBza2lwIGZpcnN0IG9mIGV2ZXJ5IDMgY2xpY2tzXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPklnbm9yZSBldmVyeSAzcmQgY2xpY2sgZXZlbnQsIHN0YXJ0aW5nIGZyb20gdGhlIHRoaXJkIG9uZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvd0NvdW50KDIsIDMpXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IGVhY2hcbiAqIHdpbmRvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRXaW5kb3dFdmVyeV0gSW50ZXJ2YWwgYXQgd2hpY2ggdG8gc3RhcnQgYSBuZXcgd2luZG93LlxuICogRm9yIGV4YW1wbGUgaWYgYHN0YXJ0V2luZG93RXZlcnlgIGlzIGAyYCwgdGhlbiBhIG5ldyB3aW5kb3cgd2lsbCBiZSBzdGFydGVkXG4gKiBvbiBldmVyeSBvdGhlciB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuIEEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIGF0IHRoZVxuICogYmVnaW5uaW5nIG9mIHRoZSBzb3VyY2UgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIE9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVyblxuICogYXJlIE9ic2VydmFibGUgb2YgdmFsdWVzLlxuICogQG1ldGhvZCB3aW5kb3dDb3VudFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2luZG93Q291bnQod2luZG93U2l6ZSwgc3RhcnRXaW5kb3dFdmVyeSkge1xuICAgIGlmIChzdGFydFdpbmRvd0V2ZXJ5ID09PSB2b2lkIDApIHsgc3RhcnRXaW5kb3dFdmVyeSA9IDA7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaW5kb3dDb3VudE9wZXJhdG9yKHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpKTtcbn1cbmV4cG9ydHMud2luZG93Q291bnQgPSB3aW5kb3dDb3VudDtcbnZhciBXaW5kb3dDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dDb3VudE9wZXJhdG9yKHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICAgICAgdGhpcy53aW5kb3dTaXplID0gd2luZG93U2l6ZTtcbiAgICAgICAgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID0gc3RhcnRXaW5kb3dFdmVyeTtcbiAgICB9XG4gICAgV2luZG93Q291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5fc3Vic2NyaWJlKG5ldyBXaW5kb3dDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy53aW5kb3dTaXplLCB0aGlzLnN0YXJ0V2luZG93RXZlcnkpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dDb3VudE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2luZG93Q291bnRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93Q291bnRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd0NvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgd2luZG93U2l6ZSwgc3RhcnRXaW5kb3dFdmVyeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy53aW5kb3dTaXplID0gd2luZG93U2l6ZTtcbiAgICAgICAgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID0gc3RhcnRXaW5kb3dFdmVyeTtcbiAgICAgICAgdGhpcy53aW5kb3dzID0gW25ldyBTdWJqZWN0XzEuU3ViamVjdCgpXTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHZhciBmaXJzdFdpbmRvdyA9IHRoaXMud2luZG93c1swXTtcbiAgICAgICAgZGVzdGluYXRpb24uYWRkKGZpcnN0V2luZG93KTtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChmaXJzdFdpbmRvdyk7XG4gICAgfVxuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2luZG93RXZlcnkgPSAodGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID4gMCkgPyB0aGlzLnN0YXJ0V2luZG93RXZlcnkgOiB0aGlzLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gdGhpcy53aW5kb3dTaXplO1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgdmFyIGxlbiA9IHdpbmRvd3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB3aW5kb3dzW2ldLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gdGhpcy5jb3VudCAtIHdpbmRvd1NpemUgKyAxO1xuICAgICAgICBpZiAoYyA+PSAwICYmIGMgJSBzdGFydFdpbmRvd0V2ZXJ5ID09PSAwKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKyt0aGlzLmNvdW50ICUgc3RhcnRXaW5kb3dFdmVyeSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICB3aW5kb3dzLnB1c2god2luZG93XzEpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uYWRkKHdpbmRvd18xKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQod2luZG93XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd0NvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd0NvdW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvb3BlcmF0b3Ivd2luZG93Q291bnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2NzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aW5kb3dUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3dUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93VGltZSA9IHdpbmRvd1RpbWVfMS53aW5kb3dUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93VGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNjc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSBwZXJpb2RpY2FsbHlcbiAqIGluIHRpbWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVGltZX0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd1RpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdGFydHMgYSBuZXcgd2luZG93IHBlcmlvZGljYWxseSwgYXNcbiAqIGRldGVybWluZWQgYnkgdGhlIGB3aW5kb3dDcmVhdGlvbkludGVydmFsYCBhcmd1bWVudC4gSXQgZW1pdHMgZWFjaCB3aW5kb3dcbiAqIGFmdGVyIGEgZml4ZWQgdGltZXNwYW4sIHNwZWNpZmllZCBieSB0aGUgYHdpbmRvd1RpbWVTcGFuYCBhcmd1bWVudC4gV2hlbiB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBvciBlbmNvdW50ZXJzIGFuIGVycm9yLCB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgcHJvcGFnYXRlcyB0aGUgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWxgIGlzIG5vdCBwcm92aWRlZCwgdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBzdGFydHMgYSBuZXcgd2luZG93IHdoZW4gdGhlIHByZXZpb3VzIHdpbmRvdyBvZiBkdXJhdGlvblxuICogYHdpbmRvd1RpbWVTcGFuYCBjb21wbGV0ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+SW4gZXZlcnkgd2luZG93IG9mIDEgc2Vjb25kIGVhY2gsIGVtaXQgYXQgbW9zdCAyIGNsaWNrIGV2ZW50czwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvd1RpbWUoMTAwMClcbiAqICAgLm1hcCh3aW4gPT4gd2luLnRha2UoMikpIC8vIGVhY2ggd2luZG93IGhhcyBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IDUgc2Vjb25kcyBzdGFydCBhIHdpbmRvdyAxIHNlY29uZCBsb25nLCBhbmQgZW1pdCBhdCBtb3N0IDIgY2xpY2sgZXZlbnRzIHBlciB3aW5kb3c8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dUaW1lKDEwMDAsIDUwMDApXG4gKiAgIC5tYXAod2luID0+IHdpbi50YWtlKDIpKSAvLyBlYWNoIHdpbmRvdyBoYXMgYXQgbW9zdCAyIGVtaXNzaW9uc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dUaW1lU3BhbiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZmlsbCBlYWNoIHdpbmRvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2luZG93Q3JlYXRpb25JbnRlcnZhbF0gVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IG5ld1xuICogd2luZG93cy5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgc2NoZWR1bGVyIG9uIHdoaWNoIHRvIHNjaGVkdWxlIHRoZVxuICogaW50ZXJ2YWxzIHRoYXQgZGV0ZXJtaW5lIHdpbmRvdyBib3VuZGFyaWVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+Pn0gQW4gb2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBpbiB0dXJuXG4gKiBhcmUgT2JzZXJ2YWJsZXMuXG4gKiBAbWV0aG9kIHdpbmRvd1RpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvd1RpbWUod2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHNjaGVkdWxlcikge1xuICAgIGlmICh3aW5kb3dDcmVhdGlvbkludGVydmFsID09PSB2b2lkIDApIHsgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IG51bGw7IH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpbmRvd1RpbWVPcGVyYXRvcih3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLndpbmRvd1RpbWUgPSB3aW5kb3dUaW1lO1xudmFyIFdpbmRvd1RpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93VGltZU9wZXJhdG9yKHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy53aW5kb3dUaW1lU3BhbiA9IHdpbmRvd1RpbWVTcGFuO1xuICAgICAgICB0aGlzLndpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSB3aW5kb3dDcmVhdGlvbkludGVydmFsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgV2luZG93VGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFdpbmRvd1RpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMud2luZG93VGltZVNwYW4sIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1RpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLndpbmRvd1RpbWVTcGFuID0gd2luZG93VGltZVNwYW47XG4gICAgICAgIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndpbmRvd3MgPSBbXTtcbiAgICAgICAgaWYgKHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgd2luZG93XzEgPSB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICAgICAgICAgIHZhciBjbG9zZVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCB3aW5kb3c6IHdpbmRvd18xLCBjb250ZXh0OiBudWxsIH07XG4gICAgICAgICAgICB2YXIgY3JlYXRpb25TdGF0ZSA9IHsgd2luZG93VGltZVNwYW46IHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsOiB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBzdWJzY3JpYmVyOiB0aGlzLCBzY2hlZHVsZXI6IHNjaGVkdWxlciB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q2xvc2UsIHdpbmRvd1RpbWVTcGFuLCBjbG9zZVN0YXRlKSk7XG4gICAgICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hXaW5kb3dDcmVhdGlvbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgY3JlYXRpb25TdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18yID0gdGhpcy5vcGVuV2luZG93KCk7XG4gICAgICAgICAgICB2YXIgdGltZVNwYW5Pbmx5U3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIHdpbmRvdzogd2luZG93XzIsIHdpbmRvd1RpbWVTcGFuOiB3aW5kb3dUaW1lU3BhbiB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93VGltZVNwYW5Pbmx5LCB3aW5kb3dUaW1lU3BhbiwgdGltZVNwYW5Pbmx5U3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHZhciBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18zID0gd2luZG93c1tpXTtcbiAgICAgICAgICAgIGlmICghd2luZG93XzMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dfMy5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgd2luZG93XzQgPSB3aW5kb3dzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvd180LmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93XzQuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbldpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLndpbmRvd3MucHVzaCh3aW5kb3cpO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5hZGQod2luZG93KTtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh3aW5kb3cpO1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH07XG4gICAgV2luZG93VGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHdpbmRvd3Muc3BsaWNlKHdpbmRvd3MuaW5kZXhPZih3aW5kb3cpLCAxKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoV2luZG93VGltZVNwYW5Pbmx5KHN0YXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCB3aW5kb3dUaW1lU3BhbiA9IHN0YXRlLndpbmRvd1RpbWVTcGFuLCB3aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcbiAgICB9XG4gICAgc3RhdGUud2luZG93ID0gc3Vic2NyaWJlci5vcGVuV2luZG93KCk7XG4gICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgd2luZG93VGltZVNwYW4pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hXaW5kb3dDcmVhdGlvbihzdGF0ZSkge1xuICAgIHZhciB3aW5kb3dUaW1lU3BhbiA9IHN0YXRlLndpbmRvd1RpbWVTcGFuLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyLCB3aW5kb3dDcmVhdGlvbkludGVydmFsID0gc3RhdGUud2luZG93Q3JlYXRpb25JbnRlcnZhbDtcbiAgICB2YXIgd2luZG93ID0gc3Vic2NyaWJlci5vcGVuV2luZG93KCk7XG4gICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSB7IGFjdGlvbjogYWN0aW9uLCBzdWJzY3JpcHRpb246IG51bGwgfTtcbiAgICB2YXIgdGltZVNwYW5TdGF0ZSA9IHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgd2luZG93OiB3aW5kb3csIGNvbnRleHQ6IGNvbnRleHQgfTtcbiAgICBjb250ZXh0LnN1YnNjcmlwdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd0Nsb3NlLCB3aW5kb3dUaW1lU3BhbiwgdGltZVNwYW5TdGF0ZSk7XG4gICAgYWN0aW9uLmFkZChjb250ZXh0LnN1YnNjcmlwdGlvbik7XG4gICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCB3aW5kb3dDcmVhdGlvbkludGVydmFsKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoV2luZG93Q2xvc2UoYXJnKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlciwgd2luZG93ID0gYXJnLndpbmRvdywgY29udGV4dCA9IGFyZy5jb250ZXh0O1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuYWN0aW9uICYmIGNvbnRleHQuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uLnJlbW92ZShjb250ZXh0LnN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHN1YnNjcmliZXIuY2xvc2VXaW5kb3cod2luZG93KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1RpbWUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci93aW5kb3dUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNjc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2luZG93VG9nZ2xlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3dUb2dnbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dUb2dnbGUgPSB3aW5kb3dUb2dnbGVfMS53aW5kb3dUb2dnbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUb2dnbGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93VG9nZ2xlLmpzXG4gKiogbW9kdWxlIGlkID0gNjc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHN0YXJ0aW5nIGZyb21cbiAqIGFuIGVtaXNzaW9uIGZyb20gYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYFxuICogZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93VG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyB0aGF0IGNvbnRhaW4gdGhvc2UgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJldHdlZW4gdGhlIHRpbWUgd2hlbiB0aGUgYG9wZW5pbmdzYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtIGFuZCB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IG90aGVyIHNlY29uZCwgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgNTAwbXM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9wZW5pbmdzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApLm1lcmdlQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPE8+fSBvcGVuaW5ncyBBbiBvYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgdG8gc3RhcnQgbmV3XG4gKiB3aW5kb3dzLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogTyk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqIHRoZSB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBgb3BlbmluZ3NgIG9ic2VydmFibGUgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSxcbiAqIHdoaWNoLCB3aGVuIGl0IGVtaXRzIChlaXRoZXIgYG5leHRgIG9yIGBjb21wbGV0ZWApLCBzaWduYWxzIHRoYXQgdGhlXG4gKiBhc3NvY2lhdGVkIHdpbmRvdyBzaG91bGQgY29tcGxldGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93VG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3dUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpbmRvd1RvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMud2luZG93VG9nZ2xlID0gd2luZG93VG9nZ2xlO1xudmFyIFdpbmRvd1RvZ2dsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIFdpbmRvd1RvZ2dsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vcGVuaW5ncywgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUb2dnbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9wZW5pbmdzID0gb3BlbmluZ3M7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgICAgIHRoaXMuYWRkKHRoaXMub3BlblN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb3BlbmluZ3MsIG9wZW5pbmdzKSk7XG4gICAgfVxuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIGlmIChjb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0c1tpXS53aW5kb3cubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2luZG93LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAob3V0ZXJWYWx1ZSA9PT0gdGhpcy5vcGVuaW5ncykge1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdTZWxlY3RvciA9IHRoaXMuY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goY2xvc2luZ1NlbGVjdG9yKShpbm5lclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHsgd2luZG93OiB3aW5kb3dfMSwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbi5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh3aW5kb3dfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMuaW5kZXhPZihvdXRlclZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lcikge1xuICAgICAgICBpZiAoaW5uZXIgIT09IHRoaXMub3BlblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh0aGlzLmNvbnRleHRzLmluZGV4T2YoaW5uZXIuY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgIHZhciB3aW5kb3cgPSBjb250ZXh0LndpbmRvdywgc3Vic2NyaXB0aW9uID0gY29udGV4dC5zdWJzY3JpcHRpb247XG4gICAgICAgIGNvbnRleHRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHdpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1RvZ2dsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL29wZXJhdG9yL3dpbmRvd1RvZ2dsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHdpbmRvd1doZW5fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3dpbmRvd1doZW4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dXaGVuID0gd2luZG93V2hlbl8xLndpbmRvd1doZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dXaGVuLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvYWRkL29wZXJhdG9yL3dpbmRvd1doZW4uanNcbiAqKiBtb2R1bGUgaWQgPSA2NzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHVzaW5nIGFcbiAqIGZhY3RvcnkgZnVuY3Rpb24gb2YgY2xvc2luZyBPYnNlcnZhYmxlcyB0byBkZXRlcm1pbmUgd2hlbiB0byBzdGFydCBhIG5ld1xuICogd2luZG93LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlcldoZW59LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3dXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgY29ubmVjdGVkLCBub24tb3ZlcmxhcHBpbmcgd2luZG93cy5cbiAqIEl0IGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgb3BlbnMgYSBuZXcgb25lIHdoZW5ldmVyIHRoZSBPYnNlcnZhYmxlXG4gKiBwcm9kdWNlZCBieSB0aGUgc3BlY2lmaWVkIGBjbG9zaW5nU2VsZWN0b3JgIGZ1bmN0aW9uIGVtaXRzIGFuIGl0ZW0uIFRoZSBmaXJzdFxuICogd2luZG93IGlzIG9wZW5lZCBpbW1lZGlhdGVseSB3aGVuIHN1YnNjcmliaW5nIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIGZpcnN0IHR3byBjbGlja3MgZXZlbnRzIGluIGV2ZXJ5IHdpbmRvdyBvZiBbMS01XSByYW5kb20gc2Vjb25kczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzXG4gKiAgIC53aW5kb3dXaGVuKCgpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCArIE1hdGgucmFuZG9tKCkgKiA0MDAwKSlcbiAqICAgLm1hcCh3aW4gPT4gd2luLnRha2UoMikpIC8vIGVhY2ggd2luZG93IGhhcyBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBPYnNlcnZhYmxlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNpZ25hbHMgKG9uIGVpdGhlciBgbmV4dGAgb3JcbiAqIGBjb21wbGV0ZWApIHdoZW4gdG8gY2xvc2UgdGhlIHByZXZpb3VzIHdpbmRvdyBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+Pn0gQW4gb2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBpbiB0dXJuXG4gKiBhcmUgT2JzZXJ2YWJsZXMuXG4gKiBAbWV0aG9kIHdpbmRvd1doZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvd1doZW4oY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93T3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSk7XG59XG5leHBvcnRzLndpbmRvd1doZW4gPSB3aW5kb3dXaGVuO1xudmFyIFdpbmRvd09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dPcGVyYXRvcihjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIFdpbmRvd09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLl9zdWJzY3JpYmUobmV3IFdpbmRvd1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1N1YnNjcmliZXIoZGVzdGluYXRpb24sIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdygpO1xuICAgIH1cbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdyhpbm5lclN1Yik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93KGlubmVyU3ViKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2luZG93Lm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNsb3NpbmdOb3RpZmljYXRpb24oKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlQ2xvc2luZ05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nTm90aWZpY2F0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKGlubmVyU3ViID09PSB2b2lkIDApIHsgaW5uZXJTdWIgPSBudWxsOyB9XG4gICAgICAgIGlmIChpbm5lclN1Yikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldldpbmRvdyA9IHRoaXMud2luZG93O1xuICAgICAgICBpZiAocHJldldpbmRvdykge1xuICAgICAgICAgICAgcHJldldpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3cgPSB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcbiAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5jbG9zaW5nU2VsZWN0b3IpKCk7XG4gICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5jbG9zaW5nTm90aWZpY2F0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHdpbmRvdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1doZW4uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci93aW5kb3dXaGVuLmpzXG4gKiogbW9kdWxlIGlkID0gNjgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci96aXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS56aXAgPSB6aXBfMS56aXBQcm90bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci96aXAuanNcbiAqKiBtb2R1bGUgaWQgPSA2ODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB6aXBBbGxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3ppcEFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnppcEFsbCA9IHppcEFsbF8xLnppcEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcEFsbC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yeGpzL2FkZC9vcGVyYXRvci96aXBBbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA2ODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHppcF8xID0gcmVxdWlyZSgnLi96aXAnKTtcbi8qKlxuICogQHBhcmFtIHByb2plY3RcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB6aXBBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHppcEFsbChwcm9qZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgemlwXzEuWmlwT3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy56aXBBbGwgPSB6aXBBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXBBbGwuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcnhqcy9vcGVyYXRvci96aXBBbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA2ODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xudmFyIE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuX3N1YnNjcmliZShuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuT3BlcmF0b3IgPSBPcGVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wZXJhdG9yLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3J4anMvT3BlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2ODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IERyb3Bkb3duQ29tcG9uZW50IH0gZnJvbSAnLi9kcm9wZG93bi5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBEcm9wZG93blRvZ2dsZUNvbXBvbmVudCB9IGZyb20gJy4vZHJvcGRvd24tdG9nZ2xlLmNvbXBvbmVudCc7XHJcblxyXG5leHBvcnQgY29uc3QgRFJPUERPV05fRElSRUNUSVZFUyA9IFtEcm9wZG93bkNvbXBvbmVudCwgRHJvcGRvd25Ub2dnbGVDb21wb25lbnRdO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zaGFyZWQvZHJvcGRvd24vaW5kZXgudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBSZW5kZXJlciwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBDb250ZW50Q2hpbGRyZW4sIEV2ZW50RW1pdHRlciwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBEcm9wZG93blRvZ2dsZUNvbXBvbmVudCB9IGZyb20gJy4vZHJvcGRvd24tdG9nZ2xlLmNvbXBvbmVudCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnW2Ryb3Bkb3duXScsXHJcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgRHJvcGRvd25Db21wb25lbnQge1xyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kcm9wZG93bicpIHRydWU7XHJcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLm9wZW4nKSBnZXQgaXNPcGVuKCkgeyByZXR1cm4gdGhpcy5vcGVuIH07XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicsIFsnJGV2ZW50J10pIHB1YmxpYyBvbk1vdXNlRW50ZXIoJGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMubW91c2VFdmVudCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLm9wZW4gPSB0cnVlLCB0aGlzLmRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScsIFsnJGV2ZW50J10pIHB1YmxpYyBvbk1vdXNlTGVhdmUoJGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMubW91c2VFdmVudCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLm9wZW4gPSBmYWxzZSwgdGhpcy5kZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSkgcHVibGljIG9uQ2xpY2soJGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zZWxmQ2xpY2sgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oRHJvcGRvd25Ub2dnbGVDb21wb25lbnQpIHRvZ2dsZUNvbXBvbmVudDogUXVlcnlMaXN0PERyb3Bkb3duVG9nZ2xlQ29tcG9uZW50PjtcclxuICAgIEBJbnB1dCgpIG9wZW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIG1vdXNlRXZlbnQgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgZG9jdW1lbnRDbGlja0xpc3RlbmVyO1xyXG4gICAgcHJpdmF0ZSBkb2N1bWVudEtleXVwTGlzdGVuZXI7XHJcbiAgICBwcml2YXRlIHNlbGZDbGljazogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSB0aW1lO1xyXG4gICAgcHJpdmF0ZSBkZWxheSA9IDUwMDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW5HbG9iYWwoJ2JvZHknLCAnY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxmQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxmQ2xpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmRvY3VtZW50S2V5dXBMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuR2xvYmFsKCdib2R5JywgJ2tleXVwJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5jb2RlID09PSAnRXNjYXBlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgdGhpcy50b2dnbGVDb21wb25lbnQuZm9yRWFjaChpdCA9PiBpdC50b2dnbGUuc3Vic2NyaWJlKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGVEcm9wZG93bihldmVudCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9nZ2xlRHJvcGRvd24oZXZlbnQpIHtcclxuICAgICAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2hhcmVkL2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnW2Ryb3Bkb3duLXRvZ2dsZV0nLFxyXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YFxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIERyb3Bkb3duVG9nZ2xlQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyB0b2dnbGU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcblxyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kcm9wZG93bi10b2dnbGUnKSB0cnVlO1xyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSkgcHVibGljIG9uQ2xpY2soJGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50b2dnbGUuZW1pdCgkZXZlbnQpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC9kcm9wZG93bi9kcm9wZG93bi10b2dnbGUuY29tcG9uZW50LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBST1VURVJfRElSRUNUSVZFUyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgSVByb2plY3RzU3RhdGUgfSBmcm9tICcuLi9yZWR1Y2Vycy9wcm9qZWN0cy5yZWR1Y2VyJztcclxuaW1wb3J0IHsgUHJvamVjdFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wcm9qZWN0LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQcm9qZWN0IH0gZnJvbSAnLi4vbW9kZWxzL3Byb2plY3QnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ1tkYXRhLWNvbXBvbmVudD1uYXZdJyxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XCJbJy90YXNrcycsICdteSddXCIgY2xhc3M9XCJuYXYtbGlua1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtcGVuY2lsXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7J215X3Rhc2tzJyB8IHRyYW5zbGF0ZX19PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICA8YSBbcm91dGVyTGlua109XCJbJy90YXNrcycsICdpbmJveCddXCIgY2xhc3M9XCJuYXYtbGlua1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtaW5ib3hcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3sndGFza3NfYXNzaWduZWRfdG9fbWUnIHwgdHJhbnNsYXRlfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cIlsnLyddXCIgY2xhc3M9XCJuYXYtbGlua1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtZGFzaGJvYXJkXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7J2Rhc2hib2FyZCcgfCB0cmFuc2xhdGV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPGxpIGNsYXNzPVwiZGl2aWRlclwiPjwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3Byb2plY3RzJ11cIiBjbGFzcz1cIm5hdi1saW5rXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1wdXp6bGUtcGllY2VcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3sncHJvamVjdHMnIHwgdHJhbnNsYXRlfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBwcm9qZWN0IG9mIHByb2plY3RzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3Byb2plY3QnLCBwcm9qZWN0LmlkLCAndGFza3MnXVwiIGNsYXNzPVwibmF2LWxpbmtcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtZmlsZS10ZXh0LW9cIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57e3Byb2plY3QubmFtZX19PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgPC91bD5cclxuICAgIGAsXHJcbiAgICBkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdLFxyXG4gICAgcGlwZXM6IFtUcmFuc2xhdGVQaXBlXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIE5hdkNvbXBvbmVudCB7XHJcbiAgICBwcml2YXRlIHN0b3JlU3ViOiBTdWJzY3JpcHRpb247XHJcbiAgICBwcml2YXRlIHByb2plY3RzOiBQcm9qZWN0W107XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogU3RvcmU8YW55PixcclxuICAgICAgICBwcml2YXRlIHByb2plY3RTZXJ2aWNlOiBQcm9qZWN0U2VydmljZVxyXG4gICAgKSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnN0b3JlLnNlbGVjdCgncHJvamVjdHMnKS5zdWJzY3JpYmUoKHN0YXRlOiBJUHJvamVjdHNTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3RzID0gc3RhdGUucHJvamVjdHM7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZE5hdlByb2plY3RzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZVN1YiAmJiB0aGlzLnN0b3JlU3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZE5hdlByb2plY3RzKCkge1xyXG4gICAgICAgIHRoaXMucHJvamVjdFNlcnZpY2UuZmV0Y2hQcm9qZWN0cygpLnN1YnNjcmliZShhY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9uYXYudHNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPG5vdGlmaWNhdGlvbj48L25vdGlmaWNhdGlvbj5cXHJcXG48ZGl2IGNsYXNzPVxcXCJsYXlvdXRcXFwiIFtjbGFzcy5oaWRkZW5dPVxcXCIhaXNSZWFkeVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnQtb3ZlcmxheVxcXCIgKG1vdXNlZG93bik9XFxcImhpZGVOYXYoJGV2ZW50KVxcXCIgKHRvdWNoc3RhcnQpPVxcXCJoaWRlTmF2KCRldmVudClcXFwiPjwvZGl2PlxcclxcbiAgICA8aGVhZGVyIGNsYXNzPVxcXCJoZWFkZXIgbmF2YmFyIG5hdmJhci1maXhlZC10b3BcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaGVhZGVyXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuLXNpZGUtbmF2LXRvZ2dsZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiAoY2xpY2spPVxcXCJ0b2dnbGVOYXYoKVxcXCI+PC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcImJyYW5kLWxvZ29cXFwiIGFsdD1cXFwibG9nb1xcXCIgc3JjPVxcXCJpbWcvbG9nby5wbmdcXFwiIC8+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJicmFuZC10aXRsZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICB7e0hFQURFUl9USVRMRX19XFxyXFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8bmF2IGNsYXNzPVxcXCJuYXZiYXItbmF2IG5hdmJhci1yaWdodFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi1pbmxpbmUgbmF2YmFyLXJpZ2h0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxsaSBkcm9wZG93biBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGRyb3Bkb3duLXRvZ2dsZSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiZHJvcGRvd24tdG9nZ2xlXFxcIiAoY2xpY2spPVxcXCJwcmV2ZW50RGVmYXVsdCgkZXZlbnQpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXVzZXJcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51IHJpZ2h0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInVzZXItcHJvZmlsZVxcXCIgW3JvdXRlckxpbmtdPVxcXCJbJ3VzZXItcHJvZmlsZSddXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdXNlclxcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7bG9nZ2VkVXNlci5uYW1lfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9saT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcIndzXFxcIiBocmVmPVxcXCJ7e3dvcmtzcGFjZVVybH19XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdGhcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57eyd3b3Jrc3BhY2UnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgICAgIDwvdWw+XFxyXFxuICAgICAgICAgICAgICAgIDxmb3JtIGNsYXNzPVxcXCJuYXZiYXItZm9ybSBuYXZiYXItc2VhcmNoXFxcIiBuYW1lPVxcXCJmdC1zZWFyY2hcXFwiIChzdWJtaXQpPVxcXCJmdFNlYXJjaCgpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcImlkXFxcIiB2YWx1ZT1cXFwic2VhcmNoXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInNlYXJjaFxcXCIgY2xhc3M9XFxcInFcXFwiIG5hbWU9XFxcImtleXdvcmRcXFwiIHZhbHVlPVxcXCJ7e3NlYXJjaF9rZXl3b3JkfX1cXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydzZWFyY2gnIHwgdHJhbnNsYXRlfX1cXFwiIHJlcXVpcmVkIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiAoZm9jdXMpPVxcXCJzZWFyY2hUb2dnbGUoKVxcXCIgKGJsdXIpPVxcXCJzZWFyY2hUb2dnbGUoKVxcXCIgLz5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwicmVzZXRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS10aW1lc1xcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwic2VhcmNoXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICA8L2Zvcm0+XFxyXFxuICAgICAgICAgICAgPC9uYXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9oZWFkZXI+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgPG5hdiBkYXRhLWNvbXBvbmVudD1cXFwibmF2XFxcIiBjbGFzcz1cXFwiYXNpZGUgc2lkZS1uYXZcXFwiPjwvbmF2PlxcclxcbiAgICAgICAgPG1haW4gY2xhc3M9XFxcImNvbnRlbnRcXFwiPlxcclxcbiAgICAgICAgICAgIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cXHJcXG4gICAgICAgIDwvbWFpbj5cXHJcXG4gICAgPC9zZWN0aW9uPlxcclxcbjwvZGl2PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC90ZW1wbGF0ZXMvYXBwLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA2OTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IHByb3ZpZGVSb3V0ZXIsIFJvdXRlckNvbmZpZyB9ICBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5cclxuaW1wb3J0IHsgQXV0aEd1YXJkIH0gZnJvbSAnLi9hdXRoLmd1YXJkJztcclxuaW1wb3J0IHsgRGFzaGJvYXJkQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2Rhc2hib2FyZCc7XHJcbmltcG9ydCB7IFByb2plY3RzQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3Byb2plY3QvcHJvamVjdHMnO1xyXG5pbXBvcnQgeyBQcm9qZWN0Q29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3Byb2plY3QvcHJvamVjdCc7XHJcbmltcG9ydCB7IFRhc2tzQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3Rhc2svdGFza3MnO1xyXG5pbXBvcnQgeyBUYXNrQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3Rhc2svdGFzayc7XHJcbmltcG9ydCB7IFVzZXJQcm9maWxlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3VzZXItcHJvZmlsZSc7XHJcbmltcG9ydCB7IExvZ2luQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2xvZ2luJztcclxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vbW9kZWxzL3VzZXInO1xyXG5cclxuY29uc3Qgcm91dGVzOiBSb3V0ZXJDb25maWcgPSBbXHJcbiAgICB7IHBhdGg6ICcnLCBjb21wb25lbnQ6IERhc2hib2FyZENvbXBvbmVudCwgY2FuQWN0aXZhdGU6IFtBdXRoR3VhcmRdIH0sXHJcbiAgICB7IHBhdGg6ICdkYXNoYm9hcmQnLCBjb21wb25lbnQ6IERhc2hib2FyZENvbXBvbmVudCwgY2FuQWN0aXZhdGU6IFtBdXRoR3VhcmRdIH0sXHJcbiAgICB7IHBhdGg6ICdwcm9qZWN0cy86cHJvamVjdElkJywgY29tcG9uZW50OiBQcm9qZWN0Q29tcG9uZW50LCBjYW5BY3RpdmF0ZTogW0F1dGhHdWFyZF0gfSxcclxuICAgIHsgcGF0aDogJ3Byb2plY3RzJywgY29tcG9uZW50OiBQcm9qZWN0c0NvbXBvbmVudCwgY2FuQWN0aXZhdGU6IFtBdXRoR3VhcmRdIH0sXHJcbiAgICAvLyB7XHJcbiAgICAvLyAgICAgcGF0aDogJ3Byb2plY3RzJywgY29tcG9uZW50OiBQcm9qZWN0c0NvbXBvbmVudCwgY2FuQWN0aXZhdGU6IFtBdXRoR3VhcmRdLCBjaGlsZHJlbjogW1xyXG4gICAgLy8gICAgICAgICB7IHBhdGg6ICc6cHJvamVjdElkJywgY29tcG9uZW50OiBQcm9qZWN0Q29tcG9uZW50IH1cclxuICAgIC8vICAgICBdXHJcbiAgICAvLyB9LFxyXG4gICAgeyBwYXRoOiAncHJvamVjdC86cHJvamVjdElkL3Rhc2tzJywgY29tcG9uZW50OiBUYXNrc0NvbXBvbmVudCwgY2FuQWN0aXZhdGU6IFtBdXRoR3VhcmRdIH0sXHJcbiAgICB7IHBhdGg6ICd0YXNrcy86Zm9yJywgY29tcG9uZW50OiBUYXNrc0NvbXBvbmVudCwgY2FuQWN0aXZhdGU6IFtBdXRoR3VhcmRdIH0sXHJcbiAgICB7IHBhdGg6ICd0YXNrcycsIGNvbXBvbmVudDogVGFza3NDb21wb25lbnQsIGNhbkFjdGl2YXRlOiBbQXV0aEd1YXJkXSB9LFxyXG4gICAgeyBwYXRoOiAndGFzay86dGFza0lkLzpuZXcnLCBjb21wb25lbnQ6IFRhc2tDb21wb25lbnQsIGNhbkFjdGl2YXRlOiBbQXV0aEd1YXJkXSB9LFxyXG4gICAgeyBwYXRoOiAndGFzay86dGFza0lkJywgY29tcG9uZW50OiBUYXNrQ29tcG9uZW50LCBjYW5BY3RpdmF0ZTogW0F1dGhHdWFyZF0gfSxcclxuICAgIHsgcGF0aDogJ3VzZXItcHJvZmlsZScsIGNvbXBvbmVudDogVXNlclByb2ZpbGVDb21wb25lbnQsIGNhbkFjdGl2YXRlOiBbQXV0aEd1YXJkXSB9LFxyXG4gICAgeyBwYXRoOiAnbG9naW4nLCBjb21wb25lbnQ6IExvZ2luQ29tcG9uZW50IH0sXHJcbiAgICB7IHBhdGg6ICcqKicsIGNvbXBvbmVudDogRGFzaGJvYXJkQ29tcG9uZW50LCBjYW5BY3RpdmF0ZTogW0F1dGhHdWFyZF0gfVxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IEFQUF9ST1VURVJfUFJPVklERVJTID0gW1xyXG4gICAgcHJvdmlkZVJvdXRlcihyb3V0ZXMpLFxyXG4gICAgQXV0aEd1YXJkXHJcbl07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2FwcC5yb3V0ZXMudHNcbiAqKi8iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgICBSb3V0ZXIsXHJcbiAgICBDYW5BY3RpdmF0ZSxcclxuICAgIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsXHJcbiAgICBSb3V0ZXJTdGF0ZVNuYXBzaG90XHJcbn0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuXHJcbmltcG9ydCB7IEFwcFNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEF1dGhHdWFyZCBpbXBsZW1lbnRzIENhbkFjdGl2YXRlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGFwcFNlcnZpY2U6IEFwcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlclxyXG4gICAgKSB7IH1cclxuXHJcbiAgICBjYW5BY3RpdmF0ZShuZXh0OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZTogUm91dGVyU3RhdGVTbmFwc2hvdCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFwcFNlcnZpY2UuaXNMb2dnZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnbG9naW4nXSk7XHJcbiAgICAgICAgLy8gcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2F1dGguZ3VhcmQudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSHR0cCwgSGVhZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVQaXBlIH0gZnJvbSAnbmcyLXRyYW5zbGF0ZS9uZzItdHJhbnNsYXRlJztcclxuXHJcbmltcG9ydCB7IFByb2plY3RTZWxlY3RDb21wb25lbnQgfSBmcm9tICcuL3NoYXJlZC9wcm9qZWN0LXNlbGVjdCc7XHJcbmltcG9ydCB7IFByb2plY3QgfSBmcm9tICcuLi9tb2RlbHMnO1xyXG5pbXBvcnQgeyBwYXJzZVJlc3BvbnNlT2JqZWN0cywgc2VyaWFsaXplT2JqLCB0cmFuc2Zvcm1Qb3N0UmVzcG9uc2UgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcblxyXG5jb25zdCBIRUFERVJTID0gbmV3IEhlYWRlcnMoe1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnLFxyXG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG59KTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdbZGFzaGJvYXJkXScsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWhlYWRlclwiPlxyXG4gICAgICAgICAgICA8aDEgY2xhc3M9XCJoZWFkZXItdGl0bGVcIj5cclxuICAgICAgICAgICAgICAgIHt7J2Rhc2hib2FyZCcgfCB0cmFuc2xhdGV9fVxyXG4gICAgICAgICAgICA8L2gxPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWJvZHlcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhc2hib2FyZFwiICpuZ0Zvcj1cImxldCBwcm9qZWN0IG9mIHByb2plY3RzXCI+XHJcbiAgICAgICAgICAgICAgICA8aGVhZGVyPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7cHJvamVjdC5uYW1lfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAoY2xpY2spPVwiZGVsZXRlUHJvamVjdEZyb21EYXNoYm9hcmQocHJvamVjdC5pZClcIj5kZWxldGU8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvaGVhZGVyPlxyXG4gICAgICAgICAgICAgICAgPHNlY3Rpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdCBkYXRhXHJcbiAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BhbjNcIj5cclxuICAgICAgICAgICAgICAgIDxwcm9qZWN0LXNlbGVjdCAob25TZWxlY3QpPVwic2VsZWN0UHJvamVjdCgkZXZlbnQpXCI+PC9wcm9qZWN0LXNlbGVjdD5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG5cIiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cImFkZFByb2plY3RUb0Rhc2hib2FyZCgpXCI+e3snZGFzaGJvYXJkX2FkZF9wcm9qZWN0JyB8IHRyYW5zbGF0ZX19PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYCxcclxuICAgIGRpcmVjdGl2ZXM6IFtQcm9qZWN0U2VsZWN0Q29tcG9uZW50XSxcclxuICAgIHBpcGVzOiBbVHJhbnNsYXRlUGlwZV1cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRDb21wb25lbnQge1xyXG5cclxuICAgIHByaXZhdGUgcHJvamVjdHM6IFByb2plY3RbXTtcclxuICAgIHByaXZhdGUgcHJvamVjdElkOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwKSB7XHJcbiAgICAgICAgdGhpcy5mZXRjaERhc2hib2FyZFByb2plY3RzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBmZXRjaERhc2hib2FyZFByb2plY3RzKCkge1xyXG4gICAgICAgIHRoaXMuaHR0cC5nZXQoJ3A/aWQ9ZGFzaGJvYXJkJywgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gcGFyc2VSZXNwb25zZU9iamVjdHMocmVzcG9uc2UuanNvbigpLm9iamVjdHMpLnByb2plY3QpXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3RzID0gZGF0YSA/IGRhdGEubGlzdCA6IFtdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFkZFByb2plY3RUb0Rhc2hib2FyZCgpIHtcclxuICAgICAgICB0aGlzLmh0dHAucG9zdCgncD9pZD1kYXNoYm9hcmQnLCBgcHJvamVjdElkPSR7dGhpcy5wcm9qZWN0SWR9YCwgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaERhc2hib2FyZFByb2plY3RzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGVsZXRlUHJvamVjdEZyb21EYXNoYm9hcmQocHJvamVjdElkOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmh0dHAuZGVsZXRlKGBwP2lkPWRhc2hib2FyZCZwcm9qZWN0SWQ9JHtwcm9qZWN0SWR9YCwgeyBoZWFkZXJzOiBIRUFERVJTIH0pXHJcbiAgICAgICAgICAgIC5tYXAocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaERhc2hib2FyZFByb2plY3RzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2VsZWN0UHJvamVjdChwcm9qZWN0OiBQcm9qZWN0KSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0LmlkO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xpY2soKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL2Rhc2hib2FyZC50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgT25EZXN0cm95LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgRFJPUERPV05fRElSRUNUSVZFUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9kcm9wZG93bic7XHJcbmltcG9ydCB7IElQcm9qZWN0c1N0YXRlIH0gZnJvbSAnLi4vLi4vcmVkdWNlcnMvcHJvamVjdHMucmVkdWNlcic7XHJcbmltcG9ydCB7IFByb2plY3QgfSBmcm9tICcuLi8uLi9tb2RlbHMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Byb2plY3Qtc2VsZWN0JyxcclxuICAgIGRpcmVjdGl2ZXM6IFtEUk9QRE9XTl9ESVJFQ1RJVkVTXSxcclxuICAgIHBpcGVzOiBbVHJhbnNsYXRlUGlwZV0sXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDxkaXYgZHJvcGRvd24gY2xhc3M9XCJzZWxlY3RcIj5cclxuICAgICAgICAgICAgPGRpdiBkcm9wZG93bi10b2dnbGUgY2xhc3M9XCJzZWxlY3Qtc2VsZWN0aW9uIGlucHV0XCI+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57e3Byb2plY3Q/Lm5hbWV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IHNlbGVjdC1kcm9wZG93blwiPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwic2VsZWN0LWxpc3Qgc2Nyb2xsLXNoYWRvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInNlbGVjdC1vcHRpb25cIiBbY2xhc3Muc2VsZWN0ZWRdPVwicHJvamVjdElkID09IG0uaWRcIiAqbmdGb3I9XCJsZXQgbSBvZiBwcm9qZWN0c1wiIChjbGljayk9XCJzZWxlY3QobSlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3ttLm5hbWV9fVxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGBcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9qZWN0U2VsZWN0Q29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIHByb2plY3RJZDogc3RyaW5nO1xyXG4gICAgQE91dHB1dCgpIG9uU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHByaXZhdGUgc3ViOiBhbnk7XHJcbiAgICBwcml2YXRlIHByb2plY3RzOiBhbnk7XHJcbiAgICBwcml2YXRlIHByb2plY3Q6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0b3JlOiBTdG9yZTxhbnk+KSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnN1YiA9IHRoaXMuc3RvcmUuc2VsZWN0KCdwcm9qZWN0cycpLnN1YnNjcmliZSgoc3RhdGU6IElQcm9qZWN0c1N0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdHMgPSBzdGF0ZS5wcm9qZWN0cztcclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gc3RhdGUucHJvamVjdHMuZmlsdGVyKGl0ID0+IGl0LmlkID09IHRoaXMucHJvamVjdElkKVswXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdChtKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gbTtcclxuICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQodGhpcy5wcm9qZWN0KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL3NoYXJlZC9wcm9qZWN0LXNlbGVjdC50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBPbkRlc3Ryb3ksIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJvdXRlciwgUk9VVEVSX0RJUkVDVElWRVMgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL25vdGlmaWNhdGlvbic7XHJcbmltcG9ydCB7IFRleHRUcmFuc2Zvcm1QaXBlLCBEYXRlRm9ybWF0UGlwZSB9IGZyb20gJy4uLy4uL3BpcGVzJztcclxuaW1wb3J0IHsgUGFnaW5hdGlvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9wYWdpbmF0aW9uJztcclxuaW1wb3J0IHsgUHJvamVjdCB9IGZyb20gJy4uLy4uL21vZGVscy9wcm9qZWN0JztcclxuaW1wb3J0IHsgUHJvamVjdFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wcm9qZWN0LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQcm9qZWN0Um93Q29tcG9uZW50IH0gZnJvbSAnLi9wcm9qZWN0LXJvdyc7XHJcbmltcG9ydCB7IFByb2plY3RDb21wb25lbnQgfSBmcm9tICcuL3Byb2plY3QnO1xyXG5pbXBvcnQgeyBGRVRDSF9QUk9KRUNUUywgSVByb2plY3RzU3RhdGUgfSBmcm9tICcuLi8uLi9yZWR1Y2Vycy9wcm9qZWN0cy5yZWR1Y2VyJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdwcm9qZWN0LWxpc3QnLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3Byb2plY3RzLmh0bWwnKSxcclxuICAgIC8vIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgZGlyZWN0aXZlczogW1xyXG4gICAgICAgIFJPVVRFUl9ESVJFQ1RJVkVTLFxyXG4gICAgICAgIFBhZ2luYXRpb25Db21wb25lbnQsXHJcbiAgICAgICAgUHJvamVjdFJvd0NvbXBvbmVudFxyXG4gICAgXSxcclxuICAgIHBpcGVzOiBbRGF0ZUZvcm1hdFBpcGUsIFRyYW5zbGF0ZVBpcGUsIFRleHRUcmFuc2Zvcm1QaXBlXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFByb2plY3RzQ29tcG9uZW50IHtcclxuICAgIHByaXZhdGUgc3RvcmVTdWI6IGFueTtcclxuXHJcbiAgICB0aXRsZSA9ICdwcm9qZWN0cyc7XHJcbiAgICBwcm9qZWN0czogUHJvamVjdFtdO1xyXG4gICAgcGFyYW1zOiBhbnkgPSB7fTtcclxuICAgIG1ldGE6IGFueSA9IHt9O1xyXG4gICAgcmVxdWVzdFByb2Nlc3M6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgc3RvcmU6IFN0b3JlPGFueT4sXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcclxuICAgICAgICBwcml2YXRlIHByb2plY3RTZXJ2aWNlOiBQcm9qZWN0U2VydmljZSxcclxuICAgICAgICBwcml2YXRlIG5vdGlmeVNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2VcclxuICAgICkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZVN1YiA9IHRoaXMuc3RvcmUuc2VsZWN0KCdwcm9qZWN0cycpLnN1YnNjcmliZSgoZGF0YTogSVByb2plY3RzU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdHMgPSBkYXRhLnByb2plY3RzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhID0gZGF0YS5tZXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UHJvY2VzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZERhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnN0b3JlU3ViICYmIHRoaXMuc3RvcmVTdWIudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkRGF0YShwYXJhbXM/KSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0U2VydmljZS5mZXRjaFByb2plY3RzKHBhcmFtcykuc3Vic2NyaWJlKGFjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnb1RvUGFnZShwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmxvYWREYXRhKHtcclxuICAgICAgICAgICAgcGFnZTogcGFyYW1zLnBhZ2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZXdQcm9qZWN0KCkge1xyXG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnL3Byb2plY3RzJywgJ25ldyddKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVQcm9qZWN0KCkge1xyXG4gICAgICAgIC8vIHRoaXMucHJvamVjdFNlcnZpY2UuZGVsZXRlUHJvamVjdCh0aGlzLnNlbGVjdGVkUHJvamVjdHMpLnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvcHJvamVjdC9wcm9qZWN0cy50c1xuICoqLyIsImV4cG9ydCB7IERhdGVGb3JtYXRQaXBlIH0gZnJvbSAnLi9kYXRlLWZvcm1hdC5waXBlJztcclxuZXhwb3J0IHsgVGV4dFRyYW5zZm9ybVBpcGUgfSBmcm9tICcuL3RleHQtdHJhbnNmb3JtLnBpcGUnO1xyXG5leHBvcnQgeyBWYWx1ZXNQaXBlIH0gZnJvbSAnLi92YWx1ZXMucGlwZSc7XHJcbmV4cG9ydCB7IEtleXNQaXBlIH0gZnJvbSAnLi9rZXlzLnBpcGUnO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9waXBlcy9pbmRleC50c1xuICoqLyIsImltcG9ydCB7IFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdkYXRlRm10JyB9KVxyXG5leHBvcnQgY2xhc3MgRGF0ZUZvcm1hdFBpcGUge1xyXG4gICAgdHJhbnNmb3JtKGRhdGU6IHN0cmluZywgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghZGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWZvcm1hdCkge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSAnREQuTU0uWVlZWSBISDptbSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWQgPSBtb21lbnQoZGF0ZSwgZm9ybWF0KTtcclxuXHJcbiAgICAgICAgaWYgKG1kLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWQuZm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvcGlwZXMvZGF0ZS1mb3JtYXQucGlwZS50c1xuICoqLyIsImltcG9ydCB7IFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBQaXBlKHsgbmFtZTogJ3RleHQnIH0pXHJcbmV4cG9ydCBjbGFzcyBUZXh0VHJhbnNmb3JtUGlwZSB7XHJcbiAgICB0cmFuc2Zvcm0odGV4dDogc3RyaW5nLCB0cmFuc2Zvcm06IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgY2FzZSAnTCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBjYXNlICdVJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvcGlwZXMvdGV4dC10cmFuc2Zvcm0ucGlwZS50c1xuICoqLyIsImltcG9ydCB7IFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBQaXBlKHsgbmFtZTogJ3ZhbHVlcycgfSlcclxuZXhwb3J0IGNsYXNzIFZhbHVlc1BpcGUge1xyXG4gICAgdHJhbnNmb3JtKHZhbHVlczogYW55LCBhcmdzOiBzdHJpbmdbXSk6IGFueSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlcykubWFwKGtleSA9PiB2YWx1ZXNba2V5XSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvcGlwZXMvdmFsdWVzLnBpcGUudHNcbiAqKi8iLCJpbXBvcnQgeyBQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AUGlwZSh7IG5hbWU6ICdrZXlzJyB9KVxyXG5leHBvcnQgY2xhc3MgS2V5c1BpcGUge1xyXG4gICAgdHJhbnNmb3JtKHZhbHVlLCBhcmdzOiBzdHJpbmdbXSk6IGFueSB7XHJcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3BpcGVzL2tleXMucGlwZS50c1xuICoqLyIsImV4cG9ydCAqIGZyb20gJy4vcGFnaW5hdGlvbic7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC9wYWdpbmF0aW9uL2luZGV4LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAncGFnaW5hdGlvbicsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uXCIgKm5nSWY9XCJ0b3RhbFBhZ2VzID4gMVwiPlxyXG4gICAgICAgICAgICA8YSBocmVmPVwiI1wiICpuZ0lmPVwic3RhcnRQYWdlID4gMVwiIChjbGljayk9XCJ0b1BhZ2UoJGV2ZW50LCAxKVwiPjE8L2E+XHJcbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwic3RhcnRQYWdlID4gMVwiPi4uLjwvc3Bhbj5cclxuICAgICAgICAgICAgPGEgW2NsYXNzLnBhZ2UtYWN0aXZlXT1cInAgPT0gY3VycmVudFBhZ2VcIiBocmVmPVwiI1wiICpuZ0Zvcj1cImxldCBwIG9mIHBhZ2VzXCIgKGNsaWNrKT1cInRvUGFnZSgkZXZlbnQsIHApXCI+e3twfX08L2E+XHJcbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwic3RvcFBhZ2UgPCB0b3RhbFBhZ2VzXCI+Li4uPC9zcGFuPlxyXG4gICAgICAgICAgICA8YSAqbmdJZj1cInN0b3BQYWdlIDwgdG90YWxQYWdlc1wiIGhyZWY9XCIjXCIgKGNsaWNrKT1cInRvUGFnZSgkZXZlbnQsIHRvdGFsUGFnZXMpXCI+e3t0b3RhbFBhZ2VzfX08L2E+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgUGFnaW5hdGlvbkNvbXBvbmVudCB7XHJcbiAgICBASG9zdEJpbmRpbmcoJ2hpZGRlbicpIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRoaXMudG90YWxQYWdlcyA8IDI7IH07XHJcbiAgICBASW5wdXQoKSBtYXhQYWdlQ29udHJvbDogbnVtYmVyID0gNTtcclxuICAgIEBJbnB1dCgpIHRvdGFsUGFnZXM6IG51bWJlciA9IC0xO1xyXG4gICAgQElucHV0KCdwYWdlJylcclxuICAgIHNldCBwYWdlKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gK3ZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA8IDIpIHtcclxuICAgICAgICAgICAgKyt0aGlzLmluaXRpYWxpemVkO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG5cclxuICAgIGluaXRpYWxpemVkOiBudW1iZXIgPSAwO1xyXG4gICAgY3VycmVudFBhZ2U6IG51bWJlciA9IDA7XHJcbiAgICBzdGFydFBhZ2U6IG51bWJlciA9IDA7XHJcbiAgICBzdG9wUGFnZTogbnVtYmVyID0gMDtcclxuICAgIHBhZ2VzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcblxyXG4gICAgdG9QYWdlKGV2ZW50LCBwYWdlOiBudW1iZXIpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSArcGFnZTtcclxuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KHsgcGFnZTogcGFnZSB9KTtcclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBwYWdpbmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucGFnZXMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxQYWdlcyA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWF4UGFnZUNvbnRyb2wgPSArdGhpcy5tYXhQYWdlQ29udHJvbDtcclxuICAgICAgICB0aGlzLnRvdGFsUGFnZXMgPSArdGhpcy50b3RhbFBhZ2VzO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSArdGhpcy5jdXJyZW50UGFnZTtcclxuXHJcbiAgICAgICAgbGV0IHBlclBhZ2UgPSBNYXRoLmZsb29yKHRoaXMubWF4UGFnZUNvbnRyb2wgLyAyKTtcclxuICAgICAgICB0aGlzLnN0YXJ0UGFnZSA9ICh0aGlzLmN1cnJlbnRQYWdlIC0gcGVyUGFnZSk7XHJcbiAgICAgICAgdGhpcy5zdG9wUGFnZSA9ICh0aGlzLmN1cnJlbnRQYWdlICsgcGVyUGFnZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0UGFnZSA8PSBwZXJQYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQYWdlID0gMTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFBhZ2UgPT0gdGhpcy50b3RhbFBhZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQYWdlID0gdGhpcy50b3RhbFBhZ2VzIC0gdGhpcy5tYXhQYWdlQ29udHJvbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN0b3BQYWdlID4gKHRoaXMudG90YWxQYWdlcyAtIHBlclBhZ2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFBhZ2UgPSB0aGlzLnRvdGFsUGFnZXM7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRQYWdlID09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wUGFnZSA9IHRoaXMubWF4UGFnZUNvbnRyb2wgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCh0aGlzLm1heFBhZ2VDb250cm9sICsgcGVyUGFnZSkgPj0gdGhpcy50b3RhbFBhZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQYWdlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wUGFnZSA9IHRoaXMudG90YWxQYWdlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnN0YXJ0UGFnZTsgcCA8PSB0aGlzLnN0b3BQYWdlOyBwKyspIHtcclxuICAgICAgICAgICAgdGhpcy5wYWdlcy5wdXNoKHApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zaGFyZWQvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJPVVRFUl9ESVJFQ1RJVkVTIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBUZXh0VHJhbnNmb3JtUGlwZSwgRGF0ZUZvcm1hdFBpcGUgfSBmcm9tICcuLi8uLi9waXBlcyc7XHJcbmltcG9ydCB7IEN1c3RvbWVyQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC9jdXN0b21lci1jZWxsJztcclxuaW1wb3J0IHsgVXNlckNlbGxDb21wb25lbnQgfSBmcm9tICcuLi9zaGFyZWQvdXNlci1jZWxsJztcclxuaW1wb3J0IHsgUHJvamVjdCB9IGZyb20gJy4uLy4uL21vZGVscy9wcm9qZWN0JztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdwcm9qZWN0LXJvdycsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90ZW1wbGF0ZXMvcHJvamVjdC1yb3cuaHRtbCcpLFxyXG4gICAgZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTLCBDdXN0b21lckNlbGxDb21wb25lbnQsIFVzZXJDZWxsQ29tcG9uZW50XSxcclxuICAgIHBpcGVzOiBbRGF0ZUZvcm1hdFBpcGUsIFRyYW5zbGF0ZVBpcGUsIFRleHRUcmFuc2Zvcm1QaXBlXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFByb2plY3RSb3dDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgcHJvamVjdDogUHJvamVjdDtcclxuICAgIC8vIEBPdXRwdXRcclxuICAgIHByaXZhdGUgc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICB0b2dnbGVTZWxlY3RlZCgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gIXRoaXMuc2VsZWN0ZWQ7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9wcm9qZWN0L3Byb2plY3Qtcm93LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnY3VzdG9tZXItY2VsbCcsXHJcbiAgICB0ZW1wbGF0ZTogYHt7IGN1c3RvbWVyPy5uYW1lIH19YFxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIEN1c3RvbWVyQ2VsbENvbXBvbmVudCB7XHJcbiAgICBASW5wdXQoKSBjdXN0b21lcklkOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgcHJpdmF0ZSBjdXN0b21lcjogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RvcmU6IFN0b3JlPGFueT4pIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc3ViID0gdGhpcy5zdG9yZS5zZWxlY3QoJ3N0YWZmJykuc3Vic2NyaWJlKChzdGF0ZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tZXIgPSBzdGF0ZS5vcmdhbml6YXRpb25zLmZpbHRlcihpdCA9PiBpdC5pZCA9PSB0aGlzLmN1c3RvbWVySWQpWzBdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvY3VzdG9tZXItY2VsbC50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3VzZXItY2VsbCcsXHJcbiAgICB0ZW1wbGF0ZTogYHt7IHVzZXI/LmxvZ2luIH19YFxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFVzZXJDZWxsQ29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIHVzZXJJZDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBzdWI6IGFueTtcclxuICAgIHByaXZhdGUgdXNlcjogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RvcmU6IFN0b3JlPGFueT4pIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc3ViID0gdGhpcy5zdG9yZS5zZWxlY3QoJ3N0YWZmJykuc3Vic2NyaWJlKChzdGF0ZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS51c2Vycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyID0gc3RhdGUudXNlcnMuZmlsdGVyKGl0ID0+IGl0LmlkID09IHRoaXMudXNlcklkKVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvdXNlci1jZWxsLnRzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImVudHJ5LXdyYXBcXFwiIFtjbGFzcy5hY3RpdmVdPVxcXCJzZWxlY3RlZFxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImVudHJ5XFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiZW50cnktc2VsZWN0XFxcIj5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInByb2plY3QtaWRcXFwiIHZhbHVlPVxcXCJ7e3Byb2plY3QuaWR9fVxcXCIgKGNoYW5nZSk9XFxcInRvZ2dsZVNlbGVjdGVkKClcXFwiIFtjaGVja2VkXT1cXFwic2VsZWN0ZWRcXFwiIC8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGEgY2xhc3M9XFxcImVudHJ5LWxpbmtcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiWycuLycsIHByb2plY3QuaWRdXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlbnRyeS1maWVsZHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctcHJvamVjdC1uYW1lXFxcIj57e3Byb2plY3QubmFtZX19PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctcHJvamVjdC1zdGF0dXNcXFwiPnt7cHJvamVjdC5zdGF0dXMgfCB0ZXh0OidMJyB8IHRyYW5zbGF0ZX19PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctaWNvblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtcGFwZXJjbGlwXFxcIiAqbmdJZj1cXFwicHJvamVjdC5oYXNBdHRhY2htZW50c1xcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy1wcm9qZWN0LWN1c3RvbWVyXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxjdXN0b21lci1jZWxsIFtjdXN0b21lcklkXT1cXFwicHJvamVjdC5jdXN0b21lcklkXFxcIj48L2N1c3RvbWVyLWNlbGw+XFxyXFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZ3LXVzZXItbWFuYWdlclxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8dXNlci1jZWxsIFt1c2VySWRdPVxcXCJwcm9qZWN0Lm1hbmFnZXJVc2VySWRcXFwiPjwvdXNlci1jZWxsPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy11c2VyLXByb2dyYW1tZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHVzZXItY2VsbCBbdXNlcklkXT1cXFwicHJvamVjdC5wcm9ncmFtbWVyVXNlcklkXFxcIj48L3VzZXItY2VsbD5cXHJcXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctdXNlci10ZXN0ZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHVzZXItY2VsbCBbdXNlcklkXT1cXFwicHJvamVjdC50ZXN0ZXJVc2VySWRcXFwiPjwvdXNlci1jZWxsPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy1kYXRlXFxcIj57e3Byb2plY3QuZmluaXNoRGF0ZSB8IGRhdGVGbXR9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvYT5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2NvbXBvbmVudHMvcHJvamVjdC90ZW1wbGF0ZXMvcHJvamVjdC1yb3cuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDgwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImNvbnRlbnQtaGVhZGVyXFxcIj5cXHJcXG4gICAgPGgxIGNsYXNzPVxcXCJoZWFkZXItdGl0bGVcXFwiPlxcclxcbiAgICAgICAge3t0aXRsZSB8IHRyYW5zbGF0ZX19XFxyXFxuICAgIDwvaDE+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnQtYWN0aW9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwibmV3UHJvamVjdCgpXFxcIj5cXHJcXG4gICAgICAgICAgICB7eyduZXdfcHJvamVjdCcgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICA8cGFnaW5hdGlvbiBbdG90YWxQYWdlc109XFxcIm1ldGEudG90YWxQYWdlc1xcXCIgW3BhZ2VdPVxcXCJtZXRhLnBhZ2VcXFwiIChjaGFuZ2UpPVxcXCJnb1RvUGFnZSgkZXZlbnQpXFxcIj48L3BhZ2luYXRpb24+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnQtYm9keVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcInZpZXcgdmlldy1wcm9qZWN0XFxcIiBbY2xhc3MubG9hZF09XFxcInJlcXVlc3RQcm9jZXNzXFxcIj5cXHJcXG4gICAgICAgIDxoZWFkZXIgY2xhc3M9XFxcImVudHJpZXMtaGVhZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZC13cmFwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJlbnRyeS1zZWxlY3RcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBjbGFzcz1cXFwiYWxsXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlbnRyeS1jYXB0aW9uc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctcHJvamVjdC1uYW1lXFxcIj57eyduYW1lJyB8IHRyYW5zbGF0ZX19PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZ3LXByb2plY3Qtc3RhdHVzXFxcIj57eydzdGF0dXMnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctaWNvblxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBhcGVyY2xpcFxcXCI+PC9pPjwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy1wcm9qZWN0LWN1c3RvbWVyXFxcIj57eydjdXN0b21lcicgfCB0cmFuc2xhdGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy11c2VyLW1hbmFnZXJcXFwiPnt7J21hbmFnZXInIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctdXNlci1wcm9ncmFtbWVyXFxcIj57eydwcm9ncmFtbWVyJyB8IHRyYW5zbGF0ZX19PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZ3LXVzZXItdGVzdGVyXFxcIj57eyd0ZXN0ZXInIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctZGF0ZVxcXCI+e3snZmluaXNoX2RhdGUnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9oZWFkZXI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlbnRyaWVzXFxcIj5cXHJcXG4gICAgICAgICAgICA8cHJvamVjdC1yb3cgW3Byb2plY3RdPVxcXCJwcm9qZWN0XFxcIiAqbmdGb3I9XFxcImxldCBwcm9qZWN0IG9mIHByb2plY3RzXFxcIj48L3Byb2plY3Qtcm93PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2Plxcclxcbjxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvY29tcG9uZW50cy9wcm9qZWN0L3RlbXBsYXRlcy9wcm9qZWN0cy5odG1sXG4gKiogbW9kdWxlIGlkID0gODEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIEluamVjdCwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyLCBBY3RpdmF0ZWRSb3V0ZSwgUk9VVEVSX0RJUkVDVElWRVMgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBGb3JtQnVpbGRlciwgVmFsaWRhdG9ycywgQ29udHJvbEdyb3VwLCBDb250cm9sLCBGT1JNX0RJUkVDVElWRVMgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUsIFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9ub3RpZmljYXRpb24nO1xyXG5pbXBvcnQgeyBEYXRlcGlja2VyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2RhdGVwaWNrZXIvZGF0ZXBpY2tlcic7XHJcbmltcG9ydCB7IERST1BET1dOX0RJUkVDVElWRVMgfSBmcm9tICcuLi8uLi9zaGFyZWQvZHJvcGRvd24nO1xyXG5pbXBvcnQgeyBNYXJrZG93bkVkaXRvckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9tYXJrZG93bic7XHJcbmltcG9ydCB7IFN3aXRjaEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9zd2l0Y2gtYnV0dG9uJztcclxuaW1wb3J0IHsgQ3VzdG9tZXJTZWxlY3RDb21wb25lbnQgfSBmcm9tICcuLi9zaGFyZWQvY3VzdG9tZXItc2VsZWN0JztcclxuaW1wb3J0IHsgVXNlclNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC91c2VyLXNlbGVjdCc7XHJcbmltcG9ydCB7IEF0dGFjaG1lbnRzQ29tcG9uZW50IH0gZnJvbSAnLi4vYXR0YWNobWVudHMnO1xyXG5pbXBvcnQgeyBUZXh0VHJhbnNmb3JtUGlwZSB9IGZyb20gJy4uLy4uL3BpcGVzJztcclxuaW1wb3J0IHsgQXBwU2VydmljZSwgUHJvamVjdFNlcnZpY2UsIFRhc2tTZXJ2aWNlLCBTdGFmZlNlcnZpY2UsIFJlZmVyZW5jZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XHJcbmltcG9ydCB7IFByb2plY3QsIE9yZ2FuaXphdGlvbiwgVXNlciwgQXR0YWNobWVudCB9IGZyb20gJy4uLy4uL21vZGVscyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAncHJvamVjdCcsXHJcbiAgICBzdHlsZXM6IFtgcHJvamVjdCB7IGRpc3BsYXk6IGJsb2NrOyB9YF0sXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90ZW1wbGF0ZXMvcHJvamVjdC5odG1sJyksXHJcbiAgICBkaXJlY3RpdmVzOiBbXHJcbiAgICAgICAgUk9VVEVSX0RJUkVDVElWRVMsXHJcbiAgICAgICAgRk9STV9ESVJFQ1RJVkVTLFxyXG4gICAgICAgIERST1BET1dOX0RJUkVDVElWRVMsXHJcbiAgICAgICAgU3dpdGNoQnV0dG9uQ29tcG9uZW50LFxyXG4gICAgICAgIEN1c3RvbWVyU2VsZWN0Q29tcG9uZW50LFxyXG4gICAgICAgIFVzZXJTZWxlY3RDb21wb25lbnQsXHJcbiAgICAgICAgQXR0YWNobWVudHNDb21wb25lbnQsXHJcbiAgICAgICAgTWFya2Rvd25FZGl0b3JDb21wb25lbnQsXHJcbiAgICAgICAgRGF0ZXBpY2tlckRpcmVjdGl2ZVxyXG4gICAgXSxcclxuICAgIHByb3ZpZGVyczogW0Zvcm1CdWlsZGVyXSxcclxuICAgIHBpcGVzOiBbVHJhbnNsYXRlUGlwZSwgVGV4dFRyYW5zZm9ybVBpcGVdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgUHJvamVjdENvbXBvbmVudCB7XHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgcHJpdmF0ZSBzdG9yZVN1YjogYW55O1xyXG5cclxuICAgIGlzUmVhZHkgPSBmYWxzZTtcclxuICAgIHByb2plY3Q6IFByb2plY3Q7XHJcbiAgICBmb3JtOiBDb250cm9sR3JvdXA7XHJcblxyXG4gICAgcHJvamVjdFN0YXR1c1R5cGVzOiBhbnk7XHJcbiAgICBwcml2YXRlIHRvO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgc3RvcmU6IFN0b3JlPGFueT4sXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcclxuICAgICAgICBwcml2YXRlIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSxcclxuICAgICAgICBwcml2YXRlIGZvcm1CdWlsZGVyOiBGb3JtQnVpbGRlcixcclxuICAgICAgICBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIGFwcFNlcnZpY2U6IEFwcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBwcm9qZWN0U2VydmljZTogUHJvamVjdFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBzdGFmZlNlcnZpY2U6IFN0YWZmU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIG5vdGlmeVNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2VcclxuICAgICkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5mb3JtQnVpbGRlci5ncm91cCh7XHJcbiAgICAgICAgICAgIG5hbWU6IFsnJywgVmFsaWRhdG9ycy5yZXF1aXJlZF0sXHJcbiAgICAgICAgICAgIHN0YXR1czogWycnXSxcclxuICAgICAgICAgICAgY3VzdG9tZXJVc2VySWQ6IFsnJ10sXHJcbiAgICAgICAgICAgIG1hbmFnZXJVc2VySWQ6IFsnJ10sXHJcbiAgICAgICAgICAgIHByb2dyYW1tZXJVc2VySWQ6IFsnJ10sXHJcbiAgICAgICAgICAgIHRlc3RlclVzZXJJZDogWycnXSxcclxuICAgICAgICAgICAgb2JzZXJ2ZXJVc2VySWRzOiBbJyddLFxyXG4gICAgICAgICAgICBjb21tZW50OiBbJyddLFxyXG4gICAgICAgICAgICBmaW5pc2hEYXRlOiBbJyddLFxyXG4gICAgICAgICAgICBhdHRhY2htZW50czogWycnXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnN1YiA9IHRoaXMucm91dGUucGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3RTZXJ2aWNlLmZldGNoUHJvamVjdEJ5SWQocGFyYW1zWydwcm9qZWN0SWQnXSkuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2plY3QgPSBhY3Rpb24ucGF5bG9hZC5wcm9qZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZERhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yID0+IHRoaXMuaGFuZGxlWGhyRXJyb3IoZXJyb3IpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZERhdGEoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0U2VydmljZS5nZXRQcm9qZWN0U3RhdHVzVHlwZXMoKS5zdWJzY3JpYmUocHN0ID0+IHRoaXMucHJvamVjdFN0YXR1c1R5cGVzID0gcHN0KTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVQcm9qZWN0Q29tbWVudCh0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnByb2plY3QuY29tbWVudCA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RmluaXNoRGF0ZShkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0LmZpbmlzaERhdGUgPSBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHNhdmVQcm9qZWN0KCkge1xyXG4gICAgICAgIGxldCBub3R5ID0gdGhpcy5ub3RpZnlTZXJ2aWNlLnByb2Nlc3ModGhpcy50cmFuc2xhdGUuaW5zdGFudCgnd2FpdF93aGlsZV9kb2N1bWVudF9zYXZlJykpLnNob3coKTtcclxuICAgICAgICB0aGlzLnByb2plY3RTZXJ2aWNlLnNhdmVQcm9qZWN0KHRoaXMucHJvamVjdCkuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBub3R5LnNldCh7IHR5cGU6ICdzdWNjZXNzJywgbWVzc2FnZTogcmVzcG9uc2UubWVzc2FnZSB9KS5yZW1vdmUoMTUwMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgICAgIG5vdHkuc2V0KHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB9KS5yZW1vdmUoMTUwMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yU2F2ZVByb2plY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAoKSA9PiBub3R5LnJlbW92ZSgxNTAwKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZXJyb3JTYXZlUHJvamVjdChlcnJvclJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3JSZXNwb25zZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlUHJvamVjdCgpIHtcclxuICAgICAgICB0aGlzLnByb2plY3RTZXJ2aWNlLmRlbGV0ZVByb2plY3QoW3RoaXMucHJvamVjdF0pLnN1YnNjcmliZShkYXRhID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnL3Byb2plY3RzJ10pO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZVhockVycm9yKGVycm9yUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvclJlc3BvbnNlKTtcclxuICAgICAgICBpZiAoZXJyb3JSZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbJy9sb2dpbiddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U3RhdHVzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0LnN0YXR1cyA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlRHJvcGRvd24oKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdEN1c3RvbWVyKGN1c3RvbWVyOiBPcmdhbml6YXRpb24pIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2VsZWN0JywgY3VzdG9tZXIpO1xyXG4gICAgICAgIHRoaXMucHJvamVjdC5jdXN0b21lcklkID0gY3VzdG9tZXIuaWQ7XHJcbiAgICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0TWFuYWdlcih1c2VyOiBVc2VyKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0Lm1hbmFnZXJVc2VySWQgPSB1c2VyLmlkO1xyXG4gICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdFByb2dyYW1tZXIodXNlcjogVXNlcikge1xyXG4gICAgICAgIHRoaXMucHJvamVjdC5wcm9ncmFtbWVyVXNlcklkID0gdXNlci5pZDtcclxuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RUZXN0ZXIodXNlcjogVXNlcikge1xyXG4gICAgICAgIHRoaXMucHJvamVjdC50ZXN0ZXJVc2VySWQgPSB1c2VyLmlkO1xyXG4gICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdE9ic2VydmVyKG9ic2VydmVyOiBVc2VyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb2plY3Qub2JzZXJ2ZXJVc2VySWRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdC5vYnNlcnZlclVzZXJJZHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0Lm9ic2VydmVyVXNlcklkcy5wdXNoKG9ic2VydmVyLmlkKTtcclxuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVPYnNlcnZlcihvYnNlcnZlcjogVXNlciwgJGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0Lm9ic2VydmVyVXNlcklkcy5mb3JFYWNoKChpZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlkID09PSBvYnNlcnZlci5pZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0Lm9ic2VydmVyVXNlcklkcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBdHRhY2htZW50KGZpbGUpIHtcclxuICAgICAgICBsZXQgYXR0OiBBdHRhY2htZW50ID0gbmV3IEF0dGFjaG1lbnQoKTtcclxuICAgICAgICBhdHQucmVhbEZpbGVOYW1lID0gZmlsZS5maWxlc1swXTtcclxuICAgICAgICBpZiAoIXRoaXMucHJvamVjdC5hdHRhY2htZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3QuYXR0YWNobWVudHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb2plY3QuZnNpZCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3QuZnNpZCA9ICcnICsgRGF0ZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0LmF0dGFjaG1lbnRzLnB1c2goYXR0KTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVBdHRhY2htZW50KGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQpIHtcclxuICAgICAgICB0aGlzLnByb2plY3RTZXJ2aWNlLmRlbGV0ZVByb2plY3RBdHRhY2htZW50KHRoaXMucHJvamVjdCwgYXR0YWNobWVudCkuc3Vic2NyaWJlKHIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3QuYXR0YWNobWVudHMgPSB0aGlzLnByb2plY3QuYXR0YWNobWVudHMuZmlsdGVyKGl0ID0+IGl0LmlkICE9IGF0dGFjaG1lbnQuaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvcHJvamVjdC9wcm9qZWN0LnRzXG4gKiovIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBFbGVtZW50UmVmLCBPbkluaXQsIE9uRGVzdHJveSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5jb25zdCBQaWthZGF5ID0gcmVxdWlyZSgncGlrYWRheScpO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1tkYXRlcGlja2VyXSdcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyRGlyZWN0aXZlIHtcclxuICAgIEBJbnB1dCgpIGZvcm1hdDogc3RyaW5nID0gJ0RELk1NLllZWVkgSEg6bW0nO1xyXG4gICAgQE91dHB1dCgpIHNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgcHJpdmF0ZSBwaWNrZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnBpY2tlciA9IG5ldyBQaWthZGF5KHtcclxuICAgICAgICAgICAgZmllbGQ6IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LFxyXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxyXG4gICAgICAgICAgICBvblNlbGVjdDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMucGlja2VyLnRvU3RyaW5nKHRoaXMuZm9ybWF0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnBpY2tlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2hhcmVkL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci50c1xuICoqLyIsImV4cG9ydCAqIGZyb20gJy4vc3dpdGNoLWJ1dHRvbic7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC9zd2l0Y2gtYnV0dG9uL2luZGV4LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgQWZ0ZXJDb250ZW50SW5pdCwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdzd2l0Y2gtYnV0dG9uJyxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPGxhYmVsXHJcbiAgICAgICAgICAgICBbbmdDbGFzc109XCJjbGFzc1wiXHJcbiAgICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cImlzU2VsZWN0ZWQoaXRlbSlcIlxyXG4gICAgICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkIHx8IGl0ZW0uZGlzYWJsZWRcIlxyXG4gICAgICAgICAgICAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj5cclxuICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICB0eXBlPVwie3ttdWx0aSA/ICdjaGVja2JveCcgOiAncmFkaW8nfX1cIlxyXG4gICAgICAgICAgICAgICAgbmFtZT1cInt7bmFtZX19XCJcclxuICAgICAgICAgICAgICAgIHZhbHVlPVwie3tpdGVtLnZhbHVlfX1cIlxyXG4gICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwiaXNTZWxlY3RlZChpdGVtKVwiXHJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgaXRlbS5kaXNhYmxlZFwiXHJcbiAgICAgICAgICAgICAgICAoY2hhbmdlKT1cInNlbGVjdChpdGVtLnZhbHVlKVwiIC8+XHJcbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEte3tpdGVtLmljb259fVwiICpuZ0lmPVwiaXRlbS5pY29uXCI+PC9pPlxyXG4gICAgICAgICAgICA8c3Bhbj57e2l0ZW0udGV4dH19PC9zcGFuPlxyXG4gICAgICAgIDwvbGFiZWw+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgU3dpdGNoQnV0dG9uQ29tcG9uZW50IHtcclxuICAgIEBIb3N0QmluZGluZygnY2xhc3Muc3dpdGNoLWJ1dHRvbicpIHRydWU7XHJcbiAgICBASW5wdXQoKSBtb2RlbDtcclxuICAgIEBJbnB1dCgpIHZhbHVlOyAvLyBtb2RlbCBmaWVsZCBuYW1lXHJcbiAgICBASW5wdXQoKSBpdGVtcztcclxuICAgIEBJbnB1dCgpIGNsYXNzID0gJ2lucHV0JztcclxuICAgIEBJbnB1dCgpIG5hbWUgPSAnc3diJyArIE1hdGgucmFuZG9tKCk7XHJcbiAgICBASW5wdXQoKSBtdWx0aSA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIGNoZWNrRGVmYXVsdCA9IHRydWU7XHJcblxyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgICAgIFtdLmNvbmNhdCh0aGlzLml0ZW1zKS5mb3JFYWNoKGl0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tEZWZhdWx0ICYmIGl0LnZhbHVlID09IHRoaXMubW9kZWxbdGhpcy52YWx1ZV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tEZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm1vZGVsW3RoaXMudmFsdWVdID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaXNTZWxlY3RlZChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgPT0gdGhpcy5tb2RlbFt0aGlzLnZhbHVlXSB8fCAodGhpcy5jaGVja0RlZmF1bHQgJiYgaXRlbS5kZWZhdWx0KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9zaGFyZWQvc3dpdGNoLWJ1dHRvbi9zd2l0Y2gtYnV0dG9uLnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBEUk9QRE9XTl9ESVJFQ1RJVkVTIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Ryb3Bkb3duJztcclxuaW1wb3J0IHsgT3JnYW5pemF0aW9uIH0gZnJvbSAnLi4vLi4vbW9kZWxzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdjdXN0b21lci1zZWxlY3QnLFxyXG4gICAgZGlyZWN0aXZlczogW0RST1BET1dOX0RJUkVDVElWRVNdLFxyXG4gICAgcGlwZXM6IFtUcmFuc2xhdGVQaXBlXSxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPGRpdiBkcm9wZG93biBjbGFzcz1cInNlbGVjdFwiPlxyXG4gICAgICAgICAgICA8ZGl2IGRyb3Bkb3duLXRvZ2dsZSBjbGFzcz1cInNlbGVjdC1zZWxlY3Rpb24gaW5wdXRcIj5cclxuICAgICAgICAgICAgICAgIDxzcGFuPnt7Y3VzdG9tZXI/Lm5hbWV9fTwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IHNlbGVjdC1kcm9wZG93blwiPlxyXG4gICAgICAgICAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwic2VsZWN0LXNlYXJjaFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBuYW1lPVwia2V5d29yZFwiIHBsYWNlaG9sZGVyPVwie3snc2VhcmNoJyB8IHRyYW5zbGF0ZX19XCIgKGtleXVwKT1cInNlYXJjaEN1c3RvbWVyKCRldmVudClcIiAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+IC0tPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwic2VsZWN0LWxpc3Qgc2Nyb2xsLXNoYWRvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInNlbGVjdC1vcHRpb25cIiBbY2xhc3Muc2VsZWN0ZWRdPVwiY3VzdG9tZXI/LmlkID09IG0uaWRcIiAqbmdGb3I9XCJsZXQgbSBvZiBjdXN0b21lcnNcIiAoY2xpY2spPVwic2VsZWN0KG0pXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7bS5uYW1lfX1cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tZXJTZWxlY3RDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgY3VzdG9tZXJJZDogc3RyaW5nO1xyXG4gICAgQE91dHB1dCgpIG9uU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHByaXZhdGUgc3ViOiBhbnk7XHJcbiAgICBwcml2YXRlIGN1c3RvbWVyczogYW55O1xyXG4gICAgcHJpdmF0ZSBjdXN0b21lcjogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RvcmU6IFN0b3JlPGFueT4pIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc3ViID0gdGhpcy5zdG9yZS5zZWxlY3QoJ3N0YWZmJykuc3Vic2NyaWJlKChzdGF0ZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tZXJzID0gc3RhdGUub3JnYW5pemF0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21lciA9IHN0YXRlLm9yZ2FuaXphdGlvbnMuZmlsdGVyKGl0ID0+IGl0LmlkID09IHRoaXMuY3VzdG9tZXJJZClbMF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QobSkge1xyXG4gICAgICAgIHRoaXMuY3VzdG9tZXIgPSBtO1xyXG4gICAgICAgIHRoaXMub25TZWxlY3QuZW1pdCh0aGlzLmN1c3RvbWVyKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL3NoYXJlZC9jdXN0b21lci1zZWxlY3QudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVQaXBlIH0gZnJvbSAnbmcyLXRyYW5zbGF0ZS9uZzItdHJhbnNsYXRlJztcclxuXHJcbmltcG9ydCB7IERST1BET1dOX0RJUkVDVElWRVMgfSBmcm9tICcuLi8uLi9zaGFyZWQvZHJvcGRvd24nO1xyXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1c2VyLXNlbGVjdCcsXHJcbiAgICBkaXJlY3RpdmVzOiBbRFJPUERPV05fRElSRUNUSVZFU10sXHJcbiAgICBwaXBlczogW1RyYW5zbGF0ZVBpcGVdLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2IGRyb3Bkb3duIGNsYXNzPVwic2VsZWN0XCI+XHJcbiAgICAgICAgICAgIDxkaXYgZHJvcGRvd24tdG9nZ2xlIGNsYXNzPVwic2VsZWN0LXNlbGVjdGlvbiBpbnB1dFwiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4+e3t1c2VyPy51c2VyTmFtZSB8fCB1c2VyPy5sb2dpbn19PC9zcGFuPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgc2VsZWN0LWRyb3Bkb3duXCI+XHJcbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJzZWxlY3QtbGlzdCBzY3JvbGwtc2hhZG93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwic2VsZWN0LW9wdGlvblwiIFtjbGFzcy5zZWxlY3RlZF09XCJ1c2VySWQgPT0gbS5pZFwiICpuZ0Zvcj1cImxldCBtIG9mIHVzZXJzXCIgKGNsaWNrKT1cInNlbGVjdChtKVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7e20ubmFtZSB8fCBtLmxvZ2lufX1cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVXNlclNlbGVjdENvbXBvbmVudCB7XHJcbiAgICBASW5wdXQoKSB1c2VySWQ6IHN0cmluZztcclxuICAgIEBPdXRwdXQoKSBvblNlbGVjdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgcHJpdmF0ZSB1c2VyczogYW55O1xyXG4gICAgcHJpdmF0ZSB1c2VyOiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzdG9yZTogU3RvcmU8YW55PikgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5zdWIgPSB0aGlzLnN0b3JlLnNlbGVjdCgnc3RhZmYnKS5zdWJzY3JpYmUoKHN0YXRlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51c2VycyA9IHN0YXRlLnVzZXJzO1xyXG4gICAgICAgICAgICB0aGlzLnVzZXIgPSBzdGF0ZS51c2Vycy5maWx0ZXIoaXQgPT4gaXQuaWQgPT0gdGhpcy51c2VySWQpWzBdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0KG0pIHtcclxuICAgICAgICB0aGlzLnVzZXIgPSBtO1xyXG4gICAgICAgIHRoaXMub25TZWxlY3QuZW1pdCh0aGlzLnVzZXIpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvc2hhcmVkL3VzZXItc2VsZWN0LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uSW5pdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHAsIEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9odHRwJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBVcGxvYWRTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMnO1xyXG5pbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnLi4vbW9kZWxzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdhdHRhY2htZW50cycsXHJcbiAgICBwaXBlczogW1RyYW5zbGF0ZVBpcGVdLFxyXG4gICAgaG9zdDoge1xyXG4gICAgICAgICdbY2xhc3MuYXR0YWNobWVudHNdJzogJ3RydWUnXHJcbiAgICB9LFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLXVwbG9hZFwiIHRpdGxlPVwie3snYXR0YWNoX2ZpbGUnIHwgdHJhbnNsYXRlfX1cIj5cclxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1wYXBlcmNsaXBcIj48L2k+XHJcbiAgICAgICAgICAgIDxzcGFuPnt7J2F0dGFjaF9maWxlJyB8IHRyYW5zbGF0ZX19PC9zcGFuPlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiAoY2hhbmdlKT1cInVwbG9hZEZpbGUoJGV2ZW50KVwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiLz5cclxuICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJhdHRhY2gtbGlzdFwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXR0YWNoLWl0ZW1cIiAqbmdGb3I9XCJsZXQgYXR0IG9mIGVudGl0eS5hdHRhY2htZW50c1wiPlxyXG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJhdHRhY2gtbmFtZVwiIGhyZWY9XCJ7e2VudGl0eS51cmx9fSZhdHRhY2htZW50PXt7YXR0LmlkfX1cIj5cclxuICAgICAgICAgICAgICAgICAgICB7e2F0dC5yZWFsRmlsZU5hbWV9fVxyXG4gICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgYnRuLXJlbW92ZVwiIChjbGljayk9XCJkZWxldGVBdHRhY2goYXR0LCAkZXZlbnQpXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS10aW1lc1wiPjwvaT5cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGBcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBBdHRhY2htZW50c0NvbXBvbmVudCB7XHJcbiAgICBASW5wdXQoKSBlbnRpdHk6IGFueTtcclxuICAgIEBPdXRwdXQoKSB1cGxvYWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSBkZWxldGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuXHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgcHJpdmF0ZSBwcm9ncmVzc0VsOiBhbnk7XHJcbiAgICBwcml2YXRlIHByb2dyZXNzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgaHR0cDogSHR0cCxcclxuICAgICAgICBwcml2YXRlIHVwbG9hZFNlcnZpY2U6IFVwbG9hZFNlcnZpY2VcclxuICAgICkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5zdWIgPSB0aGlzLnVwbG9hZFNlcnZpY2UucHJvZ3Jlc3MkLnN1YnNjcmliZShwcm9ncmVzcyA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+IDAgJiYgcHJvZ3Jlc3MgPCAxMDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGxvYWRGaWxlKCRldmVudCkge1xyXG4gICAgICAgIGxldCBmaWxlczogRmlsZVtdID0gJGV2ZW50LnRhcmdldC5maWxlcztcclxuICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UubWFrZUZpbGVSZXF1ZXN0KCdVcGxvYWRGaWxlP3RpbWU9JyArIERhdGUubm93KCksIHsgZnNpZDogdGhpcy5lbnRpdHkuZnNpZCB9LCBmaWxlcykuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgdGhpcy51cGxvYWQuZW1pdChyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlQXR0YWNoKGF0dDogQXR0YWNobWVudCwgJGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGUuZW1pdChhdHQpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvYXR0YWNobWVudHMudHNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvcm0gY2xhc3M9XFxcImZvcm1cXFwiIFtuZ0Zvcm1Nb2RlbF09XFxcImZvcm1cXFwiICpuZ0lmPVxcXCJpc1JlYWR5XFxcIj5cXHJcXG4gICAgPGhlYWRlciBjbGFzcz1cXFwiY29udGVudC1oZWFkZXJcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuLWJhY2tcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tbGVmdFxcXCI+PC9pPlxcclxcbiAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICA8aDEgY2xhc3M9XFxcImhlYWRlci10aXRsZVxcXCI+XFxyXFxuICAgICAgICAgICAge3socHJvamVjdC5pZCA/ICdwcm9qZWN0JyA6ICduZXdfcHJvamVjdCcpIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgIDwvaDE+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50LWFjdGlvbnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBbZGlzYWJsZWRdPVxcXCIhZm9ybS52YWxpZFxcXCIgKGNsaWNrKT1cXFwic2F2ZVByb2plY3QoKVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J3NhdmVfY2xvc2UnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J2Nsb3NlJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPGRpdiBkcm9wZG93biBjbGFzcz1cXFwiYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgZHJvcGRvd24tdG9nZ2xlPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0blxcXCI+Li4uPC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiZGVsZXRlUHJvamVjdCgpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB7eydkZWxldGUnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2hlYWRlcj5cXHJcXG4gICAgPHNlY3Rpb24gY2xhc3M9XFxcImNvbnRlbnQtYm9keVxcXCI+XFxyXFxuICAgICAgICA8ZmllbGRzZXQgY2xhc3M9XFxcImZpZWxkc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICB7eyduYW1lJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCIgW2NsYXNzLmhhcy1lcnJvcl09XFxcIiFmb3JtLmNvbnRyb2xzLm5hbWUudmFsaWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJzcGFuOFxcXCIgWyhuZ01vZGVsKV09XFxcInByb2plY3QubmFtZVxcXCIgbmdDb250cm9sPVxcXCJuYW1lXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICB7eydjdXN0b21lcicgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy5jdXN0b21lclVzZXJJZC52YWxpZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzcGFuOFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGN1c3RvbWVyLXNlbGVjdCBbY3VzdG9tZXJJZF09XFxcInByb2plY3QuY3VzdG9tZXJJZFxcXCIgKG9uU2VsZWN0KT1cXFwic2VsZWN0Q3VzdG9tZXIoJGV2ZW50KVxcXCI+PC9jdXN0b21lci1zZWxlY3Q+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAge3snbWFuYWdlcicgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy5tYW5hZ2VyVXNlcklkLnZhbGlkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNwYW44XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8dXNlci1zZWxlY3QgW3VzZXJJZF09XFxcInByb2plY3QubWFuYWdlclVzZXJJZFxcXCIgKG9uU2VsZWN0KT1cXFwic2VsZWN0TWFuYWdlcigkZXZlbnQpXFxcIj48L3VzZXItc2VsZWN0PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHt7J3Byb2dyYW1tZXInIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIiBbY2xhc3MuaGFzLWVycm9yXT1cXFwiIWZvcm0uY29udHJvbHMucHJvZ3JhbW1lclVzZXJJZC52YWxpZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzcGFuOFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHVzZXItc2VsZWN0IFt1c2VySWRdPVxcXCJwcm9qZWN0LnByb2dyYW1tZXJVc2VySWRcXFwiIChvblNlbGVjdCk9XFxcInNlbGVjdFByb2dyYW1tZXIoJGV2ZW50KVxcXCI+PC91c2VyLXNlbGVjdD5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICB7eyd0ZXN0ZXInIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIiBbY2xhc3MuaGFzLWVycm9yXT1cXFwiIWZvcm0uY29udHJvbHMudGVzdGVyVXNlcklkLnZhbGlkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNwYW44XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8dXNlci1zZWxlY3QgW3VzZXJJZF09XFxcInByb2plY3QudGVzdGVyVXNlcklkXFxcIiAob25TZWxlY3QpPVxcXCJzZWxlY3RUZXN0ZXIoJGV2ZW50KVxcXCI+PC91c2VyLXNlbGVjdD5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICB7eydvYnNlcnZlcnMnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNwYW44XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8dXNlci1zZWxlY3QgW3VzZXJJZF09XFxcInByb2plY3Qub2JzZXJ2ZXJVc2VySWRzXFxcIiAob25TZWxlY3QpPVxcXCJzZWxlY3RPYnNlcnZlcigkZXZlbnQpXFxcIj48L3VzZXItc2VsZWN0PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHt7J3N0YXR1cycgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHN3aXRjaC1idXR0b24gW21vZGVsXT1cXFwicHJvamVjdFxcXCIgdmFsdWU9XFxcInN0YXR1c1xcXCIgW2l0ZW1zXT1cXFwicHJvamVjdFN0YXR1c1R5cGVzXFxcIj48L3N3aXRjaC1idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHt7J2ZpbmlzaF9kYXRlJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcInNwYW4yXFxcIiBkYXRlcGlja2VyIChzZWxlY3QpPVxcXCJzZXRGaW5pc2hEYXRlKCRldmVudClcXFwiIFsobmdNb2RlbCldPVxcXCJwcm9qZWN0LmZpbmlzaERhdGVcXFwiIG5nQ29udHJvbD1cXFwiZmluaXNoRGF0ZVxcXCIgLz5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAge3snY29tbWVudCcgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy5jb21tZW50LnZhbGlkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNwYW44XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8bWFya2Rvd24tZWRpdG9yIFttYXJrZG93bl09XFxcInByb2plY3QuY29tbWVudCB8fCAnJ1xcXCIgZWRpdGFibGU9XFxcInRydWVcXFwiIHVwZGF0ZVRpbWVvdXQ9XFxcIjMwMFxcXCIgKHVwZGF0ZSk9XFxcInVwZGF0ZVByb2plY3RDb21tZW50KCRldmVudClcXFwiPjwvbWFya2Rvd24tZWRpdG9yPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9maWVsZHNldD5cXHJcXG4gICAgICAgIDxhdHRhY2htZW50cyBbZW50aXR5XT1cXFwicHJvamVjdFxcXCIgKHVwbG9hZCk9XFxcImFkZEF0dGFjaG1lbnQoJGV2ZW50KVxcXCIgKGRlbGV0ZSk9XFxcImRlbGV0ZUF0dGFjaG1lbnQoJGV2ZW50KVxcXCI+PC9hdHRhY2htZW50cz5cXHJcXG4gICAgPC9zZWN0aW9uPlxcclxcbjwvZm9ybT5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvY29tcG9uZW50cy9wcm9qZWN0L3RlbXBsYXRlcy9wcm9qZWN0Lmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA4MTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBPbkluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJvdXRlciwgQWN0aXZhdGVkUm91dGUsIFJPVVRFUl9ESVJFQ1RJVkVTIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9ub3RpZmljYXRpb24nO1xyXG5pbXBvcnQgeyBUZXh0VHJhbnNmb3JtUGlwZSwgRGF0ZUZvcm1hdFBpcGUgfSBmcm9tICcuLi8uLi9waXBlcyc7XHJcbmltcG9ydCB7IFBhZ2luYXRpb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvcGFnaW5hdGlvbic7XHJcbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuLi8uLi9tb2RlbHMvdGFzayc7XHJcbmltcG9ydCB7IFRhc2tTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvdGFzay5zZXJ2aWNlJztcclxuaW1wb3J0IHsgVGFza1Jvd0NvbXBvbmVudCB9IGZyb20gJy4vdGFzay1yb3cnO1xyXG5pbXBvcnQgeyBUYXNrQ29tcG9uZW50IH0gZnJvbSAnLi90YXNrJztcclxuaW1wb3J0IHsgRkVUQ0hfVEFTS1MsIElUYXNrc1N0YXRlIH0gZnJvbSAnLi4vLi4vcmVkdWNlcnMvdGFza3MucmVkdWNlcic7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndGFza3MnLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3Rhc2tzLmh0bWwnKSxcclxuICAgIC8vIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgZGlyZWN0aXZlczogW1JPVVRFUl9ESVJFQ1RJVkVTLCBQYWdpbmF0aW9uQ29tcG9uZW50LCBUYXNrUm93Q29tcG9uZW50XSxcclxuICAgIHBpcGVzOiBbRGF0ZUZvcm1hdFBpcGUsIFRyYW5zbGF0ZVBpcGUsIFRleHRUcmFuc2Zvcm1QaXBlXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFRhc2tzQ29tcG9uZW50IHtcclxuICAgIHByaXZhdGUgc3RvcmVTdWI6IGFueTtcclxuICAgIHByaXZhdGUgcGFyYW1zU3ViOiBhbnk7XHJcbiAgICB0aXRsZTogc3RyaW5nO1xyXG4gICAgdGFza3M6IFRhc2tbXTtcclxuICAgIHBhcmFtczogYW55ID0ge307XHJcbiAgICBtZXRhOiBhbnkgPSB7fTtcclxuICAgIHJlcXVlc3RQcm9jZXNzOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIHN0b3JlOiBTdG9yZTxhbnk+LFxyXG4gICAgICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUsXHJcbiAgICAgICAgcHJpdmF0ZSB0YXNrU2VydmljZTogVGFza1NlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBub3RpZnlTZXJ2aWNlOiBOb3RpZmljYXRpb25TZXJ2aWNlXHJcbiAgICApIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc3RvcmVTdWIgPSB0aGlzLnN0b3JlLnNlbGVjdCgndGFza3MnKS5zdWJzY3JpYmUoKGRhdGE6IElUYXNrc1N0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2tzID0gZGF0YS50YXNrcztcclxuICAgICAgICAgICAgICAgIHRoaXMubWV0YSA9IGRhdGEubWV0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFByb2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBhcmFtc1N1YiA9IHRoaXMucm91dGUucGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdGFza0ZvciA9IHBhcmFtc1snZm9yJ107XHJcbiAgICAgICAgICAgIGxldCBwcm9qZWN0SWQgPSBwYXJhbXNbJ3Byb2plY3RJZCddO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRhc2tGb3IpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2luYm94JzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpdGxlID0gJ3Rhc2tzX2Fzc2lnbmVkX3RvX21lJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ215JzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpdGxlID0gJ215X3Rhc2tzJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aXRsZSA9ICd0YXNrcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZERhdGEodGhpcy5wYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3RvcmVTdWIudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB0aGlzLnBhcmFtc1N1Yi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWREYXRhKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFByb2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZmV0Y2hUYXNrcyhwYXJhbXMpLnN1YnNjcmliZShhY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ29Ub1BhZ2UocGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkRGF0YSh7XHJcbiAgICAgICAgICAgIHBhZ2U6IHBhcmFtcy5wYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmV3VGFzaygpIHtcclxuICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbJy90YXNrJywgJ25ldyddKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVUYXNrKHRhc2s6IFRhc2spIHtcclxuICAgICAgICB0aGlzLnRhc2tTZXJ2aWNlLmRlbGV0ZVRhc2soW3Rhc2tdKS5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL3Rhc2svdGFza3MudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJPVVRFUl9ESVJFQ1RJVkVTIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBVc2VyQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC91c2VyLWNlbGwnO1xyXG5pbXBvcnQgeyBUYWdzQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC90YWdzLWNlbGwnO1xyXG5pbXBvcnQgeyBUZXh0VHJhbnNmb3JtUGlwZSwgRGF0ZUZvcm1hdFBpcGUgfSBmcm9tICcuLi8uLi9waXBlcyc7XHJcbmltcG9ydCB7IFRhc2sgfSBmcm9tICcuLi8uLi9tb2RlbHMvdGFzayc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndGFzay1yb3cnLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3Rhc2stcm93Lmh0bWwnKSxcclxuICAgIGRpcmVjdGl2ZXM6IFtST1VURVJfRElSRUNUSVZFUywgVXNlckNlbGxDb21wb25lbnQsIFRhZ3NDZWxsQ29tcG9uZW50XSxcclxuICAgIHBpcGVzOiBbRGF0ZUZvcm1hdFBpcGUsIFRyYW5zbGF0ZVBpcGUsIFRleHRUcmFuc2Zvcm1QaXBlXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFRhc2tSb3dDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgdGFzazogVGFzaztcclxuICAgIHNlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgdG9nZ2xlU2VsZWN0ZWQoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9ICF0aGlzLnNlbGVjdGVkO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvdGFzay90YXNrLXJvdy50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3RhZ3MtY2VsbCcsXHJcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwidGFnXCIgW3N0eWxlLmNvbG9yXT1cInRhZy5jb2xvclwiICpuZ0Zvcj1cImxldCB0YWcgb2YgdGFnc1wiPnt7dGFnLm5hbWV9fTwvc3Bhbj5gXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFnc0NlbGxDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgdGFnSWRzOiBzdHJpbmdbXTtcclxuICAgIHByaXZhdGUgc3ViOiBhbnk7XHJcbiAgICBwcml2YXRlIHRhZ3M6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0b3JlOiBTdG9yZTxhbnk+KSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnN1YiA9IHRoaXMuc3RvcmUuc2VsZWN0KCdyZWZlcmVuY2UnKS5zdWJzY3JpYmUoKHN0YXRlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRhZ3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IHN0YXRlLnRhZ3MuZmlsdGVyKGl0ID0+IHRoaXMudGFnSWRzLmluZGV4T2YoaXQuaWQpICE9IC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvdGFncy1jZWxsLnRzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImVudHJ5LXdyYXBcXFwiIFtjbGFzcy5hY3RpdmVdPVxcXCJzZWxlY3RlZFxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImVudHJ5XFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiZW50cnktc2VsZWN0XFxcIj5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInRhc2staWRcXFwiIHZhbHVlPVxcXCJ7e3Rhc2suaWR9fVxcXCIgKGNoYW5nZSk9XFxcInRvZ2dsZVNlbGVjdGVkKClcXFwiIFtjaGVja2VkXT1cXFwic2VsZWN0ZWRcXFwiIC8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGEgY2xhc3M9XFxcImVudHJ5LWxpbmtcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiWycvdGFzaycsIHRhc2suaWRdXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlbnRyeS1maWVsZHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctdGFzay1ib2R5XFxcIj57e3Rhc2sudGl0bGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZ3LXRhc2stc3RhdHVzXFxcIj57e3Rhc2suc3RhdHVzIHwgdGV4dDonTCcgfCB0cmFuc2xhdGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZ3LXRhc2stcHJpb3JpdHlcXFwiPnt7dGFzay5wcmlvcml0eSB8IHRleHQ6J0wnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy10YXNrLWFzc2lnbmVlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDx1c2VyLWNlbGwgW3VzZXJJZF09XFxcInRhc2suYXNzaWduZWVVc2VySWRcXFwiPjwvdXNlci1jZWxsPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy1kYXRlXFxcIj57e3Rhc2suc3RhcnREYXRlIHwgZGF0ZUZtdH19PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctZGF0ZVxcXCI+e3t0YXNrLmR1ZURhdGUgfCBkYXRlRm10fX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy10YWdzXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDx0YWdzLWNlbGwgW3RhZ0lkc109XFxcInRhc2sudGFnSWRzXFxcIj48L3RhZ3MtY2VsbD5cXHJcXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9hPlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvY29tcG9uZW50cy90YXNrL3RlbXBsYXRlcy90YXNrLXJvdy5odG1sXG4gKiogbW9kdWxlIGlkID0gODIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY29udGVudC1oZWFkZXJcXFwiPlxcclxcbiAgICA8aDEgY2xhc3M9XFxcImhlYWRlci10aXRsZVxcXCI+XFxyXFxuICAgICAgICB7e3RpdGxlIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgPC9oMT5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGVudC1hY3Rpb25zXFxcIj5cXHJcXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0blxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiAoY2xpY2spPVxcXCJuZXdUYXNrKClcXFwiPlxcclxcbiAgICAgICAgICAgIHt7J25ld190YXNrJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxwYWdpbmF0aW9uIFt0b3RhbFBhZ2VzXT1cXFwibWV0YS50b3RhbFBhZ2VzXFxcIiBbcGFnZV09XFxcIm1ldGEucGFnZVxcXCIgKGNoYW5nZSk9XFxcImdvVG9QYWdlKCRldmVudClcXFwiPjwvcGFnaW5hdGlvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuPGRpdiBjbGFzcz1cXFwiY29udGVudC1ib2R5XFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwidmlldyB2aWV3LXRhc2tcXFwiIFtjbGFzcy5sb2FkXT1cXFwicmVxdWVzdFByb2Nlc3NcXFwiPlxcclxcbiAgICAgICAgPGhlYWRlciBjbGFzcz1cXFwiZW50cmllcy1oZWFkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkLXdyYXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImVudHJ5LXNlbGVjdFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGNsYXNzPVxcXCJhbGxcXFwiIC8+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImVudHJ5LWNhcHRpb25zXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy10YXNrLWJvZHlcXFwiPnt7J3Rhc2tfdGl0bGUnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctdGFzay1zdGF0dXNcXFwiPnt7J3N0YXR1cycgfCB0cmFuc2xhdGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy10YXNrLXByaW9yaXR5XFxcIj57eydwcmlvcml0eScgfCB0cmFuc2xhdGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ2dy10YXNrLWFzc2lnbmVlXFxcIj57eydhc3NpZ25lZV91c2VyJyB8IHRyYW5zbGF0ZX19PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInZ3LWRhdGVcXFwiPnt7J3N0YXJ0X2RhdGUnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctZGF0ZVxcXCI+e3snZHVlX2RhdGUnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidnctdGFnc1xcXCI+e3sndGFncycgfCB0cmFuc2xhdGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2hlYWRlcj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImVudHJpZXNcXFwiPlxcclxcbiAgICAgICAgICAgIDx0YXNrLXJvdyBbdGFza109XFxcInRhc2tcXFwiICpuZ0Zvcj1cXFwibGV0IHRhc2sgb2YgdGFza3NcXFwiPjwvdGFzay1yb3c+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9jb21wb25lbnRzL3Rhc2svdGVtcGxhdGVzL3Rhc2tzLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA4MjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSb3V0ZXIsIEFjdGl2YXRlZFJvdXRlLCBST1VURVJfRElSRUNUSVZFUyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IEZvcm1CdWlsZGVyLCBWYWxpZGF0b3JzLCBDb250cm9sR3JvdXAsIENvbnRyb2wsIEZPUk1fRElSRUNUSVZFUyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSwgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL25vdGlmaWNhdGlvbic7XHJcbmltcG9ydCB7IERhdGVwaWNrZXJEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9zaGFyZWQvZGF0ZXBpY2tlci9kYXRlcGlja2VyJztcclxuaW1wb3J0IHsgVEFCX0RJUkVDVElWRVMgfSBmcm9tICcuLi8uLi9zaGFyZWQvdGFicyc7XHJcbmltcG9ydCB7IERST1BET1dOX0RJUkVDVElWRVMgfSBmcm9tICcuLi8uLi9zaGFyZWQvZHJvcGRvd24nO1xyXG5pbXBvcnQgeyBNYXJrZG93bkVkaXRvckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9tYXJrZG93bic7XHJcbmltcG9ydCB7IFN3aXRjaEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9zd2l0Y2gtYnV0dG9uJztcclxuaW1wb3J0IHsgVXNlclNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC91c2VyLXNlbGVjdCc7XHJcbmltcG9ydCB7IFByb2plY3RTZWxlY3RDb21wb25lbnQgfSBmcm9tICcuLi9zaGFyZWQvcHJvamVjdC1zZWxlY3QnO1xyXG5pbXBvcnQgeyBUYXNrVHlwZVNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC90YXNrLXR5cGUtc2VsZWN0JztcclxuaW1wb3J0IHsgVGFnc1NlbGVjdENvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC90YWdzLXNlbGVjdCc7XHJcbmltcG9ydCB7IFRhc2tSZXF1ZXN0c0NvbXBvbmVudCB9IGZyb20gJy4vdGFzay1yZXF1ZXN0cyc7XHJcbmltcG9ydCB7IFRhc2tSZXF1ZXN0Q29tcG9uZW50IH0gZnJvbSAnLi90YXNrLXJlcXVlc3QnO1xyXG5pbXBvcnQgeyBBdHRhY2htZW50c0NvbXBvbmVudCB9IGZyb20gJy4uL2F0dGFjaG1lbnRzJztcclxuaW1wb3J0IHsgQ29tbWVudHNDb21wb25lbnQgfSBmcm9tICcuLi9jb21tZW50L2NvbW1lbnRzJztcclxuaW1wb3J0IHsgVEFTS19SRVFVRVNUX05FVywgVEFTS19SRVFVRVNUX0NBTkNFTCwgVEFTS19DTE9TRSwgSVRhc2tTdGF0ZSB9IGZyb20gJy4uLy4uL3JlZHVjZXJzL3Rhc2sucmVkdWNlcic7XHJcbmltcG9ydCB7IFRleHRUcmFuc2Zvcm1QaXBlIH0gZnJvbSAnLi4vLi4vcGlwZXMnO1xyXG5pbXBvcnQgeyBBcHBTZXJ2aWNlLCBQcm9qZWN0U2VydmljZSwgVGFza1NlcnZpY2UsIFJlZmVyZW5jZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XHJcbmltcG9ydCB7IFByb2plY3QsIFRhc2ssIFRhZywgVGFza1R5cGUsIFJlcXVlc3QsIENvbW1lbnQsIFVzZXIsIEF0dGFjaG1lbnQgfSBmcm9tICcuLi8uLi9tb2RlbHMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Rhc2snLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3Rhc2suaHRtbCcpLFxyXG4gICAgZGlyZWN0aXZlczogW1xyXG4gICAgICAgIFJPVVRFUl9ESVJFQ1RJVkVTLFxyXG4gICAgICAgIEZPUk1fRElSRUNUSVZFUyxcclxuICAgICAgICBTd2l0Y2hCdXR0b25Db21wb25lbnQsXHJcbiAgICAgICAgRFJPUERPV05fRElSRUNUSVZFUyxcclxuICAgICAgICBUQUJfRElSRUNUSVZFUyxcclxuICAgICAgICBVc2VyU2VsZWN0Q29tcG9uZW50LFxyXG4gICAgICAgIFByb2plY3RTZWxlY3RDb21wb25lbnQsXHJcbiAgICAgICAgVGFza1R5cGVTZWxlY3RDb21wb25lbnQsXHJcbiAgICAgICAgVGFnc1NlbGVjdENvbXBvbmVudCxcclxuICAgICAgICBUYXNrUmVxdWVzdHNDb21wb25lbnQsXHJcbiAgICAgICAgVGFza1JlcXVlc3RDb21wb25lbnQsXHJcbiAgICAgICAgQXR0YWNobWVudHNDb21wb25lbnQsXHJcbiAgICAgICAgQ29tbWVudHNDb21wb25lbnQsXHJcbiAgICAgICAgTWFya2Rvd25FZGl0b3JDb21wb25lbnQsXHJcbiAgICAgICAgRGF0ZXBpY2tlckRpcmVjdGl2ZVxyXG4gICAgXSxcclxuICAgIHByb3ZpZGVyczogW0Zvcm1CdWlsZGVyXSxcclxuICAgIHBpcGVzOiBbVHJhbnNsYXRlUGlwZSwgVGV4dFRyYW5zZm9ybVBpcGVdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFza0NvbXBvbmVudCB7XHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgaXNSZWFkeSA9IGZhbHNlO1xyXG4gICAgaXNOZXcgPSB0cnVlO1xyXG4gICAgaXNTdWJ0YXNrID0gZmFsc2U7XHJcbiAgICBwYXJlbnRUYXNrOiBUYXNrO1xyXG4gICAgdGFzazogVGFzaztcclxuICAgIHJpZ2h0czogYW55ID0ge1xyXG4gICAgICAgIGFkZFN1YnRhc2s6IGZhbHNlLFxyXG4gICAgICAgIGRvUmVxdWVzdDogZmFsc2UsXHJcbiAgICAgICAgZG9SZXNvbHV0aW9uOiBmYWxzZSxcclxuICAgICAgICBhZGRDb21tZW50OiBmYWxzZSxcclxuICAgICAgICByZW1vdmVUYXNrOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIGZvcm06IENvbnRyb2xHcm91cDtcclxuICAgIHNob3dSZXF1ZXN0OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBoYXNVblJlc29sdmVkUmVxdWVzdDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBoYXNBY2NlcHRlZFJlcXVlc3RSZXNvbHV0aW9uOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICB0YXNrUHJpb3JpdHlUeXBlczogYW55O1xyXG4gICAgdGFza1N0YXR1c1R5cGVzOiBhbnk7XHJcbiAgICBjb21tZW50czogQ29tbWVudFtdO1xyXG4gICAgcmVxdWVzdHM6IFJlcXVlc3RbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIHN0b3JlOiBTdG9yZTxhbnk+LFxyXG4gICAgICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUsXHJcbiAgICAgICAgcHJpdmF0ZSBmb3JtQnVpbGRlcjogRm9ybUJ1aWxkZXIsXHJcbiAgICAgICAgcHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBhcHBTZXJ2aWNlOiBBcHBTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgcHJvamVjdFNlcnZpY2U6IFByb2plY3RTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgdGFza1NlcnZpY2U6IFRhc2tTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgcmVmZXJlbmNlU2VydmljZTogUmVmZXJlbmNlU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIG5vdGlmeVNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2VcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuc3RvcmUuc2VsZWN0KCd0YXNrJykuc3Vic2NyaWJlKChzdGF0ZTogSVRhc2tTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1lbnRzID0gc3RhdGUuY29tbWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHMgPSBzdGF0ZS5yZXF1ZXN0cztcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNVblJlc29sdmVkUmVxdWVzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5mb3JFYWNoKGl0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQucmVzb2x1dGlvbiA9PSAnVU5LTk9XTicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNVblJlc29sdmVkUmVxdWVzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5yZXNvbHV0aW9uID09ICdBQ0NFUFQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQWNjZXB0ZWRSZXF1ZXN0UmVzb2x1dGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JtID0gZm9ybUJ1aWxkZXIuZ3JvdXAoe1xyXG4gICAgICAgICAgICB0aXRsZTogWycnXSxcclxuICAgICAgICAgICAgcHJvamVjdElkOiBbJyddLFxyXG4gICAgICAgICAgICB0YXNrVHlwZUlkOiBbJyddLFxyXG4gICAgICAgICAgICBzdGF0dXM6IFsnJ10sXHJcbiAgICAgICAgICAgIHByaW9yaXR5OiBbJyddLFxyXG4gICAgICAgICAgICBib2R5OiBbJycvKiwgVmFsaWRhdG9ycy5yZXF1aXJlZCovXSxcclxuICAgICAgICAgICAgYXNzaWduZWVVc2VySWQ6IFsnJ10sXHJcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogWycnXSxcclxuICAgICAgICAgICAgZHVlRGF0ZTogWycnXSxcclxuICAgICAgICAgICAgdGFnSWRzOiBbJyddLFxyXG4gICAgICAgICAgICBhdHRhY2htZW50czogWycnXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc3ViID0gdGhpcy5yb3V0ZS5wYXJhbXMuc3Vic2NyaWJlKHBhcmFtcyA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOZXcgPSAocGFyYW1zWyd0YXNrSWQnXSA9PT0gJ25ldycpIHx8IChwYXJhbXNbJ3Rhc2tJZCddICYmIHBhcmFtc1snbmV3J10gPT09ICduZXcnKVxyXG4gICAgICAgICAgICB0aGlzLmlzU3VidGFzayA9IHBhcmFtc1sndGFza0lkJ10gJiYgcGFyYW1zWyduZXcnXSA9PT0gJ25ldyc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRhc2tTZXJ2aWNlLmZldGNoVGFza0J5SWQocGFyYW1zWyd0YXNrSWQnXSkuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N1YnRhc2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUYXNrID0gYWN0aW9uLnBheWxvYWQudGFzaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrID0gbmV3IFRhc2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrLnBhcmVudFRhc2tJZCA9IHRoaXMucGFyZW50VGFzay5pZDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhc2sgPSBhY3Rpb24ucGF5bG9hZC50YXNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU3VidGFzayA9ICEhdGhpcy50YXNrLnBhcmVudFRhc2tJZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTmV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZENvbW1lbnRzKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRSZXF1ZXN0cygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlID0+IHRoaXMuaGFuZGxlWGhyRXJyb3IoZXJyb3JSZXNwb25zZSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy50YXNrU2VydmljZS5nZXRUYXNrU3RhdHVzVHlwZXMoKS5zdWJzY3JpYmUodHN0ID0+IHRoaXMudGFza1N0YXR1c1R5cGVzID0gdHN0KTtcclxuICAgICAgICB0aGlzLnRhc2tTZXJ2aWNlLmdldFRhc2tQcmlvcml0eVR5cGVzKCkuc3Vic2NyaWJlKHRwdCA9PiB0aGlzLnRhc2tQcmlvcml0eVR5cGVzID0gdHB0KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUaXRsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05ldyAmJiB0aGlzLmlzU3VidGFzaykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ25ld19zdWJ0YXNrJztcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICduZXdfdGFzayc7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3VidGFzaykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N1Yl90YXNrJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3Rhc2snO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRTdGFydERhdGUoZGF0ZSkge1xyXG4gICAgICAgIHRoaXMudGFzay5zdGFydERhdGUgPSBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldER1ZURhdGUoZGF0ZSkge1xyXG4gICAgICAgIHRoaXMudGFzay5kdWVEYXRlID0gZGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVUYXNrQm9keSh0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnRhc2suYm9keSA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2F2ZVRhc2soKSB7XHJcbiAgICAgICAgbGV0IG5vdHkgPSB0aGlzLm5vdGlmeVNlcnZpY2UucHJvY2Vzcyh0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KCd3YWl0X3doaWxlX2RvY3VtZW50X3NhdmUnKSkuc2hvdygpO1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2Uuc2F2ZVRhc2sodGhpcy50YXNrKS5zdWJzY3JpYmUoXHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgIG5vdHkuc2V0KHsgdHlwZTogJ3N1Y2Nlc3MnLCBtZXNzYWdlOiByZXNwb25zZS5tZXNzYWdlIH0pLnJlbW92ZSgxNTAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm90eS5zZXQoeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0pLnJlbW92ZSgxNTAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JTYXZlVGFzayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZVRhc2soKSB7XHJcbiAgICAgICAgdGhpcy50YXNrU2VydmljZS5kZWxldGVUYXNrKFt0aGlzLnRhc2tdKS5zdWJzY3JpYmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRTdWJ0YXNrKCkge1xyXG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnL3Rhc2snLCB0aGlzLnRhc2suaWQsICcvbmV3J10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICBsb2FkQ29tbWVudHMocGFnZSkge1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZmV0Y2hDb21tZW50cyh0aGlzLnRhc2ssIHBhZ2UpLnN1YnNjcmliZShhY3Rpb24gPT4gdGhpcy5zdG9yZS5kaXNwYXRjaChhY3Rpb24pKTtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlQ29tbWVudChjb21tZW50OiBDb21tZW50KSB7XHJcbiAgICAgICAgdGhpcy50YXNrU2VydmljZS5zYXZlQ29tbWVudCh0aGlzLnRhc2ssIGNvbW1lbnQpLnN1YnNjcmliZShyID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQ29tbWVudHMoMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlQ29tbWVudChjb21tZW50OiBDb21tZW50KSB7XHJcbiAgICAgICAgdGhpcy50YXNrU2VydmljZS5kZWxldGVDb21tZW50KGNvbW1lbnQpLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZENvbW1lbnRzKDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICBsb2FkUmVxdWVzdHMocGFnZSkge1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZmV0Y2hUYXNrUmVxdWVzdHModGhpcy50YXNrLCBwYWdlKS5zdWJzY3JpYmUoYWN0aW9uID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFjY2VwdFJlcXVlc3QocmVxdWVzdDogUmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZG9SZXF1ZXN0UmVzb2x1dGlvbihyZXF1ZXN0LCAnQUNDRVBUJykuc3Vic2NyaWJlKGFjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkUmVxdWVzdHMoMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVjbGluZVJlcXVlc3QocmVxdWVzdDogUmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZG9SZXF1ZXN0UmVzb2x1dGlvbihyZXF1ZXN0LCAnREVDTElORScpLnN1YnNjcmliZShhY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFJlcXVlc3RzKDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICBlcnJvclNhdmVUYXNrKGVycm9yUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvclJlc3BvbnNlKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbJy90YXNrcyddKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVYaHJFcnJvcihlcnJvclJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKGVycm9yUmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGUoWycvbG9naW4nXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNhblJlcXVlc3RBY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhc2sgJiYgdGhpcy50YXNrLmlkICYmIHRoaXMudGFzay5zdGF0dXMgIT0gJ0ZJTklTSEVEJykgJiYgIXRoaXMuaGFzVW5SZXNvbHZlZFJlcXVlc3QgJiYgIXRoaXMuaGFzQWNjZXB0ZWRSZXF1ZXN0UmVzb2x1dGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBuZXdSZXF1ZXN0KCkge1xyXG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goeyB0eXBlOiBUQVNLX1JFUVVFU1RfTkVXLCBwYXlsb2FkOiB0aGlzLnRhc2sgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGFza1N0YXR1c1R5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFza1N0YXR1c1R5cGVzLmZpbHRlcihpdCA9PiBpdC52YWx1ZSA9PSB0aGlzLnRhc2suc3RhdHVzKVswXS50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0YXR1cyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudGFzay5zdGF0dXMgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQcmlvcml0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudGFzay5wcmlvcml0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlRHJvcGRvd24oKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdFByb2plY3QocHJvamVjdDogUHJvamVjdCkge1xyXG4gICAgICAgIHRoaXMudGFzay5wcm9qZWN0SWQgPSBwcm9qZWN0LmlkO1xyXG4gICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdFRhc2tUeXBlKHRhc2tUeXBlOiBUYXNrVHlwZSkge1xyXG4gICAgICAgIHRoaXMudGFzay50YXNrVHlwZUlkID0gdGFza1R5cGUuaWQ7XHJcbiAgICAgICAgdGhpcy5jbG9zZURyb3Bkb3duKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0QXNzaWduZWVVc2VyKGFzc2lnbmVlVXNlcjogVXNlcikge1xyXG4gICAgICAgIHRoaXMudGFzay5hc3NpZ25lZVVzZXJJZCA9IGFzc2lnbmVlVXNlci5pZDtcclxuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUYWdzKHRhZ3M6IFRhZ1tdKSB7XHJcbiAgICAgICAgdGhpcy50YXNrLnRhZ0lkcyA9IHRhZ3MubWFwKGl0ID0+IGl0LmlkKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RUYWcodGFnOiBUYWcpIHtcclxuICAgICAgICBpZiAoIXRoaXMudGFzay50YWdJZHMpIHtcclxuICAgICAgICAgICAgdGhpcy50YXNrLnRhZ0lkcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRhc2sudGFnSWRzLnB1c2godGFnLmlkKTtcclxuICAgICAgICB0aGlzLmNsb3NlRHJvcGRvd24oKTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVUYWcodGFnOiBUYWcsICRldmVudCkge1xyXG4gICAgICAgIHRoaXMudGFzay50YWdJZHMuZm9yRWFjaCgoaWQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpZCA9PT0gdGFnLmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2sudGFnSWRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuY2xvc2VEcm9wZG93bigpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEF0dGFjaG1lbnQoZmlsZSkge1xyXG4gICAgICAgIGxldCBhdHQ6IEF0dGFjaG1lbnQgPSBuZXcgQXR0YWNobWVudCgpO1xyXG4gICAgICAgIGF0dC5yZWFsRmlsZU5hbWUgPSBmaWxlLmZpbGVzWzBdO1xyXG4gICAgICAgIGlmICghdGhpcy50YXNrLmF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFzay5hdHRhY2htZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudGFzay5mc2lkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFzay5mc2lkID0gJycgKyBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRhc2suYXR0YWNobWVudHMucHVzaChhdHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZUF0dGFjaG1lbnQoYXR0YWNobWVudDogQXR0YWNobWVudCkge1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZGVsZXRlVGFza0F0dGFjaG1lbnQodGhpcy50YXNrLCBhdHRhY2htZW50KS5zdWJzY3JpYmUociA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFzay5hdHRhY2htZW50cyA9IHRoaXMudGFzay5hdHRhY2htZW50cy5maWx0ZXIoaXQgPT4gaXQuaWQgIT0gYXR0YWNobWVudC5pZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7IHR5cGU6IFRBU0tfQ0xPU0UgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy90YXNrL3Rhc2sudHNcbiAqKi8iLCJpbXBvcnQgeyBUYWJzIH0gZnJvbSAnLi90YWJzJztcclxuaW1wb3J0IHsgVGFiIH0gZnJvbSAnLi90YWInO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRBQl9ESVJFQ1RJVkVTID0gW1RhYnMsIFRhYl07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC90YWJzL2luZGV4LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQWZ0ZXJDb250ZW50SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUYWIgfSBmcm9tICcuL3RhYic7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndGFicycsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFic1wiPlxyXG4gICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IHRhYiBvZiB0YWJzXCIgKGNsaWNrKT1cInNlbGVjdFRhYih0YWIpXCIgW2NsYXNzLmFjdGl2ZV09XCJ0YWIuYWN0aXZlXCI+XHJcbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiIChjbGljayk9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPnt7dGFiLnRpdGxlfX08L2E+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgPC91bD5cclxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFicyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xyXG4gICAgQENvbnRlbnRDaGlsZHJlbihUYWIpIHRhYnM6IFF1ZXJ5TGlzdDxUYWI+O1xyXG5cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICBsZXQgYWN0aXZlVGFicyA9IHRoaXMudGFicy5maWx0ZXIodGFiID0+IHRhYi5hY3RpdmUpO1xyXG5cclxuICAgICAgICBpZiAoYWN0aXZlVGFicy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RUYWIodGhpcy50YWJzLmZpcnN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0VGFiKHRhYjogVGFiKSB7XHJcbiAgICAgICAgdGhpcy50YWJzLmZvckVhY2godGFiID0+IHRhYi5hY3RpdmUgPSBmYWxzZSk7XHJcbiAgICAgICAgdGFiLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc2hhcmVkL3RhYnMvdGFicy50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd0YWInLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgPGRpdiBbaGlkZGVuXT1cIiFhY3RpdmVcIj5cclxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgYFxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFRhYiB7XHJcbiAgICBASW5wdXQoJ3RhYlRpdGxlJykgdGl0bGU6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGFjdGl2ZSA9IGZhbHNlO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3NoYXJlZC90YWJzL3RhYi50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgT25EZXN0cm95LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcblxyXG5pbXBvcnQgeyBEUk9QRE9XTl9ESVJFQ1RJVkVTIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Ryb3Bkb3duJztcclxuaW1wb3J0IHsgVGFza1R5cGUgfSBmcm9tICcuLi8uLi9tb2RlbHMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Rhc2stdHlwZS1zZWxlY3QnLFxyXG4gICAgZGlyZWN0aXZlczogW0RST1BET1dOX0RJUkVDVElWRVNdLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2IGRyb3Bkb3duIGNsYXNzPVwic2VsZWN0XCI+XHJcbiAgICAgICAgICAgIDxkaXYgZHJvcGRvd24tdG9nZ2xlIGNsYXNzPVwic2VsZWN0LXNlbGVjdGlvbiBpbnB1dFwiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4+e3t0YXNrVHlwZT8ubmFtZX19PC9zcGFuPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgc2VsZWN0LWRyb3Bkb3duXCI+XHJcbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJzZWxlY3QtbGlzdCBzY3JvbGwtc2hhZG93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwic2VsZWN0LW9wdGlvblwiIFtjbGFzcy5zZWxlY3RlZF09XCJ0YXNrVHlwZUlkID09IG0uaWRcIiAqbmdGb3I9XCJsZXQgbSBvZiB0YXNrVHlwZXNcIiAoY2xpY2spPVwic2VsZWN0KG0pXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7bS5uYW1lfX1cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFza1R5cGVTZWxlY3RDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgdGFza1R5cGVJZDogc3RyaW5nO1xyXG4gICAgQE91dHB1dCgpIG9uU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHByaXZhdGUgc3ViOiBhbnk7XHJcbiAgICBwcml2YXRlIHRhc2tUeXBlczogYW55O1xyXG4gICAgcHJpdmF0ZSB0YXNrVHlwZTogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RvcmU6IFN0b3JlPGFueT4pIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc3ViID0gdGhpcy5zdG9yZS5zZWxlY3QoJ3JlZmVyZW5jZScpLnN1YnNjcmliZSgoc3RhdGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRhc2tUeXBlcyA9IHN0YXRlLnRhc2tUeXBlcztcclxuICAgICAgICAgICAgdGhpcy50YXNrVHlwZSA9IHN0YXRlLnRhc2tUeXBlcy5maWx0ZXIoaXQgPT4gaXQuaWQgPT0gdGhpcy50YXNrVHlwZUlkKVswXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdChtKSB7XHJcbiAgICAgICAgdGhpcy50YXNrVHlwZSA9IG07XHJcbiAgICAgICAgdGhpcy5vblNlbGVjdC5lbWl0KHRoaXMudGFza1R5cGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvc2hhcmVkL3Rhc2stdHlwZS1zZWxlY3QudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5cclxuaW1wb3J0IHsgRFJPUERPV05fRElSRUNUSVZFUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9kcm9wZG93bic7XHJcbmltcG9ydCB7IFRhZyB9IGZyb20gJy4uLy4uL21vZGVscyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndGFncy1zZWxlY3QnLFxyXG4gICAgZGlyZWN0aXZlczogW0RST1BET1dOX0RJUkVDVElWRVNdLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2IGRyb3Bkb3duIGNsYXNzPVwic2VsZWN0XCI+XHJcbiAgICAgICAgICAgIDxkaXYgZHJvcGRvd24tdG9nZ2xlIGNsYXNzPVwic2VsZWN0LXNlbGVjdGlvbiBpbnB1dFwiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWdcIlxyXG4gICAgICAgICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBtIG9mIHNlbGVjdGVkVGFnc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmNvbG9yXT1cIm0uY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJyZW1vdmUobSwgJGV2ZW50KVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHt7bS5uYW1lfX1cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IHNlbGVjdC1kcm9wZG93blwiPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwic2VsZWN0LWxpc3Qgc2Nyb2xsLXNoYWRvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInNlbGVjdC1vcHRpb25cIiAqbmdGb3I9XCJsZXQgbSBvZiBnZXRUYWdzKClcIiAoY2xpY2spPVwiYWRkKG0pXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7bS5uYW1lfX1cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFnc1NlbGVjdENvbXBvbmVudCB7XHJcbiAgICBASW5wdXQoKSB0YWdJZHM6IHN0cmluZ1tdID0gW107XHJcbiAgICBAT3V0cHV0KCkgc2V0VGFnczogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgcHJpdmF0ZSB0YWdzOiBhbnkgPSBbXTtcclxuICAgIHByaXZhdGUgc2VsZWN0ZWRUYWdzOiBhbnkgPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0b3JlOiBTdG9yZTxhbnk+KSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnN1YiA9IHRoaXMuc3RvcmUuc2VsZWN0KCdyZWZlcmVuY2UnKS5zdWJzY3JpYmUoKHN0YXRlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YWdzID0gc3RhdGUudGFncztcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFnSWRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVGFncyA9IHN0YXRlLnRhZ3MuZmlsdGVyKGl0ID0+IHRoaXMudGFnSWRzLmluZGV4T2YoaXQuaWQpICE9IC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGFncygpIHtcclxuICAgICAgICBpZiAodGhpcy50YWdJZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoaXQgPT4gdGhpcy50YWdJZHMuaW5kZXhPZihpdC5pZCkgPT0gLTEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZChtKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRhZ3MucHVzaChtKTtcclxuICAgICAgICB0aGlzLnNldFRhZ3MuZW1pdCh0aGlzLnNlbGVjdGVkVGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKG0pIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkVGFncyA9IHRoaXMuc2VsZWN0ZWRUYWdzLmZpbHRlcihpdCA9PiBpdC5pZCAhPSBtLmlkKTtcclxuICAgICAgICB0aGlzLnNldFRhZ3MuZW1pdCh0aGlzLnNlbGVjdGVkVGFncyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9zaGFyZWQvdGFncy1zZWxlY3QudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gJy4uLy4uL21vZGVscyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndGFzay1yZXF1ZXN0cycsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDx1bD5cclxuICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCByIG9mIHJlcXVlc3RzXCI+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57eyByLmNvbW1lbnQgfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57eyByLnJlcXVlc3RUeXBlLm5hbWUgfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cInIucmVzb2x1dGlvbiAhPSAnVU5LTk9XTidcIj5cclxuICAgICAgICAgICAgICAgICAgICB7eyByLnJlc29sdXRpb24gfX1cclxuICAgICAgICAgICAgICAgICAgICB7eyByLnJlc29sdXRpb25UaW1lIH19XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cInIucmVzb2x1dGlvbiA9PSAnVU5LTk9XTidcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1hY2NlcHRcIiAoY2xpY2spPVwiZG9BY2NlcHQocilcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIiB0eXBlPVwiYnV0dG9uXCI+QWNjZXB0PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGVjbGluZVwiIChjbGljayk9XCJkb0RlY2xpbmUocilcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIiB0eXBlPVwiYnV0dG9uXCI+RGVjbGluZTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIDwvdWw+XHJcbiAgICBgLFxyXG4gICAgZGlyZWN0aXZlczogW10sXHJcbiAgICBwaXBlczogW1RyYW5zbGF0ZVBpcGVdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFza1JlcXVlc3RzQ29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIHJlcXVlc3RzOiBSZXF1ZXN0W107XHJcbiAgICBAT3V0cHV0KCkgYWNjZXB0ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgZGVjbGluZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG5cclxuICAgIHByaXZhdGUgZGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICBkb0FjY2VwdChyZXF1ZXN0OiBSZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hY2NlcHQuZW1pdChyZXF1ZXN0KTtcclxuICAgIH1cclxuXHJcbiAgICBkb0RlY2xpbmUocmVxdWVzdDogUmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGVjbGluZS5lbWl0KHJlcXVlc3QpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvdGFzay90YXNrLXJlcXVlc3RzLnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgSG9zdEJpbmRpbmcsIE9uSW5pdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVQaXBlIH0gZnJvbSAnbmcyLXRyYW5zbGF0ZS9uZzItdHJhbnNsYXRlJztcclxuXHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbm90aWZpY2F0aW9uJztcclxuaW1wb3J0IHtcclxuICAgIElUYXNrU3RhdGUsXHJcbiAgICBUQVNLX1JFUVVFU1RfTkVXLFxyXG4gICAgVEFTS19SRVFVRVNUX0NBTkNFTFxyXG59IGZyb20gJy4uLy4uL3JlZHVjZXJzL3Rhc2sucmVkdWNlcic7XHJcbmltcG9ydCB7IElSZWZlcmVuY2VTdGF0ZSB9IGZyb20gJy4uLy4uL3JlZHVjZXJzL3JlZmVyZW5jZS5yZWR1Y2VyJztcclxuaW1wb3J0IHsgVGFza1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XHJcbmltcG9ydCB7IFRhc2ssIFJlcXVlc3QsIFJlcXVlc3RUeXBlLCBBdHRhY2htZW50IH0gZnJvbSAnLi4vLi4vbW9kZWxzJztcclxuaW1wb3J0IHsgQXR0YWNobWVudHNDb21wb25lbnQgfSBmcm9tICcuLi9hdHRhY2htZW50cyc7XHJcbmltcG9ydCB7IFJlcXVlc3RUeXBlU2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnLi4vc2hhcmVkL3JlcXVlc3QtdHlwZS1zZWxlY3QnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Rhc2stcmVxdWVzdCcsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDxmb3JtIGNsYXNzPVwidGFzay1yZXF1ZXN0LWZvcm1cIiAoc3VibWl0KT1cInNlbmRSZXF1ZXN0KCRldmVudClcIj5cclxuICAgICAgICAgICAgPGhlYWRlcj57eyAndGFza19yZXF1ZXN0JyB8IHRyYW5zbGF0ZSB9fTwvaGVhZGVyPlxyXG4gICAgICAgICAgICA8c2VjdGlvbj5cclxuICAgICAgICAgICAgICAgIDxyZXF1ZXN0LXR5cGUtc2VsZWN0IFtyZXF1ZXN0VHlwZUlkXT1cInJlcXVlc3QucmVxdWVzdFR5cGVJZFwiIChvblNlbGVjdCk9XCJzZWxlY3RSZXF1ZXN0VHlwZSgkZXZlbnQpXCI+PC9yZXF1ZXN0LXR5cGUtc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwicmVxdWVzdC1jb21tZW50XCIgWyhuZ01vZGVsKV09XCJjb21tZW50XCI+PC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgICAgIDxhdHRhY2htZW50cyBbZW50aXR5XT1cInJlcXVlc3RcIiAodXBsb2FkKT1cImFkZEF0dGFjaG1lbnQoJGV2ZW50KVwiIChkZWxldGUpPVwiYWRkQXR0YWNobWVudCgkZXZlbnQpXCI+PC9hdHRhY2htZW50cz5cclxuICAgICAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICAgICAgICA8Zm9vdGVyPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0blwiIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwiY2FuY2VsKClcIj57eyAnY2FuY2VsJyB8IHRyYW5zbGF0ZSB9fTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIHR5cGU9XCJzdWJtaXRcIiBbZGlzYWJsZWRdPVwiIXJlcXVlc3RUeXBlXCI+e3sgJ3NlbmRfcmVxdWVzdCcgfCB0cmFuc2xhdGUgfX08L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9mb290ZXI+XHJcbiAgICAgICAgPC9mb3JtPlxyXG4gICAgYCxcclxuICAgIGRpcmVjdGl2ZXM6IFtBdHRhY2htZW50c0NvbXBvbmVudCwgUmVxdWVzdFR5cGVTZWxlY3RDb21wb25lbnRdLFxyXG4gICAgaG9zdDoge1xyXG4gICAgICAgICdbY2xhc3MudGFzay1yZXF1ZXN0XSc6ICd0cnVlJyxcclxuICAgICAgICAnW2NsYXNzLnRhc2stcmVxdWVzdC1vcGVuXSc6ICdpc09wZW4nLFxyXG4gICAgICAgICcoa2V5dXAuZXNjYXBlKSc6ICdjYW5jZWwoKSdcclxuICAgIH0sXHJcbiAgICBwaXBlczogW1RyYW5zbGF0ZVBpcGVdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVGFza1JlcXVlc3RDb21wb25lbnQge1xyXG4gICAgcHJpdmF0ZSB0YXNrU3ViOiBhbnk7XHJcbiAgICBwcml2YXRlIHJlZlN1YjogYW55O1xyXG5cclxuICAgIHByaXZhdGUgcmVxdWVzdDogUmVxdWVzdDtcclxuICAgIHByaXZhdGUgaXNPcGVuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIHJlcXVlc3RUeXBlczogUmVxdWVzdFR5cGVbXTtcclxuICAgIHByaXZhdGUgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlO1xyXG4gICAgcHJpdmF0ZSBjb21tZW50OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogU3RvcmU8YW55PixcclxuICAgICAgICBwcml2YXRlIG5vdGlmeVNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSB0YXNrU2VydmljZTogVGFza1NlcnZpY2VcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMucmVmU3ViID0gc3RvcmUuc2VsZWN0KCdyZWZlcmVuY2UnKS5zdWJzY3JpYmUoKHN0YXRlOiBJUmVmZXJlbmNlU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VHlwZXMgPSBzdGF0ZS5yZXF1ZXN0VHlwZXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudGFza1N1YiA9IHN0b3JlLnNlbGVjdCgndGFzaycpLnN1YnNjcmliZSgoc3RhdGU6IElUYXNrU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBzdGF0ZS5yZXF1ZXN0IHx8IG5ldyBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IHN0YXRlLnNob3dSZXF1ZXN0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50YXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnRhc2tJZCA9IHN0YXRlLnRhc2suaWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0LmZzaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmZzaWQgPSAnJyArIERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7IH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnRhc2tTdWIudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RSZXF1ZXN0VHlwZShyZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGUpIHtcclxuICAgICAgICB0aGlzLnJlcXVlc3RUeXBlID0gcmVxdWVzdFR5cGU7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHsgdHlwZTogVEFTS19SRVFVRVNUX0NBTkNFTCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZW5kUmVxdWVzdCgkZXZlbnQpIHtcclxuICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0LnJlcXVlc3RUeXBlSWQgPSB0aGlzLnJlcXVlc3RUeXBlLmlkO1xyXG5cclxuICAgICAgICB0aGlzLnRhc2tTZXJ2aWNlLnNlbmRUYXNrUmVxdWVzdCh0aGlzLnJlcXVlc3QpLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U2VydmljZS5pbmZvKCdyZXF1ZXN0IHNlbmQ6IHN1Y2Nlc3MnKS5zaG93KCkucmVtb3ZlKDMwMDApO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEF0dGFjaG1lbnQoZmlsZSkge1xyXG4gICAgICAgIGxldCBhdHQ6IEF0dGFjaG1lbnQgPSBuZXcgQXR0YWNobWVudCgpO1xyXG4gICAgICAgIGF0dC5yZWFsRmlsZU5hbWUgPSBmaWxlLmZpbGVzWzBdO1xyXG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0LmF0dGFjaG1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5hdHRhY2htZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3QuYXR0YWNobWVudHMucHVzaChhdHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZUF0dGFjaG1lbnQoYXR0YWNobWVudDogQXR0YWNobWVudCkge1xyXG4gICAgICAgIHRoaXMudGFza1NlcnZpY2UuZGVsZXRlUmVxdWVzdEF0dGFjaG1lbnQodGhpcy5yZXF1ZXN0LCBhdHRhY2htZW50KS5zdWJzY3JpYmUociA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5hdHRhY2htZW50cyA9IHRoaXMucmVxdWVzdC5hdHRhY2htZW50cy5maWx0ZXIoaXQgPT4gaXQuaWQgIT0gYXR0YWNobWVudC5pZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy90YXNrL3Rhc2stcmVxdWVzdC50c1xuICoqLyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgT25EZXN0cm95LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcblxyXG5pbXBvcnQgeyBEUk9QRE9XTl9ESVJFQ1RJVkVTIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Ryb3Bkb3duJztcclxuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gJy4uLy4uL21vZGVscyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAncmVxdWVzdC10eXBlLXNlbGVjdCcsXHJcbiAgICBkaXJlY3RpdmVzOiBbRFJPUERPV05fRElSRUNUSVZFU10sXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgICAgIDxkaXYgZHJvcGRvd24gY2xhc3M9XCJzZWxlY3RcIj5cclxuICAgICAgICAgICAgPGRpdiBkcm9wZG93bi10b2dnbGUgY2xhc3M9XCJzZWxlY3Qtc2VsZWN0aW9uIGlucHV0XCI+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57e3JlcXVlc3RUeXBlPy5uYW1lfX08L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBzZWxlY3QtZHJvcGRvd25cIj5cclxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cInNlbGVjdC1saXN0IHNjcm9sbC1zaGFkb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJzZWxlY3Qtb3B0aW9uXCIgW2NsYXNzLnNlbGVjdGVkXT1cInJlcXVlc3RUeXBlPy5pZCA9PSBtLmlkXCIgKm5nRm9yPVwibGV0IG0gb2YgcmVxdWVzdFR5cGVzXCIgKGNsaWNrKT1cInNlbGVjdChtKVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7e20ubmFtZX19XHJcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYFxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIFJlcXVlc3RUeXBlU2VsZWN0Q29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIHJlcXVlc3RUeXBlSWQ6IHN0cmluZztcclxuICAgIEBPdXRwdXQoKSBvblNlbGVjdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBwcml2YXRlIHN1YjogYW55O1xyXG4gICAgcHJpdmF0ZSByZXF1ZXN0VHlwZXM6IGFueTtcclxuICAgIHByaXZhdGUgcmVxdWVzdFR5cGU6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0b3JlOiBTdG9yZTxhbnk+KSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnN1YiA9IHRoaXMuc3RvcmUuc2VsZWN0KCdyZWZlcmVuY2UnKS5zdWJzY3JpYmUoKHN0YXRlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VHlwZXMgPSBzdGF0ZS5yZXF1ZXN0VHlwZXM7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFR5cGUgPSBzdGF0ZS5yZXF1ZXN0VHlwZXMuZmlsdGVyKGl0ID0+IGl0LmlkID09IHRoaXMucmVxdWVzdFR5cGVJZClbMF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QobSkge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFR5cGUgPSBtO1xyXG4gICAgICAgIHRoaXMub25TZWxlY3QuZW1pdCh0aGlzLnJlcXVlc3RUeXBlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL3NoYXJlZC9yZXF1ZXN0LXR5cGUtc2VsZWN0LnRzXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ25nMi10cmFuc2xhdGUvbmcyLXRyYW5zbGF0ZSc7XHJcblxyXG5pbXBvcnQgeyBNYXJrZG93bkVkaXRvckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NoYXJlZC9tYXJrZG93bi9tYXJrZG93bi1lZGl0b3InO1xyXG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL25vdGlmaWNhdGlvbic7XHJcbmltcG9ydCB7IFBhZ2luYXRpb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9zaGFyZWQvcGFnaW5hdGlvbic7XHJcbmltcG9ydCB7IFRhc2ssIENvbW1lbnQgfSBmcm9tICcuLi8uLi9tb2RlbHMnO1xyXG5pbXBvcnQgeyBUYXNrU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcclxuaW1wb3J0IHsgSVRhc2tTdGF0ZSB9IGZyb20gJy4uLy4uL3JlZHVjZXJzL3Rhc2sucmVkdWNlcic7XHJcbmltcG9ydCB7IENvbW1lbnRDb21wb25lbnQgfSBmcm9tICcuL2NvbW1lbnQnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2NvbW1lbnRzJyxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbW1lbnRzLXdyYXBcIj5cclxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3M9XCJjb21tZW50c1wiPlxyXG4gICAgICAgICAgICAgICAgPGNvbW1lbnQgKm5nRm9yPVwibGV0IGNvbW1lbnQgb2YgY29tbWVudHNcIlxyXG4gICAgICAgICAgICAgICAgICAgIFtjb21tZW50XT1cImNvbW1lbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgICAgICAoc2F2ZSk9XCJ1cGRhdGVDb21tZW50KCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgIChkZWxldGUpPVwiZGVsZXRlQ29tbWVudCgkZXZlbnQpXCI+XHJcbiAgICAgICAgICAgICAgICA8L2NvbW1lbnQ+XHJcbiAgICAgICAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3M9XCJjb21tZW50LWNvbXBvc2VyXCIgW2NsYXNzLmVkaXRdPVwiaXNFZGl0XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tbWVudC1jb21wb3Nlcl9fZWRpdG9yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPG1hcmtkb3duLWVkaXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bj1cIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlSG9sZGVyPVwie3snYWRkX2NvbW1lbnQnIHwgdHJhbnNsYXRlfX1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodXBkYXRlKT1cInNldENvbW1lbnRUZXh0KCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZm9jdXMpPVwib25FZGl0b3JGb2N1cygkZXZlbnQpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJsdXIpPVwib25FZGl0b3JCbHVyKCRldmVudClcIj5cclxuICAgICAgICAgICAgICAgICAgICA8L21hcmtkb3duLWVkaXRvcj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tYWRkLWNvbW1lbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJhZGRDb21tZW50KClcIlxyXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCIhY29tbWVudFRleHRcIj5cclxuICAgICAgICAgICAgICAgICAgICB7eyAnYWRkX2NvbW1lbnQnIHwgdHJhbnNsYXRlIH19XHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYCxcclxuICAgIGRpcmVjdGl2ZXM6IFtQYWdpbmF0aW9uQ29tcG9uZW50LCBDb21tZW50Q29tcG9uZW50LCBNYXJrZG93bkVkaXRvckNvbXBvbmVudF0sXHJcbiAgICBwaXBlczogW1RyYW5zbGF0ZVBpcGVdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgQ29tbWVudHNDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgY29tbWVudHM6IENvbW1lbnRbXTtcclxuICAgIEBPdXRwdXQoKSBhZGQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSB1cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSBkZWxldGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuXHJcbiAgICBwcml2YXRlIGNvbW1lbnQ6IENvbW1lbnQ7XHJcbiAgICBwcml2YXRlIGNvbW1lbnRUZXh0OiBzdHJpbmcgPSAnJztcclxuICAgIHByaXZhdGUgaXNFZGl0OiBib29sZWFuO1xyXG5cclxuICAgIG9uRWRpdG9yRm9jdXMoKSB7XHJcbiAgICAgICAgdGhpcy5pc0VkaXQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRWRpdG9yQmx1cigpIHtcclxuICAgICAgICB0aGlzLmlzRWRpdCA9IHRoaXMuY29tbWVudFRleHQubGVuZ3RoID4gMDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDb21tZW50VGV4dCh0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmNvbW1lbnRUZXh0ID0gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDb21tZW50KCkge1xyXG4gICAgICAgIGxldCBjb21tZW50ID0gbmV3IENvbW1lbnQoKTtcclxuICAgICAgICBjb21tZW50LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnRUZXh0O1xyXG4gICAgICAgIHRoaXMuYWRkLmVtaXQoY29tbWVudCk7XHJcbiAgICAgICAgdGhpcy5jb21tZW50VGV4dCA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUNvbW1lbnQoY29tbWVudDogQ29tbWVudCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlLmVtaXQoY29tbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlQ29tbWVudChjb21tZW50OiBDb21tZW50KSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGUuZW1pdChjb21tZW50KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL2NvbW1lbnQvY29tbWVudHMudHNcbiAqKi8iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPdXRwdXQsIE9uSW5pdCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVQaXBlIH0gZnJvbSAnbmcyLXRyYW5zbGF0ZS9uZzItdHJhbnNsYXRlJztcclxuXHJcbmltcG9ydCB7IE1hcmtkb3duRWRpdG9yQ29tcG9uZW50LCBNYXJrZWRQaXBlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21hcmtkb3duJztcclxuaW1wb3J0IHsgQXR0YWNobWVudHNDb21wb25lbnQgfSBmcm9tICcuLi9hdHRhY2htZW50cyc7XHJcbmltcG9ydCB7IERhdGVGb3JtYXRQaXBlIH0gZnJvbSAnLi4vLi4vcGlwZXMnO1xyXG5pbXBvcnQgeyBDb21tZW50IH0gZnJvbSAnLi4vLi4vbW9kZWxzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdjb21tZW50JyxcclxuICAgIHRlbXBsYXRlOiBgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbW1lbnRcIiBbY2xhc3MuZWRpdF09XCJlZGl0XCIgW2NsYXNzLnNhdmluZ109XCJzYXZpbmdcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbW1lbnRfX2F2YXRhclwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tbWVudF9fZGV0YWlsc1wiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb21tZW50X19hdXRob3JcIj57e2NvbW1lbnQuYXV0aG9ySWR9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY29tbWVudF9fdGltZVwiPnt7Y29tbWVudC5yZWdEYXRlfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImNvbW1lbnRfX3RleHRcIiAqbmdJZj1cIiFlZGl0XCIgaW5uZXJIVE1MPVwie3tjb21tZW50LmNvbW1lbnQgfCBtYXJrZWR9fVwiPjwvcD5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21tZW50X19lZGl0b3JcIiAqbmdJZj1cImVkaXRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bWFya2Rvd24tZWRpdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duPVwie3tjb21tZW50LmNvbW1lbnR9fVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlSG9sZGVyPVwie3snYWRkX2NvbW1lbnQnIHwgdHJhbnNsYXRlfX1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodXBkYXRlKT1cInNldENvbW1lbnRUZXh0KCRldmVudClcIj5cclxuICAgICAgICAgICAgICAgICAgICA8L21hcmtkb3duLWVkaXRvcj5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tY2FuY2VsXCIgW2Rpc2FibGVkXT1cInNhdmluZ1wiIChjbGljayk9XCJ0b2dnbGVFZGl0KClcIj57eydjYW5jZWwnIHwgdHJhbnNsYXRlfX08L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tc2F2ZVwiIFtkaXNhYmxlZF09XCJzYXZpbmdcIiAoY2xpY2spPVwic2F2ZUNvbW1lbnQoKVwiPnt7J3NhdmUnIHwgdHJhbnNsYXRlfX08L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPCEtLSA8YXR0YWNobWVudHNcclxuICAgICAgICAgICAgICAgICAgICBbZW50aXR5XT1cImNvbW1lbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICh1cGxvYWQpPVwiYWRkQXR0YWNobWVudCgkZXZlbnQpXCJcclxuICAgICAgICAgICAgICAgICAgICAoZGVsZXRlKT1cImRlbGV0ZUF0dGFjaG1lbnQoJGV2ZW50KVwiPlxyXG4gICAgICAgICAgICAgICAgPC9hdHRhY2htZW50cz4gLS0+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tbWVudF9fYnV0dG9uc1wiICpuZ0lmPVwiZWRpdGFibGVcIj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbVwiICpuZ0lmPVwiIWVkaXRcIiAoY2xpY2spPVwidG9nZ2xlRWRpdCgpXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1wZW5jaWxcIj48L2k+e3snZWRpdCcgfCB0cmFuc2xhdGV9fVxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc21cIiB0aXRsZT1cInt7J2RlbGV0ZScgfCB0cmFuc2xhdGV9fVwiIChjbGljayk9XCJkZWxldGUuZW1pdChjb21tZW50KVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtcmVtb3ZlXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYCxcclxuICAgIGRpcmVjdGl2ZXM6IFtBdHRhY2htZW50c0NvbXBvbmVudCwgTWFya2Rvd25FZGl0b3JDb21wb25lbnRdLFxyXG4gICAgcGlwZXM6IFtEYXRlRm9ybWF0UGlwZSwgVHJhbnNsYXRlUGlwZSwgTWFya2VkUGlwZV1cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBDb21tZW50Q29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIGNvbW1lbnQ6IENvbW1lbnQ7XHJcbiAgICBASW5wdXQoKSBlZGl0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQE91dHB1dCgpIHNhdmUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSBkZWxldGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIHByaXZhdGUgc2F2aW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIGVkaXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgY29tbWVudFRleHQ6IHN0cmluZztcclxuXHJcbiAgICBwcml2YXRlIHRvZ2dsZUVkaXQoKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0ID0gdGhpcy5lZGl0YWJsZSAmJiAhdGhpcy5lZGl0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lZGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWVudFRleHQgPSB0aGlzLmNvbW1lbnQuY29tbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1lbnRUZXh0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0Q29tbWVudFRleHQodGV4dDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5jb21tZW50VGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzYXZlQ29tbWVudCgpIHtcclxuICAgICAgICB0aGlzLmNvbW1lbnQuY29tbWVudCA9IHRoaXMuY29tbWVudFRleHQ7XHJcbiAgICAgICAgdGhpcy5zYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2F2ZS5lbWl0KHRoaXMuY29tbWVudCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9jb21tZW50L2NvbW1lbnQudHNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvcm0gY2xhc3M9XFxcImZvcm1cXFwiIFtuZ0Zvcm1Nb2RlbF09XFxcImZvcm1cXFwiICpuZ0lmPVxcXCJpc1JlYWR5XFxcIj5cXHJcXG4gICAgPGhlYWRlciBjbGFzcz1cXFwiY29udGVudC1oZWFkZXJcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuLWJhY2tcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tbGVmdFxcXCI+PC9pPlxcclxcbiAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICA8aDEgY2xhc3M9XFxcImhlYWRlci10aXRsZVxcXCI+XFxyXFxuICAgICAgICAgICAgPGEgKm5nSWY9XFxcInBhcmVudFRhc2tcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiWycvdGFzaycsIHBhcmVudFRhc2suaWRdXFxcIiBjbGFzcz1cXFwicGFyZW50LXRhc2stbGlua1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7cGFyZW50VGFzay50aXRsZX19XFxyXFxuICAgICAgICAgICAgPC9hPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIHt7Z2V0VGl0bGUoKSB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgIDxzbWFsbD57eyBnZXRUYXNrU3RhdHVzVHlwZSgpIH19PC9zbWFsbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvaDE+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50LWFjdGlvbnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBbZGlzYWJsZWRdPVxcXCIhZm9ybS52YWxpZFxcXCIgKGNsaWNrKT1cXFwic2F2ZVRhc2soKVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J3NhdmVfY2xvc2UnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J2Nsb3NlJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiICpuZ0lmPVxcXCJjYW5SZXF1ZXN0QWN0aW9uKClcXFwiIChjbGljayk9XFxcIm5ld1JlcXVlc3QoJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J25ld19yZXF1ZXN0JyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPGJ1dHRvbiAqbmdJZj1cXFwiIWlzTmV3XFxcIiBjbGFzcz1cXFwiYnRuXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIChjbGljayk9XFxcImFkZFN1YnRhc2soJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J2FkZF9zdWJ0YXNrJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwiIWlzTmV3XFxcIiBkcm9wZG93biBjbGFzcz1cXFwiYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgZHJvcGRvd24tdG9nZ2xlPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0blxcXCI+Li4uPC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiZGVsZXRlVGFzaygpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB7eydkZWxldGUnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2hlYWRlcj5cXHJcXG4gICAgPHNlY3Rpb24gY2xhc3M9XFxcImNvbnRlbnQtYm9keVxcXCI+XFxyXFxuICAgICAgICA8dGFicz5cXHJcXG4gICAgICAgICAgICA8dGFiIGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgdGFiVGl0bGU9XFxcInt7J3Byb3BlcnRpZXMnIHwgdHJhbnNsYXRlfX1cXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3M9XFxcImZpZWxkc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyd0YXNrX3RpdGxlJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy50aXRsZS52YWxpZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwic3BhbjhcXFwiIFsobmdNb2RlbCldPVxcXCJ0YXNrLnRpdGxlXFxcIiBuZ0NvbnRyb2w9XFxcInRpdGxlXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIiAqbmdJZj1cXFwiIWlzU3VidGFza1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J3Byb2plY3QnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCIgW2NsYXNzLmhhcy1lcnJvcl09XFxcIiFmb3JtLmNvbnRyb2xzLnByb2plY3RJZC52YWxpZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNwYW44XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwcm9qZWN0LXNlbGVjdCBbcHJvamVjdElkXT1cXFwidGFzay5wcm9qZWN0SWRcXFwiIChvblNlbGVjdCk9XFxcInNlbGVjdFByb2plY3QoJGV2ZW50KVxcXCI+PC9wcm9qZWN0LXNlbGVjdD5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBbaGlkZGVuXT1cXFwiZm9ybS5jb250cm9scy5wcm9qZWN0SWQudmFsaWQgfHwgZm9ybS5jb250cm9scy5wcm9qZWN0SWQucHJpc3RpbmVcXFwiIGNsYXNzPVxcXCJlcnJvci1tZXNzYWdlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sncmVxdWlyZWQnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCIgKm5nSWY9XFxcIiFpc1N1YnRhc2tcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyd0YXNrX3R5cGUnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCIgW2NsYXNzLmhhcy1lcnJvcl09XFxcIiFmb3JtLmNvbnRyb2xzLnRhc2tUeXBlSWQudmFsaWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzcGFuOFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFzay10eXBlLXNlbGVjdCBbdGFza1R5cGVJZF09XFxcInRhc2sudGFza1R5cGVJZFxcXCIgKG9uU2VsZWN0KT1cXFwic2VsZWN0VGFza1R5cGUoJGV2ZW50KVxcXCI+PC90YXNrLXR5cGUtc2VsZWN0PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBbaGlkZGVuXT1cXFwiZm9ybS5jb250cm9scy50YXNrVHlwZUlkLnZhbGlkIHx8IGZvcm0uY29udHJvbHMudGFza1R5cGVJZC5wcmlzdGluZVxcXCIgY2xhc3M9XFxcImVycm9yLW1lc3NhZ2VcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sncmVxdWlyZWQnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eydwcmlvcml0eScgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIiBbY2xhc3MuaGFzLWVycm9yXT1cXFwiIWZvcm0uY29udHJvbHMucHJpb3JpdHkudmFsaWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3dpdGNoLWJ1dHRvbiBbbW9kZWxdPVxcXCJ0YXNrXFxcIiB2YWx1ZT1cXFwicHJpb3JpdHlcXFwiIFtpdGVtc109XFxcInRhc2tQcmlvcml0eVR5cGVzXFxcIj48L3N3aXRjaC1idXR0b24+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgW2hpZGRlbl09XFxcImZvcm0uY29udHJvbHMucHJpb3JpdHkudmFsaWQgfHwgZm9ybS5jb250cm9scy5wcmlvcml0eS5wcmlzdGluZVxcXCIgY2xhc3M9XFxcImVycm9yLW1lc3NhZ2VcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sncmVxdWlyZWQnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eydhc3NpZ25lZV91c2VyJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy5hc3NpZ25lZVVzZXJJZC52YWxpZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNwYW44XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1c2VyLXNlbGVjdCBbdXNlcklkXT1cXFwidGFzay5hc3NpZ25lZVVzZXJJZFxcXCIgKG9uU2VsZWN0KT1cXFwic2VsZWN0QXNzaWduZWVVc2VyKCRldmVudClcXFwiPjwvdXNlci1zZWxlY3Q+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IFtoaWRkZW5dPVxcXCJmb3JtLmNvbnRyb2xzLmFzc2lnbmVlVXNlcklkLnZhbGlkIHx8IGZvcm0uY29udHJvbHMuYXNzaWduZWVVc2VySWQucHJpc3RpbmVcXFwiIGNsYXNzPVxcXCJlcnJvci1tZXNzYWdlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J3JlcXVpcmVkJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3snc3RhcnRfZGF0ZScgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGRhdGVwaWNrZXIgY2xhc3M9XFxcInNwYW4yXFxcIiAoc2VsZWN0KT1cXFwic2V0U3RhcnREYXRlKCRldmVudClcXFwiIFsobmdNb2RlbCldPVxcXCJ0YXNrLnN0YXJ0RGF0ZVxcXCIgbmdDb250cm9sPVxcXCJzdGFydERhdGVcXFwiIC8+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eydkdWVfZGF0ZScgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGRhdGVwaWNrZXIgY2xhc3M9XFxcInNwYW4yXFxcIiAoc2VsZWN0KT1cXFwic2V0RHVlRGF0ZSgkZXZlbnQpXFxcIiBbKG5nTW9kZWwpXT1cXFwidGFzay5kdWVEYXRlXFxcIiBuZ0NvbnRyb2w9XFxcImR1ZURhdGVcXFwiIC8+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyd0YWdzJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy50YWdJZHMudmFsaWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzcGFuOFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFncy1zZWxlY3QgW3RhZ0lkc109XFxcInRhc2sudGFnSWRzXFxcIiAoc2V0VGFncyk9XFxcInNldFRhZ3MoJGV2ZW50KVxcXCI+PC90YWdzLXNlbGVjdD5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eydib2R5JyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiIFtjbGFzcy5oYXMtZXJyb3JdPVxcXCIhZm9ybS5jb250cm9scy5ib2R5LnZhbGlkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic3BhbjhcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hcmtkb3duLWVkaXRvciBbbWFya2Rvd25dPVxcXCJ0YXNrLmJvZHkgfHwgJydcXFwiIGVkaXRhYmxlPVxcXCJ0cnVlXFxcIiB1cGRhdGVUaW1lb3V0PVxcXCIzMDBcXFwiICh1cGRhdGUpPVxcXCJ1cGRhdGVUYXNrQm9keSgkZXZlbnQpXFxcIj48L21hcmtkb3duLWVkaXRvcj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPC9maWVsZHNldD5cXHJcXG4gICAgICAgICAgICAgICAgPGF0dGFjaG1lbnRzIFtlbnRpdHldPVxcXCJ0YXNrXFxcIiAodXBsb2FkKT1cXFwiYWRkQXR0YWNobWVudCgkZXZlbnQpXFxcIiAoZGVsZXRlKT1cXFwiZGVsZXRlQXR0YWNobWVudCgkZXZlbnQpXFxcIj48L2F0dGFjaG1lbnRzPlxcclxcbiAgICAgICAgICAgIDwvdGFiPlxcclxcbiAgICAgICAgICAgIDx0YWIgKm5nSWY9XFxcIiFpc05ld1xcXCIgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiB0YWJUaXRsZT1cXFwie3snY29tbWVudHMnIHwgdHJhbnNsYXRlfX1cXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8Y29tbWVudHMgW2NvbW1lbnRzXT1cXFwiY29tbWVudHNcXFwiIChhZGQpPVxcXCJzYXZlQ29tbWVudCgkZXZlbnQpXFxcIiAodXBkYXRlKT1cXFwic2F2ZUNvbW1lbnQoJGV2ZW50KVxcXCIgKGRlbGV0ZSk9XFxcImRlbGV0ZUNvbW1lbnQoJGV2ZW50KVxcXCI+PC9jb21tZW50cz5cXHJcXG4gICAgICAgICAgICA8L3RhYj5cXHJcXG4gICAgICAgICAgICA8dGFiICpuZ0lmPVxcXCIhaXNOZXdcXFwiIGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgdGFiVGl0bGU9XFxcInt7J3JlcXVlc3RzJyB8IHRyYW5zbGF0ZX19IHt7aGFzVW5SZXNvbHZlZFJlcXVlc3QgPyAnMScgOiAnMCd9fVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDx0YXNrLXJlcXVlc3RzIFtyZXF1ZXN0c109XFxcInJlcXVlc3RzXFxcIiAoYWNjZXB0KT1cXFwiYWNjZXB0UmVxdWVzdCgkZXZlbnQpXFxcIiAoZGVjbGluZSk9XFxcImRlY2xpbmVSZXF1ZXN0KCRldmVudClcXFwiPjwvdGFzay1yZXF1ZXN0cz5cXHJcXG4gICAgICAgICAgICA8L3RhYj5cXHJcXG4gICAgICAgIDwvdGFicz5cXHJcXG4gICAgPC9zZWN0aW9uPlxcclxcbjwvZm9ybT5cXHJcXG48dGFzay1yZXF1ZXN0PjwvdGFzay1yZXF1ZXN0PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9jb21wb25lbnRzL3Rhc2svdGVtcGxhdGVzL3Rhc2suaHRtbFxuICoqIG1vZHVsZSBpZCA9IDgzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHAsIEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9odHRwJztcclxuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgRm9ybUJ1aWxkZXIsIFZhbGlkYXRvcnMsIENvbnRyb2xHcm91cCwgQ29udHJvbCwgRk9STV9ESVJFQ1RJVkVTIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUsIFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICduZzItdHJhbnNsYXRlL25nMi10cmFuc2xhdGUnO1xyXG5cclxuaW1wb3J0IHsgVEFCX0RJUkVDVElWRVMgfSBmcm9tICcuLi9zaGFyZWQvdGFicyc7XHJcbmltcG9ydCB7IEtleXNQaXBlIH0gZnJvbSAnLi4vcGlwZXMva2V5cy5waXBlJztcclxuaW1wb3J0IHsgQXBwU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FwcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSBhcyB0cmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvdHJhbnNsYXRlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vbW9kZWxzL3VzZXInO1xyXG5pbXBvcnQgeyBJQXV0aGVkU3RhdGUgfSBmcm9tICcuLi9yZWR1Y2Vycy9hdXRoZWQucmVkdWNlcic7XHJcbmltcG9ydCB7IGNyZWF0ZUNvb2tpZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbmNvbnN0IEhFQURFUlMgPSBuZXcgSGVhZGVycyh7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOCcsXHJcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbn0pO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ1t1c2VyLXByb2ZpbGVdJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvdXNlci1wcm9maWxlLmh0bWwnKSxcclxuICAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVMsIFRBQl9ESVJFQ1RJVkVTXSxcclxuICAgIHByb3ZpZGVyczogW0Zvcm1CdWlsZGVyXSxcclxuICAgIHBpcGVzOiBbVHJhbnNsYXRlUGlwZSwgS2V5c1BpcGVdXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgVXNlclByb2ZpbGVDb21wb25lbnQge1xyXG4gICAgdXNlcjogVXNlciA9IG5ldyBVc2VyKCk7XHJcbiAgICBmb3JtOiBDb250cm9sR3JvdXA7XHJcbiAgICBjaGFuZ2VQYXNzd29yZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcGFnZVNpemU6IG51bWJlcjtcclxuICAgIGxhbmd1YWdlOiBzdHJpbmcgPSAnUlVTJztcclxuICAgIGxhbmd1YWdlczogYW55O1xyXG4gICAgcGFnZVNpemVzID0gWzEwLCAyMCwgMzAsIDQwLCA1MF07XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogU3RvcmU8YW55PixcclxuICAgICAgICBwcml2YXRlIGh0dHA6IEh0dHAsXHJcbiAgICAgICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcclxuICAgICAgICBwcml2YXRlIGZvcm1CdWlsZGVyOiBGb3JtQnVpbGRlcixcclxuICAgICAgICBwcml2YXRlIG5nMlRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBhcHBTZXJ2aWNlOiBBcHBTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgdHJhbnNsYXRlU2VydmljZTogdHJhbnNsYXRlU2VydmljZVxyXG4gICAgKSB7XHJcbiAgICAgICAgbGV0IGNrID0gZG9jdW1lbnQuY29va2llLm1hdGNoKCcobGFuZyk9KC4qPykoJHw7fCwoPyEgKSknKTtcclxuICAgICAgICBpZiAoY2spIHtcclxuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGNrWzJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3JlLnNlbGVjdCgnYXV0aGVkJykuc3Vic2NyaWJlKChkYXRhOiBJQXV0aGVkU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51c2VyID0gZGF0YS51c2VyUHJvZmlsZTtcclxuICAgICAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IGRhdGEucGFnZVNpemU7XHJcbiAgICAgICAgICAgIHRoaXMubGFuZ3VhZ2VzID0gZGF0YS5sYW5ndWFnZXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZm9ybSA9IGZvcm1CdWlsZGVyLmdyb3VwKHtcclxuICAgICAgICAgICAgbG9naW46IFtdLFxyXG4gICAgICAgICAgICBwd2Q6IFtdLFxyXG4gICAgICAgICAgICBwd2RfY29uZmlybTogW10sXHJcbiAgICAgICAgICAgIGVtYWlsOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRvZ2dsZUNoYW5nZVBhc3N3b3JkKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlUGFzc3dvcmQgPSAhdGhpcy5jaGFuZ2VQYXNzd29yZDtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVVc2VyUHJvZmlsZSgpIHtcclxuICAgICAgICB0aGlzLmFwcFNlcnZpY2UudXBkYXRlVXNlclByb2ZpbGUodGhpcy51c2VyKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2VMYW5nKCRldmVudCkge1xyXG4gICAgICAgIGxldCBsYW5nQ29kZSA9ICRldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgbGV0IHVybCA9ICcvU3RhZmYvcD9pZD1jaGFuZ2Utc2Vzc2lvbi12YWwtYWN0aW9uJmxhbmc9JyArIGxhbmdDb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIHt9LCB7IGhlYWRlcnM6IEhFQURFUlMgfSlcclxuICAgICAgICAgICAgLm1hcChyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5nMlRyYW5zbGF0ZVNlcnZpY2UucmVsb2FkTGFuZyhsYW5nQ29kZSkuc3Vic2NyaWJlKHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmcyVHJhbnNsYXRlU2VydmljZS51c2UobGFuZ0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVDb29raWUoJ2xhbmcnLCBsYW5nQ29kZSwgMzY1KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvc2UoZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL3VzZXItcHJvZmlsZS50c1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSBjbGFzcz1cXFwiZm9ybSBmb3JtLXVzZXJwcm9maWxlXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgW25nRm9ybU1vZGVsXT1cXFwiZm9ybVxcXCI+XFxyXFxuICAgIDxoZWFkZXIgY2xhc3M9XFxcImNvbnRlbnQtaGVhZGVyXFxcIj5cXHJcXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0bi1iYWNrXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIChjbGljayk9XFxcImNsb3NlKCRldmVudClcXFwiPlxcclxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWxlZnRcXFwiPjwvaT5cXHJcXG4gICAgICAgIDwvYnV0dG9uPlxcclxcbiAgICAgICAgPGgxIGNsYXNzPVxcXCJoZWFkZXItdGl0bGVcXFwiPlxcclxcbiAgICAgICAgICAgIHt7J2VtcGxveWVlJyB8IHRyYW5zbGF0ZX19IHt7dXNlci5uYW1lfX1cXHJcXG4gICAgICAgIDwvaDE+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50LWFjdGlvbnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBbZGlzYWJsZWRdPVxcXCIhZm9ybS52YWxpZFxcXCIgKGNsaWNrKT1cXFwidXBkYXRlVXNlclByb2ZpbGUoKVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J3NhdmVfY2xvc2UnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIHt7J2Nsb3NlJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9oZWFkZXI+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJjb250ZW50LWJvZHlcXFwiPlxcclxcbiAgICAgICAgPHRhYnM+XFxyXFxuICAgICAgICAgICAgPHRhYiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIHRhYlRpdGxlPVxcXCJ7eydwcm9wZXJ0aWVzJyB8IHRyYW5zbGF0ZX19XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPCEtLTxmaWVsZHNldCBjbGFzcz1cXFwiZmllbGRzZXQgZmllbGRzZXQtdXNlci1hdmF0YXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXCJ1c2VyLWF2YXRhclxcXCIgc3JjPVxcXCJpbWcvYXZhdGFyLnBuZ1xcXCIvPlxcclxcbiAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0Pi0tPlxcclxcbiAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3M9XFxcImZpZWxkc2V0IGZpZWxkc2V0LXVzZXItZmllbGRzXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyd1c2VyX25hbWUnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1wbGFjZWhvbGRlclxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e3VzZXIubmFtZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J2xvZ2luX25hbWUnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwic3BhbjRcXFwiIFsobmdNb2RlbCldPVxcXCJ1c2VyLmxvZ2luXFxcIiBuZ0NvbnRyb2w9XFxcImxvZ2luXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIiAqbmdJZj1cXFwiIWNoYW5nZVBhc3N3b3JkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJidG4gYnRuLXhzXFxcIiAoY2xpY2spPVxcXCJ0b2dnbGVDaGFuZ2VQYXNzd29yZCgpXFxcIj57eydjaGFuZ2VfcGFzc3dvcmQnIHwgdHJhbnNsYXRlfX08L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiICpuZ0lmPVxcXCJjaGFuZ2VQYXNzd29yZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J3Bhc3N3b3JkJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicGFzc3dvcmRcXFwiIGNsYXNzPVxcXCJzcGFuNFxcXCIgWyhuZ01vZGVsKV09XFxcInVzZXIucHdkXFxcIiBuZ0NvbnRyb2w9XFxcInB3ZFxcXCIgLz5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCIgKm5nSWY9XFxcImNoYW5nZVBhc3N3b3JkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sncGFzc3dvcmRfY29uZmlybScgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwic3BhbjRcXFwiIFsobmdNb2RlbCldPVxcXCJ1c2VyLnB3ZF9jb25maXJtXFxcIiBuZ0NvbnRyb2w9XFxcInB3ZF9jb25maXJtXFxcIiAvPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3snZW1haWwnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJlbWFpbFxcXCIgY2xhc3M9XFxcInNwYW40XFxcIiBbKG5nTW9kZWwpXT1cXFwidXNlci5lbWFpbFxcXCIgbmdDb250cm9sPVxcXCJlbWFpbFxcXCIgLz5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J29yZ19uYW1lJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtcGxhY2Vob2xkZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3t1c2VyLm9yZ2FuaXphdGlvbn19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J2RlcGFydG1lbnQnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1wbGFjZWhvbGRlclxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e3VzZXIuZGVwYXJ0bWVudH19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7J3Bvc2l0aW9uJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtcGxhY2Vob2xkZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3t1c2VyLnBvc2l0aW9ufX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sncm9sZXMnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiaW5wdXQtcGxhY2Vob2xkZXIgbGlzdC1zdHlsZS1ub25lXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVxcXCJmaWVsZHMvcm9sZXMvZW50cnlcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XFxcIi5cXFwiIC8+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwveHNsOmZvci1lYWNoPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICAgICAgPC90YWI+XFxyXFxuICAgICAgICAgICAgPHRhYiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIHRhYlRpdGxlPVxcXCJ7eydpbnRlcmZhY2UnIHwgdHJhbnNsYXRlfX1cXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3M9XFxcImZpZWxkc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eydsaW1pdF92aWV3JyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IG5hbWU9XFxcInBhZ2VzaXplXFxcIiBjbGFzcz1cXFwic3BhbjJcXFwiIChjaGFuZ2UpPVxcXCJjaGFuZ2VQYWdlU2l6ZSgkZXZlbnQpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7cHN9fVxcXCIgW3NlbGVjdGVkXT1cXFwicHMgPT0gcGFnZVNpemVcXFwiICpuZ0Zvcj1cXFwibGV0IHBzIG9mIHBhZ2VTaXplc1xcXCI+e3twc319PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3snaW50ZXJmYWNlX2xhbmcnIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgbmFtZT1cXFwibGFuZ1xcXCIgY2xhc3M9XFxcInNwYW4yXFxcIiAoY2hhbmdlKT1cXFwiY2hhbmdlTGFuZygkZXZlbnQpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7bGFuZ0NvZGV9fVxcXCIgW3NlbGVjdGVkXT1cXFwibGFuZ0NvZGUgPT0gbGFuZ3VhZ2VcXFwiICpuZ0Zvcj1cXFwibGV0IGxhbmdDb2RlIG9mIGxhbmd1YWdlcyB8IGtleXNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bGFuZ3VhZ2VzW2xhbmdDb2RlXX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+PC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiIGRhdGEtdG9nZ2xlLXRoZW1lPVxcXCJ0aGVtZTFcXFwiIGNsYXNzPVxcXCJpbnB1dC1wbGFjZWhvbGRlclxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eydjaGFuZ2Vfc2tpbicgfCB0cmFuc2xhdGV9fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gLS0+XFxyXFxuICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICAgICAgPC90YWI+XFxyXFxuICAgICAgICA8L3RhYnM+XFxyXFxuICAgIDwvc2VjdGlvbj5cXHJcXG48L2Zvcm0+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL3RlbXBsYXRlcy91c2VyLXByb2ZpbGUuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDgzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnW2xvZ2luXScsXHJcbiAgICB0ZW1wbGF0ZTogJydcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dpbkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICdMb2dvdXQnO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvbG9naW4udHNcbiAqKi8iLCJleHBvcnQgKiBmcm9tICcuL3N0b3JlJztcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvc3RvcmUvaW5kZXgudHNcbiAqKi8iLCJpbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAnQG5ncngvY29yZS9jb21wb3NlJztcclxuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzLCBwcm92aWRlU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XHJcbmltcG9ydCB7IHN0b3JlTG9nZ2VyIH0gZnJvbSAnbmdyeC1zdG9yZS1sb2dnZXInO1xyXG5cclxuLy8gbW9kZWxzXG5pbXBvcnQgeyBQcm9qZWN0LCBUYXNrLCBUYXNrVHlwZSwgVGFnLCBVc2VyLCBBdHRhY2htZW50LCBPcmdhbml6YXRpb24gfSBmcm9tICcuLi9tb2RlbHMnO1xuXG4vLyByZWR1Y2Vyc1xyXG5pbXBvcnQgeyBhdXRoZWRSZWR1Y2VyIGFzIGF1dGhlZCB9IGZyb20gJy4uL3JlZHVjZXJzL2F1dGhlZC5yZWR1Y2VyJztcclxuaW1wb3J0IHsgcHJvamVjdHNSZWR1Y2VyIGFzIHByb2plY3RzIH0gZnJvbSAnLi4vcmVkdWNlcnMvcHJvamVjdHMucmVkdWNlcic7XHJcbmltcG9ydCB7IHRhc2tzUmVkdWNlciBhcyB0YXNrcyB9IGZyb20gJy4uL3JlZHVjZXJzL3Rhc2tzLnJlZHVjZXInO1xyXG5pbXBvcnQgeyB0YXNrUmVkdWNlciBhcyB0YXNrIH0gZnJvbSAnLi4vcmVkdWNlcnMvdGFzay5yZWR1Y2VyJztcclxuaW1wb3J0IHsgc3RhZmZSZWR1Y2VyIGFzIHN0YWZmIH0gZnJvbSAnLi4vcmVkdWNlcnMvc3RhZmYucmVkdWNlcic7XHJcbmltcG9ydCB7IHJlZmVyZW5jZVJlZHVjZXIgYXMgcmVmZXJlbmNlIH0gZnJvbSAnLi4vcmVkdWNlcnMvcmVmZXJlbmNlLnJlZHVjZXInO1xyXG5cclxuY29uc3QgbG9nZ2VyID0gc3RvcmVMb2dnZXIoe1xyXG4gICAgbGV2ZWw6ICdsb2cnLCAvLyAnY29uc29sZScgfCAnd2FybicgfCAnZXJyb3InIHwgJ2luZm8nOyBkZWZhdWx0IGxvZ1xyXG4gICAgY29sbGFwc2VkOiBmYWxzZSxcclxuICAgIGR1cmF0aW9uOiB0cnVlLFxyXG4gICAgdGltZXN0YW1wOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IEFQUF9TVE9SRSA9IHByb3ZpZGVTdG9yZShcclxuICAgIGNvbXBvc2UobG9nZ2VyLCBjb21iaW5lUmVkdWNlcnMpKHtcclxuICAgICAgICBhdXRoZWQsXHJcbiAgICAgICAgcHJvamVjdHMsXHJcbiAgICAgICAgdGFza3MsXHJcbiAgICAgICAgdGFzayxcclxuICAgICAgICBzdGFmZixcclxuICAgICAgICByZWZlcmVuY2VcclxuICAgIH0pXHJcbik7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL3N0b3JlL3N0b3JlLnRzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmNvbXBvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZ1bmN0aW9uc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3QgPSBmdW5jdGlvbnNbZnVuY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVzdCA9IGZ1bmN0aW9ucy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZm4pIHsgcmV0dXJuIGZuKGNvbXBvc2VkKTsgfSwgbGFzdChhcmcpKTtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvc2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQG5ncngvY29yZS9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gODQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsb2dnZXIgPSBjb25zb2xlO1xudmFyIElOSVRfQUNUSU9OID0gXCJAbmdyeC9zdG9yZS9pbml0XCI7XG52YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgdGltZXMpIHsgcmV0dXJuIChuZXcgQXJyYXkodGltZXMgKyAxKSkuam9pbihzdHIpOyB9O1xudmFyIHBhZCA9IGZ1bmN0aW9uIChudW0sIG1heExlbmd0aCkgeyByZXR1cm4gcmVwZWF0KFwiMFwiLCBtYXhMZW5ndGggLSBudW0udG9TdHJpbmcoKS5sZW5ndGgpICsgbnVtOyB9O1xudmFyIGZvcm1hdFRpbWUgPSBmdW5jdGlvbiAodGltZSkgeyByZXR1cm4gKFwiQCBcIiArIHBhZCh0aW1lLmdldEhvdXJzKCksIDIpICsgXCI6XCIgKyBwYWQodGltZS5nZXRNaW51dGVzKCksIDIpICsgXCI6XCIgKyBwYWQodGltZS5nZXRTZWNvbmRzKCksIDIpICsgXCIuXCIgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMykpOyB9O1xudmFyIHRpbWVyID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09IFwiZnVuY3Rpb25cIiA/IHBlcmZvcm1hbmNlIDogRGF0ZTtcbnZhciBnZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgYWN0aW9uLCBwYXlsb2FkLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgbGV2ZWwpIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBsZXZlbFt0eXBlXSA9PT0gXCJmdW5jdGlvblwiID8gbGV2ZWxbdHlwZV0uYXBwbHkobGV2ZWwsIHBheWxvYWQpIDogbGV2ZWxbdHlwZV07XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGxldmVsKGFjdGlvbik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfVxufTtcbnZhciBwcmludEJ1ZmZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBmdW5jdGlvbiAobG9nQnVmZmVyKSB7XG4gICAgdmFyIGFjdGlvblRyYW5zZm9ybWVyID0gb3B0aW9ucy5hY3Rpb25UcmFuc2Zvcm1lciwgY29sbGFwc2VkID0gb3B0aW9ucy5jb2xsYXBzZWQsIGNvbG9ycyA9IG9wdGlvbnMuY29sb3JzLCB0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcCwgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLCBsZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG4gICAgbG9nQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGxvZ0VudHJ5LCBrZXkpIHtcbiAgICAgICAgdmFyIHN0YXJ0ZWQgPSBsb2dFbnRyeS5zdGFydGVkLCBzdGFydGVkVGltZSA9IGxvZ0VudHJ5LnN0YXJ0ZWRUaW1lLCBhY3Rpb24gPSBsb2dFbnRyeS5hY3Rpb24sIGVycm9yID0gbG9nRW50cnkuZXJyb3I7XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSBsb2dFbnRyeS5wcmV2U3RhdGUubmV4dFN0YXRlID8gbG9nRW50cnkucHJldlN0YXRlLm5leHRTdGF0ZSA6ICcoRW1wdHkpJztcbiAgICAgICAgdmFyIHRvb2sgPSBsb2dFbnRyeS50b29rLCBuZXh0U3RhdGUgPSBsb2dFbnRyeS5uZXh0U3RhdGU7XG4gICAgICAgIHZhciBuZXh0RW50cnkgPSBsb2dCdWZmZXJba2V5ICsgMV07XG4gICAgICAgIGlmIChuZXh0RW50cnkpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IG5leHRFbnRyeS5wcmV2U3RhdGU7XG4gICAgICAgICAgICB0b29rID0gbmV4dEVudHJ5LnN0YXJ0ZWQgLSBzdGFydGVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXR0ZWRBY3Rpb24gPSBhY3Rpb25UcmFuc2Zvcm1lcihhY3Rpb24pO1xuICAgICAgICB2YXIgaXNDb2xsYXBzZWQgPSAodHlwZW9mIGNvbGxhcHNlZCA9PT0gXCJmdW5jdGlvblwiKSA/IGNvbGxhcHNlZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXh0U3RhdGU7IH0sIGFjdGlvbikgOiBjb2xsYXBzZWQ7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0VGltZShzdGFydGVkVGltZSk7XG4gICAgICAgIHZhciB0aXRsZUNTUyA9IGNvbG9ycy50aXRsZSA/IFwiY29sb3I6IFwiICsgY29sb3JzLnRpdGxlKGZvcm1hdHRlZEFjdGlvbikgKyBcIjtcIiA6IG51bGw7XG4gICAgICAgIHZhciB0aXRsZSA9IFwiYWN0aW9uIFwiICsgKHRpbWVzdGFtcCA/IGZvcm1hdHRlZFRpbWUgOiBcIlwiKSArIFwiIFwiICsgZm9ybWF0dGVkQWN0aW9uLnR5cGUgKyBcIiBcIiArIChkdXJhdGlvbiA/IFwiKGluIFwiICsgdG9vay50b0ZpeGVkKDIpICsgXCIgbXMpXCIgOiBcIlwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2xvcnMudGl0bGUpXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIiVjIFwiICsgdGl0bGUsIHRpdGxlQ1NTKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZCh0aXRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JzLnRpdGxlKVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXAoXCIlYyBcIiArIHRpdGxlLCB0aXRsZUNTUyk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXAodGl0bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldlN0YXRlTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbcHJldlN0YXRlXSwgXCJwcmV2U3RhdGVcIik7XG4gICAgICAgIHZhciBhY3Rpb25MZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtmb3JtYXR0ZWRBY3Rpb25dLCBcImFjdGlvblwiKTtcbiAgICAgICAgdmFyIGVycm9yTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbZXJyb3IsIHByZXZTdGF0ZV0sIFwiZXJyb3JcIik7XG4gICAgICAgIHZhciBuZXh0U3RhdGVMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtuZXh0U3RhdGVdLCBcIm5leHRTdGF0ZVwiKTtcbiAgICAgICAgaWYgKHByZXZTdGF0ZUxldmVsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JzLnByZXZTdGF0ZSlcbiAgICAgICAgICAgICAgICBsb2dnZXJbcHJldlN0YXRlTGV2ZWxdKFwiJWMgcHJldiBzdGF0ZVwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5wcmV2U3RhdGUocHJldlN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvZ2dlcltwcmV2U3RhdGVMZXZlbF0oXCJwcmV2IHN0YXRlXCIsIHByZXZTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbkxldmVsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JzLmFjdGlvbilcbiAgICAgICAgICAgICAgICBsb2dnZXJbYWN0aW9uTGV2ZWxdKFwiJWMgYWN0aW9uXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLmFjdGlvbihmb3JtYXR0ZWRBY3Rpb24pICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIGZvcm1hdHRlZEFjdGlvbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG9nZ2VyW2FjdGlvbkxldmVsXShcImFjdGlvblwiLCBmb3JtYXR0ZWRBY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiBlcnJvckxldmVsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JzLmVycm9yKVxuICAgICAgICAgICAgICAgIGxvZ2dlcltlcnJvckxldmVsXShcIiVjIGVycm9yXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLmVycm9yKGVycm9yLCBwcmV2U3RhdGUpICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIGVycm9yKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsb2dnZXJbZXJyb3JMZXZlbF0oXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRTdGF0ZUxldmVsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JzLm5leHRTdGF0ZSlcbiAgICAgICAgICAgICAgICBsb2dnZXJbbmV4dFN0YXRlTGV2ZWxdKFwiJWMgbmV4dCBzdGF0ZVwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5uZXh0U3RhdGUobmV4dFN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvZ2dlcltuZXh0U3RhdGVMZXZlbF0oXCJuZXh0IHN0YXRlXCIsIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiXFx1MjAxNFxcdTIwMTQgbG9nIGVuZCBcXHUyMDE0XFx1MjAxNFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxvZ0J1ZmZlci5sZW5ndGggPSAwO1xufTsgfTtcbmV4cG9ydHMuc3RvcmVMb2dnZXIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyKSB7XG4gICAgICAgIHZhciBsb2cgPSB7fTtcbiAgICAgICAgdmFyIHVhID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50ID8gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgOiAnJztcbiAgICAgICAgdmFyIG1zX2llID0gZmFsc2U7XG4gICAgICAgIC8vZml4IGZvciBhY3Rpb24gZGlzcGxheSBpbiBJRVxuICAgICAgICB2YXIgb2xkX2llID0gdWEuaW5kZXhPZignTVNJRSAnKTtcbiAgICAgICAgdmFyIG5ld19pZSA9IHVhLmluZGV4T2YoJ1RyaWRlbnQvJyk7XG4gICAgICAgIGlmICgob2xkX2llID4gLTEpIHx8IChuZXdfaWUgPiAtMSkpIHtcbiAgICAgICAgICAgIG1zX2llID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBsZXZlbDogXCJsb2dcIixcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBkdXJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXRlVHJhbnNmb3JtZXI6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGU7IH0sXG4gICAgICAgICAgICBhY3Rpb25UcmFuc2Zvcm1lcjogZnVuY3Rpb24gKGFjdG4pIHsgcmV0dXJuIGFjdG47IH0sXG4gICAgICAgICAgICBjb2xvcnM6IG1zX2llID8ge30gOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiIzAwMDAwMFwiOyB9LFxuICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIjOUU5RTlFXCI7IH0sXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIiMwM0E5RjRcIjsgfSxcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiIzRDQUY1MFwiOyB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIiNGMjA0MDRcIjsgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0cyk7XG4gICAgICAgIHZhciBzdGF0ZVRyYW5zZm9ybWVyID0gb3B0aW9ucy5zdGF0ZVRyYW5zZm9ybWVyO1xuICAgICAgICB2YXIgYnVmZmVyID0gcHJpbnRCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICAgICAgdmFyIHByZUxvZyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydGVkOiB0aW1lci5ub3coKSxcbiAgICAgICAgICAgICAgICBzdGFydGVkVGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBwcmV2U3RhdGU6IHN0YXRlVHJhbnNmb3JtZXIobG9nKSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgdmFyIHBvc3RMb2cgPSB7XG4gICAgICAgICAgICAgICAgdG9vazogdGltZXIubm93KCkgLSBwcmVMb2cuc3RhcnRlZCxcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGU6IHN0YXRlVHJhbnNmb3JtZXIobmV4dFN0YXRlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvZyA9IE9iamVjdC5hc3NpZ24oe30sIHByZUxvZywgcG9zdExvZyk7XG4gICAgICAgICAgICAvL2lnbm9yZSBpbml0IGFjdGlvbiBmaXJlZCBieSBzdG9yZSBhbmQgZGV2dG9vbHNcbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gSU5JVF9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICBidWZmZXIoW2xvZ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L25ncngtc3RvcmUtbG9nZ2VyL2Rpc3QvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4NDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=